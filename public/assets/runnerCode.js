class TinyShaderRunner{canvas;graph;d;c;u;p=new Map;l=new Map;t=new Map;s;constructor(e,t){this.canvas=e,this.graph=t}async init(){const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("");this.d=await e.requestDevice(),this.c=this.canvas.getContext("webgpu");const t=navigator.gpu.getPreferredCanvasFormat();this.c.configure({device:this.d,format:t,usage:16}),this.s=this.d.createSampler({magFilter:"linear",minFilter:"linear"}),this.u=this.d.createBuffer({size:this.graph.uniforms.byteSize,usage:72});for(const e of this.graph.passes){const n=[this.graph.canvasSize.width,this.graph.canvasSize.height];if("compute"!==e.type||e.isMain){if(!e.isMain){const t=()=>this.d.createTexture({size:n,format:"bgra8unorm",usage:20});this.t.set(e.name,[t(),t()])}}else this.t.set(e.name,[this.d.createTexture({size:n,format:"rgba8unorm",usage:12})]);const r=[],i=/@binding\s*\(\s*(\d+)\s*\)\s+var\s*(?:<([^>]+)>)?\s*([\w\d_]+)/g;let a;const s="compute"===e.type?4:2;for(;null!==(a=i.exec(e.shader));){const e=parseInt(a[1]),t=a[2]||"",n=a[3];t.includes("uniform")?r.push({binding:e,visibility:s,buffer:{type:"uniform"}}):t.includes("storage")||"outTex"===n?r.push({binding:e,visibility:s,storageTexture:{format:"rgba8unorm",access:"write-only"}}):"samp"===n?r.push({binding:e,visibility:s,sampler:{type:"filtering"}}):r.push({binding:e,visibility:s,texture:{sampleType:"float"}})}const o=this.d.createBindGroupLayout({entries:r});this.l.set(e.name,o);const u=this.d.createShaderModule({code:e.shader}),c=this.d.createPipelineLayout({bindGroupLayouts:[o]});"compute"===e.type?this.p.set(e.name,this.d.createComputePipeline({layout:c,compute:{module:u,entryPoint:"main"}})):this.p.set(e.name,this.d.createRenderPipeline({layout:c,vertex:{module:u,entryPoint:"vs"},fragment:{module:u,entryPoint:"main",targets:[{format:e.isMain?t:"bgra8unorm"}]}}))}}createBindGroup(e,t){const n=this.l.get(e.name),r=1-t,i=new Map;i.set("u",{buffer:this.u}),i.set("samp",this.s);for(const n of this.graph.passes){if(n.isMain)continue;const a=this.t.get(n.name);"compute"===n.type?(n.name===e.name&&i.set("outTex",a[0].createView()),i.set(n.name,a[0].createView())):n.name===e.name?(i.set(n.name,a[r].createView()),i.set(`prev_${n.name}`,a[r].createView())):i.set(n.name,a[t].createView())}const a=[],s=/@binding\s*\(\s*(\d+)\s*\)\s+var\s*(?:<([^>]+)>)?\s*([\w\d_]+)/g;let o;for(;null!==(o=s.exec(e.shader));){const e=parseInt(o[1]),t=i.get(o[3]);t&&a.push({binding:e,resource:t})}return this.d.createBindGroup({layout:n,entries:a})}run(){let e=0;const t=n=>{e++;const r=e%2,i=new Float32Array([this.canvas.width,this.canvas.height,0,n/1e3]);this.d.queue.writeBuffer(this.u,0,i);const a=this.d.createCommandEncoder();for(const e of this.graph.passes){const t=this.createBindGroup(e,r);if("compute"===e.type){const n=a.beginComputePass();n.setPipeline(this.p.get(e.name)),n.setBindGroup(0,t),n.dispatchWorkgroups(Math.ceil(this.canvas.width/16),Math.ceil(this.canvas.height/16)),n.end()}else{const n=e.isMain?this.c.getCurrentTexture().createView():this.t.get(e.name)[r].createView(),i=a.beginRenderPass({colorAttachments:[{view:n,loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}]});i.setPipeline(this.p.get(e.name)),i.setBindGroup(0,t),i.draw(3),i.end()}}this.d.queue.submit([a.finish()]),requestAnimationFrame(t)};requestAnimationFrame(t)}}