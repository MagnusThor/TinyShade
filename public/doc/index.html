<!DOCTYPE html><html class="default" lang="en" data-base="./"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>TinyShade</title><meta name="description" content="Documentation for TinyShade"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script defer src="assets/main.js"></script><script async src="assets/icons.js" id="tsd-icons-script"></script><script async src="assets/search.js" id="tsd-search-script"></script><script async src="assets/navigation.js" id="tsd-nav-script"></script><script async src="assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => window.app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><a href="index.html" class="title">TinyShade</a><div id="tsd-toolbar-links"></div><button id="tsd-search-trigger" class="tsd-widget" aria-label="Search"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="assets/icons.svg#icon-search"></use></svg></button><dialog id="tsd-search" aria-label="Search"><input role="combobox" id="tsd-search-input" aria-controls="tsd-search-results" aria-autocomplete="list" aria-expanded="true" autocapitalize="off" autocomplete="off" placeholder="Search the docs" maxLength="100"/><ul role="listbox" id="tsd-search-results"></ul><div id="tsd-search-status" aria-live="polite" aria-atomic="true"><div>Preparing search index...</div></div></dialog><a href="#" class="tsd-widget menu" id="tsd-toolbar-menu-trigger" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="assets/icons.svg#icon-menu"></use></svg></a></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><h1>TinyShade</h1></div><div class="tsd-panel tsd-typography"><h1 id="üåë-tinyshade" class="tsd-anchor-link">üåë TinyShade<a href="#üåë-tinyshade" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h1><p><a href="https://magnusthor.github.io/TinyShade/public/doc/"><img src="https://img.shields.io/badge/API_Docs-TypeDoc-blue" alt="API Docs"></a></p>
<p>A minimalist, zero-boilerplate WebGPU framework designed for rapid prototyping of compute-driven visuals, simulations, and multi-pass post-process effects.</p>
<p>TinyShade simplifies the complex WebGPU binding model into a chainable API. It handles <strong>Ping-Ponging</strong> (feedback textures), <strong>Dynamic Compute Dispatching</strong>, and <strong>Intelligent Dependency Management</strong> automatically.</p>
<blockquote>
<p>üí≠<em>Think of TinyShade as the <strong>WebGPU evolution of Shadertoy</strong>‚Äîbuilt for those who need more than just a fragment shader, but less than a 600KB engine.</em>&quot;</p>
</blockquote>
<h2 id="‚öñÔ∏è-a-tiny-footprint" class="tsd-anchor-link">‚öñÔ∏è A Tiny Footprint<a href="#‚öñÔ∏è-a-tiny-footprint" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>TinyShade is engineered for the <strong>64k and 4k intro philosophy</strong>. It provides a full-scale WebGPU orchestration layer with a footprint smaller than a typical favicon.</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Size (Min/Gzip)</th>
<th>Strategy</th>
</tr>
</thead>
<tbody>
<tr>
<td>TinyShade Core</td>
<td>~9 KB</td>
<td>Tree-shaken dev-time graph manager</td>
</tr>
<tr>
<td>TinyShade Runner</td>
<td>~4.5 KB</td>
<td>Ultra-lean binary replay engine</td>
</tr>
<tr>
<td>Bake Output</td>
<td>Compressed</td>
<td>Frozen, minified, and packed final artifact</td>
</tr>
</tbody>
</table>
<h2 id="üì¶-installation-setup" class="tsd-anchor-link">üì¶ Installation &amp; Setup<a href="#üì¶-installation-setup" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><pre><code class="bash"><br/><span class="hl-0"># Clone the repository</span><br/><span class="hl-1">git</span><span class="hl-2"> </span><span class="hl-3">clone</span><span class="hl-2"> </span><span class="hl-3">https://github.com/MagnusThor/TinyShade.git</span><br/><br/><span class="hl-0"># Install dependencies</span><br/><span class="hl-1">npm</span><span class="hl-2"> </span><span class="hl-3">install</span><br/><br/><span class="hl-0"># Start the development server</span><br/><span class="hl-1">npm</span><span class="hl-2"> </span><span class="hl-3">run</span><span class="hl-2"> </span><span class="hl-3">start</span><br/>
</code><button type="button">Copy</button></pre>

<h2 id="üöÄ-quick-start-dependency-aware-graph" class="tsd-anchor-link">üöÄ Quick Start: Dependency-Aware Graph<a href="#üöÄ-quick-start-dependency-aware-graph" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>TinyShade uses an intelligent chaining API. This example demonstrates a <strong>branched DAG</strong>: running two independent simulations and combining them in a final fragment pass.</p>
<pre><code class="ts"><br/><span class="hl-4">import</span><span class="hl-2"> { </span><span class="hl-5">TinyShade</span><span class="hl-2"> } </span><span class="hl-4">from</span><span class="hl-2"> </span><span class="hl-3">&quot;./TinyShade&quot;</span><span class="hl-2">;</span><br/><br/><span class="hl-6">const</span><span class="hl-2"> </span><span class="hl-1">start</span><span class="hl-2"> = </span><span class="hl-6">async</span><span class="hl-2"> () </span><span class="hl-6">=&gt;</span><span class="hl-2"> {</span><br/><span class="hl-2">  </span><span class="hl-0">// 1. Initialize the WebGPU context</span><br/><span class="hl-2">  </span><span class="hl-6">const</span><span class="hl-2"> </span><span class="hl-7">app</span><span class="hl-2"> = </span><span class="hl-4">await</span><span class="hl-2"> </span><span class="hl-5">TinyShade</span><span class="hl-2">.</span><span class="hl-1">create</span><span class="hl-2">(</span><span class="hl-3">&quot;canvas&quot;</span><span class="hl-2">);</span><br/><br/><span class="hl-2">  (</span><span class="hl-4">await</span><span class="hl-2"> </span><span class="hl-5">app</span><br/><span class="hl-2">    .</span><span class="hl-1">setUniforms</span><span class="hl-2">()</span><br/><span class="hl-2">    </span><br/><span class="hl-2">    </span><span class="hl-0">// 2. Implicit Dependency: Since &#39;deps&#39; is omitted, </span><br/><span class="hl-2">    </span><span class="hl-0">// this pass is added to the linear stack by default.</span><br/><span class="hl-2">    .</span><span class="hl-1">addCompute</span><span class="hl-2">(</span><span class="hl-3">&quot;physics&quot;</span><span class="hl-2">, </span><span class="hl-5">physicsWGSL</span><span class="hl-2">)</span><br/><span class="hl-2">    </span><br/><span class="hl-2">    </span><span class="hl-0">// 3. Explicit Empty Dependency: By passing [], we tell TinyShade </span><br/><span class="hl-2">    </span><span class="hl-0">// this pass depends on NOTHING. This allows the GPU to </span><br/><span class="hl-2">    </span><span class="hl-0">// potentially run &quot;fluid&quot; and &quot;physics&quot; in parallel.</span><br/><span class="hl-2">    .</span><span class="hl-1">addCompute</span><span class="hl-2">(</span><span class="hl-3">&quot;fluid&quot;</span><span class="hl-2">, </span><span class="hl-5">fluidWGSL</span><span class="hl-2">, </span><span class="hl-8">0</span><span class="hl-2">, [])</span><br/><span class="hl-2">    </span><br/><span class="hl-2">    </span><span class="hl-0">// 4. Multi-Dependency Main: The final fragment pass </span><br/><span class="hl-2">    </span><span class="hl-0">// explicitly requests the output textures from both prior passes.</span><br/><span class="hl-2">    .</span><span class="hl-1">main</span><span class="hl-2">(</span><span class="hl-5">mainWGSL</span><span class="hl-2">, [</span><span class="hl-3">&quot;physics&quot;</span><span class="hl-2">, </span><span class="hl-3">&quot;fluid&quot;</span><span class="hl-2">])</span><br/><span class="hl-2">    </span><br/><span class="hl-2">  ).</span><span class="hl-1">run</span><span class="hl-2">(); </span><span class="hl-0">// Start the render loop</span><br/><span class="hl-2">};</span><br/><br/><span class="hl-1">start</span><span class="hl-2">();</span>
</code><button type="button">Copy</button></pre>

<h3 id="üí°-the-omit-rule-convention-over-configuration" class="tsd-anchor-link">üí° The &quot;Omit&quot; Rule (Convention over Configuration)<a href="#üí°-the-omit-rule-convention-over-configuration" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>In TinyShade, you only write <code>deps</code> when you want to be specific.</p>
<ul>
<li>
<p><strong>Omit the <code>deps</code> argument:</strong> The pass is &quot;greedy&quot;‚Äîit automatically binds <strong>every prior pass</strong> in the chain. This is the fastest way to build a post-processing stack.</p>
</li>
<li>
<p><strong>Pass an empty array <code>[]</code>:</strong> The pass is &quot;isolated&quot;‚Äîit binds nothing but the global uniforms. This is the best way to optimize performance for independent compute tasks.</p>
</li>
<li>
<p><strong>Pass a specific array <code>[&quot;a&quot;, &quot;b&quot;]</code>:</strong> The pass is &quot;surgical&quot;‚Äîit binds only the named resources you requested.</p>
</li>
</ul>
<h2 id="üó∫Ô∏è-smart-dag-execution-model" class="tsd-anchor-link">üó∫Ô∏è Smart-DAG Execution Model<a href="#üó∫Ô∏è-smart-dag-execution-model" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>TinyShade treats your pipeline as a <strong>Directed Acyclic Graph (DAG)</strong> using a <em>Convention over Configuration</em> API.</p>
<h3 id="1-implicit-dependency-linear-default" class="tsd-anchor-link">1. Implicit Dependency (Linear Default)<a href="#1-implicit-dependency-linear-default" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>If no dependency array is provided, a pass automatically sees <strong>all prior passes</strong>.</p>
<h3 id="2-explicit-dependency-" class="tsd-anchor-link">2. Explicit Dependency (<code>deps</code>)<a href="#2-explicit-dependency-" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>TinyShade simplifies the complex WebGPU binding model through a <strong>&quot;Convention over Configuration&quot;</strong> approach. You only define dependencies when you need to optimize.</p>
<h3 id="1-omit-the-argument-linear-default" class="tsd-anchor-link">1. Omit the <code>deps</code> argument (Linear Default)<a href="#1-omit-the-argument-linear-default" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The pass is &quot;greedy.&quot; It automatically binds <strong>every prior pass</strong> in the chain. This is the fastest way to build a classic post-processing stack where each layer builds on the last.</p>
<h3 id="2-pass-an-empty-array-isolated" class="tsd-anchor-link">2. Pass an empty array <code>[]</code> (Isolated)<a href="#2-pass-an-empty-array-isolated" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The pass is &quot;isolated.&quot; It binds nothing but the global uniforms. Use this for independent tasks (like a noise generator or an independent physics sim) to maximize GPU occupancy.</p>
<h3 id="3-pass-a-specific-array-surgical" class="tsd-anchor-link">3. Pass a specific array <code>[&quot;a&quot;, &quot;b&quot;]</code> (Surgical)<a href="#3-pass-a-specific-array-surgical" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>TinyShade generates a custom BindGroup containing <strong>only</strong> the requested resources. This keeps your shader code clean and reduces the performance overhead of binding unused textures.</p>
<h2 id="üìú-shader-variable-reference" class="tsd-anchor-link">üìú Shader Variable Reference<a href="#üìú-shader-variable-reference" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Source</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vec3f</code></td>
<td><code>u.resolution</code></td>
<td>Internal</td>
<td>Width, height, DPR</td>
</tr>
<tr>
<td><code>f32</code></td>
<td><code>u.time</code></td>
<td>Internal</td>
<td>Global clock (seconds)</td>
</tr>
<tr>
<td><code>f32</code></td>
<td><code>u.sceneId</code></td>
<td>Sequencer</td>
<td>Active timeline segment</td>
</tr>
<tr>
<td><code>f32</code></td>
<td><code>u.progress</code></td>
<td>Sequencer</td>
<td>0‚Äì1 progress in current scene</td>
</tr>
<tr>
<td><code>f32</code></td>
<td><code>u.flags</code></td>
<td>Sequencer</td>
<td>Bitmask for event triggers</td>
</tr>
<tr>
<td><code>texture_2d</code></td>
<td><code>&lt;name&gt;</code></td>
<td>addCompute</td>
<td>Output of named compute pass</td>
</tr>
<tr>
<td><code>texture_2d</code></td>
<td><code>prev_&lt;name&gt;</code></td>
<td>addPass</td>
<td>Previous-frame feedback</td>
</tr>
<tr>
<td><code>sampler</code></td>
<td><code>samp</code></td>
<td>Internal</td>
<td>Global linear sampler</td>
</tr>
</tbody>
</table>
<h2 id="üß†-high-level-pipeline-overview" class="tsd-anchor-link">üß† High-Level Pipeline Overview<a href="#üß†-high-level-pipeline-overview" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>TinyShade is built around a <strong>named execution model</strong> that balances simplicity with surgical control:</p>
<blockquote>
<p><strong>Data flows through a Directed Acyclic Graph (DAG) ‚Äî where every pass can access the present and the past of its ancestors.</strong></p>
</blockquote>
<h3 id="the-named-execution-flow" class="tsd-anchor-link">The Named Execution Flow<a href="#the-named-execution-flow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Every frame, TinyShade executes your pipeline <strong>in the order it was defined</strong>. By naming your passes, your shaders reference data via semantic names rather than opaque binding indices:</p>
<ul>
<li>
<p><strong>Greedy Access (Default):</strong> If you omit <code>deps</code>, a pass can <strong>see the output of every stage before it</strong> automatically.</p>
</li>
<li>
<p><strong>Surgical Access (<code>deps</code>):</strong> If you specify <code>deps</code>, the pass only binds the specific resources requested, reducing GPU overhead and enabling internal parallel optimizations.</p>
</li>
</ul>
<pre><code class="rs">Uniforms 
   ‚Üì 
"sim_data" (Compute) 
   ‚Üì 
"post_fx" (Fragment) ‚Üí sees ["sim_data"]
   ‚Üì 
main() ‚Üí sees ["post_fx", "sim_data"] ‚Üí Canvas

</code><button type="button">Copy</button></pre>

<h3 id="temporal-feedback-ping-ponging" class="tsd-anchor-link">Temporal Feedback (Ping-Ponging)<a href="#temporal-feedback-ping-ponging" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Temporal logic is a first-class citizen in TinyShade. Every fragment pass is automatically double-buffered. If you name a pass <code>&quot;fx&quot;</code>, TinyShade manages two textures behind the scenes:</p>
<ul>
<li>
<p><strong><code>fx</code></strong>: The current texture being written (available to <em>subsequent</em> passes).</p>
</li>
<li>
<p><strong><code>prev_fx</code></strong>: The texture as it looked in the previous frame (available to the <em>current</em> pass).</p>
</li>
</ul>
<p>This makes complex effects like <strong>motion blur, temporal accumulation, and cellular automata</strong> effortless to implement.</p>
<h3 id="üß™-best-practice-atomic-heatmaps" class="tsd-anchor-link">üß™ Best Practice: Atomic Heatmaps<a href="#üß™-best-practice-atomic-heatmaps" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>When using <code>addAtomicCompute</code>, remember that the storage buffer persists. A common pattern is to have one pass &quot;clear&quot; the buffer (or use the <code>u.frame</code> index to offset) and a second pass &quot;splat&quot; data into it.</p>
<p>TypeScript</p>
<pre><code class="ts"><span class="hl-0">// Clear/Reset pass (optional depending on shader logic)</span><br/><span class="hl-5">app</span><span class="hl-2">.</span><span class="hl-1">addCompute</span><span class="hl-2">(</span><span class="hl-3">&quot;clear&quot;</span><span class="hl-2">, </span><span class="hl-5">clearWGSL</span><span class="hl-2">, </span><span class="hl-8">1</span><span class="hl-2">, []);</span><br/><br/><span class="hl-0">// Splatting pass</span><br/><span class="hl-5">app</span><span class="hl-2">.</span><span class="hl-1">addAtomicCompute</span><span class="hl-2">(</span><span class="hl-3">&quot;particles&quot;</span><span class="hl-2">, </span><span class="hl-5">splatWGSL</span><span class="hl-2">, </span><span class="hl-7">COUNT</span><span class="hl-2">, [</span><span class="hl-3">&quot;clear&quot;</span><span class="hl-2">]);</span>
</code><button type="button">Copy</button></pre>

<h2 id="‚¨õ-core-api" class="tsd-anchor-link">‚¨õ Core API<a href="#‚¨õ-core-api" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>TinyShade's API is designed to be declarative yet chainable. It eliminates the &quot;Boilerplate Tax&quot; of WebGPU by inferring BindGroups and Pipeline layouts from your graph structure.
<a href="https://magnusthor.github.io/TinyShade/public/doc/"><img src="https://img.shields.io/badge/API_Docs-TypeDoc-blue" alt="API Docs"></a></p>
<h3 id="1-initialize" class="tsd-anchor-link">1. Initialize<a href="#1-initialize" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Initialize the WebGPU context and attach it to a canvas. This setup is asynchronous and handles adapter/device discovery internally.</p>
<pre><code class="ts"><span class="hl-6">const</span><span class="hl-2"> </span><span class="hl-7">app</span><span class="hl-2"> = </span><span class="hl-4">await</span><span class="hl-2"> </span><span class="hl-5">TinyShade</span><span class="hl-2">.</span><span class="hl-1">create</span><span class="hl-2">(</span><span class="hl-3">&quot;canvas-id&quot;</span><span class="hl-2">);</span>
</code><button type="button">Copy</button></pre>

<h3 id="2-compute-pass" class="tsd-anchor-link">2. Compute Pass<a href="#2-compute-pass" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Registers a GPU compute task. TinyShade automatically handles the creation of the output storage texture and calculates the dispatch workgroups based on your canvas size.</p>
<pre><code class="ts"><span class="hl-5">app</span><span class="hl-2">.</span><span class="hl-1">addCompute</span><span class="hl-2">(</span><span class="hl-3">&quot;particles&quot;</span><span class="hl-2">, </span><span class="hl-5">particlesWGSL</span><span class="hl-2">, </span><span class="hl-8">1024</span><span class="hl-2">, [</span><span class="hl-3">&quot;background_sim&quot;</span><span class="hl-2">]);</span><br/><span class="hl-2">);</span>
</code><button type="button">Copy</button></pre>

<h3 id="3-atomic-passes" class="tsd-anchor-link">3. Atomic Passes<a href="#3-atomic-passes" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>A specialized compute pass that pre-configures a storage buffer with <code>atomic&lt;u32&gt;</code> support. Essential for &quot;Many-to-One&quot; operations like splatting particles onto a grid or building heatmaps.</p>
<pre><code class="ts"><span class="hl-5">app</span><span class="hl-2">.</span><span class="hl-1">addAtomicCompute</span><span class="hl-2">(</span><span class="hl-3">&quot;heatmap&quot;</span><span class="hl-2">, </span><span class="hl-5">heatmapWGSL</span><span class="hl-2">, </span><span class="hl-7">PIXEL_COUNT</span><span class="hl-2">, [</span><span class="hl-3">&quot;physics&quot;</span><span class="hl-2">]);</span>
</code><button type="button">Copy</button></pre>

<h3 id="fragment-pass-ping-pong-managed" class="tsd-anchor-link">Fragment Pass (Ping-Pong Managed)<a href="#fragment-pass-ping-pong-managed" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Registers a full-screen render pass. If a pass depends on itself (e.g., <code>[&quot;blur&quot;]</code>), TinyShade automatically creates a <strong>Ping-Pong</strong> feedback loop, allowing you to sample <code>prev_blur</code> in your WGSL.</p>
<pre><code class="ts"><span class="hl-5">app</span><span class="hl-2">.</span><span class="hl-1">addPass</span><span class="hl-2">(</span><span class="hl-3">&quot;blur&quot;</span><span class="hl-2">, </span><span class="hl-5">blurWGSL</span><span class="hl-2">, [</span><span class="hl-3">&quot;simulation&quot;</span><span class="hl-2">]);</span>
</code><button type="button">Copy</button></pre>

<h2 id="üé¨-plugin-system-sequencer" class="tsd-anchor-link">üé¨ Plugin System &amp; Sequencer<a href="#üé¨-plugin-system-sequencer" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>TinyShade uses a <strong>Plug-and-Tick</strong> architecture. Animation logic, timelines, and audio sync live in optional plugins.</p>
<h3 id="tssequencer" class="tsd-anchor-link">TSSequencer<a href="#tssequencer" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="ts"><span class="hl-6">const</span><span class="hl-2"> </span><span class="hl-7">seq</span><span class="hl-2"> = </span><span class="hl-6">new</span><span class="hl-2"> </span><span class="hl-1">TSSequencer</span><span class="hl-2">(</span><span class="hl-5">timeline</span><span class="hl-2">, </span><span class="hl-7">TOTAL_LENGTH_MS</span><span class="hl-2">, </span><span class="hl-8">120</span><span class="hl-2">, </span><span class="hl-8">4</span><span class="hl-2">);</span><br/><span class="hl-4">await</span><span class="hl-2"> </span><span class="hl-5">app</span><span class="hl-2">.</span><span class="hl-1">addSequencer</span><span class="hl-2">(</span><span class="hl-5">seq</span><span class="hl-2">).</span><span class="hl-1">run</span><span class="hl-2">();</span>
</code><button type="button">Copy</button></pre>

<h3 id="ibakeplugin-interface" class="tsd-anchor-link">IBakePlugin Interface<a href="#ibakeplugin-interface" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="ts"><span class="hl-4">export</span><span class="hl-2"> </span><span class="hl-6">interface</span><span class="hl-2"> </span><span class="hl-9">IBakePlugin</span><span class="hl-2"> {</span><br/><span class="hl-2">  </span><span class="hl-5">code</span><span class="hl-2">: </span><span class="hl-9">string</span><span class="hl-2">;</span><br/><span class="hl-2">  </span><span class="hl-5">activator</span><span class="hl-2">: </span><span class="hl-9">any</span><span class="hl-2">[];</span><br/><span class="hl-2">  </span><span class="hl-5">data</span><span class="hl-2">: </span><span class="hl-9">any</span><span class="hl-2">;</span><br/><span class="hl-2">}</span>
</code><button type="button">Copy</button></pre>

<h3 id="üé≠-frame-locked-orchestration" class="tsd-anchor-link">üé≠ Frame-Locked Orchestration<a href="#üé≠-frame-locked-orchestration" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p><code>TSSequencer</code> is built for synchronization. By integrating the sequencer, the framework drives your entire GPU pipeline through a unified uniform contract. Transition between scenes, modulate effects via <code>u.progress</code>, and trigger visual events using bitwise <code>u.flags</code>‚Äîall perfectly locked to the timeline.</p>
<pre><code class="ts"><span class="hl-2"> </span><span class="hl-6">const</span><span class="hl-2"> </span><span class="hl-7">app</span><span class="hl-2"> = </span><span class="hl-4">await</span><span class="hl-2"> </span><span class="hl-5">TinyShade</span><span class="hl-2">.</span><span class="hl-1">create</span><span class="hl-2">(</span><span class="hl-3">&quot;canvas&quot;</span><span class="hl-2">);</span><br/><span class="hl-2">    </span><br/><span class="hl-2">    </span><span class="hl-6">const</span><span class="hl-2"> </span><span class="hl-7">L</span><span class="hl-2"> = </span><span class="hl-8">170000</span><span class="hl-2">; </span><br/><span class="hl-2">    </span><span class="hl-6">const</span><span class="hl-2"> </span><span class="hl-7">seq</span><span class="hl-2"> = </span><span class="hl-6">new</span><span class="hl-2"> </span><span class="hl-1">TSSequencer</span><span class="hl-2">([], </span><span class="hl-7">L</span><span class="hl-2">, </span><span class="hl-8">120</span><span class="hl-2">, </span><span class="hl-8">4</span><span class="hl-2">);</span><br/><br/><span class="hl-2">    </span><span class="hl-6">const</span><span class="hl-2"> </span><span class="hl-7">SS</span><span class="hl-2"> = [</span><br/><span class="hl-2">        [</span><span class="hl-5">seq</span><span class="hl-2">.</span><span class="hl-1">getUnitsFromMs</span><span class="hl-2">(</span><span class="hl-8">1800</span><span class="hl-2">, </span><span class="hl-7">L</span><span class="hl-2">), </span><span class="hl-8">0x4000</span><span class="hl-2">, </span><span class="hl-8">1</span><span class="hl-2">],</span><br/><span class="hl-2">        [</span><span class="hl-5">seq</span><span class="hl-2">.</span><span class="hl-1">getUnitsFromBars</span><span class="hl-2">(</span><span class="hl-8">4</span><span class="hl-2">, </span><span class="hl-7">L</span><span class="hl-2">),  </span><span class="hl-8">0x4001</span><span class="hl-2">, </span><span class="hl-8">2</span><span class="hl-2">],</span><br/><span class="hl-2">        [</span><span class="hl-5">seq</span><span class="hl-2">.</span><span class="hl-1">getUnitsFromMs</span><span class="hl-2">(</span><span class="hl-8">5000</span><span class="hl-2">, </span><span class="hl-7">L</span><span class="hl-2">), </span><span class="hl-8">0x0000</span><span class="hl-2">, </span><span class="hl-8">3</span><span class="hl-2">],</span><br/><span class="hl-2">        [</span><span class="hl-8">255</span><span class="hl-2">, </span><span class="hl-8">0x0000</span><span class="hl-2">, </span><span class="hl-8">0</span><span class="hl-2">]</span><br/><span class="hl-2">    ];</span><br/><span class="hl-2">    </span><span class="hl-5">seq</span><span class="hl-2">.</span><span class="hl-5">timeline</span><span class="hl-2"> = </span><span class="hl-7">SS</span><span class="hl-2">;</span><br/><br/><span class="hl-2">    (</span><span class="hl-4">await</span><span class="hl-2"> </span><span class="hl-5">app</span><br/><span class="hl-2">        .</span><span class="hl-1">addSequencer</span><span class="hl-2">(</span><span class="hl-5">seq</span><span class="hl-2">)</span><br/><span class="hl-2">        .</span><span class="hl-1">setUniforms</span><span class="hl-2">().</span><br/><span class="hl-2">        </span><span class="hl-0">//....</span>
</code><button type="button">Copy</button></pre>

<p>and within the <code>main</code> pass as an example you do</p>
<pre><code class="rust">   @fragment fn main(in: VSOut) -> @location(0) vec4f {
    
                let noise = textureSample(noise_source, samp, in.uv).r;
                let color = textureSample(color_mask, samp, in.uv).rgb;

                var finalColor = vec3f(0.0);

                var sId:f32 = u.sceneId;

                if (sId == 1.0) {
                    finalColor = vec3f(noise);
                } else if (sId == 2.0) {
                    finalColor = color * noise;
                } else if (sId == 3.0) {
                    finalColor = mix(color * noise, 1.0 - (color * noise), u.progress);
                } else {
                    finalColor = vec3f(1.); // Idle state
                }

                return vec4f(finalColor, 1.0);
            }

</code><button type="button">Copy</button></pre>

<h2 id="üéπ-audio-integration-addaudio" class="tsd-anchor-link">üéπ Audio Integration (addAudio)<a href="#üéπ-audio-integration-addaudio" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>TinyShade supports sample-accurate timing. By implementing IAudioPlugin, an engine (like GPUSynth) can drive the u.time uniform.</p>
<pre><code class="ts"><span class="hl-5">app</span><span class="hl-2">.</span><span class="hl-1">addAudio</span><span class="hl-2">(</span><span class="hl-5">mySynth</span><span class="hl-2">) </span><span class="hl-0">// u.time is now driven by the audio clock</span><br/><span class="hl-2">   .</span><span class="hl-1">run</span><span class="hl-2">();</span>
</code><button type="button">Copy</button></pre>

<h3 id="üñ•Ô∏èüé∂-gpu-music-from-pcrush" class="tsd-anchor-link">üñ•Ô∏èüé∂ GPU Music from PCrush<a href="#üñ•Ô∏èüé∂-gpu-music-from-pcrush" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>My dear friend PCrush (Peter C) and co-developer of GPUSynth created several example tracks for GPUSynth. These can be found in the following folder:</p>
<p><a href="media/PCrushSongs">src/example/music/PCrushSongs/</a></p>
<blockquote>
<p>Note: PCrush forked my old repository <a href="https://github.com/MagnusThor/demolishedAudio">https://github.com/MagnusThor/demolishedAudio</a> and significantly improved it, modernizing the codebase and adapting it toward a more WebGPU / WGSL‚Äìstyle architecture.</p>
</blockquote>
<h2 id="various-examples-on-tinyshade" class="tsd-anchor-link">Various Examples on TinyShade<a href="#various-examples-on-tinyshade" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>You can try the live examples here:<br>
<a href="https://magnusthor.github.io/TinyShade/public/">TinyShade Examples</a></p>
<blockquote>
<p>‚ö†Ô∏è <strong>Note:</strong> TinyShade is under active development. APIs, visuals, and performance characteristics may change.</p>
</blockquote>
<p>The source code for each example can be found in:</p>
<p><a href="media/example">/src/example/</a></p>
<pre><code class="python">Each example is self-contained and intended to demonstrate a specific feature or rendering technique.
</code><button type="button">Copy</button></pre>

<hr>
<h2 id="üßÅ-tinyshadebake-45-kb-runner" class="tsd-anchor-link">üßÅ TinyShadeBake &amp; 4.5 KB Runner<a href="#üßÅ-tinyshadebake-45-kb-runner" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Bake freezes your live dependency graph into a <strong>portable, replay-only artifact</strong>.</p>
<blockquote>
<p>&quot;While standard WebGPU wrappers start at 100 KB+, TinyShade delivers a complete Compute/Fragment pipeline at ~4% of the size.&quot;</p>
</blockquote>
<h3 id="baking-pipeline" class="tsd-anchor-link">Baking Pipeline<a href="#baking-pipeline" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li><strong>Entropic Optimization:</strong> uniform + WGSL deduplication</li>
<li><strong>Shader Mangling:</strong> aggressive minification</li>
<li><strong>Steganographic Packing:</strong> app encoded into PNG RGB channels</li>
<li><strong>Self-Contained Bootloader:</strong> single <code>.html</code> output</li>
</ul>
<h3 id="size-comparison" class="tsd-anchor-link">Size Comparison<a href="#size-comparison" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><table>
<thead>
<tr>
<th>Stage</th>
<th>Raw Dev State</th>
<th>Baked &amp; Packed</th>
</tr>
</thead>
<tbody>
<tr>
<td>Framework/Runner</td>
<td>~15 KB</td>
<td>4.5 KB</td>
</tr>
<tr>
<td>Shader Library</td>
<td>128 KB</td>
<td>~15 KB</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>143 KB</strong></td>
<td><strong>&lt; 20 KB</strong></td>
</tr>
</tbody>
</table>
<h3 id="baking-an-app-code-example" class="tsd-anchor-link">Baking an app (Code Example)<a href="#baking-an-app-code-example" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Once your TinyShade scene/app  is complete, baking it into a distributable artifact is a <strong>single call</strong>.</p>
<h4 id="default-runner" class="tsd-anchor-link">Default Runner<a href="#default-runner" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><pre><code class="ts"><span class="hl-4">import</span><span class="hl-2"> { </span><span class="hl-5">TinyShadeBake</span><span class="hl-2"> } </span><span class="hl-4">from</span><span class="hl-2"> </span><span class="hl-3">&quot;./TinyShadeBake&quot;</span><span class="hl-2">;</span><br/><span class="hl-4">import</span><span class="hl-2"> </span><span class="hl-5">RunnerSource</span><span class="hl-2"> </span><span class="hl-4">from</span><span class="hl-2"> </span><span class="hl-3">&quot;../TinyShaderRunner.ts?raw&quot;</span><span class="hl-2">;</span><br/><br/><span class="hl-6">const</span><span class="hl-2"> </span><span class="hl-7">minifiedRunnerCode</span><span class="hl-2"> = </span><span class="hl-4">await</span><span class="hl-2"> </span><span class="hl-1">minifyJS</span><span class="hl-2">(</span><span class="hl-5">RunnerSource</span><span class="hl-2">);</span><br/><br/><span class="hl-4">await</span><span class="hl-2"> </span><span class="hl-5">TinyShadeBake</span><span class="hl-2">.</span><span class="hl-1">downloadSelfContained</span><span class="hl-2">(</span><span class="hl-5">app</span><span class="hl-2">, </span><span class="hl-3">&quot;demo.html&quot;</span><span class="hl-2">, </span><span class="hl-5">minifiedRunnerCode</span><span class="hl-2">.</span><span class="hl-5">code</span><span class="hl-2">!);</span><br/>
</code><button type="button">Copy</button></pre>

<p>This produces:</p>
<ul>
<li>One <code>.html</code> file</li>
<li>No external assets</li>
<li>No runtime dependencies</li>
<li>Ready-to-share output</li>
<li>Works offline</li>
</ul>
<blockquote>
<p>The runner source is embedded directly into the baked payload and instantiated at runtime.<br>
This allows <strong>full control over execution</strong> while keeping the original scene untouched.</p>
</blockquote>
<h2 id="üõ†-scripts-overview" class="tsd-anchor-link">üõ† Scripts Overview<a href="#üõ†-scripts-overview" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><table>
<thead>
<tr>
<th>Command</th>
<th>Action</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>npm run build</code></td>
<td><code>tsc</code></td>
<td>Compile TypeScript sources using <code>tsconfig.json</code>.</td>
</tr>
<tr>
<td><code>npm run prepublishOnly</code></td>
<td>build hook</td>
<td>Ensures compiled output before publishing.</td>
</tr>
<tr>
<td><code>npm run start</code></td>
<td>dev server</td>
<td>Launches webpack dev server with live reload.</td>
</tr>
<tr>
<td><code>npm run start-prod</code></td>
<td>prod server</td>
<td>Dev server simulating production build.</td>
</tr>
<tr>
<td><code>npm run build-examples</code></td>
<td>bundle</td>
<td>Builds example projects to static output.</td>
</tr>
<tr>
<td><code>npm run wgsl:minify</code></td>
<td>custom script</td>
<td>Minifies WGSL shaders for size and packing.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="‚ö°-the-wgsl-shrinker-utility-overview" class="tsd-anchor-link">‚ö° The WGSL Shrinker (Utility Overview)<a href="#‚ö°-the-wgsl-shrinker-utility-overview" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The <code>wgsl:minify script</code> is a specialized build-step utility designed for WebGPU workflows.</p>
<p>Recursive Processing: It scans the <code>src/</code> directory for any .wgsl files, including those nested deep in subfolders.</p>
<p>Clean &amp; Compress: It strips out single-line (//) and multi-line (/* */) comments and collapses redundant whitespace into a single space.</p>
<p>Artifact Creation: For every source.wgsl, it generates a source.min.wgsl.</p>
<blockquote>
<p>Purpose: This reduces the final &quot;Bake&quot; payload size (essential for the PNG-encoded self-contained demos) and provides a basic layer of code obfuscation for shared shaders.</p>
</blockquote>
<h2 id="‚ö°-technical-architecture" class="tsd-anchor-link">‚ö° Technical Architecture<a href="#‚ö°-technical-architecture" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><ul>
<li>
<p><strong>Atomic Pass Orchestration</strong>: TinyShade treats the GPU as a sequential state machine. It handles the heavy lifting of <code>CommandEncoder</code> management and <code>Compute-to-Render</code> synchronization, ensuring zero-latency data handover between simulation and visualization stages.</p>
</li>
<li>
<p><strong>Recursive Temporal Buffer Management</strong>: Implements a sophisticated &quot;Ping-Pong&quot; texture strategy. By maintaining dual-buffer states for every fragment pass, the engine enables $O(1)$ access to historical frame data (<code>prev_name</code>), turning linear shaders into recursive feedback systems.</p>
</li>
<li>
<p><strong>Adaptive Dispatch Heuristics</strong>: Rather than using naive thread counts, the engine queries hardware limits to calculate the <strong>Optimal Workgroup Topology</strong>. It aligns dispatch grids with the GPU's internal SIMD width, maximizing occupancy and throughput across varying architectures.</p>
</li>
<li>
<p><strong>Sample-Locked Synchronization</strong>: By hijacking the uniform update loop with <code>IAudioPlugin</code>, the engine achieves sample-accurate phase alignment between visuals and audio. This eliminates the &quot;clock drift&quot; common in <code>requestAnimationFrame</code> and ensures every pixel update is chronologically locked to the audio sample clock.</p>
</li>
<li>
<p><strong>Procedural Geometry Injection</strong>: Utilizes a &quot;Vertex-less&quot; rendering technique. By generating Clip Space coordinates directly from <code>@builtin(vertex_index)</code>, it bypasses the entire Input Assembler stage, reducing memory bandwidth overhead and eliminating the need for CPU-side vertex buffers.</p>
</li>
</ul>
<hr>
<h2 id="ü•Ç-credits" class="tsd-anchor-link">ü•Ç Credits<a href="#ü•Ç-credits" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><ul>
<li><strong>M√•rten R√•nge</strong> ‚Äî Path tracing example &amp; inspiration (SYTYCC 2025)</li>
<li><strong>PCrush</strong> ‚Äî GPUSynth &amp; audio architecture</li>
</ul>
<h2 id="üìö-resources-learning" class="tsd-anchor-link">üìö Resources &amp; Learning<a href="#üìö-resources-learning" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><ul>
<li><strong><a href="https://magnusthor.github.io/TinyShade/public/doc">Full API Reference</a></strong> ‚Äì Auto-generated documentation for all classes, types, and methods.</li>
<li><strong><a href="https://magnusthor.github.io/TinyShade/public/">Live Examples</a></strong> ‚Äì Interactive shaders and experiments.</li>
</ul>
<hr>
<p><strong>Magnus Thor</strong></p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="assets/icons.svg#icon-chevronDown"></use></svg><h3>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="assets/icons.svg#icon-chevronDown"></use></svg><h3>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#üåë-tinyshade"><span>üåë <wbr/>Tiny<wbr/>Shade</span></a><ul><li><a href="#‚öñÔ∏è-a-tiny-footprint"><span>‚öñÔ∏è <wbr/>A <wbr/>Tiny <wbr/>Footprint</span></a></li><li><a href="#üì¶-installation-setup"><span>üì¶ <wbr/>Installation &amp; <wbr/>Setup</span></a></li><li><a href="#üöÄ-quick-start-dependency-aware-graph"><span>üöÄ <wbr/>Quick <wbr/>Start: <wbr/>Dependency-<wbr/>Aware <wbr/>Graph</span></a></li><li><ul><li><a href="#üí°-the-omit-rule-convention-over-configuration"><span>üí° <wbr/>The &quot;<wbr/>Omit&quot; <wbr/>Rule (<wbr/>Convention over <wbr/>Configuration)</span></a></li></ul></li><li><a href="#üó∫Ô∏è-smart-dag-execution-model"><span>üó∫Ô∏è <wbr/>Smart-<wbr/>DAG <wbr/>Execution <wbr/>Model</span></a></li><li><ul><li><a href="#1-implicit-dependency-linear-default"><span>1. <wbr/>Implicit <wbr/>Dependency (<wbr/>Linear <wbr/>Default)</span></a></li><li><a href="#2-explicit-dependency-"><span>2. <wbr/>Explicit <wbr/>Dependency ()</span></a></li><li><a href="#1-omit-the-argument-linear-default"><span>1. <wbr/>Omit the  argument (<wbr/>Linear <wbr/>Default)</span></a></li><li><a href="#2-pass-an-empty-array-isolated"><span>2. <wbr/>Pass an empty array  (<wbr/>Isolated)</span></a></li><li><a href="#3-pass-a-specific-array-surgical"><span>3. <wbr/>Pass a specific array  (<wbr/>Surgical)</span></a></li></ul></li><li><a href="#üìú-shader-variable-reference"><span>üìú <wbr/>Shader <wbr/>Variable <wbr/>Reference</span></a></li><li><a href="#üß†-high-level-pipeline-overview"><span>üß† <wbr/>High-<wbr/>Level <wbr/>Pipeline <wbr/>Overview</span></a></li><li><ul><li><a href="#the-named-execution-flow"><span>The <wbr/>Named <wbr/>Execution <wbr/>Flow</span></a></li><li><a href="#temporal-feedback-ping-ponging"><span>Temporal <wbr/>Feedback (<wbr/>Ping-<wbr/>Ponging)</span></a></li><li><a href="#üß™-best-practice-atomic-heatmaps"><span>üß™ <wbr/>Best <wbr/>Practice: <wbr/>Atomic <wbr/>Heatmaps</span></a></li></ul></li><li><a href="#‚¨õ-core-api"><span>‚¨õ <wbr/>Core <wbr/>API</span></a></li><li><ul><li><a href="#1-initialize"><span>1. <wbr/>Initialize</span></a></li><li><a href="#2-compute-pass"><span>2. <wbr/>Compute <wbr/>Pass</span></a></li><li><a href="#3-atomic-passes"><span>3. <wbr/>Atomic <wbr/>Passes</span></a></li><li><a href="#fragment-pass-ping-pong-managed"><span>Fragment <wbr/>Pass (<wbr/>Ping-<wbr/>Pong <wbr/>Managed)</span></a></li></ul></li><li><a href="#üé¨-plugin-system-sequencer"><span>üé¨ <wbr/>Plugin <wbr/>System &amp; <wbr/>Sequencer</span></a></li><li><ul><li><a href="#tssequencer"><span>TS<wbr/>Sequencer</span></a></li><li><a href="#ibakeplugin-interface"><span>I<wbr/>Bake<wbr/>Plugin <wbr/>Interface</span></a></li><li><a href="#üé≠-frame-locked-orchestration"><span>üé≠ <wbr/>Frame-<wbr/>Locked <wbr/>Orchestration</span></a></li></ul></li><li><a href="#üéπ-audio-integration-addaudio"><span>üéπ <wbr/>Audio <wbr/>Integration (add<wbr/>Audio)</span></a></li><li><ul><li><a href="#üñ•Ô∏èüé∂-gpu-music-from-pcrush"><span>üñ•Ô∏èüé∂ <wbr/>GPU <wbr/>Music from <wbr/>P<wbr/>Crush</span></a></li></ul></li><li><a href="#various-examples-on-tinyshade"><span>Various <wbr/>Examples on <wbr/>Tiny<wbr/>Shade</span></a></li><li><a href="#üßÅ-tinyshadebake-45-kb-runner"><span>üßÅ <wbr/>Tiny<wbr/>Shade<wbr/>Bake &amp; 4.5 <wbr/>KB <wbr/>Runner</span></a></li><li><ul><li><a href="#baking-pipeline"><span>Baking <wbr/>Pipeline</span></a></li><li><a href="#size-comparison"><span>Size <wbr/>Comparison</span></a></li><li><a href="#baking-an-app-code-example"><span>Baking an app (<wbr/>Code <wbr/>Example)</span></a></li><li><ul><li><a href="#default-runner"><span>Default <wbr/>Runner</span></a></li></ul></li></ul></li><li><a href="#üõ†-scripts-overview"><span>üõ† <wbr/>Scripts <wbr/>Overview</span></a></li><li><ul><li><a href="#‚ö°-the-wgsl-shrinker-utility-overview"><span>‚ö° <wbr/>The <wbr/>WGSL <wbr/>Shrinker (<wbr/>Utility <wbr/>Overview)</span></a></li></ul></li><li><a href="#‚ö°-technical-architecture"><span>‚ö° <wbr/>Technical <wbr/>Architecture</span></a></li><li><a href="#ü•Ç-credits"><span>ü•Ç <wbr/>Credits</span></a></li><li><a href="#üìö-resources-learning"><span>üìö <wbr/>Resources &amp; <wbr/>Learning</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="modules.html">TinyShade</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>
