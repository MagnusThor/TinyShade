/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/TinyShade.ts"
/*!**************************!*\
  !*** ./src/TinyShade.ts ***!
  \**************************/
(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TinyShade = void 0;\nconst UniformLayout_1 = __webpack_require__(/*! ./UniformLayout */ \"./src/UniformLayout.ts\");\n/**\n * Utility for writing data to GPU Buffers.\n */\nconst Buffer = {\n    /**\n     * Writes an ArrayBufferView to a GPUBuffer.\n     * @param device The active GPUDevice.\n     * @param buffer The target GPUBuffer.\n     * @param data The data to write.\n     * @param offset Byte offset in the buffer.\n     */\n    write(device, buffer, data, offset = 0) {\n        device.queue.writeBuffer(buffer, offset, data.buffer, data.byteOffset, data.byteLength);\n        return buffer;\n    }\n};\n/**\n * Calculates the largest power of two less than or equal to n.\n * Useful for optimizing workgroup sizes.\n */\nconst largestPowerOf2LessThan = (n) => {\n    let power = 1;\n    while (power * 2 <= n)\n        power *= 2;\n    return power;\n};\n/**\n * Determines optimal workgroup sizes based on hardware limits.\n */\nconst getWorkgroupSize = (limits) => {\n    const x = Math.min(16, largestPowerOf2LessThan(limits.maxComputeWorkgroupSizeX));\n    const y = Math.min(16, largestPowerOf2LessThan(limits.maxComputeWorkgroupSizeY));\n    return { x, y, z: 1, str: `@workgroup_size(${x}, ${y}, 1)` };\n};\n/**\n * TinyShade: A minimal, high-performance WebGPU framework for\n * multi-pass fragment and compute shaders.\n */\nclass TinyShade {\n    device;\n    context;\n    canvas;\n    uniforms;\n    uniformBuffer;\n    audioPlugin;\n    startTime = 0;\n    frameCounter = 0;\n    sequencer;\n    globalTextures = new Map();\n    commonWGSL = \"\";\n    passes = [];\n    passLayouts = [];\n    bgCache = [];\n    mainPassShader = \"\";\n    mainPipeline;\n    isCompiled = false;\n    startedAudio = false;\n    _mainDeps = undefined;\n    workgroupSize = { x: 8, y: 8, z: 1, str: \"@workgroup_size(8, 8, 1)\" };\n    globalSampler;\n    constructor(canvas) {\n        this.canvas = canvas;\n        const dpr = window.devicePixelRatio || 1;\n        this.uniforms = new UniformLayout_1.UniformLayout([this.canvas.width * dpr, this.canvas.height * dpr, dpr]);\n    }\n    /**\n     * Initializes the WebGPU context and creates a TinyShade instance.\n     * @param canvasId The ID of the HTML canvas element.\n     */\n    static async create(canvasId) {\n        const canvas = document.getElementById(canvasId);\n        const ts = new TinyShade(canvas);\n        await ts.initWebGPU();\n        return ts;\n    }\n    async initWebGPU() {\n        const adapter = await navigator.gpu?.requestAdapter();\n        if (!adapter)\n            throw \"WebGPU not supported\";\n        const features = [];\n        if (adapter.features.has('bgra8unorm-storage'))\n            features.push('bgra8unorm-storage');\n        if (adapter.features.has('timestamp-query'))\n            features.push('timestamp-query');\n        this.device = await adapter.requestDevice({ requiredFeatures: features });\n        this.globalSampler = this.device.createSampler({ magFilter: 'linear', minFilter: 'linear' });\n        this.workgroupSize = getWorkgroupSize(adapter.limits);\n        this.context = this.canvas.getContext(\"webgpu\");\n        this.context.configure({\n            device: this.device,\n            format: navigator.gpu.getPreferredCanvasFormat(),\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.startTime = performance.now();\n    }\n    getRelevantPasses(currentPass) {\n        const base = currentPass.dependencies\n            ? this.passes.filter(p => currentPass.dependencies.includes(p.name))\n            : this.passes;\n        const resultSet = new Set(base);\n        if (!currentPass.isMain)\n            resultSet.add(currentPass);\n        return Array.from(resultSet);\n    }\n    /**\n     * Connects an audio plugin to synchronize uniforms with audio data.\n     */\n    addAudio(plugin) { this.audioPlugin = plugin; return this; }\n    /**\n     * Attaches a sequencer to the engine to drive sceneId, progress, and flags.\n     */\n    addSequencer(sequencer) {\n        this.sequencer = sequencer;\n        return this;\n    }\n    /**\n     * Adds WGSL code that will be prepended to all subsequent pass shaders.\n     * Useful for shared structs and constants.\n     */\n    addCommon(wgsl) { this.commonWGSL += `\\n${wgsl}\\n`; return this; }\n    /**\n     * Loads an image into a global texture accessible by all passes.\n     * @param name Name of the variable in WGSL (e.g., 'var tex: texture_2d<f32>').\n     * @param src URL or image element source.\n     */\n    async addTexture(name, src) {\n        let source;\n        if (typeof src === 'string') {\n            const img = new Image();\n            img.src = src;\n            await img.decode();\n            source = await createImageBitmap(img);\n        }\n        else {\n            source = src;\n        }\n        const texture = this.device.createTexture({\n            size: [source.width, source.height],\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.device.queue.copyExternalImageToTexture({ source }, { texture }, [source.width, source.height]);\n        this.globalTextures.set(name, texture);\n        return this;\n    }\n    /**\n     * configures the global uniform layout.\n     * @param callback Use this to add custom uniforms via layout.add().\n     */\n    setUniforms(callback) {\n        if (callback)\n            callback(this.uniforms);\n        this.uniformBuffer = this.device.createBuffer({\n            size: this.uniforms.byteSize,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n        return this;\n    }\n    /**\n     * Adds a GPGPU compute pass.\n     * @param name Used to reference this pass result in others.\n     * @param wgsl Compute shader code. Use '##WORKGROUP_SIZE' for auto-optimization.\n     * @param size Optional size for a storage buffer (array<f32>).\n     * @param deps List of pass names to read from.\n     */\n    addCompute(name, wgsl, size = 0, deps) {\n        const tex = this.device.createTexture({\n            size: [this.canvas.width, this.canvas.height],\n            format: \"rgba8unorm\",\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING\n        });\n        let buf;\n        if (size > 0)\n            buf = this.device.createBuffer({ size: size * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n        this.passes.push({ name, type: 'compute', shader: wgsl, textures: [tex], storageBuffer: buf, pipelines: [], dependencies: deps });\n        return this;\n    }\n    /**\n     * Adds a compute pass optimized for atomic operations (e.g., histograms, particle counters).\n     */\n    addAtomicCompute(name, wgsl, bufferSize, clear = true, deps) {\n        const buf = this.device.createBuffer({\n            size: bufferSize * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n        });\n        this.passes.push({ name, type: 'compute', shader: wgsl, storageBuffer: buf, isAtomic: true, clear: clear, pipelines: [], textures: [], dependencies: deps });\n        return this;\n    }\n    /**\n     * Adds a full-screen fragment pass.\n     * This automatically manages two textures for feedback loops (ping-ponging).\n     * @param name Name of the texture variable in WGSL.\n     * @param wgsl Fragment shader code.\n     * @param deps List of pass names to read from.\n     */\n    addPass(name, wgsl, deps) {\n        const createTex = () => this.device.createTexture({\n            size: [this.canvas.width, this.canvas.height],\n            format: \"bgra8unorm\",\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.passes.push({ name, type: 'fragment', shader: wgsl, textures: [createTex(), createTex()], pipelines: [], dependencies: deps });\n        return this;\n    }\n    /**\n     * The final output pass that renders to the canvas.\n     * Calling this triggers the shader compilation process.\n     * @param wgsl Final fragment shader code.\n     * @param deps Pass names to be sampled in the final output.\n     */\n    async main(wgsl, deps) {\n        this.mainPassShader = wgsl;\n        this._mainDeps = deps;\n        this.compile(deps);\n        return this;\n    }\n    compile(mainDeps) {\n        if (!this.uniformBuffer)\n            this.setUniforms();\n        const vertCode = `\r\n            struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\r\n            @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\r\n                var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\r\n                return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\r\n            }\r\n        `;\n        const allStages = [...this.passes, {\n                name: \"main\", type: 'fragment', shader: this.mainPassShader,\n                isMain: true, textures: [], pipelines: [], dependencies: mainDeps\n            }];\n        allStages.forEach((currentPass, stageIdx) => {\n            let b = 0;\n            const layoutEntries = [];\n            let header = `${this.uniforms.wgslStruct}\\n@group(0) @binding(${b}) var<uniform> u: Uniforms;\\n`;\n            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } });\n            this.globalTextures.forEach((_, name) => {\n                header += `@group(0) @binding(${b}) var ${name}: texture_2d<f32>;\\n`;\n                layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n            });\n            header += `@group(0) @binding(${b}) var samp: sampler;\\n`;\n            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, sampler: {} });\n            this.getRelevantPasses(currentPass).forEach((p) => {\n                const isSelf = (currentPass === p);\n                if (p.type === 'compute') {\n                    if (p.textures.length > 0) {\n                        if (isSelf) {\n                            header += `@group(0) @binding(${b}) var outTex: texture_storage_2d<rgba8unorm, write>;\\n`;\n                            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.COMPUTE, storageTexture: { format: 'rgba8unorm', access: 'write-only' } });\n                        }\n                        else {\n                            header += `@group(0) @binding(${b}) var ${p.name}: texture_2d<f32>;\\n`;\n                            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n                        }\n                    }\n                    if (p.storageBuffer) {\n                        const bufName = isSelf ? \"data\" : `${p.name}_data`;\n                        header += `@group(0) @binding(${b}) var<storage, read_write> ${bufName}: ${p.isAtomic ? \"array<atomic<u32>>\" : \"array<f32>\"};\\n`;\n                        layoutEntries.push({ binding: b++, visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT, buffer: { type: 'storage' } });\n                    }\n                }\n                else {\n                    header += `@group(0) @binding(${b}) var ${p.name}: texture_2d<f32>;\\n`;\n                    layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n                    header += `@group(0) @binding(${b}) var prev_${p.name}: texture_2d<f32>;\\n`;\n                    layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n                }\n            });\n            const layout = this.device.createBindGroupLayout({ entries: layoutEntries });\n            this.passLayouts[stageIdx] = layout;\n            const code = (currentPass.type === 'fragment' ? vertCode : \"\") + header + this.commonWGSL +\n                (currentPass.type === 'compute' ? currentPass.shader.replace(\"##WORKGROUP_SIZE\", `@compute ${this.workgroupSize.str}`) : currentPass.shader);\n            const mod = this.device.createShaderModule({ code });\n            console.info(`${currentPass.name}\\n\\n${code}\\n\\n`);\n            const pipeLayout = this.device.createPipelineLayout({ bindGroupLayouts: [layout] });\n            if (currentPass.type === 'compute') {\n                currentPass.pipelines[0] = this.device.createComputePipeline({ layout: pipeLayout, compute: { module: mod, entryPoint: 'main' } });\n            }\n            else {\n                currentPass.pipelines[0] = this.device.createRenderPipeline({\n                    layout: pipeLayout, vertex: { module: mod, entryPoint: 'vs' },\n                    fragment: { module: mod, entryPoint: 'main', targets: [{ format: currentPass.isMain ? navigator.gpu.getPreferredCanvasFormat() : \"bgra8unorm\" }] }\n                });\n                if (currentPass.isMain)\n                    this.mainPipeline = currentPass.pipelines[0];\n            }\n        });\n        this.isCompiled = true;\n    }\n    createBindGroup(stageIdx, writeIdx) {\n        const readIdx = 1 - writeIdx;\n        const isMainPass = stageIdx === this.passes.length;\n        const currentPass = isMainPass\n            ? { name: 'main', isMain: true, dependencies: this._mainDeps }\n            : this.passes[stageIdx];\n        const entries = [];\n        let b = 0;\n        entries.push({ binding: b++, resource: { buffer: this.uniformBuffer } });\n        this.globalTextures.forEach(tex => entries.push({ binding: b++, resource: tex.createView() }));\n        entries.push({ binding: b++, resource: this.globalSampler });\n        this.getRelevantPasses(currentPass).forEach((p) => {\n            const isSelf = (currentPass === p);\n            if (p.type === 'compute') {\n                if (p.textures.length > 0)\n                    entries.push({ binding: b++, resource: p.textures[0].createView() });\n                if (p.storageBuffer)\n                    entries.push({ binding: b++, resource: { buffer: p.storageBuffer } });\n            }\n            else {\n                if (isSelf) {\n                    entries.push({ binding: b++, resource: p.textures[readIdx].createView() });\n                    entries.push({ binding: b++, resource: p.textures[readIdx].createView() });\n                }\n                else {\n                    entries.push({ binding: b++, resource: p.textures[writeIdx].createView() });\n                    entries.push({ binding: b++, resource: p.textures[readIdx].createView() });\n                }\n            }\n        });\n        return this.device.createBindGroup({ layout: this.passLayouts[stageIdx], entries });\n    }\n    /**\n * Starts the render loop and manages the GPU command lifecycle.\n * @param timer Optional WebGPUTiming plugin for profiling.\n */\n    run(timer) {\n        const frame = (now) => {\n            if (!this.isCompiled)\n                return;\n            if (this.audioPlugin && !this.startedAudio) {\n                this.audioPlugin.play();\n                this.startedAudio = true;\n            }\n            const time = (this.audioPlugin?.isPlaying) ? this.audioPlugin.getTime() : (now - this.startTime) / 1000;\n            const writeIdx = (this.frameCounter % 2);\n            if (this.sequencer) {\n                const state = this.sequencer.update(time);\n                this.uniforms.updateSequencer(state.sceneId, state.progress, state.flags);\n            }\n            this.uniforms.update(time);\n            this.device.queue.writeBuffer(this.uniformBuffer, 0, this.uniforms.float32Array);\n            const enc = this.device.createCommandEncoder();\n            const passTimings = [];\n            if (timer)\n                timer.reset();\n            this.passes.forEach((p, i) => {\n                // Framework Logic: Only clear if explicitly requested or if it's a fresh atomic pass\n                if (p.isAtomic && p.storageBuffer && p.clear !== false) {\n                    enc.clearBuffer(p.storageBuffer);\n                }\n                const bg = this.createBindGroup(i, writeIdx);\n                let tw;\n                if (timer) {\n                    const idx = timer.allocateIndices();\n                    if (idx) {\n                        tw = { querySet: timer.querySet, beginningOfPassWriteIndex: idx.start, endOfPassWriteIndex: idx.end };\n                        passTimings.push({ name: p.name, ...idx });\n                    }\n                }\n                if (p.type === 'compute') {\n                    const cp = enc.beginComputePass({ timestampWrites: tw });\n                    cp.setPipeline(p.pipelines[0]);\n                    cp.setBindGroup(0, bg);\n                    /**\n                     * FRAMEWORK DISPATCH LOGIC:\n                     * 1. If the pass has textures, it's likely a Screen-Space Compute (Resolution based).\n                     * 2. If it has NO textures but HAS a buffer, it's a Data-only Compute (Buffer size based).\n                     */\n                    if (p.textures && p.textures.length > 0) {\n                        // Screen-space: Dispatch by Canvas Dimensions\n                        cp.dispatchWorkgroups(Math.ceil(this.canvas.width / this.workgroupSize.x), Math.ceil(this.canvas.height / this.workgroupSize.y), 1);\n                    }\n                    else if (p.storageBuffer) {\n                        // Data-space: Dispatch by Buffer Length (divided by 4 bytes per float)\n                        // We assume 1D dispatch for data-only buffers\n                        const totalElements = p.storageBuffer.size / 4;\n                        const threadsPerGroup = this.workgroupSize.x * this.workgroupSize.y;\n                        cp.dispatchWorkgroups(Math.ceil(totalElements / threadsPerGroup), 1, 1);\n                    }\n                    cp.end();\n                }\n                else {\n                    // Standard Fragment Pass\n                    const rp = enc.beginRenderPass({\n                        colorAttachments: [{\n                                view: p.textures[writeIdx].createView(),\n                                loadOp: \"clear\",\n                                storeOp: \"store\",\n                                clearValue: [0, 0, 0, 1]\n                            }],\n                        timestampWrites: tw\n                    });\n                    rp.setPipeline(p.pipelines[0]);\n                    rp.setBindGroup(0, bg);\n                    rp.draw(3);\n                    rp.end();\n                }\n            });\n            // Final Canvas Output\n            const mainBG = this.createBindGroup(this.passes.length, writeIdx);\n            let mtw;\n            if (timer) {\n                const idx = timer.allocateIndices();\n                if (idx) {\n                    mtw = { querySet: timer.querySet, beginningOfPassWriteIndex: idx.start, endOfPassWriteIndex: idx.end };\n                    passTimings.push({ name: \"main\", ...idx });\n                }\n            }\n            const mp = enc.beginRenderPass({\n                colorAttachments: [{\n                        view: this.context.getCurrentTexture().createView(),\n                        loadOp: \"clear\",\n                        storeOp: \"store\",\n                        clearValue: [0, 0, 0, 1]\n                    }],\n                timestampWrites: mtw\n            });\n            mp.setPipeline(this.mainPipeline);\n            mp.setBindGroup(0, mainBG);\n            mp.draw(3);\n            mp.end();\n            this.device.queue.submit([enc.finish()]);\n            if (timer)\n                timer.resolve(passTimings);\n            this.frameCounter++;\n            requestAnimationFrame(frame);\n        };\n        requestAnimationFrame(frame);\n        return this;\n    }\n}\nexports.TinyShade = TinyShade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVGlueVNoYWRlLnRzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQix3QkFBd0IsbUJBQU8sQ0FBQywrQ0FBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0NBQW9DLEVBQUUsSUFBSSxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDRCQUE0QjtBQUNoRix5REFBeUQsMENBQTBDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QixLQUFLLEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1REFBdUQsUUFBUSxJQUFJLFNBQVM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkNBQTZDLHlFQUF5RTtBQUN0SCwyQkFBMkIsNkdBQTZHO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyQkFBMkIsd0lBQXdJO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCLCtHQUErRztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCLHVCQUF1QixFQUFFLDJCQUEyQjtBQUN6RyxpQ0FBaUMsOEdBQThHLG1CQUFtQjtBQUNsSztBQUNBLGdEQUFnRCxFQUFFLFFBQVEsS0FBSyxrQkFBa0I7QUFDakYscUNBQXFDLHlGQUF5RjtBQUM5SCxhQUFhO0FBQ2IsNENBQTRDLEVBQUUsb0JBQW9CO0FBQ2xFLGlDQUFpQyx5RkFBeUY7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxFQUFFLG9EQUFvRDtBQUNsSCxpREFBaUQsb0VBQW9FLDhDQUE4QztBQUNuSztBQUNBO0FBQ0EsNERBQTRELEVBQUUsUUFBUSxPQUFPLGtCQUFrQjtBQUMvRixpREFBaUQseUZBQXlGO0FBQzFJO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxPQUFPO0FBQ3BFLHdEQUF3RCxFQUFFLDZCQUE2QixRQUFRLElBQUksa0RBQWtEO0FBQ3JKLDZDQUE2QyxzRkFBc0YsbUJBQW1CO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFLFFBQVEsT0FBTyxrQkFBa0I7QUFDdkYseUNBQXlDLHlGQUF5RjtBQUNsSSxvREFBb0QsRUFBRSxhQUFhLE9BQU8sa0JBQWtCO0FBQzVGLHlDQUF5Qyx5RkFBeUY7QUFDbEk7QUFDQSxhQUFhO0FBQ2IsK0RBQStELHdCQUF3QjtBQUN2RjtBQUNBO0FBQ0EsNkdBQTZHLHVCQUF1QjtBQUNwSSx5REFBeUQsTUFBTTtBQUMvRCw0QkFBNEIsaUJBQWlCLE1BQU0sS0FBSztBQUN4RCxrRUFBa0UsNEJBQTRCO0FBQzlGO0FBQ0EsK0VBQStFLCtCQUErQixtQ0FBbUM7QUFDako7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELCtCQUErQjtBQUNqRixnQ0FBZ0MsNkNBQTZDLHNGQUFzRjtBQUNuSyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCLDhCQUE4QjtBQUMvRSwwREFBMEQsMENBQTBDO0FBQ3BHLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0RBQW9EO0FBQ3ZGO0FBQ0EsbUNBQW1DLDBCQUEwQiwyQkFBMkI7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBEQUEwRDtBQUM3RixtQ0FBbUMsMERBQTBEO0FBQzdGO0FBQ0E7QUFDQSxtQ0FBbUMsMkRBQTJEO0FBQzlGLG1DQUFtQywwREFBMEQ7QUFDN0Y7QUFDQTtBQUNBLFNBQVM7QUFDVCw2Q0FBNkMsNkNBQTZDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlueXNoYWRlLy4vc3JjL1RpbnlTaGFkZS50cz8yOTllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UaW55U2hhZGUgPSB2b2lkIDA7XG5jb25zdCBVbmlmb3JtTGF5b3V0XzEgPSByZXF1aXJlKFwiLi9Vbmlmb3JtTGF5b3V0XCIpO1xuLyoqXG4gKiBVdGlsaXR5IGZvciB3cml0aW5nIGRhdGEgdG8gR1BVIEJ1ZmZlcnMuXG4gKi9cbmNvbnN0IEJ1ZmZlciA9IHtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gQXJyYXlCdWZmZXJWaWV3IHRvIGEgR1BVQnVmZmVyLlxuICAgICAqIEBwYXJhbSBkZXZpY2UgVGhlIGFjdGl2ZSBHUFVEZXZpY2UuXG4gICAgICogQHBhcmFtIGJ1ZmZlciBUaGUgdGFyZ2V0IEdQVUJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IEJ5dGUgb2Zmc2V0IGluIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgd3JpdGUoZGV2aWNlLCBidWZmZXIsIGRhdGEsIG9mZnNldCA9IDApIHtcbiAgICAgICAgZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxhcmdlc3QgcG93ZXIgb2YgdHdvIGxlc3MgdGhhbiBvciBlcXVhbCB0byBuLlxuICogVXNlZnVsIGZvciBvcHRpbWl6aW5nIHdvcmtncm91cCBzaXplcy5cbiAqL1xuY29uc3QgbGFyZ2VzdFBvd2VyT2YyTGVzc1RoYW4gPSAobikgPT4ge1xuICAgIGxldCBwb3dlciA9IDE7XG4gICAgd2hpbGUgKHBvd2VyICogMiA8PSBuKVxuICAgICAgICBwb3dlciAqPSAyO1xuICAgIHJldHVybiBwb3dlcjtcbn07XG4vKipcbiAqIERldGVybWluZXMgb3B0aW1hbCB3b3JrZ3JvdXAgc2l6ZXMgYmFzZWQgb24gaGFyZHdhcmUgbGltaXRzLlxuICovXG5jb25zdCBnZXRXb3JrZ3JvdXBTaXplID0gKGxpbWl0cykgPT4ge1xuICAgIGNvbnN0IHggPSBNYXRoLm1pbigxNiwgbGFyZ2VzdFBvd2VyT2YyTGVzc1RoYW4obGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCkpO1xuICAgIGNvbnN0IHkgPSBNYXRoLm1pbigxNiwgbGFyZ2VzdFBvd2VyT2YyTGVzc1RoYW4obGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSkpO1xuICAgIHJldHVybiB7IHgsIHksIHo6IDEsIHN0cjogYEB3b3JrZ3JvdXBfc2l6ZSgke3h9LCAke3l9LCAxKWAgfTtcbn07XG4vKipcbiAqIFRpbnlTaGFkZTogQSBtaW5pbWFsLCBoaWdoLXBlcmZvcm1hbmNlIFdlYkdQVSBmcmFtZXdvcmsgZm9yXG4gKiBtdWx0aS1wYXNzIGZyYWdtZW50IGFuZCBjb21wdXRlIHNoYWRlcnMuXG4gKi9cbmNsYXNzIFRpbnlTaGFkZSB7XG4gICAgZGV2aWNlO1xuICAgIGNvbnRleHQ7XG4gICAgY2FudmFzO1xuICAgIHVuaWZvcm1zO1xuICAgIHVuaWZvcm1CdWZmZXI7XG4gICAgYXVkaW9QbHVnaW47XG4gICAgc3RhcnRUaW1lID0gMDtcbiAgICBmcmFtZUNvdW50ZXIgPSAwO1xuICAgIHNlcXVlbmNlcjtcbiAgICBnbG9iYWxUZXh0dXJlcyA9IG5ldyBNYXAoKTtcbiAgICBjb21tb25XR1NMID0gXCJcIjtcbiAgICBwYXNzZXMgPSBbXTtcbiAgICBwYXNzTGF5b3V0cyA9IFtdO1xuICAgIGJnQ2FjaGUgPSBbXTtcbiAgICBtYWluUGFzc1NoYWRlciA9IFwiXCI7XG4gICAgbWFpblBpcGVsaW5lO1xuICAgIGlzQ29tcGlsZWQgPSBmYWxzZTtcbiAgICBzdGFydGVkQXVkaW8gPSBmYWxzZTtcbiAgICBfbWFpbkRlcHMgPSB1bmRlZmluZWQ7XG4gICAgd29ya2dyb3VwU2l6ZSA9IHsgeDogOCwgeTogOCwgejogMSwgc3RyOiBcIkB3b3JrZ3JvdXBfc2l6ZSg4LCA4LCAxKVwiIH07XG4gICAgZ2xvYmFsU2FtcGxlcjtcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSBuZXcgVW5pZm9ybUxheW91dF8xLlVuaWZvcm1MYXlvdXQoW3RoaXMuY2FudmFzLndpZHRoICogZHByLCB0aGlzLmNhbnZhcy5oZWlnaHQgKiBkcHIsIGRwcl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgV2ViR1BVIGNvbnRleHQgYW5kIGNyZWF0ZXMgYSBUaW55U2hhZGUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIGNhbnZhc0lkIFRoZSBJRCBvZiB0aGUgSFRNTCBjYW52YXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGNhbnZhc0lkKSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKTtcbiAgICAgICAgY29uc3QgdHMgPSBuZXcgVGlueVNoYWRlKGNhbnZhcyk7XG4gICAgICAgIGF3YWl0IHRzLmluaXRXZWJHUFUoKTtcbiAgICAgICAgcmV0dXJuIHRzO1xuICAgIH1cbiAgICBhc3luYyBpbml0V2ViR1BVKCkge1xuICAgICAgICBjb25zdCBhZGFwdGVyID0gYXdhaXQgbmF2aWdhdG9yLmdwdT8ucmVxdWVzdEFkYXB0ZXIoKTtcbiAgICAgICAgaWYgKCFhZGFwdGVyKVxuICAgICAgICAgICAgdGhyb3cgXCJXZWJHUFUgbm90IHN1cHBvcnRlZFwiO1xuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgICAgICBpZiAoYWRhcHRlci5mZWF0dXJlcy5oYXMoJ2JncmE4dW5vcm0tc3RvcmFnZScpKVxuICAgICAgICAgICAgZmVhdHVyZXMucHVzaCgnYmdyYTh1bm9ybS1zdG9yYWdlJyk7XG4gICAgICAgIGlmIChhZGFwdGVyLmZlYXR1cmVzLmhhcygndGltZXN0YW1wLXF1ZXJ5JykpXG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKCd0aW1lc3RhbXAtcXVlcnknKTtcbiAgICAgICAgdGhpcy5kZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2UoeyByZXF1aXJlZEZlYXR1cmVzOiBmZWF0dXJlcyB9KTtcbiAgICAgICAgdGhpcy5nbG9iYWxTYW1wbGVyID0gdGhpcy5kZXZpY2UuY3JlYXRlU2FtcGxlcih7IG1hZ0ZpbHRlcjogJ2xpbmVhcicsIG1pbkZpbHRlcjogJ2xpbmVhcicgfSk7XG4gICAgICAgIHRoaXMud29ya2dyb3VwU2l6ZSA9IGdldFdvcmtncm91cFNpemUoYWRhcHRlci5saW1pdHMpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ3B1XCIpO1xuICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlndXJlKHtcbiAgICAgICAgICAgIGRldmljZTogdGhpcy5kZXZpY2UsXG4gICAgICAgICAgICBmb3JtYXQ6IG5hdmlnYXRvci5ncHUuZ2V0UHJlZmVycmVkQ2FudmFzRm9ybWF0KCksXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICAgIGdldFJlbGV2YW50UGFzc2VzKGN1cnJlbnRQYXNzKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBjdXJyZW50UGFzcy5kZXBlbmRlbmNpZXNcbiAgICAgICAgICAgID8gdGhpcy5wYXNzZXMuZmlsdGVyKHAgPT4gY3VycmVudFBhc3MuZGVwZW5kZW5jaWVzLmluY2x1ZGVzKHAubmFtZSkpXG4gICAgICAgICAgICA6IHRoaXMucGFzc2VzO1xuICAgICAgICBjb25zdCByZXN1bHRTZXQgPSBuZXcgU2V0KGJhc2UpO1xuICAgICAgICBpZiAoIWN1cnJlbnRQYXNzLmlzTWFpbilcbiAgICAgICAgICAgIHJlc3VsdFNldC5hZGQoY3VycmVudFBhc3MpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHRTZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyBhbiBhdWRpbyBwbHVnaW4gdG8gc3luY2hyb25pemUgdW5pZm9ybXMgd2l0aCBhdWRpbyBkYXRhLlxuICAgICAqL1xuICAgIGFkZEF1ZGlvKHBsdWdpbikgeyB0aGlzLmF1ZGlvUGx1Z2luID0gcGx1Z2luOyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgc2VxdWVuY2VyIHRvIHRoZSBlbmdpbmUgdG8gZHJpdmUgc2NlbmVJZCwgcHJvZ3Jlc3MsIGFuZCBmbGFncy5cbiAgICAgKi9cbiAgICBhZGRTZXF1ZW5jZXIoc2VxdWVuY2VyKSB7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VyID0gc2VxdWVuY2VyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBXR1NMIGNvZGUgdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBhbGwgc3Vic2VxdWVudCBwYXNzIHNoYWRlcnMuXG4gICAgICogVXNlZnVsIGZvciBzaGFyZWQgc3RydWN0cyBhbmQgY29uc3RhbnRzLlxuICAgICAqL1xuICAgIGFkZENvbW1vbih3Z3NsKSB7IHRoaXMuY29tbW9uV0dTTCArPSBgXFxuJHt3Z3NsfVxcbmA7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gaW1hZ2UgaW50byBhIGdsb2JhbCB0ZXh0dXJlIGFjY2Vzc2libGUgYnkgYWxsIHBhc3Nlcy5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZSBpbiBXR1NMIChlLmcuLCAndmFyIHRleDogdGV4dHVyZV8yZDxmMzI+JykuXG4gICAgICogQHBhcmFtIHNyYyBVUkwgb3IgaW1hZ2UgZWxlbWVudCBzb3VyY2UuXG4gICAgICovXG4gICAgYXN5bmMgYWRkVGV4dHVyZShuYW1lLCBzcmMpIHtcbiAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgICAgICAgICBhd2FpdCBpbWcuZGVjb2RlKCk7XG4gICAgICAgICAgICBzb3VyY2UgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc291cmNlID0gc3JjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmRldmljZS5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgICAgIHNpemU6IFtzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHRdLFxuICAgICAgICAgICAgZm9ybWF0OiAncmdiYTh1bm9ybScsXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCB8IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZXZpY2UucXVldWUuY29weUV4dGVybmFsSW1hZ2VUb1RleHR1cmUoeyBzb3VyY2UgfSwgeyB0ZXh0dXJlIH0sIFtzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHRdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxUZXh0dXJlcy5zZXQobmFtZSwgdGV4dHVyZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25maWd1cmVzIHRoZSBnbG9iYWwgdW5pZm9ybSBsYXlvdXQuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFVzZSB0aGlzIHRvIGFkZCBjdXN0b20gdW5pZm9ybXMgdmlhIGxheW91dC5hZGQoKS5cbiAgICAgKi9cbiAgICBzZXRVbmlmb3JtcyhjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLnVuaWZvcm1zKTtcbiAgICAgICAgdGhpcy51bmlmb3JtQnVmZmVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIHNpemU6IHRoaXMudW5pZm9ybXMuYnl0ZVNpemUsXG4gICAgICAgICAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIEdQR1BVIGNvbXB1dGUgcGFzcy5cbiAgICAgKiBAcGFyYW0gbmFtZSBVc2VkIHRvIHJlZmVyZW5jZSB0aGlzIHBhc3MgcmVzdWx0IGluIG90aGVycy5cbiAgICAgKiBAcGFyYW0gd2dzbCBDb21wdXRlIHNoYWRlciBjb2RlLiBVc2UgJyMjV09SS0dST1VQX1NJWkUnIGZvciBhdXRvLW9wdGltaXphdGlvbi5cbiAgICAgKiBAcGFyYW0gc2l6ZSBPcHRpb25hbCBzaXplIGZvciBhIHN0b3JhZ2UgYnVmZmVyIChhcnJheTxmMzI+KS5cbiAgICAgKiBAcGFyYW0gZGVwcyBMaXN0IG9mIHBhc3MgbmFtZXMgdG8gcmVhZCBmcm9tLlxuICAgICAqL1xuICAgIGFkZENvbXB1dGUobmFtZSwgd2dzbCwgc2l6ZSA9IDAsIGRlcHMpIHtcbiAgICAgICAgY29uc3QgdGV4ID0gdGhpcy5kZXZpY2UuY3JlYXRlVGV4dHVyZSh7XG4gICAgICAgICAgICBzaXplOiBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF0sXG4gICAgICAgICAgICBmb3JtYXQ6IFwicmdiYTh1bm9ybVwiLFxuICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgYnVmO1xuICAgICAgICBpZiAoc2l6ZSA+IDApXG4gICAgICAgICAgICBidWYgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoeyBzaXplOiBzaXplICogNCwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB9KTtcbiAgICAgICAgdGhpcy5wYXNzZXMucHVzaCh7IG5hbWUsIHR5cGU6ICdjb21wdXRlJywgc2hhZGVyOiB3Z3NsLCB0ZXh0dXJlczogW3RleF0sIHN0b3JhZ2VCdWZmZXI6IGJ1ZiwgcGlwZWxpbmVzOiBbXSwgZGVwZW5kZW5jaWVzOiBkZXBzIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbXB1dGUgcGFzcyBvcHRpbWl6ZWQgZm9yIGF0b21pYyBvcGVyYXRpb25zIChlLmcuLCBoaXN0b2dyYW1zLCBwYXJ0aWNsZSBjb3VudGVycykuXG4gICAgICovXG4gICAgYWRkQXRvbWljQ29tcHV0ZShuYW1lLCB3Z3NsLCBidWZmZXJTaXplLCBjbGVhciA9IHRydWUsIGRlcHMpIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIHNpemU6IGJ1ZmZlclNpemUgKiA0LFxuICAgICAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhc3Nlcy5wdXNoKHsgbmFtZSwgdHlwZTogJ2NvbXB1dGUnLCBzaGFkZXI6IHdnc2wsIHN0b3JhZ2VCdWZmZXI6IGJ1ZiwgaXNBdG9taWM6IHRydWUsIGNsZWFyOiBjbGVhciwgcGlwZWxpbmVzOiBbXSwgdGV4dHVyZXM6IFtdLCBkZXBlbmRlbmNpZXM6IGRlcHMgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZnVsbC1zY3JlZW4gZnJhZ21lbnQgcGFzcy5cbiAgICAgKiBUaGlzIGF1dG9tYXRpY2FsbHkgbWFuYWdlcyB0d28gdGV4dHVyZXMgZm9yIGZlZWRiYWNrIGxvb3BzIChwaW5nLXBvbmdpbmcpLlxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIHRleHR1cmUgdmFyaWFibGUgaW4gV0dTTC5cbiAgICAgKiBAcGFyYW0gd2dzbCBGcmFnbWVudCBzaGFkZXIgY29kZS5cbiAgICAgKiBAcGFyYW0gZGVwcyBMaXN0IG9mIHBhc3MgbmFtZXMgdG8gcmVhZCBmcm9tLlxuICAgICAqL1xuICAgIGFkZFBhc3MobmFtZSwgd2dzbCwgZGVwcykge1xuICAgICAgICBjb25zdCBjcmVhdGVUZXggPSAoKSA9PiB0aGlzLmRldmljZS5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgICAgIHNpemU6IFt0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0XSxcbiAgICAgICAgICAgIGZvcm1hdDogXCJiZ3JhOHVub3JtXCIsXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXNzZXMucHVzaCh7IG5hbWUsIHR5cGU6ICdmcmFnbWVudCcsIHNoYWRlcjogd2dzbCwgdGV4dHVyZXM6IFtjcmVhdGVUZXgoKSwgY3JlYXRlVGV4KCldLCBwaXBlbGluZXM6IFtdLCBkZXBlbmRlbmNpZXM6IGRlcHMgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmluYWwgb3V0cHV0IHBhc3MgdGhhdCByZW5kZXJzIHRvIHRoZSBjYW52YXMuXG4gICAgICogQ2FsbGluZyB0aGlzIHRyaWdnZXJzIHRoZSBzaGFkZXIgY29tcGlsYXRpb24gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gd2dzbCBGaW5hbCBmcmFnbWVudCBzaGFkZXIgY29kZS5cbiAgICAgKiBAcGFyYW0gZGVwcyBQYXNzIG5hbWVzIHRvIGJlIHNhbXBsZWQgaW4gdGhlIGZpbmFsIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBtYWluKHdnc2wsIGRlcHMpIHtcbiAgICAgICAgdGhpcy5tYWluUGFzc1NoYWRlciA9IHdnc2w7XG4gICAgICAgIHRoaXMuX21haW5EZXBzID0gZGVwcztcbiAgICAgICAgdGhpcy5jb21waWxlKGRlcHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29tcGlsZShtYWluRGVwcykge1xuICAgICAgICBpZiAoIXRoaXMudW5pZm9ybUJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybXMoKTtcbiAgICAgICAgY29uc3QgdmVydENvZGUgPSBgXHJcbiAgICAgICAgICAgIHN0cnVjdCBWU091dCB7IEBidWlsdGluKHBvc2l0aW9uKSBwb3M6IHZlYzRmLCBAbG9jYXRpb24oMCkgdXY6IHZlYzJmIH07XHJcbiAgICAgICAgICAgIEB2ZXJ0ZXggZm4gdnMoQGJ1aWx0aW4odmVydGV4X2luZGV4KSBpOiB1MzIpIC0+IFZTT3V0IHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gYXJyYXk8dmVjMmYsIDM+KHZlYzJmKC0xLjAsIC0xLjApLCB2ZWMyZigzLjAsIC0xLjApLCB2ZWMyZigtMS4wLCAzLjApKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBWU091dCh2ZWM0ZihwW2ldLCAwLjAsIDEuMCksIHZlYzJmKHBbaV0ueCAqIDAuNSArIDAuNSwgMC41IC0gcFtpXS55ICogMC41KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBgO1xuICAgICAgICBjb25zdCBhbGxTdGFnZXMgPSBbLi4udGhpcy5wYXNzZXMsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm1haW5cIiwgdHlwZTogJ2ZyYWdtZW50Jywgc2hhZGVyOiB0aGlzLm1haW5QYXNzU2hhZGVyLFxuICAgICAgICAgICAgICAgIGlzTWFpbjogdHJ1ZSwgdGV4dHVyZXM6IFtdLCBwaXBlbGluZXM6IFtdLCBkZXBlbmRlbmNpZXM6IG1haW5EZXBzXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgYWxsU3RhZ2VzLmZvckVhY2goKGN1cnJlbnRQYXNzLCBzdGFnZUlkeCkgPT4ge1xuICAgICAgICAgICAgbGV0IGIgPSAwO1xuICAgICAgICAgICAgY29uc3QgbGF5b3V0RW50cmllcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGhlYWRlciA9IGAke3RoaXMudW5pZm9ybXMud2dzbFN0cnVjdH1cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoJHtifSkgdmFyPHVuaWZvcm0+IHU6IFVuaWZvcm1zO1xcbmA7XG4gICAgICAgICAgICBsYXlvdXRFbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLlZFUlRFWCB8IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5UIHwgR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSwgYnVmZmVyOiB7IHR5cGU6ICd1bmlmb3JtJyB9IH0pO1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxUZXh0dXJlcy5mb3JFYWNoKChfLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaGVhZGVyICs9IGBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtifSkgdmFyICR7bmFtZX06IHRleHR1cmVfMmQ8ZjMyPjtcXG5gO1xuICAgICAgICAgICAgICAgIGxheW91dEVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQgfCBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLCB0ZXh0dXJlOiB7fSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGVhZGVyICs9IGBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtifSkgdmFyIHNhbXA6IHNhbXBsZXI7XFxuYDtcbiAgICAgICAgICAgIGxheW91dEVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQgfCBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLCBzYW1wbGVyOiB7fSB9KTtcbiAgICAgICAgICAgIHRoaXMuZ2V0UmVsZXZhbnRQYXNzZXMoY3VycmVudFBhc3MpLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1NlbGYgPSAoY3VycmVudFBhc3MgPT09IHApO1xuICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT09ICdjb21wdXRlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50ZXh0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyICs9IGBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtifSkgdmFyIG91dFRleDogdGV4dHVyZV9zdG9yYWdlXzJkPHJnYmE4dW5vcm0sIHdyaXRlPjtcXG5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSwgc3RvcmFnZVRleHR1cmU6IHsgZm9ybWF0OiAncmdiYTh1bm9ybScsIGFjY2VzczogJ3dyaXRlLW9ubHknIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgKz0gYEBncm91cCgwKSBAYmluZGluZygke2J9KSB2YXIgJHtwLm5hbWV9OiB0ZXh0dXJlXzJkPGYzMj47XFxuYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5UIHwgR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSwgdGV4dHVyZToge30gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHAuc3RvcmFnZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmTmFtZSA9IGlzU2VsZiA/IFwiZGF0YVwiIDogYCR7cC5uYW1lfV9kYXRhYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciArPSBgQGdyb3VwKDApIEBiaW5kaW5nKCR7Yn0pIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiAke2J1Zk5hbWV9OiAke3AuaXNBdG9taWMgPyBcImFycmF5PGF0b21pYzx1MzI+PlwiIDogXCJhcnJheTxmMzI+XCJ9O1xcbmA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUgfCBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCwgYnVmZmVyOiB7IHR5cGU6ICdzdG9yYWdlJyB9IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgKz0gYEBncm91cCgwKSBAYmluZGluZygke2J9KSB2YXIgJHtwLm5hbWV9OiB0ZXh0dXJlXzJkPGYzMj47XFxuYDtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCB8IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUsIHRleHR1cmU6IHt9IH0pO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgKz0gYEBncm91cCgwKSBAYmluZGluZygke2J9KSB2YXIgcHJldl8ke3AubmFtZX06IHRleHR1cmVfMmQ8ZjMyPjtcXG5gO1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5UIHwgR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSwgdGV4dHVyZToge30gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoeyBlbnRyaWVzOiBsYXlvdXRFbnRyaWVzIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXNzTGF5b3V0c1tzdGFnZUlkeF0gPSBsYXlvdXQ7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gKGN1cnJlbnRQYXNzLnR5cGUgPT09ICdmcmFnbWVudCcgPyB2ZXJ0Q29kZSA6IFwiXCIpICsgaGVhZGVyICsgdGhpcy5jb21tb25XR1NMICtcbiAgICAgICAgICAgICAgICAoY3VycmVudFBhc3MudHlwZSA9PT0gJ2NvbXB1dGUnID8gY3VycmVudFBhc3Muc2hhZGVyLnJlcGxhY2UoXCIjI1dPUktHUk9VUF9TSVpFXCIsIGBAY29tcHV0ZSAke3RoaXMud29ya2dyb3VwU2l6ZS5zdHJ9YCkgOiBjdXJyZW50UGFzcy5zaGFkZXIpO1xuICAgICAgICAgICAgY29uc3QgbW9kID0gdGhpcy5kZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHsgY29kZSB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgJHtjdXJyZW50UGFzcy5uYW1lfVxcblxcbiR7Y29kZX1cXG5cXG5gKTtcbiAgICAgICAgICAgIGNvbnN0IHBpcGVMYXlvdXQgPSB0aGlzLmRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCh7IGJpbmRHcm91cExheW91dHM6IFtsYXlvdXRdIH0pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXNzLnR5cGUgPT09ICdjb21wdXRlJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXNzLnBpcGVsaW5lc1swXSA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7IGxheW91dDogcGlwZUxheW91dCwgY29tcHV0ZTogeyBtb2R1bGU6IG1vZCwgZW50cnlQb2ludDogJ21haW4nIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFzcy5waXBlbGluZXNbMF0gPSB0aGlzLmRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZSh7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dDogcGlwZUxheW91dCwgdmVydGV4OiB7IG1vZHVsZTogbW9kLCBlbnRyeVBvaW50OiAndnMnIH0sXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiB7IG1vZHVsZTogbW9kLCBlbnRyeVBvaW50OiAnbWFpbicsIHRhcmdldHM6IFt7IGZvcm1hdDogY3VycmVudFBhc3MuaXNNYWluID8gbmF2aWdhdG9yLmdwdS5nZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKSA6IFwiYmdyYTh1bm9ybVwiIH1dIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhc3MuaXNNYWluKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW5QaXBlbGluZSA9IGN1cnJlbnRQYXNzLnBpcGVsaW5lc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaXNDb21waWxlZCA9IHRydWU7XG4gICAgfVxuICAgIGNyZWF0ZUJpbmRHcm91cChzdGFnZUlkeCwgd3JpdGVJZHgpIHtcbiAgICAgICAgY29uc3QgcmVhZElkeCA9IDEgLSB3cml0ZUlkeDtcbiAgICAgICAgY29uc3QgaXNNYWluUGFzcyA9IHN0YWdlSWR4ID09PSB0aGlzLnBhc3Nlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXNzID0gaXNNYWluUGFzc1xuICAgICAgICAgICAgPyB7IG5hbWU6ICdtYWluJywgaXNNYWluOiB0cnVlLCBkZXBlbmRlbmNpZXM6IHRoaXMuX21haW5EZXBzIH1cbiAgICAgICAgICAgIDogdGhpcy5wYXNzZXNbc3RhZ2VJZHhdO1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgICAgIGxldCBiID0gMDtcbiAgICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCByZXNvdXJjZTogeyBidWZmZXI6IHRoaXMudW5pZm9ybUJ1ZmZlciB9IH0pO1xuICAgICAgICB0aGlzLmdsb2JhbFRleHR1cmVzLmZvckVhY2godGV4ID0+IGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgcmVzb3VyY2U6IHRleC5jcmVhdGVWaWV3KCkgfSkpO1xuICAgICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHJlc291cmNlOiB0aGlzLmdsb2JhbFNhbXBsZXIgfSk7XG4gICAgICAgIHRoaXMuZ2V0UmVsZXZhbnRQYXNzZXMoY3VycmVudFBhc3MpLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzU2VsZiA9IChjdXJyZW50UGFzcyA9PT0gcCk7XG4gICAgICAgICAgICBpZiAocC50eXBlID09PSAnY29tcHV0ZScpIHtcbiAgICAgICAgICAgICAgICBpZiAocC50ZXh0dXJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHJlc291cmNlOiBwLnRleHR1cmVzWzBdLmNyZWF0ZVZpZXcoKSB9KTtcbiAgICAgICAgICAgICAgICBpZiAocC5zdG9yYWdlQnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHJlc291cmNlOiB7IGJ1ZmZlcjogcC5zdG9yYWdlQnVmZmVyIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgcmVzb3VyY2U6IHAudGV4dHVyZXNbcmVhZElkeF0uY3JlYXRlVmlldygpIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHJlc291cmNlOiBwLnRleHR1cmVzW3JlYWRJZHhdLmNyZWF0ZVZpZXcoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgcmVzb3VyY2U6IHAudGV4dHVyZXNbd3JpdGVJZHhdLmNyZWF0ZVZpZXcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCByZXNvdXJjZTogcC50ZXh0dXJlc1tyZWFkSWR4XS5jcmVhdGVWaWV3KCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7IGxheW91dDogdGhpcy5wYXNzTGF5b3V0c1tzdGFnZUlkeF0sIGVudHJpZXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICogU3RhcnRzIHRoZSByZW5kZXIgbG9vcCBhbmQgbWFuYWdlcyB0aGUgR1BVIGNvbW1hbmQgbGlmZWN5Y2xlLlxuICogQHBhcmFtIHRpbWVyIE9wdGlvbmFsIFdlYkdQVVRpbWluZyBwbHVnaW4gZm9yIHByb2ZpbGluZy5cbiAqL1xuICAgIHJ1bih0aW1lcikge1xuICAgICAgICBjb25zdCBmcmFtZSA9IChub3cpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0NvbXBpbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvUGx1Z2luICYmICF0aGlzLnN0YXJ0ZWRBdWRpbykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9QbHVnaW4ucGxheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRlZEF1ZGlvID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSAodGhpcy5hdWRpb1BsdWdpbj8uaXNQbGF5aW5nKSA/IHRoaXMuYXVkaW9QbHVnaW4uZ2V0VGltZSgpIDogKG5vdyAtIHRoaXMuc3RhcnRUaW1lKSAvIDEwMDA7XG4gICAgICAgICAgICBjb25zdCB3cml0ZUlkeCA9ICh0aGlzLmZyYW1lQ291bnRlciAlIDIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VxdWVuY2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnNlcXVlbmNlci51cGRhdGUodGltZSk7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy51cGRhdGVTZXF1ZW5jZXIoc3RhdGUuc2NlbmVJZCwgc3RhdGUucHJvZ3Jlc3MsIHN0YXRlLmZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudXBkYXRlKHRpbWUpO1xuICAgICAgICAgICAgdGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIodGhpcy51bmlmb3JtQnVmZmVyLCAwLCB0aGlzLnVuaWZvcm1zLmZsb2F0MzJBcnJheSk7XG4gICAgICAgICAgICBjb25zdCBlbmMgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgICAgICAgICAgY29uc3QgcGFzc1RpbWluZ3MgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aW1lcilcbiAgICAgICAgICAgICAgICB0aW1lci5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5wYXNzZXMuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZyYW1ld29yayBMb2dpYzogT25seSBjbGVhciBpZiBleHBsaWNpdGx5IHJlcXVlc3RlZCBvciBpZiBpdCdzIGEgZnJlc2ggYXRvbWljIHBhc3NcbiAgICAgICAgICAgICAgICBpZiAocC5pc0F0b21pYyAmJiBwLnN0b3JhZ2VCdWZmZXIgJiYgcC5jbGVhciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jLmNsZWFyQnVmZmVyKHAuc3RvcmFnZUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJnID0gdGhpcy5jcmVhdGVCaW5kR3JvdXAoaSwgd3JpdGVJZHgpO1xuICAgICAgICAgICAgICAgIGxldCB0dztcbiAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gdGltZXIuYWxsb2NhdGVJbmRpY2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ID0geyBxdWVyeVNldDogdGltZXIucXVlcnlTZXQsIGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6IGlkeC5zdGFydCwgZW5kT2ZQYXNzV3JpdGVJbmRleDogaWR4LmVuZCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc1RpbWluZ3MucHVzaCh7IG5hbWU6IHAubmFtZSwgLi4uaWR4IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT09ICdjb21wdXRlJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcCA9IGVuYy5iZWdpbkNvbXB1dGVQYXNzKHsgdGltZXN0YW1wV3JpdGVzOiB0dyB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3Auc2V0UGlwZWxpbmUocC5waXBlbGluZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBjcC5zZXRCaW5kR3JvdXAoMCwgYmcpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRlJBTUVXT1JLIERJU1BBVENIIExPR0lDOlxuICAgICAgICAgICAgICAgICAgICAgKiAxLiBJZiB0aGUgcGFzcyBoYXMgdGV4dHVyZXMsIGl0J3MgbGlrZWx5IGEgU2NyZWVuLVNwYWNlIENvbXB1dGUgKFJlc29sdXRpb24gYmFzZWQpLlxuICAgICAgICAgICAgICAgICAgICAgKiAyLiBJZiBpdCBoYXMgTk8gdGV4dHVyZXMgYnV0IEhBUyBhIGJ1ZmZlciwgaXQncyBhIERhdGEtb25seSBDb21wdXRlIChCdWZmZXIgc2l6ZSBiYXNlZCkuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50ZXh0dXJlcyAmJiBwLnRleHR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNjcmVlbi1zcGFjZTogRGlzcGF0Y2ggYnkgQ2FudmFzIERpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwLmRpc3BhdGNoV29ya2dyb3VwcyhNYXRoLmNlaWwodGhpcy5jYW52YXMud2lkdGggLyB0aGlzLndvcmtncm91cFNpemUueCksIE1hdGguY2VpbCh0aGlzLmNhbnZhcy5oZWlnaHQgLyB0aGlzLndvcmtncm91cFNpemUueSksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAuc3RvcmFnZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGF0YS1zcGFjZTogRGlzcGF0Y2ggYnkgQnVmZmVyIExlbmd0aCAoZGl2aWRlZCBieSA0IGJ5dGVzIHBlciBmbG9hdClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSAxRCBkaXNwYXRjaCBmb3IgZGF0YS1vbmx5IGJ1ZmZlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsRWxlbWVudHMgPSBwLnN0b3JhZ2VCdWZmZXIuc2l6ZSAvIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aHJlYWRzUGVyR3JvdXAgPSB0aGlzLndvcmtncm91cFNpemUueCAqIHRoaXMud29ya2dyb3VwU2l6ZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3AuZGlzcGF0Y2hXb3JrZ3JvdXBzKE1hdGguY2VpbCh0b3RhbEVsZW1lbnRzIC8gdGhyZWFkc1Blckdyb3VwKSwgMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3AuZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGFuZGFyZCBGcmFnbWVudCBQYXNzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJwID0gZW5jLmJlZ2luUmVuZGVyUGFzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckF0dGFjaG1lbnRzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBwLnRleHR1cmVzW3dyaXRlSWR4XS5jcmVhdGVWaWV3KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRPcDogXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZU9wOiBcInN0b3JlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVmFsdWU6IFswLCAwLCAwLCAxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wV3JpdGVzOiB0d1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcnAuc2V0UGlwZWxpbmUocC5waXBlbGluZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBycC5zZXRCaW5kR3JvdXAoMCwgYmcpO1xuICAgICAgICAgICAgICAgICAgICBycC5kcmF3KDMpO1xuICAgICAgICAgICAgICAgICAgICBycC5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEZpbmFsIENhbnZhcyBPdXRwdXRcbiAgICAgICAgICAgIGNvbnN0IG1haW5CRyA9IHRoaXMuY3JlYXRlQmluZEdyb3VwKHRoaXMucGFzc2VzLmxlbmd0aCwgd3JpdGVJZHgpO1xuICAgICAgICAgICAgbGV0IG10dztcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRpbWVyLmFsbG9jYXRlSW5kaWNlcygpO1xuICAgICAgICAgICAgICAgIGlmIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgbXR3ID0geyBxdWVyeVNldDogdGltZXIucXVlcnlTZXQsIGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6IGlkeC5zdGFydCwgZW5kT2ZQYXNzV3JpdGVJbmRleDogaWR4LmVuZCB9O1xuICAgICAgICAgICAgICAgICAgICBwYXNzVGltaW5ncy5wdXNoKHsgbmFtZTogXCJtYWluXCIsIC4uLmlkeCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtcCA9IGVuYy5iZWdpblJlbmRlclBhc3Moe1xuICAgICAgICAgICAgICAgIGNvbG9yQXR0YWNobWVudHM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiB0aGlzLmNvbnRleHQuZ2V0Q3VycmVudFRleHR1cmUoKS5jcmVhdGVWaWV3KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkT3A6IFwiY2xlYXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlT3A6IFwic3RvcmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVmFsdWU6IFswLCAwLCAwLCAxXVxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBXcml0ZXM6IG10d1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtcC5zZXRQaXBlbGluZSh0aGlzLm1haW5QaXBlbGluZSk7XG4gICAgICAgICAgICBtcC5zZXRCaW5kR3JvdXAoMCwgbWFpbkJHKTtcbiAgICAgICAgICAgIG1wLmRyYXcoMyk7XG4gICAgICAgICAgICBtcC5lbmQoKTtcbiAgICAgICAgICAgIHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZW5jLmZpbmlzaCgpXSk7XG4gICAgICAgICAgICBpZiAodGltZXIpXG4gICAgICAgICAgICAgICAgdGltZXIucmVzb2x2ZShwYXNzVGltaW5ncyk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lQ291bnRlcisrO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5UaW55U2hhZGUgPSBUaW55U2hhZGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/TinyShade.ts\n\n}");

/***/ },

/***/ "./src/UniformLayout.ts"
/*!******************************!*\
  !*** ./src/UniformLayout.ts ***!
  \******************************/
(__unused_webpack_module, exports) {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UniformLayout = void 0;\n/**\n * Manages memory-aligned WebGPU Uniform Buffers.\n * Handles the strict 16-byte alignment and O(1) update performance.\n */\nclass UniformLayout {\n    entries = [];\n    buffer;\n    floatView;\n    // Fast-access maps to avoid string searching in the render loop\n    setters = new Map();\n    dynamicUpdates = [];\n    isBuilt = false;\n    _currentOffset = 0;\n    frameCount = 0;\n    currentTime = 0;\n    constructor(initialResolution) {\n        // Register standard demoscene globals\n        this.addUniform({ name: \"resolution\", value: initialResolution });\n        this.addUniform({ name: \"time\", value: 0 });\n        this.addUniform({ name: \"sceneId\", value: 0 });\n        this.addUniform({ name: \"progress\", value: 0 });\n        this.addUniform({ name: \"flags\", value: 0 });\n    }\n    /**\n     * Step 1: Register the structure of your uniforms.\n     * This handles the complex WGSL alignment logic.\n     */\n    addUniform({ name, value }) {\n        if (this.isBuilt)\n            throw new Error(\"Cannot add uniforms after build()\");\n        const { type, size, align } = this.inferType(value);\n        // WGSL Alignment Rule: The offset must be a multiple of the alignment\n        this._currentOffset = Math.ceil(this._currentOffset / align) * align;\n        this.entries.push({\n            name,\n            type,\n            size,\n            align,\n            offset: this._currentOffset,\n            value\n        });\n        this._currentOffset += size;\n        return this;\n    }\n    /**\n     * Step 2: Bake the memory buffer and create O(1) setters.\n     */\n    build() {\n        if (this.isBuilt)\n            return;\n        // Final buffer size must be a multiple of 16 bytes\n        const totalSize = Math.ceil(this._currentOffset / 16) * 16;\n        this.buffer = new ArrayBuffer(totalSize);\n        this.floatView = new Float32Array(this.buffer);\n        for (const e of this.entries) {\n            const idx = e.offset / 4;\n            // Create a specialized closure for setting this specific memory slot\n            const setter = (val) => {\n                const resolved = typeof val === \"function\" ? val(this.currentTime, this.frameCount) : val;\n                if (typeof resolved === \"number\") {\n                    this.floatView[idx] = resolved;\n                }\n                else {\n                    // Optimized set for vec2, vec3, vec4\n                    this.floatView.set(resolved, idx);\n                }\n            };\n            this.setters.set(e.name, setter);\n            // If it's a dynamic function, queue it for the update loop\n            if (typeof e.value === \"function\") {\n                this.dynamicUpdates.push(() => setter(e.value));\n            }\n            else {\n                setter(e.value); // Initial value\n            }\n        }\n        this.isBuilt = true;\n    }\n    /**\n     * Updates globals and runs all dynamic uniform functions.\n     */\n    update(time) {\n        if (!this.isBuilt)\n            this.build();\n        this.currentTime = time;\n        this.frameCount++;\n        // This actually writes the new time into the floatView/ArrayBuffer\n        this.setters.get(\"time\")?.(time);\n        for (const update of this.dynamicUpdates) {\n            update();\n        }\n    }\n    /**\n     * Sequencer-specific update for scene management.\n     */\n    updateSequencer(sceneId, progress, flags) {\n        if (!this.isBuilt)\n            this.build();\n        // Get the pre-compiled setter functions and execute them\n        const setId = this.setters.get(\"sceneId\");\n        const setProg = this.setters.get(\"progress\");\n        const setFlags = this.setters.get(\"flags\");\n        if (setId)\n            setId(sceneId);\n        if (setProg)\n            setProg(progress);\n        if (setFlags)\n            setFlags(flags);\n        if (this.entries) {\n            //console.log(\"Buffer SceneId Index:\", this.entries.find(e => e.name === 'sceneId')?.offset / 4);\n            console.log(\"Value in Buffer:\", this.floatView[this.entries.find(e => e.name === 'sceneId').offset / 4]);\n        }\n    }\n    // --- Getters ---\n    get byteSize() {\n        if (!this.isBuilt)\n            this.build();\n        return this.buffer.byteLength;\n    }\n    get float32Array() {\n        if (!this.isBuilt)\n            this.build();\n        return this.floatView;\n    }\n    get wgslStruct() {\n        const lines = this.entries.map(e => `    ${e.name}: ${e.type},`);\n        return `struct Uniforms {\\n${lines.join(\"\\n\")}\\n};`;\n    }\n    /**\n     * Resolves WGSL types based on the input data format.\n     */\n    inferType(value) {\n        // If it's a function, run it once with 0 to see what it returns\n        const sample = typeof value === \"function\" ? value(0, 0) : value;\n        if (typeof sample === \"number\") {\n            return { type: \"f32\", size: 4, align: 4 };\n        }\n        if (Array.isArray(sample)) {\n            const len = sample.length;\n            switch (len) {\n                case 2: return { type: \"vec2f\", size: 8, align: 8 };\n                case 3: return { type: \"vec3f\", size: 12, align: 16 }; // Vec3 requires 16-byte alignment\n                case 4: return { type: \"vec4f\", size: 16, align: 16 };\n            }\n        }\n        throw new Error(`Unsupported uniform value type: ${typeof sample}`);\n    }\n}\nexports.UniformLayout = UniformLayout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVW5pZm9ybUxheW91dC50cyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEUsMEJBQTBCLHdCQUF3QjtBQUNsRCwwQkFBMEIsMkJBQTJCO0FBQ3JELDBCQUEwQiw0QkFBNEI7QUFDdEQsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU8sSUFBSSxPQUFPO0FBQ3JFLGlDQUFpQyxJQUFJLGlCQUFpQixJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDLHNDQUFzQztBQUN2RSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW55c2hhZGUvLi9zcmMvVW5pZm9ybUxheW91dC50cz85MTZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Vbmlmb3JtTGF5b3V0ID0gdm9pZCAwO1xuLyoqXG4gKiBNYW5hZ2VzIG1lbW9yeS1hbGlnbmVkIFdlYkdQVSBVbmlmb3JtIEJ1ZmZlcnMuXG4gKiBIYW5kbGVzIHRoZSBzdHJpY3QgMTYtYnl0ZSBhbGlnbm1lbnQgYW5kIE8oMSkgdXBkYXRlIHBlcmZvcm1hbmNlLlxuICovXG5jbGFzcyBVbmlmb3JtTGF5b3V0IHtcbiAgICBlbnRyaWVzID0gW107XG4gICAgYnVmZmVyO1xuICAgIGZsb2F0VmlldztcbiAgICAvLyBGYXN0LWFjY2VzcyBtYXBzIHRvIGF2b2lkIHN0cmluZyBzZWFyY2hpbmcgaW4gdGhlIHJlbmRlciBsb29wXG4gICAgc2V0dGVycyA9IG5ldyBNYXAoKTtcbiAgICBkeW5hbWljVXBkYXRlcyA9IFtdO1xuICAgIGlzQnVpbHQgPSBmYWxzZTtcbiAgICBfY3VycmVudE9mZnNldCA9IDA7XG4gICAgZnJhbWVDb3VudCA9IDA7XG4gICAgY3VycmVudFRpbWUgPSAwO1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxSZXNvbHV0aW9uKSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHN0YW5kYXJkIGRlbW9zY2VuZSBnbG9iYWxzXG4gICAgICAgIHRoaXMuYWRkVW5pZm9ybSh7IG5hbWU6IFwicmVzb2x1dGlvblwiLCB2YWx1ZTogaW5pdGlhbFJlc29sdXRpb24gfSk7XG4gICAgICAgIHRoaXMuYWRkVW5pZm9ybSh7IG5hbWU6IFwidGltZVwiLCB2YWx1ZTogMCB9KTtcbiAgICAgICAgdGhpcy5hZGRVbmlmb3JtKHsgbmFtZTogXCJzY2VuZUlkXCIsIHZhbHVlOiAwIH0pO1xuICAgICAgICB0aGlzLmFkZFVuaWZvcm0oeyBuYW1lOiBcInByb2dyZXNzXCIsIHZhbHVlOiAwIH0pO1xuICAgICAgICB0aGlzLmFkZFVuaWZvcm0oeyBuYW1lOiBcImZsYWdzXCIsIHZhbHVlOiAwIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGVwIDE6IFJlZ2lzdGVyIHRoZSBzdHJ1Y3R1cmUgb2YgeW91ciB1bmlmb3Jtcy5cbiAgICAgKiBUaGlzIGhhbmRsZXMgdGhlIGNvbXBsZXggV0dTTCBhbGlnbm1lbnQgbG9naWMuXG4gICAgICovXG4gICAgYWRkVW5pZm9ybSh7IG5hbWUsIHZhbHVlIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCdWlsdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgdW5pZm9ybXMgYWZ0ZXIgYnVpbGQoKVwiKTtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBzaXplLCBhbGlnbiB9ID0gdGhpcy5pbmZlclR5cGUodmFsdWUpO1xuICAgICAgICAvLyBXR1NMIEFsaWdubWVudCBSdWxlOiBUaGUgb2Zmc2V0IG11c3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgYWxpZ25tZW50XG4gICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSBNYXRoLmNlaWwodGhpcy5fY3VycmVudE9mZnNldCAvIGFsaWduKSAqIGFsaWduO1xuICAgICAgICB0aGlzLmVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBhbGlnbixcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fY3VycmVudE9mZnNldCxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ICs9IHNpemU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGVwIDI6IEJha2UgdGhlIG1lbW9yeSBidWZmZXIgYW5kIGNyZWF0ZSBPKDEpIHNldHRlcnMuXG4gICAgICovXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQnVpbHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIEZpbmFsIGJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNiBieXRlc1xuICAgICAgICBjb25zdCB0b3RhbFNpemUgPSBNYXRoLmNlaWwodGhpcy5fY3VycmVudE9mZnNldCAvIDE2KSAqIDE2O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0b3RhbFNpemUpO1xuICAgICAgICB0aGlzLmZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5idWZmZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5lbnRyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBlLm9mZnNldCAvIDQ7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzcGVjaWFsaXplZCBjbG9zdXJlIGZvciBzZXR0aW5nIHRoaXMgc3BlY2lmaWMgbWVtb3J5IHNsb3RcbiAgICAgICAgICAgIGNvbnN0IHNldHRlciA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiA/IHZhbCh0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmZyYW1lQ291bnQpIDogdmFsO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZWQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbG9hdFZpZXdbaWR4XSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemVkIHNldCBmb3IgdmVjMiwgdmVjMywgdmVjNFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb2F0Vmlldy5zZXQocmVzb2x2ZWQsIGlkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2V0dGVycy5zZXQoZS5uYW1lLCBzZXR0ZXIpO1xuICAgICAgICAgICAgLy8gSWYgaXQncyBhIGR5bmFtaWMgZnVuY3Rpb24sIHF1ZXVlIGl0IGZvciB0aGUgdXBkYXRlIGxvb3BcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZS52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5keW5hbWljVXBkYXRlcy5wdXNoKCgpID0+IHNldHRlcihlLnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXR0ZXIoZS52YWx1ZSk7IC8vIEluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQnVpbHQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGdsb2JhbHMgYW5kIHJ1bnMgYWxsIGR5bmFtaWMgdW5pZm9ybSBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgdXBkYXRlKHRpbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQnVpbHQpXG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLmZyYW1lQ291bnQrKztcbiAgICAgICAgLy8gVGhpcyBhY3R1YWxseSB3cml0ZXMgdGhlIG5ldyB0aW1lIGludG8gdGhlIGZsb2F0Vmlldy9BcnJheUJ1ZmZlclxuICAgICAgICB0aGlzLnNldHRlcnMuZ2V0KFwidGltZVwiKT8uKHRpbWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB0aGlzLmR5bmFtaWNVcGRhdGVzKSB7XG4gICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXF1ZW5jZXItc3BlY2lmaWMgdXBkYXRlIGZvciBzY2VuZSBtYW5hZ2VtZW50LlxuICAgICAqL1xuICAgIHVwZGF0ZVNlcXVlbmNlcihzY2VuZUlkLCBwcm9ncmVzcywgZmxhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQnVpbHQpXG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIC8vIEdldCB0aGUgcHJlLWNvbXBpbGVkIHNldHRlciBmdW5jdGlvbnMgYW5kIGV4ZWN1dGUgdGhlbVxuICAgICAgICBjb25zdCBzZXRJZCA9IHRoaXMuc2V0dGVycy5nZXQoXCJzY2VuZUlkXCIpO1xuICAgICAgICBjb25zdCBzZXRQcm9nID0gdGhpcy5zZXR0ZXJzLmdldChcInByb2dyZXNzXCIpO1xuICAgICAgICBjb25zdCBzZXRGbGFncyA9IHRoaXMuc2V0dGVycy5nZXQoXCJmbGFnc1wiKTtcbiAgICAgICAgaWYgKHNldElkKVxuICAgICAgICAgICAgc2V0SWQoc2NlbmVJZCk7XG4gICAgICAgIGlmIChzZXRQcm9nKVxuICAgICAgICAgICAgc2V0UHJvZyhwcm9ncmVzcyk7XG4gICAgICAgIGlmIChzZXRGbGFncylcbiAgICAgICAgICAgIHNldEZsYWdzKGZsYWdzKTtcbiAgICAgICAgaWYgKHRoaXMuZW50cmllcykge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkJ1ZmZlciBTY2VuZUlkIEluZGV4OlwiLCB0aGlzLmVudHJpZXMuZmluZChlID0+IGUubmFtZSA9PT0gJ3NjZW5lSWQnKT8ub2Zmc2V0IC8gNCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZhbHVlIGluIEJ1ZmZlcjpcIiwgdGhpcy5mbG9hdFZpZXdbdGhpcy5lbnRyaWVzLmZpbmQoZSA9PiBlLm5hbWUgPT09ICdzY2VuZUlkJykub2Zmc2V0IC8gNF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLSBHZXR0ZXJzIC0tLVxuICAgIGdldCBieXRlU2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQnVpbHQpXG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgZmxvYXQzMkFycmF5KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNCdWlsdClcbiAgICAgICAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvYXRWaWV3O1xuICAgIH1cbiAgICBnZXQgd2dzbFN0cnVjdCgpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSB0aGlzLmVudHJpZXMubWFwKGUgPT4gYCAgICAke2UubmFtZX06ICR7ZS50eXBlfSxgKTtcbiAgICAgICAgcmV0dXJuIGBzdHJ1Y3QgVW5pZm9ybXMge1xcbiR7bGluZXMuam9pbihcIlxcblwiKX1cXG59O2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIFdHU0wgdHlwZXMgYmFzZWQgb24gdGhlIGlucHV0IGRhdGEgZm9ybWF0LlxuICAgICAqL1xuICAgIGluZmVyVHlwZSh2YWx1ZSkge1xuICAgICAgICAvLyBJZiBpdCdzIGEgZnVuY3Rpb24sIHJ1biBpdCBvbmNlIHdpdGggMCB0byBzZWUgd2hhdCBpdCByZXR1cm5zXG4gICAgICAgIGNvbnN0IHNhbXBsZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWUoMCwgMCkgOiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzYW1wbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZjMyXCIsIHNpemU6IDQsIGFsaWduOiA0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2FtcGxlKSkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gc2FtcGxlLmxlbmd0aDtcbiAgICAgICAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4geyB0eXBlOiBcInZlYzJmXCIsIHNpemU6IDgsIGFsaWduOiA4IH07XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4geyB0eXBlOiBcInZlYzNmXCIsIHNpemU6IDEyLCBhbGlnbjogMTYgfTsgLy8gVmVjMyByZXF1aXJlcyAxNi1ieXRlIGFsaWdubWVudFxuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIHsgdHlwZTogXCJ2ZWM0ZlwiLCBzaXplOiAxNiwgYWxpZ246IDE2IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHZhbHVlIHR5cGU6ICR7dHlwZW9mIHNhbXBsZX1gKTtcbiAgICB9XG59XG5leHBvcnRzLlVuaWZvcm1MYXlvdXQgPSBVbmlmb3JtTGF5b3V0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/UniformLayout.ts\n\n}");

/***/ },

/***/ "./src/example/example11.ts"
/*!**********************************!*\
  !*** ./src/example/example11.ts ***!
  \**********************************/
(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst TinyShade_1 = __webpack_require__(/*! ../TinyShade */ \"./src/TinyShade.ts\");\nconst common_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/common.wgsl */ \"./src/example/wgsl/common.wgsl\"));\nconst skyFrag_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/skyFrag.wgsl */ \"./src/example/wgsl/skyFrag.wgsl\"));\nconst worldFrag_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/worldFrag.wgsl */ \"./src/example/wgsl/worldFrag.wgsl\"));\nconst finalFrag_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/finalFrag.wgsl */ \"./src/example/wgsl/finalFrag.wgsl\"));\nconst mainFrag_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/mainFrag.wgsl */ \"./src/example/wgsl/mainFrag.wgsl\"));\nconst meteorsCompute_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/meteorsCompute.wgsl */ \"./src/example/wgsl/meteorsCompute.wgsl\"));\nconst meteorsFrag_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/meteorsFrag.wgsl */ \"./src/example/wgsl/meteorsFrag.wgsl\"));\nconst cratersAtomic_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/cratersAtomic.wgsl */ \"./src/example/wgsl/cratersAtomic.wgsl\"));\nconst particlesCompute_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/particlesCompute.wgsl */ \"./src/example/wgsl/particlesCompute.wgsl\"));\nconst particleTrailsFrag_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/particleTrailsFrag.wgsl */ \"./src/example/wgsl/particleTrailsFrag.wgsl\"));\nconst volcanoCompute_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/volcanoCompute.wgsl */ \"./src/example/wgsl/volcanoCompute.wgsl\"));\nconst volcanoAtomic_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/volcanoAtomic.wgsl */ \"./src/example/wgsl/volcanoAtomic.wgsl\"));\nconst volcanoFrag_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/volcanoFrag.wgsl */ \"./src/example/wgsl/volcanoFrag.wgsl\"));\nconst flashCompute_wgsl_1 = __importDefault(__webpack_require__(/*! ./wgsl/flashCompute.wgsl */ \"./src/example/wgsl/flashCompute.wgsl\"));\nconst WebGPUTiming_1 = __webpack_require__(/*! ../plugins/WebGPUTiming */ \"./src/plugins/WebGPUTiming.ts\");\nconst start = async () => {\n    const app = await TinyShade_1.TinyShade.create(\"canvas\");\n    const PARTICLE_COUNT = 4_000;\n    const PARTICLE_STORAGE_SIZE = PARTICLE_COUNT * 4;\n    const ASTEROID_COUNT = 32;\n    const PHYSICS_STORAGE_SIZE = ASTEROID_COUNT * 4;\n    const ATOMIC_BUFFER_SIZE = app.canvas.width * app.canvas.height;\n    const stats = document.createElement(\"div\");\n    stats.style.cssText = \"position:absolute;top:10px;left:10px;color:#0f0;font-family:monospace;background:rgba(0,0,0,0.8);padding:10px;border-radius:5px;pointer-events:none;z-index:100;line-height:1.4;font-size:12px;border:1px solid #333;\";\n    document.body.appendChild(stats);\n    const avg = new WebGPUTiming_1.RollingAverage(60);\n    const timing = new WebGPUTiming_1.WebGPUTiming(app.device, (results) => {\n        let displayStr = \"\";\n        let totalFrameTime = 0;\n        results.forEach(res => {\n            displayStr += `${res.name.padEnd(12)} : ${res.ms.toFixed(3)} ms\\n`;\n            totalFrameTime += res.ms;\n        });\n        avg.add(totalFrameTime);\n        displayStr += `---------------------------\\n`;\n        displayStr += `${\"Total GPU\".padEnd(12)} : ${avg.get().toFixed(3)} ms`;\n        stats.innerText = displayStr;\n    });\n    (await app\n        .setUniforms((l) => l.addUniform({ name: \"count\", value: PARTICLE_COUNT })\n        .addUniform({ name: \"asteroids\", value: 10 }))\n        .addCommon(common_wgsl_1.default)\n        .addCompute(\"physics\", meteorsCompute_wgsl_1.default, PHYSICS_STORAGE_SIZE)\n        .addAtomicCompute(\"crater_map\", cratersAtomic_wgsl_1.default, ATOMIC_BUFFER_SIZE, false)\n        .addCompute(\"particles\", particlesCompute_wgsl_1.default, PARTICLE_STORAGE_SIZE)\n        .addPass(\"particleTrails\", particleTrailsFrag_wgsl_1.default)\n        .addCompute(\"volcano\", volcanoCompute_wgsl_1.default, 1000 * 4)\n        .addAtomicCompute(\"volcano_map\", volcanoAtomic_wgsl_1.default, (app.canvas.width * app.canvas.height) * 4, true)\n        .addPass(\"sky\", skyFrag_wgsl_1.default)\n        .addPass(\"volcanoFrag\", volcanoFrag_wgsl_1.default) // accum visuals for volcano & heatmap\n        .addPass(\"world\", worldFrag_wgsl_1.default)\n        .addPass(\"meteors\", meteorsFrag_wgsl_1.default)\n        .addCompute(\"flash\", flashCompute_wgsl_1.default, 4, [])\n        .addPass(\"fin\", finalFrag_wgsl_1.default)\n        .main(mainFrag_wgsl_1.default)).run(timing);\n};\nstart();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZXhhbXBsZS9leGFtcGxlMTEudHMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyx3Q0FBYztBQUMxQyxzQ0FBc0MsbUJBQU8sQ0FBQywwREFBb0I7QUFDbEUsdUNBQXVDLG1CQUFPLENBQUMsNERBQXFCO0FBQ3BFLHlDQUF5QyxtQkFBTyxDQUFDLGdFQUF1QjtBQUN4RSx5Q0FBeUMsbUJBQU8sQ0FBQyxnRUFBdUI7QUFDeEUsd0NBQXdDLG1CQUFPLENBQUMsOERBQXNCO0FBQ3RFLDhDQUE4QyxtQkFBTyxDQUFDLDBFQUE0QjtBQUNsRiwyQ0FBMkMsbUJBQU8sQ0FBQyxvRUFBeUI7QUFDNUUsNkNBQTZDLG1CQUFPLENBQUMsd0VBQTJCO0FBQ2hGLGdEQUFnRCxtQkFBTyxDQUFDLDhFQUE4QjtBQUN0RixrREFBa0QsbUJBQU8sQ0FBQyxrRkFBZ0M7QUFDMUYsOENBQThDLG1CQUFPLENBQUMsMEVBQTRCO0FBQ2xGLDZDQUE2QyxtQkFBTyxDQUFDLHdFQUEyQjtBQUNoRiwyQ0FBMkMsbUJBQU8sQ0FBQyxvRUFBeUI7QUFDNUUsNENBQTRDLG1CQUFPLENBQUMsc0VBQTBCO0FBQzlFLHVCQUF1QixtQkFBTyxDQUFDLDhEQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsVUFBVSxXQUFXLHNCQUFzQiwyQkFBMkIsYUFBYSxrQkFBa0Isb0JBQW9CLFlBQVksZ0JBQWdCLGVBQWUsc0JBQXNCO0FBQ2hQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUIsSUFBSSxtQkFBbUI7QUFDekU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0IsSUFBSSxzQkFBc0I7QUFDM0U7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkMsc0NBQXNDO0FBQ2pGLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW55c2hhZGUvLi9zcmMvZXhhbXBsZS9leGFtcGxlMTEudHM/N2UxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFRpbnlTaGFkZV8xID0gcmVxdWlyZShcIi4uL1RpbnlTaGFkZVwiKTtcbmNvbnN0IGNvbW1vbl93Z3NsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vd2dzbC9jb21tb24ud2dzbFwiKSk7XG5jb25zdCBza3lGcmFnX3dnc2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi93Z3NsL3NreUZyYWcud2dzbFwiKSk7XG5jb25zdCB3b3JsZEZyYWdfd2dzbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3dnc2wvd29ybGRGcmFnLndnc2xcIikpO1xuY29uc3QgZmluYWxGcmFnX3dnc2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi93Z3NsL2ZpbmFsRnJhZy53Z3NsXCIpKTtcbmNvbnN0IG1haW5GcmFnX3dnc2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi93Z3NsL21haW5GcmFnLndnc2xcIikpO1xuY29uc3QgbWV0ZW9yc0NvbXB1dGVfd2dzbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3dnc2wvbWV0ZW9yc0NvbXB1dGUud2dzbFwiKSk7XG5jb25zdCBtZXRlb3JzRnJhZ193Z3NsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vd2dzbC9tZXRlb3JzRnJhZy53Z3NsXCIpKTtcbmNvbnN0IGNyYXRlcnNBdG9taWNfd2dzbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3dnc2wvY3JhdGVyc0F0b21pYy53Z3NsXCIpKTtcbmNvbnN0IHBhcnRpY2xlc0NvbXB1dGVfd2dzbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3dnc2wvcGFydGljbGVzQ29tcHV0ZS53Z3NsXCIpKTtcbmNvbnN0IHBhcnRpY2xlVHJhaWxzRnJhZ193Z3NsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vd2dzbC9wYXJ0aWNsZVRyYWlsc0ZyYWcud2dzbFwiKSk7XG5jb25zdCB2b2xjYW5vQ29tcHV0ZV93Z3NsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vd2dzbC92b2xjYW5vQ29tcHV0ZS53Z3NsXCIpKTtcbmNvbnN0IHZvbGNhbm9BdG9taWNfd2dzbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3dnc2wvdm9sY2Fub0F0b21pYy53Z3NsXCIpKTtcbmNvbnN0IHZvbGNhbm9GcmFnX3dnc2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi93Z3NsL3ZvbGNhbm9GcmFnLndnc2xcIikpO1xuY29uc3QgZmxhc2hDb21wdXRlX3dnc2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi93Z3NsL2ZsYXNoQ29tcHV0ZS53Z3NsXCIpKTtcbmNvbnN0IFdlYkdQVVRpbWluZ18xID0gcmVxdWlyZShcIi4uL3BsdWdpbnMvV2ViR1BVVGltaW5nXCIpO1xuY29uc3Qgc3RhcnQgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgYXBwID0gYXdhaXQgVGlueVNoYWRlXzEuVGlueVNoYWRlLmNyZWF0ZShcImNhbnZhc1wiKTtcbiAgICBjb25zdCBQQVJUSUNMRV9DT1VOVCA9IDRfMDAwO1xuICAgIGNvbnN0IFBBUlRJQ0xFX1NUT1JBR0VfU0laRSA9IFBBUlRJQ0xFX0NPVU5UICogNDtcbiAgICBjb25zdCBBU1RFUk9JRF9DT1VOVCA9IDMyO1xuICAgIGNvbnN0IFBIWVNJQ1NfU1RPUkFHRV9TSVpFID0gQVNURVJPSURfQ09VTlQgKiA0O1xuICAgIGNvbnN0IEFUT01JQ19CVUZGRVJfU0laRSA9IGFwcC5jYW52YXMud2lkdGggKiBhcHAuY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBzdGF0cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc3RhdHMuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7dG9wOjEwcHg7bGVmdDoxMHB4O2NvbG9yOiMwZjA7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwwLjgpO3BhZGRpbmc6MTBweDtib3JkZXItcmFkaXVzOjVweDtwb2ludGVyLWV2ZW50czpub25lO3otaW5kZXg6MTAwO2xpbmUtaGVpZ2h0OjEuNDtmb250LXNpemU6MTJweDtib3JkZXI6MXB4IHNvbGlkICMzMzM7XCI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0cyk7XG4gICAgY29uc3QgYXZnID0gbmV3IFdlYkdQVVRpbWluZ18xLlJvbGxpbmdBdmVyYWdlKDYwKTtcbiAgICBjb25zdCB0aW1pbmcgPSBuZXcgV2ViR1BVVGltaW5nXzEuV2ViR1BVVGltaW5nKGFwcC5kZXZpY2UsIChyZXN1bHRzKSA9PiB7XG4gICAgICAgIGxldCBkaXNwbGF5U3RyID0gXCJcIjtcbiAgICAgICAgbGV0IHRvdGFsRnJhbWVUaW1lID0gMDtcbiAgICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlcyA9PiB7XG4gICAgICAgICAgICBkaXNwbGF5U3RyICs9IGAke3Jlcy5uYW1lLnBhZEVuZCgxMil9IDogJHtyZXMubXMudG9GaXhlZCgzKX0gbXNcXG5gO1xuICAgICAgICAgICAgdG90YWxGcmFtZVRpbWUgKz0gcmVzLm1zO1xuICAgICAgICB9KTtcbiAgICAgICAgYXZnLmFkZCh0b3RhbEZyYW1lVGltZSk7XG4gICAgICAgIGRpc3BsYXlTdHIgKz0gYC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbmA7XG4gICAgICAgIGRpc3BsYXlTdHIgKz0gYCR7XCJUb3RhbCBHUFVcIi5wYWRFbmQoMTIpfSA6ICR7YXZnLmdldCgpLnRvRml4ZWQoMyl9IG1zYDtcbiAgICAgICAgc3RhdHMuaW5uZXJUZXh0ID0gZGlzcGxheVN0cjtcbiAgICB9KTtcbiAgICAoYXdhaXQgYXBwXG4gICAgICAgIC5zZXRVbmlmb3JtcygobCkgPT4gbC5hZGRVbmlmb3JtKHsgbmFtZTogXCJjb3VudFwiLCB2YWx1ZTogUEFSVElDTEVfQ09VTlQgfSlcbiAgICAgICAgLmFkZFVuaWZvcm0oeyBuYW1lOiBcImFzdGVyb2lkc1wiLCB2YWx1ZTogMTAgfSkpXG4gICAgICAgIC5hZGRDb21tb24oY29tbW9uX3dnc2xfMS5kZWZhdWx0KVxuICAgICAgICAuYWRkQ29tcHV0ZShcInBoeXNpY3NcIiwgbWV0ZW9yc0NvbXB1dGVfd2dzbF8xLmRlZmF1bHQsIFBIWVNJQ1NfU1RPUkFHRV9TSVpFKVxuICAgICAgICAuYWRkQXRvbWljQ29tcHV0ZShcImNyYXRlcl9tYXBcIiwgY3JhdGVyc0F0b21pY193Z3NsXzEuZGVmYXVsdCwgQVRPTUlDX0JVRkZFUl9TSVpFLCBmYWxzZSlcbiAgICAgICAgLmFkZENvbXB1dGUoXCJwYXJ0aWNsZXNcIiwgcGFydGljbGVzQ29tcHV0ZV93Z3NsXzEuZGVmYXVsdCwgUEFSVElDTEVfU1RPUkFHRV9TSVpFKVxuICAgICAgICAuYWRkUGFzcyhcInBhcnRpY2xlVHJhaWxzXCIsIHBhcnRpY2xlVHJhaWxzRnJhZ193Z3NsXzEuZGVmYXVsdClcbiAgICAgICAgLmFkZENvbXB1dGUoXCJ2b2xjYW5vXCIsIHZvbGNhbm9Db21wdXRlX3dnc2xfMS5kZWZhdWx0LCAxMDAwICogNClcbiAgICAgICAgLmFkZEF0b21pY0NvbXB1dGUoXCJ2b2xjYW5vX21hcFwiLCB2b2xjYW5vQXRvbWljX3dnc2xfMS5kZWZhdWx0LCAoYXBwLmNhbnZhcy53aWR0aCAqIGFwcC5jYW52YXMuaGVpZ2h0KSAqIDQsIHRydWUpXG4gICAgICAgIC5hZGRQYXNzKFwic2t5XCIsIHNreUZyYWdfd2dzbF8xLmRlZmF1bHQpXG4gICAgICAgIC5hZGRQYXNzKFwidm9sY2Fub0ZyYWdcIiwgdm9sY2Fub0ZyYWdfd2dzbF8xLmRlZmF1bHQpIC8vIGFjY3VtIHZpc3VhbHMgZm9yIHZvbGNhbm8gJiBoZWF0bWFwXG4gICAgICAgIC5hZGRQYXNzKFwid29ybGRcIiwgd29ybGRGcmFnX3dnc2xfMS5kZWZhdWx0KVxuICAgICAgICAuYWRkUGFzcyhcIm1ldGVvcnNcIiwgbWV0ZW9yc0ZyYWdfd2dzbF8xLmRlZmF1bHQpXG4gICAgICAgIC5hZGRDb21wdXRlKFwiZmxhc2hcIiwgZmxhc2hDb21wdXRlX3dnc2xfMS5kZWZhdWx0LCA0LCBbXSlcbiAgICAgICAgLmFkZFBhc3MoXCJmaW5cIiwgZmluYWxGcmFnX3dnc2xfMS5kZWZhdWx0KVxuICAgICAgICAubWFpbihtYWluRnJhZ193Z3NsXzEuZGVmYXVsdCkpLnJ1bih0aW1pbmcpO1xufTtcbnN0YXJ0KCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/example/example11.ts\n\n}");

/***/ },

/***/ "./src/example/wgsl/common.wgsl"
/*!**************************************!*\
  !*** ./src/example/wgsl/common.wgsl ***!
  \**************************************/
(module) {

module.exports = "// Constants\r\nconst PI: f32 = 3.141592654;\r\nconst TAU: f32 = 6.283185307;\r\nconst OFF: f32 = 0.7;\r\nconst ZZ_GRID: f32 = 22.0;\r\nconst tomb_probability: f32 = .1;\r\nconst fov: f32 = 2.0;\r\n\r\n//const WORLD_SCALE : f32 = 2000.0; \r\nconst WORLD_SCALE: f32 = 800.0;\r\n\r\nconst R_mat: mat2x2f = mat2x2f(1.2, 1.6, -1.6, 1.2);\r\nconst GG_pos: vec3f = vec3f(-700.0, 300.0, 1000.0);\r\nconst GG_radius: f32 = 400.0;\r\nconst RN: vec3f = normalize(vec3f(-0.2, 1.0, -1.1));\r\nconst LD: vec3f = normalize(vec3f(1.0, -0.5, 1.0));\r\n\r\n\r\nfn worldXZtoUV(worldXZ: vec2f, camXZ: vec2f, scale: f32) -> vec2f {\r\n    let rel = worldXZ - camXZ;\r\n    var uv = rel / scale * 0.5 + 0.5; // map [-scale/2, scale/2] -> [0,1]\r\n    uv = clamp(uv, vec2f(0.0), vec2f(0.999, 0.999));\r\n    return uv;\r\n}\r\n\r\n\r\n// Path logic\r\nfn path(z: f32) -> vec3f {\r\n    return vec3f(vec2f(25.0, 3.3) + vec2f(6.0, 1.41) * cos(vec2f(0.056, 0.035) * z), z);\r\n}\r\n\r\nfn dpath(z: f32) -> vec3f {\r\n    return vec3f(vec2f(-6.0 * 0.056, -1.41 * 0.035) * sin(vec2f(0.056, 0.035) * z), 1.0);\r\n}\r\n\r\n// Math helpers\r\nfn hash(p: vec2f) -> f32 {\r\n    return fract(sin(dot(p, vec2f(12.9898, 58.233))) * 43758.5453);\r\n}\r\n\r\n\r\nfn hsv2rgb(c: vec3f) -> vec3f {\r\n    let k = vec4f(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    let p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\r\n    return c.z * mix(k.xxx, clamp(p - k.xxx, vec3f(0.0), vec3f(1.0)), c.y);\r\n}\r\n\r\nfn tanh_approx(x: vec3f) -> vec3f {\r\n    let x2 = x * x;\r\n    return clamp(x * (27.0 + x2) / (27.0 + 9.0 * x2), vec3f(-1.0), vec3f(1.0));\r\n}\r\n\r\nfn fbm(x_in: f32) -> f32 {\r\n    var x = x_in;\r\n    var a: f32 = 1.0;\r\n    var h: f32 = 0.0;\r\n    for (var i = 0; i < 5; i++) {\r\n        h += a * sin(x);\r\n        x *= 2.03; x += 123.4; a *= 0.55;\r\n    }\r\n    return abs(h);\r\n}\r\n\r\n// THE TERRAIN SDF (3D Fractal)\r\nfn dfbm(p_in: vec3f) -> f32 {\r\n    var p = p_in;\r\n    var d: f32 = p.y + 0.6;\r\n    var a: f32 = 1.0;\r\n    var D = vec2f(0.0);\r\n    var P_map = 0.23 * p.xz;\r\n\r\n    for (var j = 0; j < 7; j++) {\r\n        let o = cos(P_map.xxyy + vec4f(11.0, 0.0, 11.0, 0.0));\r\n        let p_rot = o.yxx * o.zwz;\r\n        D += p_rot.xy;\r\n        d -= a * (1.0 + p_rot.z) / (1.0 + 3.0 * dot(D, D));\r\n        P_map = R_mat * P_map;\r\n        a *= 0.55;\r\n    }\r\n    return d;\r\n}\r\n\r\nfn dpyramid(p_in: vec3f) -> vec3f {\r\n    var p = p_in;\r\n    let n = floor(p.xz / ZZ_GRID + 0.5);\r\n    p.x -= n.x * ZZ_GRID;\r\n    p.z -= n.y * ZZ_GRID;\r\n    \r\n    let h0 = hash(n);\r\n    let h1 = fract(9677.0 * h0);\r\n    \r\n    // --- THE SCALE FIX ---\r\n    // Original was 0.3 * 11.0. \r\n    // New is 0.9 * 11.0 (Approx 10 units high). \r\n    // This makes them 3x taller without breaking the raymarcher.\r\n    let h = 0.9 * 22.0 * (h0 * h0 + 0.2); \r\n    \r\n    let a = abs(p);\r\n    let d = (a.x + a.y + a.z - h) * 0.57735027;\r\n    \r\n    if (h1 > tomb_probability) { return vec3f(1e4, 0.0, 0.0); }\r\n    return vec3f(d, h0, h);\r\n}\r\n\r\n// fn dpyramid(p_in: vec3f) -> vec3f {\r\n//     var p = p_in;\r\n//     let n = floor(p.xz / ZZ_GRID + 0.5);\r\n//     p.x -= n.x * ZZ_GRID;\r\n//     p.z -= n.y * ZZ_GRID;\r\n    \r\n//     let h0 = hash(n);\r\n//     let h1 = fract(9677.0 * h0);\r\n//     let h = 0.3 * ZZ_GRID * h0 * h0 + 0.1;\r\n    \r\n//     // Check if the pyramid exists at all\r\n//     if (h1 > tomb_probability) { return vec3f(1e3, 0.0, 0.0); }\r\n\r\n//     var d: f32;\r\n//     let a = abs(p);\r\n\r\n//     // RANDOMLY PICK SHAPE\r\n//     // h1 is our random seed. If > 0.5, make it a Ziggurat, else Smooth.\r\n//     if (h1 > 0.4) {\r\n//         // --- ZIGGURAT SHAPE ---\r\n//         let num_steps = 5.0; \r\n//         let step_h = h / num_steps;\r\n//         let snapped_y = floor(max(0.0, p.y) / step_h) * step_h;\r\n        \r\n//         let horizontal = max(a.x, a.z);\r\n//         d = max(horizontal + snapped_y - h, p.y - h); \r\n//     } else {\r\n//         // --- SMOOTH SHAPE (Original Diamond Style) ---\r\n//         d = (a.x + a.y + a.z - h) * 0.57735027;\r\n//     }\r\n\r\n//     // Return d * 0.5 for stability, the hash h0, and the height h\r\n//     return vec3f(d * 0.5, h0, h);\r\n// }\r\n\r\n\r\nfn get_BY() -> vec3f { return hsv2rgb(vec3f(0.05 + OFF, 0.7, 0.8)); }\r\nfn get_BG() -> vec3f { return hsv2rgb(vec3f(0.95 + OFF, 0.6, 0.3)); }\r\nfn get_BW() -> vec3f { return hsv2rgb(vec3f(0.55 + OFF, 0.1, 2.5)); }\r\nfn get_BF() -> vec3f { return hsv2rgb(vec3f(0.82 + OFF, 0.6, 2.0)); }";

/***/ },

/***/ "./src/example/wgsl/cratersAtomic.wgsl"
/*!*********************************************!*\
  !*** ./src/example/wgsl/cratersAtomic.wgsl ***!
  \*********************************************/
(module) {

module.exports = "##WORKGROUP_SIZE\r\nfn main(@builtin(global_invocation_id) id: vec3u) {\r\n    let i = id.x;\r\n    if (i >= u32(u.asteroids)) { return; }\r\n\r\n    let b = i * 4u;\r\n    let p_w = physics_data[b + 3u];\r\n\r\n    // Check for impact state: Be more generous with the window\r\n    if (p_w < 1.0 || p_w > 1.9) { return; }\r\n\r\n    // Use the XZ position from the moment of impact\r\n    let p_xz = vec2f(physics_data[b + 0u], physics_data[b + 2u]);\r\n    let res = vec2f(u.resolution.xy);\r\n    \r\n\r\n    // Use floor to handle negative coordinates correctly\r\n    let uv = (p_xz / WORLD_SCALE) - floor(p_xz / WORLD_SCALE); \r\n    let center = uv * res;\r\n\r\n    let rad : f32 = 6.0; // Slightly larger radius\r\n    let search = 8; \r\n\r\n    for (var x = -search; x <= search; x++) {\r\n        for (var y = -search; y <= search; y++) {\r\n            let offset = vec2f(f32(x), f32(y));\r\n            let d = length(offset);\r\n            if (d > rad) { continue; }\r\n\r\n            // Ensure we wrap around the resolution correctly\r\n            let coords = (vec2i(center + offset) + vec2i(res)) % vec2i(res);\r\n            let idx = u32(coords.y) * u32(res.x) + u32(coords.x);\r\n\r\n            // Use a steeper falloff for a sharper crater rim\r\n            let falloff = pow(1.0 - d / rad, 2.0);\r\n            \r\n            // atomicMax ensures that multiple meteors in the same spot \r\n            // don't flicker, but the biggest crater wins.\r\n            atomicMax(&data[idx], u32(falloff * 60000.0));\r\n        }\r\n    }\r\n}";

/***/ },

/***/ "./src/example/wgsl/finalFrag.wgsl"
/*!*****************************************!*\
  !*** ./src/example/wgsl/finalFrag.wgsl ***!
  \*****************************************/
(module) {

module.exports = "@fragment \r\nfn main(in: VSOut) -> @location(0) vec4f {\r\n    let uv = in.uv;\r\n    let r = u.resolution.xy;\r\n\r\n    let world_tex = textureSample(world, samp, uv).rgb;\r\n    let particle_trails = textureSample(particleTrails, samp, uv).rgb;\r\n    let meteor_tex = textureSample(meteors, samp, uv).rgb;\r\n\r\n    let ripple = sin(uv.x * 25.0 + u.time * 2.0) * 0.003;\r\n    let reflected_uv = vec2f(uv.x + ripple, 1.0 - uv.y);\r\n    \r\n    let refl_trails = textureSample(particleTrails, samp, reflected_uv).rgb;\r\n    let refl_meteors = textureSample(meteors, samp, reflected_uv).rgb;\r\n    \r\n    let water_mask = smoothstep(0.46, 0.44, uv.y); \r\n    let water_tint = vec3f(0.02, 0.05, 0.1); \r\n    let reflections = (refl_trails + refl_meteors) * vec3f(0.4, 0.6, 1.0);\r\n\r\n    var color = world_tex + particle_trails;\r\n    \r\n    color = mix(color, color * 0.5 + reflections + water_tint, water_mask);\r\n\r\n    let tint_color = hsv2rgb(vec3f(0.3, 0.7, 0.2)); \r\n    let vignette_mask = length(-1.0 + 2.0 * uv);\r\n    color = color - (vignette_mask + 0.2) * tint_color;\r\n\r\n    color = tanh_approx(color);\r\n\r\n    color += meteor_tex;\r\n\r\n    let final_vignette = smoothstep(1.6, 0.5, vignette_mask);\r\n    color *= final_vignette;\r\n\r\n    return vec4f(max(color, vec3f(0.0)), 1.0);\r\n}";

/***/ },

/***/ "./src/example/wgsl/flashCompute.wgsl"
/*!********************************************!*\
  !*** ./src/example/wgsl/flashCompute.wgsl ***!
  \********************************************/
(module) {

module.exports = "@compute @workgroup_size(1)\r\nfn main() {\r\n    let flash_period = 15.0;\r\n    let flash_time = u.time % flash_period;\r\n    \r\n    // Calculate the spike\r\n    let envelope = smoothstep(0.0, 0.05, flash_time) * smoothstep(0.8, 0.1, flash_time);\r\n    let flicker = sin(u.time * 60.0) * 0.15 + 0.85;\r\n    \r\n    // Result: 0.0 to 2.5\r\n    let brightness = envelope * flicker * 2.5;\r\n    \r\n    // Store in a single float buffer\r\n    data[0] = brightness;\r\n}";

/***/ },

/***/ "./src/example/wgsl/mainFrag.wgsl"
/*!****************************************!*\
  !*** ./src/example/wgsl/mainFrag.wgsl ***!
  \****************************************/
(module) {

module.exports = "@fragment \r\nfn main(in: VSOut) -> @location(0) vec4f {\r\n    let uv = in.uv;\r\n    let center = vec2f(0.5, 0.5);\r\n\r\n    // 1. QUICK READ (One value for the whole screen)\r\n    let flash_strength = flash_data[0];\r\n\r\n    // 2. SAMPLING (Minimal samples)\r\n    let current = textureSample(fin, samp, uv).rgb;\r\n    \r\n    let zoom = 0.995; \r\n    let feedback_uv = (uv - center) * zoom + center;\r\n    let previous = textureSample(prev_fin, samp, feedback_uv).rgb;\r\n\r\n    var color = mix(current, previous, 0.2);\r\n\r\n    // 3. SHIFT (Only calculate if flash is active to save GPU)\r\n    var shift = 0.003 * length(uv - center);\r\n    if (flash_strength > 0.01) {\r\n        shift += flash_strength * 0.01 * length(uv - center);\r\n    }\r\n    \r\n    let r = textureSample(fin, samp, uv + vec2f(shift, 0.0)).r;\r\n    let b = textureSample(fin, samp, uv - vec2f(shift, 0.0)).b;\r\n    color = vec3f(mix(color.r, r, 0.5), color.g, mix(color.b, b, 0.5));\r\n\r\n    // 4. FLASH TINT (Simple math)\r\n    // Strongest at top of screen (1.0 - uv.y)\r\n    color += vec3f(0.4, 0.5, 0.6) * flash_strength * (1.0 - uv.y);\r\n    color *= (1.0 + flash_strength * 0.2);\r\n\r\n    // 5. POST-PROCESS\r\n    let dist = length(uv - center);\r\n    color *= smoothstep(1.0, 0.2, dist * 0.9);\r\n    color = 1.0 - exp(-color * 1.5);\r\n    color = pow(max(color, vec3f(0.0)), vec3f(1.0 / 2.2)); \r\n\r\n    return vec4f(color, 1.0);\r\n}";

/***/ },

/***/ "./src/example/wgsl/meteorsCompute.wgsl"
/*!**********************************************!*\
  !*** ./src/example/wgsl/meteorsCompute.wgsl ***!
  \**********************************************/
(module) {

module.exports = "const STATE_FALLING : f32 = 0.0;\r\nconst STATE_IMPACT  : f32 = 1.0;\r\nconst STATE_SLEEP   : f32 = 2.0;\r\n\r\n@compute @workgroup_size(64)\r\nfn main(@builtin(global_invocation_id) id: vec3u) {\r\n    let i = id.x;\r\n    if (i >= u32(u.asteroids)) { return; }\r\n    let b = i * 4u;\r\n    var p = vec4f(data[b], data[b+1], data[b+2], data[b+3]);\r\n\r\n    let T = u.time * 3.0; \r\n    let F = normalize(dpath(T)); \r\n    let Right = normalize(vec3f(-F.z, 0.0, F.x));\r\n\r\n    // Unique seed for this specific meteor instance\r\n    let meteor_seed = hash(vec2f(f32(i), 123.456));\r\n\r\n    if (p.w <= STATE_FALLING) {\r\n        // --- 1. RANDOMIZED SPEED ---\r\n        // Range: 0.3 (30%) to 1.0 (100%)\r\n        let speed_mult = mix(0.3, 1.0, meteor_seed);\r\n        \r\n        // Base speeds (The max speed we decided on previously)\r\n        let base_h_speed = 0.8;\r\n        let base_v_drop = 0.6;\r\n\r\n        let h = hash(vec2f(f32(i), 7.89));\r\n        let target_pos = path(T + 25.0) + Right * (h - 0.5) * 60.0;\r\n        let to_target = normalize(target_pos - p.xyz);\r\n\r\n        // Apply movement using the unique speed multiplier\r\n        p.x += to_target.x * base_h_speed * speed_mult;\r\n        p.z += to_target.z * base_h_speed * speed_mult;\r\n        p.y -= base_v_drop * speed_mult;\r\n\r\n        if (p.y <= 0.0) {\r\n            p.y = 0.0;\r\n            p.w = STATE_IMPACT; \r\n        }\r\n    } \r\n    else if (p.w >= STATE_IMPACT && p.w < STATE_SLEEP) {\r\n        p.y = -10.0; \r\n        p.w += 0.2; \r\n        if (p.w >= 1.5) {\r\n            // Randomize sleep time so they don't all respawn together\r\n            p.w = STATE_SLEEP + 10.0 + (meteor_seed * 100.0); \r\n        }\r\n    } \r\n    else {\r\n        p.w -= 0.016; \r\n        if (p.w <= STATE_SLEEP) {\r\n            let h = hash(vec2f(f32(i), T + f32(i)));\r\n            \r\n            // Re-centering logic (Camera offset -0.5)\r\n            let look_ahead = 110.0; \r\n            let spawn_ref = path(T + look_ahead) + vec3f(-0.5 * look_ahead, 0.0, 0.0);\r\n            \r\n            p.x = spawn_ref.x + Right.x * ((h - 0.5) * 180.0);\r\n            p.z = spawn_ref.z + Right.z * ((h - 0.5) * 180.0);\r\n            p.y = 100.0; \r\n            p.w = STATE_FALLING;\r\n        }\r\n    }\r\n\r\n    data[b] = p.x; data[b+1] = p.y; data[b+2] = p.z; data[b+3] = p.w;\r\n}";

/***/ },

/***/ "./src/example/wgsl/meteorsFrag.wgsl"
/*!*******************************************!*\
  !*** ./src/example/wgsl/meteorsFrag.wgsl ***!
  \*******************************************/
(module) {

module.exports = "@fragment\r\nfn main(in: VSOut) -> @location(0) vec4f {\r\n    let r = u.resolution.xy;\r\n    let p2 = (vec2f(in.uv.x, 1.0 - in.uv.y) * 2.0 - 1.0) * vec2f(r.x / r.y, 1.0);\r\n\r\n    let T = u.time * 3.0;\r\n    let P = path(T);\r\n    let ZZ = normalize(dpath(T) + vec3f(-0.5, 0.1, 0.0));\r\n    let XX = normalize(cross(ZZ, vec3f(0.0, 1.0, 0.0)));\r\n    let YY = cross(XX, ZZ);\r\n    let R = normalize(-p2.x * XX + p2.y * YY + fov * ZZ);\r\n\r\n    var layer = vec3f(0.0);\r\n\r\n    for (var i = 0u; i < u32(u.asteroids); i++) {\r\n        let b = i * 4u;\r\n        let m_pos = vec3f(physics_data[b], physics_data[b+1], physics_data[b+2]);\r\n        let state = physics_data[b+3];\r\n\r\n        if (state >= 1.0) { continue; }\r\n\r\n        let dir = m_pos - P;\r\n        let dist = length(dir);\r\n        let align = max(dot(R, normalize(dir)), 0.0);\r\n        let dist_norm = clamp(dist / 180.0, 0.0, 1.0);\r\n\r\n\r\n        // Massive sharpness (150,000) makes the core tiny.\r\n        // Even at a distance, we keep it high (20,000) so it's a \"star\".\r\n        let sharpness = mix(150000.0, 20000.0, dist_norm);\r\n        \r\n        // Core is now a needle-point\r\n        let core = pow(align, sharpness) * 80.0;\r\n        \r\n        // Very subtle atmospheric glow (reduced size)\r\n        let halo = pow(align, mix(2000.0, 500.0, dist_norm)) * 1.5;\r\n\r\n        // Flicker is faster to simulate atmospheric turbulence\r\n        let flicker = 0.7 + 0.3 * sin(u.time * 35.0 + f32(i));\r\n        \r\n        let color = mix(vec3f(1.0, 0.9, 0.7), vec3f(1.0, 0.4, 0.1), dist_norm);\r\n\r\n        layer += color * (core + halo) * flicker * (300.0 / (dist + 50.0));\r\n    }\r\n\r\n    // Gentle bloom/tonemap to prevent blocky pixels\r\n    return vec4f(layer / (1.0 + layer), 1.0);\r\n}";

/***/ },

/***/ "./src/example/wgsl/particleTrailsFrag.wgsl"
/*!**************************************************!*\
  !*** ./src/example/wgsl/particleTrailsFrag.wgsl ***!
  \**************************************************/
(module) {

module.exports = "  @fragment fn main(in: VSOut) -> @location(0) vec4f {\r\n            let dots = textureSample(particles, samp, in.uv).rgb;\r\n            let oldTrails = textureSample(particleTrails, samp, in.uv).rgb;\r\n            let fade = oldTrails * 0.2;\r\n            return vec4f(dots + fade, 1.0);\r\n}   ";

/***/ },

/***/ "./src/example/wgsl/particlesCompute.wgsl"
/*!************************************************!*\
  !*** ./src/example/wgsl/particlesCompute.wgsl ***!
  \************************************************/
(module) {

module.exports = "##WORKGROUP_SIZE\r\nfn main(@builtin(global_invocation_id) id: vec3u) {\r\n    let res = vec2f(u.resolution.xy);\r\n    if (f32(id.x) < res.x && f32(id.y) < res.y) {\r\n        textureStore(outTex, id.xy, vec4f(0.0));\r\n    }\r\n\r\n    let i = id.x;\r\n    if (i >= u32(u.count)) { return; }\r\n    \r\n    let b = i * 4u;\r\n    var p = vec4f(data[b], data[b+1], data[b+2], data[b+3]);\r\n\r\n    p.z -= 0.0005 + (fract(f32(i) * 0.13) * 0.0007);\r\n\r\n    if (p.z < 0.1 || u.time < 0.1) {\r\n        let angle = fract(f32(i) * 0.001) * 6.28 + u.time * 0.2;\r\n        let radius = 0.5 + fract(f32(i) * 0.5) * 2.0;\r\n        p.x = cos(angle) * radius;\r\n        p.y = sin(angle) * radius;\r\n        p.z = 4.0 + fract(f32(i) * 123.45);\r\n        p.w = 0.1 + fract(f32(i) * 7.7) * 0.5;\r\n    }\r\n\r\n    p.x += sin(p.z + u.time) * 0.001;\r\n    p.y += cos(p.z + u.time) * 0.001;\r\n\r\n    data[b] = p.x; data[b+1] = p.y; data[b+2] = p.z; data[b+3] = p.w;\r\n\r\n    let aspect = res.x / res.y;\r\n    let screenX = (p.x / p.z);\r\n    let screenY = (p.y / (p.z * aspect));\r\n\r\n    let coords = vec2i(\r\n        i32((screenX * 0.5 + 0.5) * res.x), \r\n        i32((screenY * 0.5 + 0.5) * res.y)\r\n    );\r\n    \r\n    if(coords.x <= 1 || coords.x >= i32(res.x)-1 || coords.y <= 1 || coords.y >= i32(res.y)-1) { return; }\r\n\r\n    let depthFactor = saturate(1.0 - (p.z / 4.0));\r\n    let color = mix(vec3f(0.0, 0.1, 0.5), vec3f(0.2, 0.9, 1.0), depthFactor);\r\n    \r\n    textureStore(outTex, coords, vec4f(color * (depthFactor * 3.0), 1.0));\r\n}";

/***/ },

/***/ "./src/example/wgsl/skyFrag.wgsl"
/*!***************************************!*\
  !*** ./src/example/wgsl/skyFrag.wgsl ***!
  \***************************************/
(module) {

module.exports = "fn stars(R_in: vec3f) -> vec3f {\r\n    var R = R_in; var Z = 6.28318 / 200.0; var col = vec3f(0.0); var a = 1.0;\r\n    for (var i = 0; i < 3; i++) {\r\n        R = R.zxy; \r\n        let s = vec2f(acos(clamp(R.z/length(R), -1.0, 1.0)), atan2(R.y, R.x));\r\n        let n = floor(s/Z + 0.5); var c = s - Z*n;\r\n        let h0 = hash(n + 123.4 * f32(i+1));\r\n        c.y *= sin(s.x);\r\n        let intensity = step(h0, 0.1 * sin(s.x)) * fract(8887.0 * h0) * 0.000007;\r\n        col += a * hsv2rgb(vec3f(-0.4 * fract(8887.0 * h0), sqrt(fract(9677.0 * h0)), intensity / dot(c, c)));\r\n        Z *= 0.5; a *= 0.5;\r\n    }\r\n    return col;\r\n}\r\n\r\n@fragment\r\nfn main(in: VSOut) -> @location(0) vec4f {\r\n    let r = u.resolution.xy;\r\n    let p2 = (vec2f(in.uv.x, 1.0 - in.uv.y) * 2.0 - 1.0) * vec2f(r.x / r.y, 1.0);\r\n    let T = 3.0 * u.time;\r\n    let P = path(T);\r\n    let ZZ_cam = normalize(dpath(T) + vec3f(-0.5, 0.1, 0.0));\r\n    let XX = normalize(cross(ZZ_cam, vec3f(0.0, 1.0, 0.0)));\r\n    let YY = cross(XX, ZZ_cam); \r\n    let R = normalize(-p2.x * XX + p2.y * YY + fov * ZZ_cam);\r\n\r\n    var Y = vec3f(0.0);\r\n    if (R.y > -0.2) {\r\n        let sph_center = GG_pos + P;\r\n        let b_s = dot(P - sph_center, R);\r\n        let c_s = dot(P - sph_center, P - sph_center) - GG_radius * GG_radius;\r\n        let h_s = b_s * b_s - c_s;\r\n        var z_sph = -1.0; if (h_s >= 0.0) { z_sph = -b_s - sqrt(h_s); }\r\n        \r\n        let F_sky = smoothstep(-0.05, 0.05, R.y);\r\n        Y = clamp(hsv2rgb(vec3f(OFF - 0.4 * R.y, 0.5 + 1.0 * R.y, 3.0 / (1.0 + 800.0 * pow(max(0.0, R.y), 3.0)))), vec3f(0.0), vec3f(1.0));\r\n        let L_val = dot(vec3f(0.2126, 0.7152, 0.0722), Y);\r\n        \r\n        if (z_sph > 0.0) {\r\n            let p_sph = P + R * z_sph;\r\n            let norm_s = normalize(p_sph - sph_center);\r\n            Y += max(dot(LD, norm_s), 0.0) * F_sky * smoothstep(1.0, 0.89, 1.0 + dot(R, norm_s)) * fbm(0.02 * dot(p_sph - sph_center, RN));\r\n        }\r\n        \r\n        let plane_dist = -(dot(P, RN) + (-dot(RN, sph_center))) / dot(R, RN);\r\n        if (plane_dist > 0.0 && (z_sph < 0.0 || plane_dist < z_sph)) {\r\n            let p_ring = P + R * plane_dist;\r\n            let d_ring = distance(sph_center, p_ring);\r\n            \r\n            let ring_to_light = LD;\r\n            let ring_to_center = normalize(p_ring - sph_center);\r\n            let shadow = smoothstep(-0.2, 0.1, dot(ring_to_center, ring_to_light));\r\n\r\n            let ring_mask = smoothstep(GG_radius * 1.41, GG_radius * 1.46, d_ring) * smoothstep(GG_radius * 2.0, GG_radius * 1.95, d_ring);\r\n            let ring_tex = fbm(0.035 * d_ring) * abs(dot(LD, RN));\r\n            \r\n            Y += F_sky * ring_mask * ring_tex * shadow;\r\n        }\r\n        if (z_sph < 0.0) { Y += pow(max(0.0, 1.0 - L_val), 4.0) * stars(R); }\r\n    }\r\n    return vec4f(Y, 1.0);\r\n}";

/***/ },

/***/ "./src/example/wgsl/volcanoAtomic.wgsl"
/*!*********************************************!*\
  !*** ./src/example/wgsl/volcanoAtomic.wgsl ***!
  \*********************************************/
(module) {

module.exports = "##WORKGROUP_SIZE\r\nfn main(@builtin(global_invocation_id) id: vec3u) {\r\n    let i = id.x;\r\n    if (i >= 1000u) { return; } \r\n    \r\n    let b = i * 4u;\r\n    let pos = vec3f(volcano_data[b], volcano_data[b+1], volcano_data[b+2]);\r\n    let life = volcano_data[b+3];\r\n\r\n    if (life <= 0.0) { return; }\r\n\r\n    // --- CAMERA SYSTEM ---\r\n    let T = u.time * 3.0;\r\n    let P = path(T);\r\n    let ZZ = normalize(dpath(T) + vec3f(-0.5, 0.1, 0.0));\r\n    let XX = normalize(cross(ZZ, vec3f(0.0, 1.0, 0.0)));\r\n    let YY = cross(XX, ZZ);\r\n\r\n    let rel = pos - P;           \r\n    let depth = dot(rel, ZZ);    \r\n\r\n\r\n    // If it's closer than 2.0 units or behind the camera, KILL IT.\r\n    if (depth <= 2.0) { return; }\r\n\r\n    let res = u.resolution.xy;\r\n    let aspect = res.x / res.y;\r\n    let inv_d = fov / depth;\r\n    \r\n    // Project to Camera Space\r\n    let p_x = dot(rel, XX) * inv_d;\r\n    let p_y = dot(rel, YY) * inv_d;\r\n\r\n  \r\n    // In normalized device coordinates, the screen is roughly -aspect to +aspect.\r\n    // If the math results in a point way outside this, it's a \"ghost\" projection.\r\n    if (abs(p_x) > aspect * 1.5 || abs(p_y) > 1.5) { return; }\r\n\r\n    // Map to UV [0, 1]\r\n    let uv = vec2f((-p_x / aspect + 1.0) * 0.5, 1.0 - (p_y + 1.0) * 0.5);\r\n\r\n   \r\n    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {\r\n        let coords = vec2u(u32(uv.x * res.x), u32(uv.y * res.y));\r\n        \r\n        // Final safety check to prevent writing to index 0 or out of bounds\r\n        if (coords.x < u32(res.x) && coords.y < u32(res.y)) {\r\n            let idx = coords.y * u32(res.x) + coords.x;\r\n            \r\n         \r\n            atomicAdd(&data[idx], 10u); \r\n        }\r\n    }\r\n}";

/***/ },

/***/ "./src/example/wgsl/volcanoCompute.wgsl"
/*!**********************************************!*\
  !*** ./src/example/wgsl/volcanoCompute.wgsl ***!
  \**********************************************/
(module) {

module.exports = "        ##WORKGROUP_SIZE\r\n        fn main(@builtin(global_invocation_id) id: vec3u) {\r\n            let i = id.x;\r\n            if (i >= 1000u) { return; } \r\n            \r\n            let b = i * 4u;\r\n            var p = vec4f(data[b], data[b+1], data[b+2], data[b+3]);\r\n\r\n            // 1. UPDATE EXISTING PARTICLES\r\n            if (p.w > 0.0) {\r\n                p.y += 0.15; \r\n                p.w -= 0.01; // Particle life\r\n\r\n                let angle = p.y * 0.5 + f32(i);\r\n                p.x += sin(angle) * 0.04;\r\n                p.z += cos(angle) * 0.04;\r\n            }\r\n\r\n            // 2. TRIGGER LOGIC: Watch a specific meteor\r\n            // Each volcano \"id\" monitors a specific meteor \"id\"\r\n            let meteor_idx = i % u32(u.asteroids);\r\n            let m_pos = vec3f(physics_data[meteor_idx * 4u], physics_data[meteor_idx * 4u + 1u], physics_data[meteor_idx * 4u + 2u]);\r\n            let m_state = physics_data[meteor_idx * 4u + 3u];\r\n\r\n            // If the particle is dead AND its assigned meteor is in IMPACT or SLEEP state\r\n            if (p.w <= 0.0 && m_state >= 1.0) {\r\n                // Jitter the spawn position slightly so they don't all look like 1 line\r\n                let seed = f32(i) + u.time;\r\n                let noise = vec2f(fract(sin(seed)*437.5), fract(cos(seed)*234.1)) - 0.5;\r\n                \r\n                p.x = m_pos.x + noise.x * 2.0;\r\n                p.z = m_pos.z + noise.y * 2.0;\r\n                p.y = 0.0; \r\n                p.w = 1.0; \r\n            }\r\n\r\n            data[b] = p.x; data[b+1] = p.y; data[b+2] = p.z; data[b+3] = p.w;\r\n        }";

/***/ },

/***/ "./src/example/wgsl/volcanoFrag.wgsl"
/*!*******************************************!*\
  !*** ./src/example/wgsl/volcanoFrag.wgsl ***!
  \*******************************************/
(module) {

module.exports = "@fragment fn main(in: VSOut) -> @location(0) vec4f {\r\n    let res = u.resolution.xy;\r\n    let idx = u32(in.uv.y * res.y) * u32(res.x) + u32(in.uv.x * res.x);\r\n    let val = f32(atomicLoad(&volcano_map_data[idx]));\r\n    \r\n    var explosion = vec3f(0.0);\r\n    if (val > 0.0) {\r\n        let heat = saturate(val * 0.1);\r\n        explosion = mix(vec3f(1.0, 0.2, 0.0), vec3f(1.0, 0.8, 0.3), heat) * heat * 5.0;\r\n    }\r\n\r\n    // THE TRAIL (Rising heat and falling debris)\r\n    let history = textureSample(prev_volcanoFrag, samp, in.uv).rgb;\r\n    \r\n    // This creates the \"fade\" and \"upward drift\" of the eruption smoke\r\n    let trail = textureSample(prev_volcanoFrag, samp, in.uv + vec2f(0.0, 0.003)).rgb;\r\n\r\n    // Mix them: Current explosion + persistent trail\r\n    let final_col = explosion + (trail * 0.96);\r\n\r\n    return vec4f(final_col, 1.0);\r\n}";

/***/ },

/***/ "./src/example/wgsl/worldFrag.wgsl"
/*!*****************************************!*\
  !*** ./src/example/wgsl/worldFrag.wgsl ***!
  \*****************************************/
(module) {

module.exports = "fn sampleCrater(st: vec2f, r: vec2f) -> f32 {\r\n    let i = vec2u(st);\r\n    let f = fract(st);\r\n\r\n    let w = u32(r.x);\r\n    let h = u32(r.y);\r\n\r\n    let idx = i.y * w + i.x;\r\n\r\n    let s00 = f32(atomicLoad(&crater_map_data[idx]));\r\n    let s10 = f32(atomicLoad(&crater_map_data[i.y * w + (i.x + 1u) % w]));\r\n    let s01 = f32(atomicLoad(&crater_map_data[((i.y + 1u) % h) * w + i.x]));\r\n    let s11 = f32(atomicLoad(&crater_map_data[((i.y + 1u) % h) * w + (i.x + 1u) % w]));\r\n\r\n    return mix(mix(s00, s10, f.x), mix(s01, s11, f.x), f.y);\r\n}\r\n\r\n\r\n@fragment\r\nfn main(in: VSOut) -> @location(0) vec4f {\r\n    let r = u.resolution.xy;\r\n    let p2 = (vec2f(in.uv.x, 1.0 - in.uv.y) * 2.0 - 1.0) * vec2f(r.x / r.y, 1.0);\r\n    let sky_bg = textureSample(sky, samp, in.uv).rgb;\r\n\r\n    // --- CAMERA SYSTEM ---\r\n    let T = u.time * 3.0;\r\n    let P = path(T);\r\n    let ZZ = normalize(dpath(T) + vec3f(-0.5, 0.1, 0.0));\r\n    let XX = normalize(cross(ZZ, vec3f(0.0, 1.0, 0.0)));\r\n    let YY = cross(XX, ZZ);\r\n    let R = normalize(-p2.x * XX + p2.y * YY + fov * ZZ);\r\n\r\n    var O = vec3f(0.0);\r\n    var z_dist: f32 = 0.0;\r\n    let Y_vec = (1.0 + R.x) * get_BY();\r\n    let S_col = (1.0 + R.y) * get_BW() * Y_vec;\r\n\r\n    for (var i = 0; i < 85; i++) {\r\n        let p_m = P + z_dist * R;\r\n        \r\n        if (p_m.y > 15.0 && R.y > 0.0) {\r\n            z_dist += p_m.y * 0.5; \r\n            continue; \r\n        }\r\n\r\n        // --- BILINEAR CRATER LOOKUP (Smoothes Squares) ---\r\n        var crater_norm: f32 = 0.0;\r\n        var rim: f32 = 0.0;\r\n        \r\n        if (p_m.y < 12.0) {\r\n            let uv_raw = (p_m.xz / WORLD_SCALE) % 1.0;\r\n            let uv_c = uv_raw + select(vec2f(0.0), vec2f(1.0), uv_raw < vec2f(0.0));\r\n            let st = uv_c * r;\r\n            let i_st = vec2u(st);\r\n            let f = fract(st);\r\n\r\n\r\n            let smooth_val = sampleCrater(st, r);\r\n\r\n\r\n            crater_norm = clamp(smooth_val / 60000.0, 0.0, 1.0);\r\n            rim = sin(crater_norm * 3.1415) * 1.8;\r\n        }\r\n\r\n        var p_sample = p_m;\r\n        p_sample.y = abs(p_sample.y);\r\n\r\n        let d_terrain = dfbm(p_sample);\r\n        let pyr = dpyramid(p_sample);\r\n        \r\n        // --- CARVING LOGIC ---\r\n        // Subtracting pulls geometry in (Hole). Adding pushes it out (Rim).\r\n        let hole_shape = pow(crater_norm, 0.8) * 6.5;\r\n        //let displacement = hole_shape - (rim * 0.4); \r\n        let displacement =\r\n            hole_shape * 1.0   // dig hole\r\n                - rim * 1.2;         // push rim upward\r\n\r\n        let limit = smoothstep(10.0, -0.5, p_m.y);\r\n\r\n        var d = min(d_terrain, pyr.x) - (displacement * limit);\r\n\r\n        if (p_m.y > 0.0) {\r\n            let base_col = get_BG();\r\n            let pulse = 0.9 + 0.1 * sin(u.time * 5.0);\r\n            let lava = vec3f(2.5, 0.45, 0.05) * pow(crater_norm, 2.5) * 10.0 * pulse;\r\n            let surface = mix(base_col, vec3f(0.01, 0.005, 0.008), pow(crater_norm, 1.2));\r\n\r\n            O += (surface + lava) + min(d, 9.0) * Y_vec;\r\n        } else {\r\n            O += S_col;\r\n        }\r\n\r\n        O += smoothstep(pyr.z * 0.78, pyr.z * 0.8, abs(p_m.y)) /\r\n             max(pyr.x + pow(pyr.x, 4.0) * 9.0, 0.01) * get_BF();\r\n\r\n        z_dist += d * 0.5;\r\n        if (d < 1e-3 || z_dist > 180.0) { break; }\r\n    }\r\n\r\n    O *= 9e-3;\r\n    if (R.y > 0.0) { O *= sky_bg; }\r\n\r\n   \r\n    let pillar_tex = textureSample(volcanoFrag, samp, in.uv).rgb;\r\n    O += pillar_tex * 2.8;\r\n\r\n    return vec4f(max(O, vec3f(0.0)), 1.0);\r\n}";

/***/ },

/***/ "./src/plugins/WebGPUTiming.ts"
/*!*************************************!*\
  !*** ./src/plugins/WebGPUTiming.ts ***!
  \*************************************/
(__unused_webpack_module, exports) {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebGPUTiming = exports.RollingAverage = void 0;\nclass RollingAverage {\n    size;\n    samples = [];\n    constructor(size = 60) {\n        this.size = size;\n    }\n    add(val) {\n        this.samples.push(val);\n        if (this.samples.length > this.size)\n            this.samples.shift();\n    }\n    get() { return this.samples.reduce((a, b) => a + b, 0) / this.samples.length; }\n}\nexports.RollingAverage = RollingAverage;\nclass WebGPUTiming {\n    device;\n    onResult;\n    supportsTimeStampQuery;\n    querySet;\n    resolveBuffer;\n    readBuffer;\n    currentIndex = 0;\n    maxQueries = 20;\n    isMapping = false;\n    constructor(device, onResult) {\n        this.device = device;\n        this.onResult = onResult;\n        this.supportsTimeStampQuery = device.features.has(\"timestamp-query\");\n        if (this.supportsTimeStampQuery) {\n            this.querySet = device.createQuerySet({ type: \"timestamp\", count: this.maxQueries });\n            this.resolveBuffer = device.createBuffer({\n                size: this.maxQueries * 8,\n                usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n            });\n            this.readBuffer = device.createBuffer({\n                size: this.maxQueries * 8,\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n            });\n        }\n    }\n    reset() { this.currentIndex = 0; }\n    allocateIndices() {\n        if (!this.supportsTimeStampQuery || this.currentIndex + 2 > this.maxQueries)\n            return null;\n        const indices = { start: this.currentIndex, end: this.currentIndex + 1 };\n        this.currentIndex += 2;\n        return indices;\n    }\n    async resolve(passTimings) {\n        if (!this.supportsTimeStampQuery || this.isMapping || passTimings.length === 0)\n            return;\n        if (this.readBuffer.mapState !== \"unmapped\")\n            return;\n        this.isMapping = true;\n        try {\n            const enc = this.device.createCommandEncoder();\n            enc.resolveQuerySet(this.querySet, 0, this.currentIndex, this.resolveBuffer, 0);\n            enc.copyBufferToBuffer(this.resolveBuffer, 0, this.readBuffer, 0, this.currentIndex * 8);\n            this.device.queue.submit([enc.finish()]);\n            await this.readBuffer.mapAsync(GPUMapMode.READ);\n            const timestamps = new BigUint64Array(this.readBuffer.getMappedRange().slice(0));\n            this.readBuffer.unmap();\n            const results = passTimings.map(t => ({\n                name: t.name,\n                ms: Number(timestamps[t.end] - timestamps[t.start]) / 1000000\n            }));\n            if (this.onResult)\n                this.onResult(results);\n        }\n        catch (e) {\n            // Mapping interrupted or device lost\n        }\n        finally {\n            this.isMapping = false;\n        }\n    }\n}\nexports.WebGPUTiming = WebGPUTiming;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGx1Z2lucy9XZWJHUFVUaW1pbmcudHMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDJDQUEyQztBQUMvRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RpbnlzaGFkZS8uL3NyYy9wbHVnaW5zL1dlYkdQVVRpbWluZy50cz81ZjhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJHUFVUaW1pbmcgPSBleHBvcnRzLlJvbGxpbmdBdmVyYWdlID0gdm9pZCAwO1xuY2xhc3MgUm9sbGluZ0F2ZXJhZ2Uge1xuICAgIHNpemU7XG4gICAgc2FtcGxlcyA9IFtdO1xuICAgIGNvbnN0cnVjdG9yKHNpemUgPSA2MCkge1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbiAgICBhZGQodmFsKSB7XG4gICAgICAgIHRoaXMuc2FtcGxlcy5wdXNoKHZhbCk7XG4gICAgICAgIGlmICh0aGlzLnNhbXBsZXMubGVuZ3RoID4gdGhpcy5zaXplKVxuICAgICAgICAgICAgdGhpcy5zYW1wbGVzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGdldCgpIHsgcmV0dXJuIHRoaXMuc2FtcGxlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHRoaXMuc2FtcGxlcy5sZW5ndGg7IH1cbn1cbmV4cG9ydHMuUm9sbGluZ0F2ZXJhZ2UgPSBSb2xsaW5nQXZlcmFnZTtcbmNsYXNzIFdlYkdQVVRpbWluZyB7XG4gICAgZGV2aWNlO1xuICAgIG9uUmVzdWx0O1xuICAgIHN1cHBvcnRzVGltZVN0YW1wUXVlcnk7XG4gICAgcXVlcnlTZXQ7XG4gICAgcmVzb2x2ZUJ1ZmZlcjtcbiAgICByZWFkQnVmZmVyO1xuICAgIGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbWF4UXVlcmllcyA9IDIwO1xuICAgIGlzTWFwcGluZyA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKGRldmljZSwgb25SZXN1bHQpIHtcbiAgICAgICAgdGhpcy5kZXZpY2UgPSBkZXZpY2U7XG4gICAgICAgIHRoaXMub25SZXN1bHQgPSBvblJlc3VsdDtcbiAgICAgICAgdGhpcy5zdXBwb3J0c1RpbWVTdGFtcFF1ZXJ5ID0gZGV2aWNlLmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUaW1lU3RhbXBRdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeVNldCA9IGRldmljZS5jcmVhdGVRdWVyeVNldCh7IHR5cGU6IFwidGltZXN0YW1wXCIsIGNvdW50OiB0aGlzLm1heFF1ZXJpZXMgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVCdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgICAgICBzaXplOiB0aGlzLm1heFF1ZXJpZXMgKiA4LFxuICAgICAgICAgICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlciA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICAgICAgICAgIHNpemU6IHRoaXMubWF4UXVlcmllcyAqIDgsXG4gICAgICAgICAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldCgpIHsgdGhpcy5jdXJyZW50SW5kZXggPSAwOyB9XG4gICAgYWxsb2NhdGVJbmRpY2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNUaW1lU3RhbXBRdWVyeSB8fCB0aGlzLmN1cnJlbnRJbmRleCArIDIgPiB0aGlzLm1heFF1ZXJpZXMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IHsgc3RhcnQ6IHRoaXMuY3VycmVudEluZGV4LCBlbmQ6IHRoaXMuY3VycmVudEluZGV4ICsgMSB9O1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCArPSAyO1xuICAgICAgICByZXR1cm4gaW5kaWNlcztcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZShwYXNzVGltaW5ncykge1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNUaW1lU3RhbXBRdWVyeSB8fCB0aGlzLmlzTWFwcGluZyB8fCBwYXNzVGltaW5ncy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJlYWRCdWZmZXIubWFwU3RhdGUgIT09IFwidW5tYXBwZWRcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pc01hcHBpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5jID0gdGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICAgICAgICAgIGVuYy5yZXNvbHZlUXVlcnlTZXQodGhpcy5xdWVyeVNldCwgMCwgdGhpcy5jdXJyZW50SW5kZXgsIHRoaXMucmVzb2x2ZUJ1ZmZlciwgMCk7XG4gICAgICAgICAgICBlbmMuY29weUJ1ZmZlclRvQnVmZmVyKHRoaXMucmVzb2x2ZUJ1ZmZlciwgMCwgdGhpcy5yZWFkQnVmZmVyLCAwLCB0aGlzLmN1cnJlbnRJbmRleCAqIDgpO1xuICAgICAgICAgICAgdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFtlbmMuZmluaXNoKCldKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVhZEJ1ZmZlci5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO1xuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IG5ldyBCaWdVaW50NjRBcnJheSh0aGlzLnJlYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKS5zbGljZSgwKSk7XG4gICAgICAgICAgICB0aGlzLnJlYWRCdWZmZXIudW5tYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBwYXNzVGltaW5ncy5tYXAodCA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHQubmFtZSxcbiAgICAgICAgICAgICAgICBtczogTnVtYmVyKHRpbWVzdGFtcHNbdC5lbmRdIC0gdGltZXN0YW1wc1t0LnN0YXJ0XSkgLyAxMDAwMDAwXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vblJlc3VsdClcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVzdWx0KHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBNYXBwaW5nIGludGVycnVwdGVkIG9yIGRldmljZSBsb3N0XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmlzTWFwcGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5XZWJHUFVUaW1pbmcgPSBXZWJHUFVUaW1pbmc7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/plugins/WebGPUTiming.ts\n\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/example/example11.ts");
/******/ 	
/******/ })()
;