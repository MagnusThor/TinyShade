/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/TinyShade.ts"
/*!**************************!*\
  !*** ./src/TinyShade.ts ***!
  \**************************/
(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TinyShade = void 0;\nconst UniformLayout_1 = __webpack_require__(/*! ./UniformLayout */ \"./src/UniformLayout.ts\");\n/**\n * Utility for writing data to GPU Buffers.\n */\nconst Buffer = {\n    /**\n     * Writes an ArrayBufferView to a GPUBuffer.\n     * @param device The active GPUDevice.\n     * @param buffer The target GPUBuffer.\n     * @param data The data to write.\n     * @param offset Byte offset in the buffer.\n     */\n    write(device, buffer, data, offset = 0) {\n        device.queue.writeBuffer(buffer, offset, data.buffer, data.byteOffset, data.byteLength);\n        return buffer;\n    }\n};\n/**\n * Calculates the largest power of two less than or equal to n.\n * Useful for optimizing workgroup sizes.\n */\nconst largestPowerOf2LessThan = (n) => {\n    let power = 1;\n    while (power * 2 <= n)\n        power *= 2;\n    return power;\n};\n/**\n * Determines optimal workgroup sizes based on hardware limits.\n */\nconst getWorkgroupSize = (limits) => {\n    const x = Math.min(16, largestPowerOf2LessThan(limits.maxComputeWorkgroupSizeX));\n    const y = Math.min(16, largestPowerOf2LessThan(limits.maxComputeWorkgroupSizeY));\n    return { x, y, z: 1, str: `@workgroup_size(${x}, ${y}, 1)` };\n};\n/**\n * TinyShade: A minimal, high-performance WebGPU framework for\n * multi-pass fragment and compute shaders.\n */\nclass TinyShade {\n    device;\n    context;\n    canvas;\n    uniforms;\n    uniformBuffer;\n    audioPlugin;\n    startTime = 0;\n    frameCounter = 0;\n    sequencer;\n    globalTextures = new Map();\n    commonWGSL = \"\";\n    passes = [];\n    passLayouts = [];\n    bgCache = [];\n    mainPassShader = \"\";\n    mainPipeline;\n    isCompiled = false;\n    startedAudio = false;\n    _mainDeps = undefined;\n    workgroupSize = { x: 8, y: 8, z: 1, str: \"@workgroup_size(8, 8, 1)\" };\n    globalSampler;\n    constructor(canvas) {\n        this.canvas = canvas;\n        const dpr = window.devicePixelRatio || 1;\n        this.uniforms = new UniformLayout_1.UniformLayout([this.canvas.width * dpr, this.canvas.height * dpr, dpr]);\n    }\n    /**\n     * Initializes the WebGPU context and creates a TinyShade instance.\n     * @param canvasId The ID of the HTML canvas element.\n     */\n    static async create(canvasId) {\n        const canvas = document.getElementById(canvasId);\n        const ts = new TinyShade(canvas);\n        await ts.initWebGPU();\n        return ts;\n    }\n    async initWebGPU() {\n        const adapter = await navigator.gpu?.requestAdapter();\n        if (!adapter)\n            throw \"WebGPU not supported\";\n        const features = [];\n        if (adapter.features.has('bgra8unorm-storage'))\n            features.push('bgra8unorm-storage');\n        if (adapter.features.has('timestamp-query'))\n            features.push('timestamp-query');\n        this.device = await adapter.requestDevice({ requiredFeatures: features });\n        this.globalSampler = this.device.createSampler({ magFilter: 'linear', minFilter: 'linear' });\n        this.workgroupSize = getWorkgroupSize(adapter.limits);\n        this.context = this.canvas.getContext(\"webgpu\");\n        this.context.configure({\n            device: this.device,\n            format: navigator.gpu.getPreferredCanvasFormat(),\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.startTime = performance.now();\n    }\n    getRelevantPasses(currentPass) {\n        const base = currentPass.dependencies\n            ? this.passes.filter(p => currentPass.dependencies.includes(p.name))\n            : this.passes;\n        const resultSet = new Set(base);\n        if (!currentPass.isMain)\n            resultSet.add(currentPass);\n        return Array.from(resultSet);\n    }\n    /**\n     * Connects an audio plugin to synchronize uniforms with audio data.\n     */\n    addAudio(plugin) { this.audioPlugin = plugin; return this; }\n    /**\n     * Attaches a sequencer to the engine to drive sceneId, progress, and flags.\n     */\n    addSequencer(sequencer) {\n        this.sequencer = sequencer;\n        return this;\n    }\n    /**\n     * Adds WGSL code that will be prepended to all subsequent pass shaders.\n     * Useful for shared structs and constants.\n     */\n    addCommon(wgsl) { this.commonWGSL += `\\n${wgsl}\\n`; return this; }\n    /**\n     * Loads an image into a global texture accessible by all passes.\n     * @param name Name of the variable in WGSL (e.g., 'var tex: texture_2d<f32>').\n     * @param src URL or image element source.\n     */\n    async addTexture(name, src) {\n        let source;\n        if (typeof src === 'string') {\n            const img = new Image();\n            img.src = src;\n            await img.decode();\n            source = await createImageBitmap(img);\n        }\n        else {\n            source = src;\n        }\n        const texture = this.device.createTexture({\n            size: [source.width, source.height],\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.device.queue.copyExternalImageToTexture({ source }, { texture }, [source.width, source.height]);\n        this.globalTextures.set(name, texture);\n        return this;\n    }\n    /**\n     * configures the global uniform layout.\n     * @param callback Use this to add custom uniforms via layout.add().\n     */\n    setUniforms(callback) {\n        if (callback)\n            callback(this.uniforms);\n        this.uniformBuffer = this.device.createBuffer({\n            size: this.uniforms.byteSize,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n        return this;\n    }\n    /**\n     * Adds a GPGPU compute pass.\n     * @param name Used to reference this pass result in others.\n     * @param wgsl Compute shader code. Use '##WORKGROUP_SIZE' for auto-optimization.\n     * @param size Optional size for a storage buffer (array<f32>).\n     * @param deps List of pass names to read from.\n     */\n    addCompute(name, wgsl, size = 0, deps) {\n        const tex = this.device.createTexture({\n            size: [this.canvas.width, this.canvas.height],\n            format: \"rgba8unorm\",\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING\n        });\n        let buf;\n        if (size > 0)\n            buf = this.device.createBuffer({ size: size * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n        this.passes.push({ name, type: 'compute', shader: wgsl, textures: [tex], storageBuffer: buf, pipelines: [], dependencies: deps });\n        return this;\n    }\n    /**\n     * Adds a compute pass optimized for atomic operations (e.g., histograms, particle counters).\n     */\n    addAtomicCompute(name, wgsl, bufferSize, deps) {\n        const buf = this.device.createBuffer({\n            size: bufferSize * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n        });\n        this.passes.push({ name, type: 'compute', shader: wgsl, storageBuffer: buf, isAtomic: true, pipelines: [], textures: [], dependencies: deps });\n        return this;\n    }\n    /**\n     * Adds a full-screen fragment pass.\n     * This automatically manages two textures for feedback loops (ping-ponging).\n     * @param name Name of the texture variable in WGSL.\n     * @param wgsl Fragment shader code.\n     * @param deps List of pass names to read from.\n     */\n    addPass(name, wgsl, deps) {\n        const createTex = () => this.device.createTexture({\n            size: [this.canvas.width, this.canvas.height],\n            format: \"bgra8unorm\",\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.passes.push({ name, type: 'fragment', shader: wgsl, textures: [createTex(), createTex()], pipelines: [], dependencies: deps });\n        return this;\n    }\n    /**\n     * The final output pass that renders to the canvas.\n     * Calling this triggers the shader compilation process.\n     * @param wgsl Final fragment shader code.\n     * @param deps Pass names to be sampled in the final output.\n     */\n    async main(wgsl, deps) {\n        this.mainPassShader = wgsl;\n        this._mainDeps = deps;\n        this.compile(deps);\n        return this;\n    }\n    compile(mainDeps) {\n        if (!this.uniformBuffer)\n            this.setUniforms();\n        const vertCode = `\r\n            struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\r\n            @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\r\n                var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\r\n                return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\r\n            }\r\n        `;\n        const allStages = [...this.passes, {\n                name: \"main\", type: 'fragment', shader: this.mainPassShader,\n                isMain: true, textures: [], pipelines: [], dependencies: mainDeps\n            }];\n        allStages.forEach((currentPass, stageIdx) => {\n            let b = 0;\n            const layoutEntries = [];\n            let header = `${this.uniforms.wgslStruct}\\n@group(0) @binding(${b}) var<uniform> u: Uniforms;\\n`;\n            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } });\n            this.globalTextures.forEach((_, name) => {\n                header += `@group(0) @binding(${b}) var ${name}: texture_2d<f32>;\\n`;\n                layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n            });\n            header += `@group(0) @binding(${b}) var samp: sampler;\\n`;\n            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, sampler: {} });\n            this.getRelevantPasses(currentPass).forEach((p) => {\n                const isSelf = (currentPass === p);\n                if (p.type === 'compute') {\n                    if (p.textures.length > 0) {\n                        if (isSelf) {\n                            header += `@group(0) @binding(${b}) var outTex: texture_storage_2d<rgba8unorm, write>;\\n`;\n                            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.COMPUTE, storageTexture: { format: 'rgba8unorm', access: 'write-only' } });\n                        }\n                        else {\n                            header += `@group(0) @binding(${b}) var ${p.name}: texture_2d<f32>;\\n`;\n                            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n                        }\n                    }\n                    if (p.storageBuffer) {\n                        const bufName = isSelf ? \"data\" : `${p.name}_data`;\n                        header += `@group(0) @binding(${b}) var<storage, read_write> ${bufName}: ${p.isAtomic ? \"array<atomic<u32>>\" : \"array<f32>\"};\\n`;\n                        layoutEntries.push({ binding: b++, visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT, buffer: { type: 'storage' } });\n                    }\n                }\n                else {\n                    header += `@group(0) @binding(${b}) var ${p.name}: texture_2d<f32>;\\n`;\n                    layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n                    header += `@group(0) @binding(${b}) var prev_${p.name}: texture_2d<f32>;\\n`;\n                    layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n                }\n            });\n            const layout = this.device.createBindGroupLayout({ entries: layoutEntries });\n            this.passLayouts[stageIdx] = layout;\n            const code = (currentPass.type === 'fragment' ? vertCode : \"\") + header + this.commonWGSL +\n                (currentPass.type === 'compute' ? currentPass.shader.replace(\"##WORKGROUP_SIZE\", `@compute ${this.workgroupSize.str}`) : currentPass.shader);\n            const mod = this.device.createShaderModule({ code });\n            const pipeLayout = this.device.createPipelineLayout({ bindGroupLayouts: [layout] });\n            if (currentPass.type === 'compute') {\n                currentPass.pipelines[0] = this.device.createComputePipeline({ layout: pipeLayout, compute: { module: mod, entryPoint: 'main' } });\n            }\n            else {\n                currentPass.pipelines[0] = this.device.createRenderPipeline({\n                    layout: pipeLayout, vertex: { module: mod, entryPoint: 'vs' },\n                    fragment: { module: mod, entryPoint: 'main', targets: [{ format: currentPass.isMain ? navigator.gpu.getPreferredCanvasFormat() : \"bgra8unorm\" }] }\n                });\n                if (currentPass.isMain)\n                    this.mainPipeline = currentPass.pipelines[0];\n            }\n        });\n        this.isCompiled = true;\n    }\n    createBindGroup(stageIdx, writeIdx) {\n        const readIdx = 1 - writeIdx;\n        const isMainPass = stageIdx === this.passes.length;\n        const currentPass = isMainPass\n            ? { name: 'main', isMain: true, dependencies: this._mainDeps }\n            : this.passes[stageIdx];\n        const entries = [];\n        let b = 0;\n        entries.push({ binding: b++, resource: { buffer: this.uniformBuffer } });\n        this.globalTextures.forEach(tex => entries.push({ binding: b++, resource: tex.createView() }));\n        entries.push({ binding: b++, resource: this.globalSampler });\n        this.getRelevantPasses(currentPass).forEach((p) => {\n            const isSelf = (currentPass === p);\n            if (p.type === 'compute') {\n                if (p.textures.length > 0)\n                    entries.push({ binding: b++, resource: p.textures[0].createView() });\n                if (p.storageBuffer)\n                    entries.push({ binding: b++, resource: { buffer: p.storageBuffer } });\n            }\n            else {\n                if (isSelf) {\n                    entries.push({ binding: b++, resource: p.textures[readIdx].createView() });\n                    entries.push({ binding: b++, resource: p.textures[readIdx].createView() });\n                }\n                else {\n                    entries.push({ binding: b++, resource: p.textures[writeIdx].createView() });\n                    entries.push({ binding: b++, resource: p.textures[readIdx].createView() });\n                }\n            }\n        });\n        return this.device.createBindGroup({ layout: this.passLayouts[stageIdx], entries });\n    }\n    /**\n     * Starts the render loop.\n     * @param timer Optional WebGPUTiming plugin for profiling.\n     */\n    run(timer) {\n        const frame = (now) => {\n            if (!this.isCompiled)\n                return;\n            if (this.audioPlugin && !this.startedAudio) {\n                this.audioPlugin.play();\n                this.startedAudio = true;\n            }\n            const time = (this.audioPlugin?.isPlaying) ? this.audioPlugin.getTime() : (now - this.startTime) / 1000;\n            const writeIdx = (this.frameCounter % 2);\n            let sId = 0, sProg = 0, sFlags = 0;\n            if (this.sequencer) {\n                const state = this.sequencer.update(time);\n                sId = state.sceneId;\n                sProg = state.progress;\n                sFlags = state.flags;\n                this.uniforms.updateSequencer(sId, sProg, sFlags);\n            }\n            this.uniforms.update(time);\n            // Buffer.write(this.device, this.uniformBuffer, this.uniforms.float32Array);\n            this.device.queue.writeBuffer(this.uniformBuffer, 0, this.uniforms.float32Array);\n            const enc = this.device.createCommandEncoder();\n            this.passes.forEach((p, i) => {\n                if (p.isAtomic && p.storageBuffer)\n                    enc.clearBuffer(p.storageBuffer);\n                const bg = this.createBindGroup(i, writeIdx);\n                if (p.type === 'compute') {\n                    const cp = enc.beginComputePass();\n                    cp.setPipeline(p.pipelines[0]);\n                    cp.setBindGroup(0, bg);\n                    cp.dispatchWorkgroups(Math.ceil(this.canvas.width / this.workgroupSize.x), Math.ceil(this.canvas.height / this.workgroupSize.y), 1);\n                    cp.end();\n                }\n                else {\n                    const rp = enc.beginRenderPass({\n                        colorAttachments: [{ view: p.textures[writeIdx].createView(), loadOp: \"clear\", storeOp: \"store\", clearValue: [0, 0, 0, 1] }]\n                    });\n                    rp.setPipeline(p.pipelines[0]);\n                    rp.setBindGroup(0, bg);\n                    rp.draw(3);\n                    rp.end();\n                }\n            });\n            const mainBG = this.createBindGroup(this.passes.length, writeIdx);\n            const mp = enc.beginRenderPass({\n                colorAttachments: [{ view: this.context.getCurrentTexture().createView(), loadOp: \"clear\", storeOp: \"store\", clearValue: [0, 0, 0, 1] }]\n            });\n            mp.setPipeline(this.mainPipeline);\n            mp.setBindGroup(0, mainBG);\n            mp.draw(3);\n            mp.end();\n            this.device.queue.submit([enc.finish()]);\n            this.frameCounter++;\n            requestAnimationFrame(frame);\n        };\n        requestAnimationFrame(frame);\n        return this;\n    }\n}\nexports.TinyShade = TinyShade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNHQUFzRztBQUNuSixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUNBQXFDLGtIQUFrSDtBQUN2SixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlueXNoYWRlLy4vc3JjL1RpbnlTaGFkZS50cz8yOTllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UaW55U2hhZGUgPSB2b2lkIDA7XG5jb25zdCBVbmlmb3JtTGF5b3V0XzEgPSByZXF1aXJlKFwiLi9Vbmlmb3JtTGF5b3V0XCIpO1xuLyoqXG4gKiBVdGlsaXR5IGZvciB3cml0aW5nIGRhdGEgdG8gR1BVIEJ1ZmZlcnMuXG4gKi9cbmNvbnN0IEJ1ZmZlciA9IHtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gQXJyYXlCdWZmZXJWaWV3IHRvIGEgR1BVQnVmZmVyLlxuICAgICAqIEBwYXJhbSBkZXZpY2UgVGhlIGFjdGl2ZSBHUFVEZXZpY2UuXG4gICAgICogQHBhcmFtIGJ1ZmZlciBUaGUgdGFyZ2V0IEdQVUJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IEJ5dGUgb2Zmc2V0IGluIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgd3JpdGUoZGV2aWNlLCBidWZmZXIsIGRhdGEsIG9mZnNldCA9IDApIHtcbiAgICAgICAgZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxhcmdlc3QgcG93ZXIgb2YgdHdvIGxlc3MgdGhhbiBvciBlcXVhbCB0byBuLlxuICogVXNlZnVsIGZvciBvcHRpbWl6aW5nIHdvcmtncm91cCBzaXplcy5cbiAqL1xuY29uc3QgbGFyZ2VzdFBvd2VyT2YyTGVzc1RoYW4gPSAobikgPT4ge1xuICAgIGxldCBwb3dlciA9IDE7XG4gICAgd2hpbGUgKHBvd2VyICogMiA8PSBuKVxuICAgICAgICBwb3dlciAqPSAyO1xuICAgIHJldHVybiBwb3dlcjtcbn07XG4vKipcbiAqIERldGVybWluZXMgb3B0aW1hbCB3b3JrZ3JvdXAgc2l6ZXMgYmFzZWQgb24gaGFyZHdhcmUgbGltaXRzLlxuICovXG5jb25zdCBnZXRXb3JrZ3JvdXBTaXplID0gKGxpbWl0cykgPT4ge1xuICAgIGNvbnN0IHggPSBNYXRoLm1pbigxNiwgbGFyZ2VzdFBvd2VyT2YyTGVzc1RoYW4obGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCkpO1xuICAgIGNvbnN0IHkgPSBNYXRoLm1pbigxNiwgbGFyZ2VzdFBvd2VyT2YyTGVzc1RoYW4obGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSkpO1xuICAgIHJldHVybiB7IHgsIHksIHo6IDEsIHN0cjogYEB3b3JrZ3JvdXBfc2l6ZSgke3h9LCAke3l9LCAxKWAgfTtcbn07XG4vKipcbiAqIFRpbnlTaGFkZTogQSBtaW5pbWFsLCBoaWdoLXBlcmZvcm1hbmNlIFdlYkdQVSBmcmFtZXdvcmsgZm9yXG4gKiBtdWx0aS1wYXNzIGZyYWdtZW50IGFuZCBjb21wdXRlIHNoYWRlcnMuXG4gKi9cbmNsYXNzIFRpbnlTaGFkZSB7XG4gICAgZGV2aWNlO1xuICAgIGNvbnRleHQ7XG4gICAgY2FudmFzO1xuICAgIHVuaWZvcm1zO1xuICAgIHVuaWZvcm1CdWZmZXI7XG4gICAgYXVkaW9QbHVnaW47XG4gICAgc3RhcnRUaW1lID0gMDtcbiAgICBmcmFtZUNvdW50ZXIgPSAwO1xuICAgIHNlcXVlbmNlcjtcbiAgICBnbG9iYWxUZXh0dXJlcyA9IG5ldyBNYXAoKTtcbiAgICBjb21tb25XR1NMID0gXCJcIjtcbiAgICBwYXNzZXMgPSBbXTtcbiAgICBwYXNzTGF5b3V0cyA9IFtdO1xuICAgIGJnQ2FjaGUgPSBbXTtcbiAgICBtYWluUGFzc1NoYWRlciA9IFwiXCI7XG4gICAgbWFpblBpcGVsaW5lO1xuICAgIGlzQ29tcGlsZWQgPSBmYWxzZTtcbiAgICBzdGFydGVkQXVkaW8gPSBmYWxzZTtcbiAgICBfbWFpbkRlcHMgPSB1bmRlZmluZWQ7XG4gICAgd29ya2dyb3VwU2l6ZSA9IHsgeDogOCwgeTogOCwgejogMSwgc3RyOiBcIkB3b3JrZ3JvdXBfc2l6ZSg4LCA4LCAxKVwiIH07XG4gICAgZ2xvYmFsU2FtcGxlcjtcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSBuZXcgVW5pZm9ybUxheW91dF8xLlVuaWZvcm1MYXlvdXQoW3RoaXMuY2FudmFzLndpZHRoICogZHByLCB0aGlzLmNhbnZhcy5oZWlnaHQgKiBkcHIsIGRwcl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgV2ViR1BVIGNvbnRleHQgYW5kIGNyZWF0ZXMgYSBUaW55U2hhZGUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIGNhbnZhc0lkIFRoZSBJRCBvZiB0aGUgSFRNTCBjYW52YXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGNhbnZhc0lkKSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKTtcbiAgICAgICAgY29uc3QgdHMgPSBuZXcgVGlueVNoYWRlKGNhbnZhcyk7XG4gICAgICAgIGF3YWl0IHRzLmluaXRXZWJHUFUoKTtcbiAgICAgICAgcmV0dXJuIHRzO1xuICAgIH1cbiAgICBhc3luYyBpbml0V2ViR1BVKCkge1xuICAgICAgICBjb25zdCBhZGFwdGVyID0gYXdhaXQgbmF2aWdhdG9yLmdwdT8ucmVxdWVzdEFkYXB0ZXIoKTtcbiAgICAgICAgaWYgKCFhZGFwdGVyKVxuICAgICAgICAgICAgdGhyb3cgXCJXZWJHUFUgbm90IHN1cHBvcnRlZFwiO1xuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgICAgICBpZiAoYWRhcHRlci5mZWF0dXJlcy5oYXMoJ2JncmE4dW5vcm0tc3RvcmFnZScpKVxuICAgICAgICAgICAgZmVhdHVyZXMucHVzaCgnYmdyYTh1bm9ybS1zdG9yYWdlJyk7XG4gICAgICAgIGlmIChhZGFwdGVyLmZlYXR1cmVzLmhhcygndGltZXN0YW1wLXF1ZXJ5JykpXG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKCd0aW1lc3RhbXAtcXVlcnknKTtcbiAgICAgICAgdGhpcy5kZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2UoeyByZXF1aXJlZEZlYXR1cmVzOiBmZWF0dXJlcyB9KTtcbiAgICAgICAgdGhpcy5nbG9iYWxTYW1wbGVyID0gdGhpcy5kZXZpY2UuY3JlYXRlU2FtcGxlcih7IG1hZ0ZpbHRlcjogJ2xpbmVhcicsIG1pbkZpbHRlcjogJ2xpbmVhcicgfSk7XG4gICAgICAgIHRoaXMud29ya2dyb3VwU2l6ZSA9IGdldFdvcmtncm91cFNpemUoYWRhcHRlci5saW1pdHMpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ3B1XCIpO1xuICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlndXJlKHtcbiAgICAgICAgICAgIGRldmljZTogdGhpcy5kZXZpY2UsXG4gICAgICAgICAgICBmb3JtYXQ6IG5hdmlnYXRvci5ncHUuZ2V0UHJlZmVycmVkQ2FudmFzRm9ybWF0KCksXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICAgIGdldFJlbGV2YW50UGFzc2VzKGN1cnJlbnRQYXNzKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBjdXJyZW50UGFzcy5kZXBlbmRlbmNpZXNcbiAgICAgICAgICAgID8gdGhpcy5wYXNzZXMuZmlsdGVyKHAgPT4gY3VycmVudFBhc3MuZGVwZW5kZW5jaWVzLmluY2x1ZGVzKHAubmFtZSkpXG4gICAgICAgICAgICA6IHRoaXMucGFzc2VzO1xuICAgICAgICBjb25zdCByZXN1bHRTZXQgPSBuZXcgU2V0KGJhc2UpO1xuICAgICAgICBpZiAoIWN1cnJlbnRQYXNzLmlzTWFpbilcbiAgICAgICAgICAgIHJlc3VsdFNldC5hZGQoY3VycmVudFBhc3MpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHRTZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyBhbiBhdWRpbyBwbHVnaW4gdG8gc3luY2hyb25pemUgdW5pZm9ybXMgd2l0aCBhdWRpbyBkYXRhLlxuICAgICAqL1xuICAgIGFkZEF1ZGlvKHBsdWdpbikgeyB0aGlzLmF1ZGlvUGx1Z2luID0gcGx1Z2luOyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgc2VxdWVuY2VyIHRvIHRoZSBlbmdpbmUgdG8gZHJpdmUgc2NlbmVJZCwgcHJvZ3Jlc3MsIGFuZCBmbGFncy5cbiAgICAgKi9cbiAgICBhZGRTZXF1ZW5jZXIoc2VxdWVuY2VyKSB7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VyID0gc2VxdWVuY2VyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBXR1NMIGNvZGUgdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBhbGwgc3Vic2VxdWVudCBwYXNzIHNoYWRlcnMuXG4gICAgICogVXNlZnVsIGZvciBzaGFyZWQgc3RydWN0cyBhbmQgY29uc3RhbnRzLlxuICAgICAqL1xuICAgIGFkZENvbW1vbih3Z3NsKSB7IHRoaXMuY29tbW9uV0dTTCArPSBgXFxuJHt3Z3NsfVxcbmA7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gaW1hZ2UgaW50byBhIGdsb2JhbCB0ZXh0dXJlIGFjY2Vzc2libGUgYnkgYWxsIHBhc3Nlcy5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZSBpbiBXR1NMIChlLmcuLCAndmFyIHRleDogdGV4dHVyZV8yZDxmMzI+JykuXG4gICAgICogQHBhcmFtIHNyYyBVUkwgb3IgaW1hZ2UgZWxlbWVudCBzb3VyY2UuXG4gICAgICovXG4gICAgYXN5bmMgYWRkVGV4dHVyZShuYW1lLCBzcmMpIHtcbiAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgICAgICAgICBhd2FpdCBpbWcuZGVjb2RlKCk7XG4gICAgICAgICAgICBzb3VyY2UgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc291cmNlID0gc3JjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmRldmljZS5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgICAgIHNpemU6IFtzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHRdLFxuICAgICAgICAgICAgZm9ybWF0OiAncmdiYTh1bm9ybScsXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCB8IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZXZpY2UucXVldWUuY29weUV4dGVybmFsSW1hZ2VUb1RleHR1cmUoeyBzb3VyY2UgfSwgeyB0ZXh0dXJlIH0sIFtzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHRdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxUZXh0dXJlcy5zZXQobmFtZSwgdGV4dHVyZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25maWd1cmVzIHRoZSBnbG9iYWwgdW5pZm9ybSBsYXlvdXQuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFVzZSB0aGlzIHRvIGFkZCBjdXN0b20gdW5pZm9ybXMgdmlhIGxheW91dC5hZGQoKS5cbiAgICAgKi9cbiAgICBzZXRVbmlmb3JtcyhjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLnVuaWZvcm1zKTtcbiAgICAgICAgdGhpcy51bmlmb3JtQnVmZmVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIHNpemU6IHRoaXMudW5pZm9ybXMuYnl0ZVNpemUsXG4gICAgICAgICAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIEdQR1BVIGNvbXB1dGUgcGFzcy5cbiAgICAgKiBAcGFyYW0gbmFtZSBVc2VkIHRvIHJlZmVyZW5jZSB0aGlzIHBhc3MgcmVzdWx0IGluIG90aGVycy5cbiAgICAgKiBAcGFyYW0gd2dzbCBDb21wdXRlIHNoYWRlciBjb2RlLiBVc2UgJyMjV09SS0dST1VQX1NJWkUnIGZvciBhdXRvLW9wdGltaXphdGlvbi5cbiAgICAgKiBAcGFyYW0gc2l6ZSBPcHRpb25hbCBzaXplIGZvciBhIHN0b3JhZ2UgYnVmZmVyIChhcnJheTxmMzI+KS5cbiAgICAgKiBAcGFyYW0gZGVwcyBMaXN0IG9mIHBhc3MgbmFtZXMgdG8gcmVhZCBmcm9tLlxuICAgICAqL1xuICAgIGFkZENvbXB1dGUobmFtZSwgd2dzbCwgc2l6ZSA9IDAsIGRlcHMpIHtcbiAgICAgICAgY29uc3QgdGV4ID0gdGhpcy5kZXZpY2UuY3JlYXRlVGV4dHVyZSh7XG4gICAgICAgICAgICBzaXplOiBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF0sXG4gICAgICAgICAgICBmb3JtYXQ6IFwicmdiYTh1bm9ybVwiLFxuICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgYnVmO1xuICAgICAgICBpZiAoc2l6ZSA+IDApXG4gICAgICAgICAgICBidWYgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoeyBzaXplOiBzaXplICogNCwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB9KTtcbiAgICAgICAgdGhpcy5wYXNzZXMucHVzaCh7IG5hbWUsIHR5cGU6ICdjb21wdXRlJywgc2hhZGVyOiB3Z3NsLCB0ZXh0dXJlczogW3RleF0sIHN0b3JhZ2VCdWZmZXI6IGJ1ZiwgcGlwZWxpbmVzOiBbXSwgZGVwZW5kZW5jaWVzOiBkZXBzIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbXB1dGUgcGFzcyBvcHRpbWl6ZWQgZm9yIGF0b21pYyBvcGVyYXRpb25zIChlLmcuLCBoaXN0b2dyYW1zLCBwYXJ0aWNsZSBjb3VudGVycykuXG4gICAgICovXG4gICAgYWRkQXRvbWljQ29tcHV0ZShuYW1lLCB3Z3NsLCBidWZmZXJTaXplLCBkZXBzKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgICBzaXplOiBidWZmZXJTaXplICogNCxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXNzZXMucHVzaCh7IG5hbWUsIHR5cGU6ICdjb21wdXRlJywgc2hhZGVyOiB3Z3NsLCBzdG9yYWdlQnVmZmVyOiBidWYsIGlzQXRvbWljOiB0cnVlLCBwaXBlbGluZXM6IFtdLCB0ZXh0dXJlczogW10sIGRlcGVuZGVuY2llczogZGVwcyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmdWxsLXNjcmVlbiBmcmFnbWVudCBwYXNzLlxuICAgICAqIFRoaXMgYXV0b21hdGljYWxseSBtYW5hZ2VzIHR3byB0ZXh0dXJlcyBmb3IgZmVlZGJhY2sgbG9vcHMgKHBpbmctcG9uZ2luZykuXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdGV4dHVyZSB2YXJpYWJsZSBpbiBXR1NMLlxuICAgICAqIEBwYXJhbSB3Z3NsIEZyYWdtZW50IHNoYWRlciBjb2RlLlxuICAgICAqIEBwYXJhbSBkZXBzIExpc3Qgb2YgcGFzcyBuYW1lcyB0byByZWFkIGZyb20uXG4gICAgICovXG4gICAgYWRkUGFzcyhuYW1lLCB3Z3NsLCBkZXBzKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZVRleCA9ICgpID0+IHRoaXMuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgICAgICAgc2l6ZTogW3RoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHRdLFxuICAgICAgICAgICAgZm9ybWF0OiBcImJncmE4dW5vcm1cIixcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhc3Nlcy5wdXNoKHsgbmFtZSwgdHlwZTogJ2ZyYWdtZW50Jywgc2hhZGVyOiB3Z3NsLCB0ZXh0dXJlczogW2NyZWF0ZVRleCgpLCBjcmVhdGVUZXgoKV0sIHBpcGVsaW5lczogW10sIGRlcGVuZGVuY2llczogZGVwcyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaW5hbCBvdXRwdXQgcGFzcyB0aGF0IHJlbmRlcnMgdG8gdGhlIGNhbnZhcy5cbiAgICAgKiBDYWxsaW5nIHRoaXMgdHJpZ2dlcnMgdGhlIHNoYWRlciBjb21waWxhdGlvbiBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB3Z3NsIEZpbmFsIGZyYWdtZW50IHNoYWRlciBjb2RlLlxuICAgICAqIEBwYXJhbSBkZXBzIFBhc3MgbmFtZXMgdG8gYmUgc2FtcGxlZCBpbiB0aGUgZmluYWwgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIG1haW4od2dzbCwgZGVwcykge1xuICAgICAgICB0aGlzLm1haW5QYXNzU2hhZGVyID0gd2dzbDtcbiAgICAgICAgdGhpcy5fbWFpbkRlcHMgPSBkZXBzO1xuICAgICAgICB0aGlzLmNvbXBpbGUoZGVwcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb21waWxlKG1haW5EZXBzKSB7XG4gICAgICAgIGlmICghdGhpcy51bmlmb3JtQnVmZmVyKVxuICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtcygpO1xuICAgICAgICBjb25zdCB2ZXJ0Q29kZSA9IGBcclxuICAgICAgICAgICAgc3RydWN0IFZTT3V0IHsgQGJ1aWx0aW4ocG9zaXRpb24pIHBvczogdmVjNGYsIEBsb2NhdGlvbigwKSB1djogdmVjMmYgfTtcclxuICAgICAgICAgICAgQHZlcnRleCBmbiB2cyhAYnVpbHRpbih2ZXJ0ZXhfaW5kZXgpIGk6IHUzMikgLT4gVlNPdXQge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBhcnJheTx2ZWMyZiwgMz4odmVjMmYoLTEuMCwgLTEuMCksIHZlYzJmKDMuMCwgLTEuMCksIHZlYzJmKC0xLjAsIDMuMCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZTT3V0KHZlYzRmKHBbaV0sIDAuMCwgMS4wKSwgdmVjMmYocFtpXS54ICogMC41ICsgMC41LCAwLjUgLSBwW2ldLnkgKiAwLjUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGA7XG4gICAgICAgIGNvbnN0IGFsbFN0YWdlcyA9IFsuLi50aGlzLnBhc3Nlcywge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwibWFpblwiLCB0eXBlOiAnZnJhZ21lbnQnLCBzaGFkZXI6IHRoaXMubWFpblBhc3NTaGFkZXIsXG4gICAgICAgICAgICAgICAgaXNNYWluOiB0cnVlLCB0ZXh0dXJlczogW10sIHBpcGVsaW5lczogW10sIGRlcGVuZGVuY2llczogbWFpbkRlcHNcbiAgICAgICAgICAgIH1dO1xuICAgICAgICBhbGxTdGFnZXMuZm9yRWFjaCgoY3VycmVudFBhc3MsIHN0YWdlSWR4KSA9PiB7XG4gICAgICAgICAgICBsZXQgYiA9IDA7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXRFbnRyaWVzID0gW107XG4gICAgICAgICAgICBsZXQgaGVhZGVyID0gYCR7dGhpcy51bmlmb3Jtcy53Z3NsU3RydWN0fVxcbkBncm91cCgwKSBAYmluZGluZygke2J9KSB2YXI8dW5pZm9ybT4gdTogVW5pZm9ybXM7XFxuYDtcbiAgICAgICAgICAgIGxheW91dEVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuVkVSVEVYIHwgR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQgfCBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLCBidWZmZXI6IHsgdHlwZTogJ3VuaWZvcm0nIH0gfSk7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbFRleHR1cmVzLmZvckVhY2goKF8sIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBoZWFkZXIgKz0gYEBncm91cCgwKSBAYmluZGluZygke2J9KSB2YXIgJHtuYW1lfTogdGV4dHVyZV8yZDxmMzI+O1xcbmA7XG4gICAgICAgICAgICAgICAgbGF5b3V0RW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCB8IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUsIHRleHR1cmU6IHt9IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoZWFkZXIgKz0gYEBncm91cCgwKSBAYmluZGluZygke2J9KSB2YXIgc2FtcDogc2FtcGxlcjtcXG5gO1xuICAgICAgICAgICAgbGF5b3V0RW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCB8IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUsIHNhbXBsZXI6IHt9IH0pO1xuICAgICAgICAgICAgdGhpcy5nZXRSZWxldmFudFBhc3NlcyhjdXJyZW50UGFzcykuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2VsZiA9IChjdXJyZW50UGFzcyA9PT0gcCk7XG4gICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gJ2NvbXB1dGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnRleHR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgKz0gYEBncm91cCgwKSBAYmluZGluZygke2J9KSB2YXIgb3V0VGV4OiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8cmdiYTh1bm9ybSwgd3JpdGU+O1xcbmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLCBzdG9yYWdlVGV4dHVyZTogeyBmb3JtYXQ6ICdyZ2JhOHVub3JtJywgYWNjZXNzOiAnd3JpdGUtb25seScgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciArPSBgQGdyb3VwKDApIEBiaW5kaW5nKCR7Yn0pIHZhciAke3AubmFtZX06IHRleHR1cmVfMmQ8ZjMyPjtcXG5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQgfCBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLCB0ZXh0dXJlOiB7fSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocC5zdG9yYWdlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZOYW1lID0gaXNTZWxmID8gXCJkYXRhXCIgOiBgJHtwLm5hbWV9X2RhdGFgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyICs9IGBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtifSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+ICR7YnVmTmFtZX06ICR7cC5pc0F0b21pYyA/IFwiYXJyYXk8YXRvbWljPHUzMj4+XCIgOiBcImFycmF5PGYzMj5cIn07XFxuYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSB8IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULCBidWZmZXI6IHsgdHlwZTogJ3N0b3JhZ2UnIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciArPSBgQGdyb3VwKDApIEBiaW5kaW5nKCR7Yn0pIHZhciAke3AubmFtZX06IHRleHR1cmVfMmQ8ZjMyPjtcXG5gO1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5UIHwgR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSwgdGV4dHVyZToge30gfSk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciArPSBgQGdyb3VwKDApIEBiaW5kaW5nKCR7Yn0pIHZhciBwcmV2XyR7cC5uYW1lfTogdGV4dHVyZV8yZDxmMzI+O1xcbmA7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dEVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQgfCBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLCB0ZXh0dXJlOiB7fSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7IGVudHJpZXM6IGxheW91dEVudHJpZXMgfSk7XG4gICAgICAgICAgICB0aGlzLnBhc3NMYXlvdXRzW3N0YWdlSWR4XSA9IGxheW91dDtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAoY3VycmVudFBhc3MudHlwZSA9PT0gJ2ZyYWdtZW50JyA/IHZlcnRDb2RlIDogXCJcIikgKyBoZWFkZXIgKyB0aGlzLmNvbW1vbldHU0wgK1xuICAgICAgICAgICAgICAgIChjdXJyZW50UGFzcy50eXBlID09PSAnY29tcHV0ZScgPyBjdXJyZW50UGFzcy5zaGFkZXIucmVwbGFjZShcIiMjV09SS0dST1VQX1NJWkVcIiwgYEBjb21wdXRlICR7dGhpcy53b3JrZ3JvdXBTaXplLnN0cn1gKSA6IGN1cnJlbnRQYXNzLnNoYWRlcik7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSB0aGlzLmRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoeyBjb2RlIH0pO1xuICAgICAgICAgICAgY29uc3QgcGlwZUxheW91dCA9IHRoaXMuZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHsgYmluZEdyb3VwTGF5b3V0czogW2xheW91dF0gfSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhc3MudHlwZSA9PT0gJ2NvbXB1dGUnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBhc3MucGlwZWxpbmVzWzBdID0gdGhpcy5kZXZpY2UuY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHsgbGF5b3V0OiBwaXBlTGF5b3V0LCBjb21wdXRlOiB7IG1vZHVsZTogbW9kLCBlbnRyeVBvaW50OiAnbWFpbicgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXNzLnBpcGVsaW5lc1swXSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiBwaXBlTGF5b3V0LCB2ZXJ0ZXg6IHsgbW9kdWxlOiBtb2QsIGVudHJ5UG9pbnQ6ICd2cycgfSxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQ6IHsgbW9kdWxlOiBtb2QsIGVudHJ5UG9pbnQ6ICdtYWluJywgdGFyZ2V0czogW3sgZm9ybWF0OiBjdXJyZW50UGFzcy5pc01haW4gPyBuYXZpZ2F0b3IuZ3B1LmdldFByZWZlcnJlZENhbnZhc0Zvcm1hdCgpIDogXCJiZ3JhOHVub3JtXCIgfV0gfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFzcy5pc01haW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFpblBpcGVsaW5lID0gY3VycmVudFBhc3MucGlwZWxpbmVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pc0NvbXBpbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgY3JlYXRlQmluZEdyb3VwKHN0YWdlSWR4LCB3cml0ZUlkeCkge1xuICAgICAgICBjb25zdCByZWFkSWR4ID0gMSAtIHdyaXRlSWR4O1xuICAgICAgICBjb25zdCBpc01haW5QYXNzID0gc3RhZ2VJZHggPT09IHRoaXMucGFzc2VzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY3VycmVudFBhc3MgPSBpc01haW5QYXNzXG4gICAgICAgICAgICA/IHsgbmFtZTogJ21haW4nLCBpc01haW46IHRydWUsIGRlcGVuZGVuY2llczogdGhpcy5fbWFpbkRlcHMgfVxuICAgICAgICAgICAgOiB0aGlzLnBhc3Nlc1tzdGFnZUlkeF07XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgICAgbGV0IGIgPSAwO1xuICAgICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHJlc291cmNlOiB7IGJ1ZmZlcjogdGhpcy51bmlmb3JtQnVmZmVyIH0gfSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsVGV4dHVyZXMuZm9yRWFjaCh0ZXggPT4gZW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCByZXNvdXJjZTogdGV4LmNyZWF0ZVZpZXcoKSB9KSk7XG4gICAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgcmVzb3VyY2U6IHRoaXMuZ2xvYmFsU2FtcGxlciB9KTtcbiAgICAgICAgdGhpcy5nZXRSZWxldmFudFBhc3NlcyhjdXJyZW50UGFzcykuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNTZWxmID0gKGN1cnJlbnRQYXNzID09PSBwKTtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09ICdjb21wdXRlJykge1xuICAgICAgICAgICAgICAgIGlmIChwLnRleHR1cmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgcmVzb3VyY2U6IHAudGV4dHVyZXNbMF0uY3JlYXRlVmlldygpIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwLnN0b3JhZ2VCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgcmVzb3VyY2U6IHsgYnVmZmVyOiBwLnN0b3JhZ2VCdWZmZXIgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1NlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCByZXNvdXJjZTogcC50ZXh0dXJlc1tyZWFkSWR4XS5jcmVhdGVWaWV3KCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgcmVzb3VyY2U6IHAudGV4dHVyZXNbcmVhZElkeF0uY3JlYXRlVmlldygpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCByZXNvdXJjZTogcC50ZXh0dXJlc1t3cml0ZUlkeF0uY3JlYXRlVmlldygpIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHJlc291cmNlOiBwLnRleHR1cmVzW3JlYWRJZHhdLmNyZWF0ZVZpZXcoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwKHsgbGF5b3V0OiB0aGlzLnBhc3NMYXlvdXRzW3N0YWdlSWR4XSwgZW50cmllcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAcGFyYW0gdGltZXIgT3B0aW9uYWwgV2ViR1BVVGltaW5nIHBsdWdpbiBmb3IgcHJvZmlsaW5nLlxuICAgICAqL1xuICAgIHJ1bih0aW1lcikge1xuICAgICAgICBjb25zdCBmcmFtZSA9IChub3cpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0NvbXBpbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvUGx1Z2luICYmICF0aGlzLnN0YXJ0ZWRBdWRpbykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9QbHVnaW4ucGxheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRlZEF1ZGlvID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSAodGhpcy5hdWRpb1BsdWdpbj8uaXNQbGF5aW5nKSA/IHRoaXMuYXVkaW9QbHVnaW4uZ2V0VGltZSgpIDogKG5vdyAtIHRoaXMuc3RhcnRUaW1lKSAvIDEwMDA7XG4gICAgICAgICAgICBjb25zdCB3cml0ZUlkeCA9ICh0aGlzLmZyYW1lQ291bnRlciAlIDIpO1xuICAgICAgICAgICAgbGV0IHNJZCA9IDAsIHNQcm9nID0gMCwgc0ZsYWdzID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcXVlbmNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zZXF1ZW5jZXIudXBkYXRlKHRpbWUpO1xuICAgICAgICAgICAgICAgIHNJZCA9IHN0YXRlLnNjZW5lSWQ7XG4gICAgICAgICAgICAgICAgc1Byb2cgPSBzdGF0ZS5wcm9ncmVzcztcbiAgICAgICAgICAgICAgICBzRmxhZ3MgPSBzdGF0ZS5mbGFncztcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVwZGF0ZVNlcXVlbmNlcihzSWQsIHNQcm9nLCBzRmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy51cGRhdGUodGltZSk7XG4gICAgICAgICAgICAvLyBCdWZmZXIud3JpdGUodGhpcy5kZXZpY2UsIHRoaXMudW5pZm9ybUJ1ZmZlciwgdGhpcy51bmlmb3Jtcy5mbG9hdDMyQXJyYXkpO1xuICAgICAgICAgICAgdGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIodGhpcy51bmlmb3JtQnVmZmVyLCAwLCB0aGlzLnVuaWZvcm1zLmZsb2F0MzJBcnJheSk7XG4gICAgICAgICAgICBjb25zdCBlbmMgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgICAgICAgICAgdGhpcy5wYXNzZXMuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwLmlzQXRvbWljICYmIHAuc3RvcmFnZUJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgZW5jLmNsZWFyQnVmZmVyKHAuc3RvcmFnZUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgYmcgPSB0aGlzLmNyZWF0ZUJpbmRHcm91cChpLCB3cml0ZUlkeCk7XG4gICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gJ2NvbXB1dGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNwID0gZW5jLmJlZ2luQ29tcHV0ZVBhc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgY3Auc2V0UGlwZWxpbmUocC5waXBlbGluZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBjcC5zZXRCaW5kR3JvdXAoMCwgYmcpO1xuICAgICAgICAgICAgICAgICAgICBjcC5kaXNwYXRjaFdvcmtncm91cHMoTWF0aC5jZWlsKHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy53b3JrZ3JvdXBTaXplLngpLCBNYXRoLmNlaWwodGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy53b3JrZ3JvdXBTaXplLnkpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY3AuZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBycCA9IGVuYy5iZWdpblJlbmRlclBhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW3sgdmlldzogcC50ZXh0dXJlc1t3cml0ZUlkeF0uY3JlYXRlVmlldygpLCBsb2FkT3A6IFwiY2xlYXJcIiwgc3RvcmVPcDogXCJzdG9yZVwiLCBjbGVhclZhbHVlOiBbMCwgMCwgMCwgMV0gfV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJwLnNldFBpcGVsaW5lKHAucGlwZWxpbmVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcnAuc2V0QmluZEdyb3VwKDAsIGJnKTtcbiAgICAgICAgICAgICAgICAgICAgcnAuZHJhdygzKTtcbiAgICAgICAgICAgICAgICAgICAgcnAuZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBtYWluQkcgPSB0aGlzLmNyZWF0ZUJpbmRHcm91cCh0aGlzLnBhc3Nlcy5sZW5ndGgsIHdyaXRlSWR4KTtcbiAgICAgICAgICAgIGNvbnN0IG1wID0gZW5jLmJlZ2luUmVuZGVyUGFzcyh7XG4gICAgICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW3sgdmlldzogdGhpcy5jb250ZXh0LmdldEN1cnJlbnRUZXh0dXJlKCkuY3JlYXRlVmlldygpLCBsb2FkT3A6IFwiY2xlYXJcIiwgc3RvcmVPcDogXCJzdG9yZVwiLCBjbGVhclZhbHVlOiBbMCwgMCwgMCwgMV0gfV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbXAuc2V0UGlwZWxpbmUodGhpcy5tYWluUGlwZWxpbmUpO1xuICAgICAgICAgICAgbXAuc2V0QmluZEdyb3VwKDAsIG1haW5CRyk7XG4gICAgICAgICAgICBtcC5kcmF3KDMpO1xuICAgICAgICAgICAgbXAuZW5kKCk7XG4gICAgICAgICAgICB0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW2VuYy5maW5pc2goKV0pO1xuICAgICAgICAgICAgdGhpcy5mcmFtZUNvdW50ZXIrKztcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuVGlueVNoYWRlID0gVGlueVNoYWRlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/TinyShade.ts\n\n}");

/***/ },

/***/ "./src/UniformLayout.ts"
/*!******************************!*\
  !*** ./src/UniformLayout.ts ***!
  \******************************/
(__unused_webpack_module, exports) {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UniformLayout = void 0;\n/**\n * Manages memory-aligned WebGPU Uniform Buffers.\n * Handles the strict 16-byte alignment and O(1) update performance.\n */\nclass UniformLayout {\n    entries = [];\n    buffer;\n    floatView;\n    // Fast-access maps to avoid string searching in the render loop\n    setters = new Map();\n    dynamicUpdates = [];\n    isBuilt = false;\n    _currentOffset = 0;\n    frameCount = 0;\n    currentTime = 0;\n    constructor(initialResolution) {\n        // Register standard demoscene globals\n        this.addUniform({ name: \"resolution\", value: initialResolution });\n        this.addUniform({ name: \"time\", value: 0 });\n        this.addUniform({ name: \"sceneId\", value: 0 });\n        this.addUniform({ name: \"progress\", value: 0 });\n        this.addUniform({ name: \"flags\", value: 0 });\n    }\n    /**\n     * Step 1: Register the structure of your uniforms.\n     * This handles the complex WGSL alignment logic.\n     */\n    addUniform({ name, value }) {\n        if (this.isBuilt)\n            throw new Error(\"Cannot add uniforms after build()\");\n        const { type, size, align } = this.inferType(value);\n        // WGSL Alignment Rule: The offset must be a multiple of the alignment\n        this._currentOffset = Math.ceil(this._currentOffset / align) * align;\n        this.entries.push({\n            name,\n            type,\n            size,\n            align,\n            offset: this._currentOffset,\n            value\n        });\n        this._currentOffset += size;\n        return this;\n    }\n    /**\n     * Step 2: Bake the memory buffer and create O(1) setters.\n     */\n    build() {\n        if (this.isBuilt)\n            return;\n        // Final buffer size must be a multiple of 16 bytes\n        const totalSize = Math.ceil(this._currentOffset / 16) * 16;\n        this.buffer = new ArrayBuffer(totalSize);\n        this.floatView = new Float32Array(this.buffer);\n        for (const e of this.entries) {\n            const idx = e.offset / 4;\n            // Create a specialized closure for setting this specific memory slot\n            const setter = (val) => {\n                const resolved = typeof val === \"function\" ? val(this.currentTime, this.frameCount) : val;\n                if (typeof resolved === \"number\") {\n                    this.floatView[idx] = resolved;\n                }\n                else {\n                    // Optimized set for vec2, vec3, vec4\n                    this.floatView.set(resolved, idx);\n                }\n            };\n            this.setters.set(e.name, setter);\n            // If it's a dynamic function, queue it for the update loop\n            if (typeof e.value === \"function\") {\n                this.dynamicUpdates.push(() => setter(e.value));\n            }\n            else {\n                setter(e.value); // Initial value\n            }\n        }\n        this.isBuilt = true;\n    }\n    /**\n     * Updates globals and runs all dynamic uniform functions.\n     */\n    update(time) {\n        if (!this.isBuilt)\n            this.build();\n        this.currentTime = time;\n        this.frameCount++;\n        // This actually writes the new time into the floatView/ArrayBuffer\n        this.setters.get(\"time\")?.(time);\n        for (const update of this.dynamicUpdates) {\n            update();\n        }\n    }\n    /**\n     * Sequencer-specific update for scene management.\n     */\n    updateSequencer(sceneId, progress, flags) {\n        if (!this.isBuilt)\n            this.build();\n        // Get the pre-compiled setter functions and execute them\n        const setId = this.setters.get(\"sceneId\");\n        const setProg = this.setters.get(\"progress\");\n        const setFlags = this.setters.get(\"flags\");\n        if (setId)\n            setId(sceneId);\n        if (setProg)\n            setProg(progress);\n        if (setFlags)\n            setFlags(flags);\n        if (this.entries) {\n            //console.log(\"Buffer SceneId Index:\", this.entries.find(e => e.name === 'sceneId')?.offset / 4);\n            console.log(\"Value in Buffer:\", this.floatView[this.entries.find(e => e.name === 'sceneId').offset / 4]);\n        }\n    }\n    // --- Getters ---\n    get byteSize() {\n        if (!this.isBuilt)\n            this.build();\n        return this.buffer.byteLength;\n    }\n    get float32Array() {\n        if (!this.isBuilt)\n            this.build();\n        return this.floatView;\n    }\n    get wgslStruct() {\n        const lines = this.entries.map(e => `    ${e.name}: ${e.type},`);\n        return `struct Uniforms {\\n${lines.join(\"\\n\")}\\n};`;\n    }\n    /**\n     * Resolves WGSL types based on the input data format.\n     */\n    inferType(value) {\n        // If it's a function, run it once with 0 to see what it returns\n        const sample = typeof value === \"function\" ? value(0, 0) : value;\n        if (typeof sample === \"number\") {\n            return { type: \"f32\", size: 4, align: 4 };\n        }\n        if (Array.isArray(sample)) {\n            const len = sample.length;\n            switch (len) {\n                case 2: return { type: \"vec2f\", size: 8, align: 8 };\n                case 3: return { type: \"vec3f\", size: 12, align: 16 }; // Vec3 requires 16-byte alignment\n                case 4: return { type: \"vec4f\", size: 16, align: 16 };\n            }\n        }\n        throw new Error(`Unsupported uniform value type: ${typeof sample}`);\n    }\n}\nexports.UniformLayout = UniformLayout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVW5pZm9ybUxheW91dC50cyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEUsMEJBQTBCLHdCQUF3QjtBQUNsRCwwQkFBMEIsMkJBQTJCO0FBQ3JELDBCQUEwQiw0QkFBNEI7QUFDdEQsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU8sSUFBSSxPQUFPO0FBQ3JFLGlDQUFpQyxJQUFJLGlCQUFpQixJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDLHNDQUFzQztBQUN2RSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW55c2hhZGUvLi9zcmMvVW5pZm9ybUxheW91dC50cz85MTZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Vbmlmb3JtTGF5b3V0ID0gdm9pZCAwO1xuLyoqXG4gKiBNYW5hZ2VzIG1lbW9yeS1hbGlnbmVkIFdlYkdQVSBVbmlmb3JtIEJ1ZmZlcnMuXG4gKiBIYW5kbGVzIHRoZSBzdHJpY3QgMTYtYnl0ZSBhbGlnbm1lbnQgYW5kIE8oMSkgdXBkYXRlIHBlcmZvcm1hbmNlLlxuICovXG5jbGFzcyBVbmlmb3JtTGF5b3V0IHtcbiAgICBlbnRyaWVzID0gW107XG4gICAgYnVmZmVyO1xuICAgIGZsb2F0VmlldztcbiAgICAvLyBGYXN0LWFjY2VzcyBtYXBzIHRvIGF2b2lkIHN0cmluZyBzZWFyY2hpbmcgaW4gdGhlIHJlbmRlciBsb29wXG4gICAgc2V0dGVycyA9IG5ldyBNYXAoKTtcbiAgICBkeW5hbWljVXBkYXRlcyA9IFtdO1xuICAgIGlzQnVpbHQgPSBmYWxzZTtcbiAgICBfY3VycmVudE9mZnNldCA9IDA7XG4gICAgZnJhbWVDb3VudCA9IDA7XG4gICAgY3VycmVudFRpbWUgPSAwO1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxSZXNvbHV0aW9uKSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHN0YW5kYXJkIGRlbW9zY2VuZSBnbG9iYWxzXG4gICAgICAgIHRoaXMuYWRkVW5pZm9ybSh7IG5hbWU6IFwicmVzb2x1dGlvblwiLCB2YWx1ZTogaW5pdGlhbFJlc29sdXRpb24gfSk7XG4gICAgICAgIHRoaXMuYWRkVW5pZm9ybSh7IG5hbWU6IFwidGltZVwiLCB2YWx1ZTogMCB9KTtcbiAgICAgICAgdGhpcy5hZGRVbmlmb3JtKHsgbmFtZTogXCJzY2VuZUlkXCIsIHZhbHVlOiAwIH0pO1xuICAgICAgICB0aGlzLmFkZFVuaWZvcm0oeyBuYW1lOiBcInByb2dyZXNzXCIsIHZhbHVlOiAwIH0pO1xuICAgICAgICB0aGlzLmFkZFVuaWZvcm0oeyBuYW1lOiBcImZsYWdzXCIsIHZhbHVlOiAwIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGVwIDE6IFJlZ2lzdGVyIHRoZSBzdHJ1Y3R1cmUgb2YgeW91ciB1bmlmb3Jtcy5cbiAgICAgKiBUaGlzIGhhbmRsZXMgdGhlIGNvbXBsZXggV0dTTCBhbGlnbm1lbnQgbG9naWMuXG4gICAgICovXG4gICAgYWRkVW5pZm9ybSh7IG5hbWUsIHZhbHVlIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCdWlsdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgdW5pZm9ybXMgYWZ0ZXIgYnVpbGQoKVwiKTtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBzaXplLCBhbGlnbiB9ID0gdGhpcy5pbmZlclR5cGUodmFsdWUpO1xuICAgICAgICAvLyBXR1NMIEFsaWdubWVudCBSdWxlOiBUaGUgb2Zmc2V0IG11c3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgYWxpZ25tZW50XG4gICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSBNYXRoLmNlaWwodGhpcy5fY3VycmVudE9mZnNldCAvIGFsaWduKSAqIGFsaWduO1xuICAgICAgICB0aGlzLmVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBhbGlnbixcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fY3VycmVudE9mZnNldCxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ICs9IHNpemU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGVwIDI6IEJha2UgdGhlIG1lbW9yeSBidWZmZXIgYW5kIGNyZWF0ZSBPKDEpIHNldHRlcnMuXG4gICAgICovXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQnVpbHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIEZpbmFsIGJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNiBieXRlc1xuICAgICAgICBjb25zdCB0b3RhbFNpemUgPSBNYXRoLmNlaWwodGhpcy5fY3VycmVudE9mZnNldCAvIDE2KSAqIDE2O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0b3RhbFNpemUpO1xuICAgICAgICB0aGlzLmZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5idWZmZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5lbnRyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBlLm9mZnNldCAvIDQ7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzcGVjaWFsaXplZCBjbG9zdXJlIGZvciBzZXR0aW5nIHRoaXMgc3BlY2lmaWMgbWVtb3J5IHNsb3RcbiAgICAgICAgICAgIGNvbnN0IHNldHRlciA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiA/IHZhbCh0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmZyYW1lQ291bnQpIDogdmFsO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZWQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbG9hdFZpZXdbaWR4XSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemVkIHNldCBmb3IgdmVjMiwgdmVjMywgdmVjNFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb2F0Vmlldy5zZXQocmVzb2x2ZWQsIGlkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2V0dGVycy5zZXQoZS5uYW1lLCBzZXR0ZXIpO1xuICAgICAgICAgICAgLy8gSWYgaXQncyBhIGR5bmFtaWMgZnVuY3Rpb24sIHF1ZXVlIGl0IGZvciB0aGUgdXBkYXRlIGxvb3BcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZS52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5keW5hbWljVXBkYXRlcy5wdXNoKCgpID0+IHNldHRlcihlLnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXR0ZXIoZS52YWx1ZSk7IC8vIEluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQnVpbHQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGdsb2JhbHMgYW5kIHJ1bnMgYWxsIGR5bmFtaWMgdW5pZm9ybSBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgdXBkYXRlKHRpbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQnVpbHQpXG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLmZyYW1lQ291bnQrKztcbiAgICAgICAgLy8gVGhpcyBhY3R1YWxseSB3cml0ZXMgdGhlIG5ldyB0aW1lIGludG8gdGhlIGZsb2F0Vmlldy9BcnJheUJ1ZmZlclxuICAgICAgICB0aGlzLnNldHRlcnMuZ2V0KFwidGltZVwiKT8uKHRpbWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB0aGlzLmR5bmFtaWNVcGRhdGVzKSB7XG4gICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXF1ZW5jZXItc3BlY2lmaWMgdXBkYXRlIGZvciBzY2VuZSBtYW5hZ2VtZW50LlxuICAgICAqL1xuICAgIHVwZGF0ZVNlcXVlbmNlcihzY2VuZUlkLCBwcm9ncmVzcywgZmxhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQnVpbHQpXG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIC8vIEdldCB0aGUgcHJlLWNvbXBpbGVkIHNldHRlciBmdW5jdGlvbnMgYW5kIGV4ZWN1dGUgdGhlbVxuICAgICAgICBjb25zdCBzZXRJZCA9IHRoaXMuc2V0dGVycy5nZXQoXCJzY2VuZUlkXCIpO1xuICAgICAgICBjb25zdCBzZXRQcm9nID0gdGhpcy5zZXR0ZXJzLmdldChcInByb2dyZXNzXCIpO1xuICAgICAgICBjb25zdCBzZXRGbGFncyA9IHRoaXMuc2V0dGVycy5nZXQoXCJmbGFnc1wiKTtcbiAgICAgICAgaWYgKHNldElkKVxuICAgICAgICAgICAgc2V0SWQoc2NlbmVJZCk7XG4gICAgICAgIGlmIChzZXRQcm9nKVxuICAgICAgICAgICAgc2V0UHJvZyhwcm9ncmVzcyk7XG4gICAgICAgIGlmIChzZXRGbGFncylcbiAgICAgICAgICAgIHNldEZsYWdzKGZsYWdzKTtcbiAgICAgICAgaWYgKHRoaXMuZW50cmllcykge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkJ1ZmZlciBTY2VuZUlkIEluZGV4OlwiLCB0aGlzLmVudHJpZXMuZmluZChlID0+IGUubmFtZSA9PT0gJ3NjZW5lSWQnKT8ub2Zmc2V0IC8gNCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZhbHVlIGluIEJ1ZmZlcjpcIiwgdGhpcy5mbG9hdFZpZXdbdGhpcy5lbnRyaWVzLmZpbmQoZSA9PiBlLm5hbWUgPT09ICdzY2VuZUlkJykub2Zmc2V0IC8gNF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLSBHZXR0ZXJzIC0tLVxuICAgIGdldCBieXRlU2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQnVpbHQpXG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgZmxvYXQzMkFycmF5KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNCdWlsdClcbiAgICAgICAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvYXRWaWV3O1xuICAgIH1cbiAgICBnZXQgd2dzbFN0cnVjdCgpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSB0aGlzLmVudHJpZXMubWFwKGUgPT4gYCAgICAke2UubmFtZX06ICR7ZS50eXBlfSxgKTtcbiAgICAgICAgcmV0dXJuIGBzdHJ1Y3QgVW5pZm9ybXMge1xcbiR7bGluZXMuam9pbihcIlxcblwiKX1cXG59O2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIFdHU0wgdHlwZXMgYmFzZWQgb24gdGhlIGlucHV0IGRhdGEgZm9ybWF0LlxuICAgICAqL1xuICAgIGluZmVyVHlwZSh2YWx1ZSkge1xuICAgICAgICAvLyBJZiBpdCdzIGEgZnVuY3Rpb24sIHJ1biBpdCBvbmNlIHdpdGggMCB0byBzZWUgd2hhdCBpdCByZXR1cm5zXG4gICAgICAgIGNvbnN0IHNhbXBsZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWUoMCwgMCkgOiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzYW1wbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZjMyXCIsIHNpemU6IDQsIGFsaWduOiA0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2FtcGxlKSkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gc2FtcGxlLmxlbmd0aDtcbiAgICAgICAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4geyB0eXBlOiBcInZlYzJmXCIsIHNpemU6IDgsIGFsaWduOiA4IH07XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4geyB0eXBlOiBcInZlYzNmXCIsIHNpemU6IDEyLCBhbGlnbjogMTYgfTsgLy8gVmVjMyByZXF1aXJlcyAxNi1ieXRlIGFsaWdubWVudFxuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIHsgdHlwZTogXCJ2ZWM0ZlwiLCBzaXplOiAxNiwgYWxpZ246IDE2IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHZhbHVlIHR5cGU6ICR7dHlwZW9mIHNhbXBsZX1gKTtcbiAgICB9XG59XG5leHBvcnRzLlVuaWZvcm1MYXlvdXQgPSBVbmlmb3JtTGF5b3V0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/UniformLayout.ts\n\n}");

/***/ },

/***/ "./src/example/example4.ts"
/*!*********************************!*\
  !*** ./src/example/example4.ts ***!
  \*********************************/
(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst TinyShade_1 = __webpack_require__(/*! ../TinyShade */ \"./src/TinyShade.ts\");\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\n    const app = await TinyShade_1.TinyShade.create(\"canvas\");\n    const dpr = window.devicePixelRatio || 1;\n    app.canvas.width = window.innerWidth * dpr;\n    app.canvas.height = window.innerHeight * dpr;\n    const COUNT = 1_000_000;\n    const PHYSICS_SIZE = COUNT * 4;\n    const HEATMAP_SIZE = app.canvas.width * app.canvas.height;\n    (await app.setUniforms(l => {\n        l.addUniform({ name: \"count\", value: COUNT });\n    })\n        .addCompute(\"physics\", /*wgsl*/ `\r\n        ##WORKGROUP_SIZE\r\n        fn main(@builtin(global_invocation_id) id: vec3u) {\r\n            let i = id.x;\r\n            if (i >= u32(u.count)) { return; }\r\n            \r\n            let b = i * 4u;\r\n            var p = vec4f(data[b], data[b+1], data[b+2], data[b+3]);\r\n\r\n            p.z -= 0.004 + (fract(f32(i) * 0.13) * 0.006);\r\n\r\n            if (p.z < 0.1 || u.time < 0.1) {\r\n                let angle = fract(f32(i) * 0.001) * 6.28 + u.time * 0.05;\r\n                let radius = 0.2 + fract(f32(i) * 0.5) * 2.5;\r\n                p.x = cos(angle) * radius;\r\n                p.y = sin(angle) * radius;\r\n                p.z = 4.0 + fract(f32(i) * 123.45);\r\n            }\r\n\r\n            p.x += sin(p.z * 2.0 + u.time) * 0.0015;\r\n            p.y += cos(p.z * 2.0 + u.time) * 0.0015;\r\n\r\n            data[b] = p.x; data[b+1] = p.y; data[b+2] = p.z; data[b+3] = p.w;\r\n        }\r\n        `, PHYSICS_SIZE)\n        .addAtomicCompute(\"heatmap\", /*wgsl*/ `\r\n        ##WORKGROUP_SIZE\r\n        fn main(@builtin(global_invocation_id) id: vec3u) {\r\n            let i = id.x;\r\n            if (i >= u32(u.count)) { return; }\r\n            let b = i * 4u;\r\n            let p = vec3f(physics_data[b], physics_data[b+1], physics_data[b+2]);\r\n\r\n            let res = u.resolution.xy;\r\n            let screen = vec2f(p.x / p.z, p.y / (p.z * (res.x/res.y))) * 0.5 + 0.5;\r\n            let coords = vec2i(screen * res);\r\n            \r\n            if(coords.x >= 0 && coords.x < i32(res.x) && coords.y >= 0 && coords.y < i32(res.y)) {\r\n                let idx = u32(coords.y) * u32(res.x) + u32(coords.x);\r\n                atomicAdd(&data[idx], 1u); \r\n            }\r\n        }\r\n        `, HEATMAP_SIZE)\n        .addPass(\"accum\", /*wgsl*/ `\r\n        @fragment fn main(in: VSOut) -> @location(0) vec4f {\r\n            let res = u.resolution.xy;\r\n            let idx = u32(in.uv.y * res.y) * u32(res.x) + u32(in.uv.x * res.x);\r\n            \r\n            let val = f32(atomicLoad(&heatmap_data[idx]));\r\n            \r\n            let colIndigo = vec3f(0.07, 0.0, 0.25); // Gas\r\n            let colAzure  = vec3f(0.0, 0.3, 1.0);  // Young Stars\r\n            let colCyan   = vec3f(0.4, 1.0, 0.9);  // Hot Stars\r\n            let colWhite  = vec3f(1.0, 1.0, 1.0);  // Core\r\n            \r\n            var dots = mix(colIndigo, colAzure, saturate(val * 0.1));\r\n            dots = mix(dots, colCyan, saturate(val * 0.02 - 0.2));\r\n            dots = mix(dots, colWhite, saturate(val * 0.01 - 0.8));\r\n            \r\n            dots *= val * 0.6; \r\n            \r\n            let d = 1.2 / res;\r\n            let history = (\r\n                textureSample(prev_accum, samp, in.uv + vec2f(d.x, d.y)).rgb +\r\n                textureSample(prev_accum, samp, in.uv + vec2f(-d.x, d.y)).rgb +\r\n                textureSample(prev_accum, samp, in.uv + vec2f(d.x, -d.y)).rgb +\r\n                textureSample(prev_accum, samp, in.uv + vec2f(-d.x, -d.y)).rgb\r\n            ) * 0.25;\r\n            \r\n            return vec4f(max(dots, history * 0.97), 1.0);\r\n        }\r\n        `)\n        .main(/*wgsl*/ `\r\n        @fragment fn main(in: VSOut) -> @location(0) vec4f {\r\n            let uv = in.uv;\r\n            let centerDist = length(uv - 0.5);\r\n            \r\n            let shift = centerDist * 0.02;\r\n            let r = textureSample(accum, samp, uv + vec2f(shift, 0.0)).r;\r\n            let g = textureSample(accum, samp, uv).g;\r\n            let b = textureSample(accum, samp, uv - vec2f(shift, 0.0)).b;\r\n            \r\n            var color = vec3f(r, g, b);\r\n\r\n            color = pow(color, vec3f(0.85)); \r\n            \r\n      \r\n            color = (color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14);\r\n            \r\n            let vignette = smoothstep(1.2, 0.25, centerDist);\r\n            return vec4f(color * vignette, 1.0);\r\n        }\r\n        `))\n        .run();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZXhhbXBsZS9leGFtcGxlNC50cyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyx3Q0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQixpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsbURBQW1EO0FBQ25ELG1EQUFtRDtBQUNuRCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlueXNoYWRlLy4vc3JjL2V4YW1wbGUvZXhhbXBsZTQudHM/ZDgxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFRpbnlTaGFkZV8xID0gcmVxdWlyZShcIi4uL1RpbnlTaGFkZVwiKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBhcHAgPSBhd2FpdCBUaW55U2hhZGVfMS5UaW55U2hhZGUuY3JlYXRlKFwiY2FudmFzXCIpO1xuICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgYXBwLmNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICogZHByO1xuICAgIGFwcC5jYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ICogZHByO1xuICAgIGNvbnN0IENPVU5UID0gMV8wMDBfMDAwO1xuICAgIGNvbnN0IFBIWVNJQ1NfU0laRSA9IENPVU5UICogNDtcbiAgICBjb25zdCBIRUFUTUFQX1NJWkUgPSBhcHAuY2FudmFzLndpZHRoICogYXBwLmNhbnZhcy5oZWlnaHQ7XG4gICAgKGF3YWl0IGFwcC5zZXRVbmlmb3JtcyhsID0+IHtcbiAgICAgICAgbC5hZGRVbmlmb3JtKHsgbmFtZTogXCJjb3VudFwiLCB2YWx1ZTogQ09VTlQgfSk7XG4gICAgfSlcbiAgICAgICAgLmFkZENvbXB1dGUoXCJwaHlzaWNzXCIsIC8qd2dzbCovIGBcclxuICAgICAgICAjI1dPUktHUk9VUF9TSVpFXHJcbiAgICAgICAgZm4gbWFpbihAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgaWQ6IHZlYzN1KSB7XHJcbiAgICAgICAgICAgIGxldCBpID0gaWQueDtcclxuICAgICAgICAgICAgaWYgKGkgPj0gdTMyKHUuY291bnQpKSB7IHJldHVybjsgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGIgPSBpICogNHU7XHJcbiAgICAgICAgICAgIHZhciBwID0gdmVjNGYoZGF0YVtiXSwgZGF0YVtiKzFdLCBkYXRhW2IrMl0sIGRhdGFbYiszXSk7XHJcblxyXG4gICAgICAgICAgICBwLnogLT0gMC4wMDQgKyAoZnJhY3QoZjMyKGkpICogMC4xMykgKiAwLjAwNik7XHJcblxyXG4gICAgICAgICAgICBpZiAocC56IDwgMC4xIHx8IHUudGltZSA8IDAuMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGFuZ2xlID0gZnJhY3QoZjMyKGkpICogMC4wMDEpICogNi4yOCArIHUudGltZSAqIDAuMDU7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmFkaXVzID0gMC4yICsgZnJhY3QoZjMyKGkpICogMC41KSAqIDIuNTtcclxuICAgICAgICAgICAgICAgIHAueCA9IGNvcyhhbmdsZSkgKiByYWRpdXM7XHJcbiAgICAgICAgICAgICAgICBwLnkgPSBzaW4oYW5nbGUpICogcmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgcC56ID0gNC4wICsgZnJhY3QoZjMyKGkpICogMTIzLjQ1KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcC54ICs9IHNpbihwLnogKiAyLjAgKyB1LnRpbWUpICogMC4wMDE1O1xyXG4gICAgICAgICAgICBwLnkgKz0gY29zKHAueiAqIDIuMCArIHUudGltZSkgKiAwLjAwMTU7XHJcblxyXG4gICAgICAgICAgICBkYXRhW2JdID0gcC54OyBkYXRhW2IrMV0gPSBwLnk7IGRhdGFbYisyXSA9IHAuejsgZGF0YVtiKzNdID0gcC53O1xyXG4gICAgICAgIH1cclxuICAgICAgICBgLCBQSFlTSUNTX1NJWkUpXG4gICAgICAgIC5hZGRBdG9taWNDb21wdXRlKFwiaGVhdG1hcFwiLCAvKndnc2wqLyBgXHJcbiAgICAgICAgIyNXT1JLR1JPVVBfU0laRVxyXG4gICAgICAgIGZuIG1haW4oQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGlkOiB2ZWMzdSkge1xyXG4gICAgICAgICAgICBsZXQgaSA9IGlkLng7XHJcbiAgICAgICAgICAgIGlmIChpID49IHUzMih1LmNvdW50KSkgeyByZXR1cm47IH1cclxuICAgICAgICAgICAgbGV0IGIgPSBpICogNHU7XHJcbiAgICAgICAgICAgIGxldCBwID0gdmVjM2YocGh5c2ljc19kYXRhW2JdLCBwaHlzaWNzX2RhdGFbYisxXSwgcGh5c2ljc19kYXRhW2IrMl0pO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlcyA9IHUucmVzb2x1dGlvbi54eTtcclxuICAgICAgICAgICAgbGV0IHNjcmVlbiA9IHZlYzJmKHAueCAvIHAueiwgcC55IC8gKHAueiAqIChyZXMueC9yZXMueSkpKSAqIDAuNSArIDAuNTtcclxuICAgICAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzJpKHNjcmVlbiAqIHJlcyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihjb29yZHMueCA+PSAwICYmIGNvb3Jkcy54IDwgaTMyKHJlcy54KSAmJiBjb29yZHMueSA+PSAwICYmIGNvb3Jkcy55IDwgaTMyKHJlcy55KSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IHUzMihjb29yZHMueSkgKiB1MzIocmVzLngpICsgdTMyKGNvb3Jkcy54KTtcclxuICAgICAgICAgICAgICAgIGF0b21pY0FkZCgmZGF0YVtpZHhdLCAxdSk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGAsIEhFQVRNQVBfU0laRSlcbiAgICAgICAgLmFkZFBhc3MoXCJhY2N1bVwiLCAvKndnc2wqLyBgXHJcbiAgICAgICAgQGZyYWdtZW50IGZuIG1haW4oaW46IFZTT3V0KSAtPiBAbG9jYXRpb24oMCkgdmVjNGYge1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gdS5yZXNvbHV0aW9uLnh5O1xyXG4gICAgICAgICAgICBsZXQgaWR4ID0gdTMyKGluLnV2LnkgKiByZXMueSkgKiB1MzIocmVzLngpICsgdTMyKGluLnV2LnggKiByZXMueCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgdmFsID0gZjMyKGF0b21pY0xvYWQoJmhlYXRtYXBfZGF0YVtpZHhdKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgY29sSW5kaWdvID0gdmVjM2YoMC4wNywgMC4wLCAwLjI1KTsgLy8gR2FzXHJcbiAgICAgICAgICAgIGxldCBjb2xBenVyZSAgPSB2ZWMzZigwLjAsIDAuMywgMS4wKTsgIC8vIFlvdW5nIFN0YXJzXHJcbiAgICAgICAgICAgIGxldCBjb2xDeWFuICAgPSB2ZWMzZigwLjQsIDEuMCwgMC45KTsgIC8vIEhvdCBTdGFyc1xyXG4gICAgICAgICAgICBsZXQgY29sV2hpdGUgID0gdmVjM2YoMS4wLCAxLjAsIDEuMCk7ICAvLyBDb3JlXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgZG90cyA9IG1peChjb2xJbmRpZ28sIGNvbEF6dXJlLCBzYXR1cmF0ZSh2YWwgKiAwLjEpKTtcclxuICAgICAgICAgICAgZG90cyA9IG1peChkb3RzLCBjb2xDeWFuLCBzYXR1cmF0ZSh2YWwgKiAwLjAyIC0gMC4yKSk7XHJcbiAgICAgICAgICAgIGRvdHMgPSBtaXgoZG90cywgY29sV2hpdGUsIHNhdHVyYXRlKHZhbCAqIDAuMDEgLSAwLjgpKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGRvdHMgKj0gdmFsICogMC42OyBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBkID0gMS4yIC8gcmVzO1xyXG4gICAgICAgICAgICBsZXQgaGlzdG9yeSA9IChcclxuICAgICAgICAgICAgICAgIHRleHR1cmVTYW1wbGUocHJldl9hY2N1bSwgc2FtcCwgaW4udXYgKyB2ZWMyZihkLngsIGQueSkpLnJnYiArXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlU2FtcGxlKHByZXZfYWNjdW0sIHNhbXAsIGluLnV2ICsgdmVjMmYoLWQueCwgZC55KSkucmdiICtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVTYW1wbGUocHJldl9hY2N1bSwgc2FtcCwgaW4udXYgKyB2ZWMyZihkLngsIC1kLnkpKS5yZ2IgK1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZVNhbXBsZShwcmV2X2FjY3VtLCBzYW1wLCBpbi51diArIHZlYzJmKC1kLngsIC1kLnkpKS5yZ2JcclxuICAgICAgICAgICAgKSAqIDAuMjU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gdmVjNGYobWF4KGRvdHMsIGhpc3RvcnkgKiAwLjk3KSwgMS4wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYClcbiAgICAgICAgLm1haW4oLyp3Z3NsKi8gYFxyXG4gICAgICAgIEBmcmFnbWVudCBmbiBtYWluKGluOiBWU091dCkgLT4gQGxvY2F0aW9uKDApIHZlYzRmIHtcclxuICAgICAgICAgICAgbGV0IHV2ID0gaW4udXY7XHJcbiAgICAgICAgICAgIGxldCBjZW50ZXJEaXN0ID0gbGVuZ3RoKHV2IC0gMC41KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBzaGlmdCA9IGNlbnRlckRpc3QgKiAwLjAyO1xyXG4gICAgICAgICAgICBsZXQgciA9IHRleHR1cmVTYW1wbGUoYWNjdW0sIHNhbXAsIHV2ICsgdmVjMmYoc2hpZnQsIDAuMCkpLnI7XHJcbiAgICAgICAgICAgIGxldCBnID0gdGV4dHVyZVNhbXBsZShhY2N1bSwgc2FtcCwgdXYpLmc7XHJcbiAgICAgICAgICAgIGxldCBiID0gdGV4dHVyZVNhbXBsZShhY2N1bSwgc2FtcCwgdXYgLSB2ZWMyZihzaGlmdCwgMC4wKSkuYjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHZlYzNmKHIsIGcsIGIpO1xyXG5cclxuICAgICAgICAgICAgY29sb3IgPSBwb3coY29sb3IsIHZlYzNmKDAuODUpKTsgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICBcclxuICAgICAgICAgICAgY29sb3IgPSAoY29sb3IgKiAoMi41MSAqIGNvbG9yICsgMC4wMykpIC8gKGNvbG9yICogKDIuNDMgKiBjb2xvciArIDAuNTkpICsgMC4xNCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgdmlnbmV0dGUgPSBzbW9vdGhzdGVwKDEuMiwgMC4yNSwgY2VudGVyRGlzdCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWM0Zihjb2xvciAqIHZpZ25ldHRlLCAxLjApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBgKSlcbiAgICAgICAgLnJ1bigpO1xufSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/example/example4.ts\n\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/example/example4.ts");
/******/ 	
/******/ })()
;