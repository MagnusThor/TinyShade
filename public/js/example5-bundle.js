(()=>{"use strict";var e={279(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),t.TinyShade=void 0;const s=i(954),r=(e,t,i,s=0)=>(e.queue.writeBuffer(t,s,i.buffer,i.byteOffset,i.byteLength),t),n=e=>{let t=1;for(;2*t<=e;)t*=2;return t};class a{device;context;canvas;uniforms;uniformBuffer;audioPlugin;startTime=0;frameCounter=0;globalTextures=new Map;commonWGSL="";passes=[];passLayouts=[];mainPassShader="";mainPipeline;isCompiled=!1;startedAudio=!1;workgroupSize={x:8,y:8,z:1,str:"@workgroup_size(8, 8, 1)"};constructor(e){this.canvas=e;const t=window.devicePixelRatio||1;this.uniforms=new s.UniformLayout([this.canvas.width*t,this.canvas.height*t,t])}static async create(e){const t=document.getElementById(e),i=new a(t);return await i.initWebGPU(),i}async initWebGPU(){const e=await(navigator.gpu?.requestAdapter());if(!e)throw"WebGPU not supported";const t=[];e.features.has("bgra8unorm-storage")&&t.push("bgra8unorm-storage"),e.features.has("timestamp-query")&&t.push("timestamp-query"),this.device=await e.requestDevice({requiredFeatures:t}),this.workgroupSize=(e=>{const t=Math.min(16,n(e.maxComputeWorkgroupSizeX)),i=Math.min(16,n(e.maxComputeWorkgroupSizeY));return{x:t,y:i,z:1,str:`@workgroup_size(${t}, ${i}, 1)`}})(e.limits),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}),this.startTime=performance.now()}addAudio(e){return this.audioPlugin=e,this}addCommon(e){return this.commonWGSL+=`\n${e}\n`,this}async addTexture(e,t){let i;if("string"==typeof t){const e=new Image;e.src=t,await e.decode(),i=await createImageBitmap(e)}else i=t;const s=this.device.createTexture({size:[i.width,i.height],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return this.device.queue.copyExternalImageToTexture({source:i},{texture:s},[i.width,i.height]),this.globalTextures.set(e,s),this}setUniforms(e){return e&&e(this.uniforms),this.uniformBuffer=this.device.createBuffer({size:this.uniforms.byteSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this}addCompute(e,t,i=0){const s=this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING});let r;return i>0&&(r=this.device.createBuffer({size:4*i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})),this.passes.push({name:e,type:"compute",shader:t,textures:[s],storageBuffer:r,pipelines:[]}),this}addAtomicCompute(e,t,i){const s=this.device.createBuffer({size:4*i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});return this.passes.push({name:e,type:"compute",shader:t,storageBuffer:s,isAtomic:!0,pipelines:[],textures:[]}),this}addPass(e,t){const i=()=>this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"bgra8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT});return this.passes.push({name:e,type:"fragment",shader:t,textures:[i(),i()],pipelines:[]}),this}async main(e){return this.mainPassShader=e,this.compile(),this}compile(){this.uniformBuffer||this.setUniforms(),[...this.passes,{name:"main",type:"fragment",shader:this.mainPassShader,isMain:!0,textures:[],pipelines:[]}].forEach((e,t)=>{let i=1;const s=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}];let r=`${this.uniforms.wgslStruct}\n@group(0) @binding(0) var<uniform> u: Uniforms;\n`;this.globalTextures.forEach((e,t)=>{r+=`@group(0) @binding(${i}) var ${t}: texture_2d<f32>;\n`,s.push({binding:i++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}})}),r+=`@group(0) @binding(${i}) var samp: sampler;\n`,s.push({binding:i++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,sampler:{}}),this.passes.forEach(t=>{if("compute"===t.type){if(t.textures.length>0&&(e===t?(r+=`@group(0) @binding(${i}) var outTex: texture_storage_2d<rgba8unorm, write>;\n`,s.push({binding:i++,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",access:"write-only"}})):(r+=`@group(0) @binding(${i}) var ${t.name}: texture_2d<f32>;\n`,s.push({binding:i++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}}))),t.storageBuffer){const n=e===t,a=t.isAtomic?"array<atomic<u32>>":"array<f32>",u=n?"data":`${t.name}_data`;r+=`@group(0) @binding(${i}) var<storage, read_write> ${u}: ${a};\n`,s.push({binding:i++,visibility:GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT,buffer:{type:"storage"}})}}else r+=`@group(0) @binding(${i}) var ${t.name}: texture_2d<f32>;\n`,s.push({binding:i++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}}),r+=`@group(0) @binding(${i}) var prev_${t.name}: texture_2d<f32>;\n`,s.push({binding:i++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}})});const n=this.device.createBindGroupLayout({entries:s});this.passLayouts[t]=n;const a=("fragment"===e.type?"\n        struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\n        @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\n            var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\n            return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\n        }\n    ":"")+r+this.commonWGSL+("compute"===e.type?e.shader.replace("##WORKGROUP_SIZE",`@compute ${this.workgroupSize.str}`):e.shader),u=this.device.createShaderModule({code:a}),o=this.device.createPipelineLayout({bindGroupLayouts:[n]});"compute"===e.type?e.pipelines[0]=this.device.createComputePipeline({layout:o,compute:{module:u,entryPoint:"main"}}):(e.pipelines[0]=this.device.createRenderPipeline({layout:o,vertex:{module:u,entryPoint:"vs"},fragment:{module:u,entryPoint:"main",targets:[{format:e.isMain?navigator.gpu.getPreferredCanvasFormat():"bgra8unorm"}]}}),e.isMain&&(this.mainPipeline=e.pipelines[0]))}),this.isCompiled=!0}createBindGroup(e,t){const i=1-t,s=[{binding:0,resource:{buffer:this.uniformBuffer}}];let r=1;return this.globalTextures.forEach(e=>s.push({binding:r++,resource:e.createView()})),s.push({binding:r++,resource:this.device.createSampler({magFilter:"linear",minFilter:"linear"})}),this.passes.forEach((n,a)=>{"compute"===n.type?(n.textures.length>0&&s.push({binding:r++,resource:n.textures[0].createView()}),n.storageBuffer&&s.push({binding:r++,resource:{buffer:n.storageBuffer}})):a===e?(s.push({binding:r++,resource:n.textures[i].createView()}),s.push({binding:r++,resource:n.textures[i].createView()})):(s.push({binding:r++,resource:n.textures[t].createView()}),s.push({binding:r++,resource:n.textures[i].createView()}))}),this.device.createBindGroup({layout:this.passLayouts[e],entries:s})}run(e){const t=i=>{if(!this.isCompiled)return;this.audioPlugin&&!this.startedAudio&&(this.audioPlugin.play(),this.startedAudio=!0);const s=this.audioPlugin&&this.audioPlugin.isPlaying?this.audioPlugin.getTime():(i-this.startTime)/1e3,n=this.frameCounter%2;this.uniforms.update(s),r(this.device,this.uniformBuffer,this.uniforms.float32Array);const a=this.device.createCommandEncoder(),u=[];let o;if(e&&e.reset(),this.passes.forEach((t,i)=>{t.isAtomic&&t.storageBuffer&&a.clearBuffer(t.storageBuffer);const s=this.createBindGroup(i,n);let r;if(e){const i=e.allocateIndices();i&&(r={querySet:e.querySet,beginningOfPassWriteIndex:i.start,endOfPassWriteIndex:i.end},u.push({name:t.name,...i}))}if("compute"===t.type){const e=a.beginComputePass({timestampWrites:r});e.setPipeline(t.pipelines[0]),e.setBindGroup(0,s),e.dispatchWorkgroups(Math.ceil(this.canvas.width/this.workgroupSize.x),Math.ceil(this.canvas.height/this.workgroupSize.y),1),e.end()}else{const e=a.beginRenderPass({colorAttachments:[{view:t.textures[n].createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}],timestampWrites:r});e.setPipeline(t.pipelines[0]),e.setBindGroup(0,s),e.draw(3),e.end()}}),e){const t=e.allocateIndices();t&&(o={querySet:e.querySet,beginningOfPassWriteIndex:t.start,endOfPassWriteIndex:t.end},u.push({name:"main",...t}))}const c=a.beginRenderPass({colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}],timestampWrites:o});c.setPipeline(this.mainPipeline),c.setBindGroup(0,this.createBindGroup(this.passes.length,n)),c.draw(3),c.end(),this.device.queue.submit([a.finish()]),e&&e.resolve(u),this.frameCounter++,requestAnimationFrame(t)};return requestAnimationFrame(t),this}}t.TinyShade=a},833(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.WebGPUTiming=t.RollingAverage=void 0,t.RollingAverage=class{size;samples=[];constructor(e=60){this.size=e}add(e){this.samples.push(e),this.samples.length>this.size&&this.samples.shift()}get(){return this.samples.reduce((e,t)=>e+t,0)/this.samples.length}},t.WebGPUTiming=class{device;onResult;supportsTimeStampQuery;querySet;resolveBuffer;readBuffer;currentIndex=0;maxQueries=20;isMapping=!1;constructor(e,t){this.device=e,this.onResult=t,this.supportsTimeStampQuery=e.features.has("timestamp-query"),this.supportsTimeStampQuery&&(this.querySet=e.createQuerySet({type:"timestamp",count:this.maxQueries}),this.resolveBuffer=e.createBuffer({size:8*this.maxQueries,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.readBuffer=e.createBuffer({size:8*this.maxQueries,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}))}reset(){this.currentIndex=0}allocateIndices(){if(!this.supportsTimeStampQuery||this.currentIndex+2>this.maxQueries)return null;const e={start:this.currentIndex,end:this.currentIndex+1};return this.currentIndex+=2,e}async resolve(e){if(this.supportsTimeStampQuery&&!this.isMapping&&0!==e.length&&"unmapped"===this.readBuffer.mapState){this.isMapping=!0;try{const t=this.device.createCommandEncoder();t.resolveQuerySet(this.querySet,0,this.currentIndex,this.resolveBuffer,0),t.copyBufferToBuffer(this.resolveBuffer,0,this.readBuffer,0,8*this.currentIndex),this.device.queue.submit([t.finish()]),await this.readBuffer.mapAsync(GPUMapMode.READ);const i=new BigUint64Array(this.readBuffer.getMappedRange().slice(0));this.readBuffer.unmap();const s=e.map(e=>({name:e.name,ms:Number(i[e.end]-i[e.start])/1e6}));this.onResult&&this.onResult(s)}catch(e){}finally{this.isMapping=!1}}}}},954(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.UniformLayout=void 0,t.UniformLayout=class{entries=[];size=0;_cache=null;frameCount=0;currentTime=0;constructor(e){this.addUniform({name:"resolution",value:e}),this.addUniform({name:"time",value:0})}addUniform({name:e,value:t}){const{type:i,size:s,align:r}=this.inferType(t),n=Math.ceil(this.size/r)*r;return this.entries.push({name:e,type:i,size:s,align:r,offset:n,value:t}),this.size=n+s,this._cache=null,this}update(e){this.currentTime=e,this.frameCount++}get byteSize(){return 16*Math.ceil(this.size/16)}get wgslStruct(){return`struct Uniforms {\n${this.entries.map(e=>`  ${e.name}: ${e.type},`).join("\n")}\n};`}get float32Array(){this._cache||(this._cache=new Float32Array(this.byteSize/4));for(const e of this.entries){let t;t="time"===e.name?this.currentTime:"function"==typeof e.value?e.value(this.currentTime,this.frameCount):e.value;const i=e.offset/4;if("number"==typeof t)this._cache[i]=t;else for(let e=0;e<t.length;e++)this._cache[i+e]=t[e]}return this._cache}inferType(e){const t="function"==typeof e?e(0,0):e;if("number"==typeof t)return{type:"f32",size:4,align:4};const i=t.length;switch(i){case 2:return{type:"vec2f",size:8,align:8};case 3:return{type:"vec3f",size:12,align:16};case 4:return{type:"vec4f",size:16,align:16};default:throw new Error(`Uniform array length ${i} not supported.`)}}}}},t={};function i(s){var r=t[s];if(void 0!==r)return r.exports;var n=t[s]={exports:{}};return e[s](n,n.exports,i),n.exports}(()=>{const e=i(833),t=i(279);document.addEventListener("DOMContentLoaded",async()=>{const i=await t.TinyShade.create("canvas"),s=document.createElement("div");s.style.cssText="position:absolute;top:10px;left:10px;color:#0f0;font-family:monospace;background:rgba(0,0,0,0.8);padding:10px;border-radius:5px;pointer-events:none;z-index:100;line-height:1.4;font-size:12px;border:1px solid #333;",document.body.appendChild(s);const r=new e.RollingAverage(60),n=new e.WebGPUTiming(i.device,e=>{let t="",i=0;e.forEach(e=>{t+=`${e.name.padEnd(12)} : ${e.ms.toFixed(3)} ms\n`,i+=e.ms}),r.add(i),t+="---------------------------\n",t+=`${"Total GPU".padEnd(12)} : ${r.get().toFixed(3)} ms`,s.innerText=t});(await i.setUniforms(e=>{e.addUniform({name:"count",value:5e3})}).addCompute("computeTex0","\n        ##WORKGROUP_SIZE\n        fn main(@builtin(global_invocation_id) id: vec3u) {\n            let res = vec2f(u.resolution.xy);\n            if (f32(id.x) < res.x && f32(id.y) < res.y) {\n                textureStore(outTex, id.xy, vec4f(0.0));\n            }\n\n            let i = id.x;\n            if (i >= u32(u.count)) { return; }\n            \n            let b = i * 4u;\n            var p = vec4f(data[b], data[b+1], data[b+2], data[b+3]);\n\n            p.z -= 0.0005 + (fract(f32(i) * 0.13) * 0.0007);\n\n            if (p.z < 0.1 || u.time < 0.1) {\n                let angle = fract(f32(i) * 0.001) * 6.28 + u.time * 0.2;\n                let radius = 0.5 + fract(f32(i) * 0.5) * 2.0;\n                p.x = cos(angle) * radius;\n                p.y = sin(angle) * radius;\n                p.z = 4.0 + fract(f32(i) * 123.45);\n                p.w = 0.1 + fract(f32(i) * 7.7) * 0.5;\n            }\n\n            p.x += sin(p.z + u.time) * 0.001;\n            p.y += cos(p.z + u.time) * 0.001;\n\n            data[b] = p.x; data[b+1] = p.y; data[b+2] = p.z; data[b+3] = p.w;\n\n            let aspect = res.x / res.y;\n            let screenX = (p.x / p.z);\n            let screenY = (p.y / (p.z * aspect));\n\n            let coords = vec2i(\n                i32((screenX * 0.5 + 0.5) * res.x), \n                i32((screenY * 0.5 + 0.5) * res.y)\n            );\n            \n            if(coords.x <= 1 || coords.x >= i32(res.x)-1 || coords.y <= 1 || coords.y >= i32(res.y)-1) { return; }\n\n            let depthFactor = saturate(1.0 - (p.z / 4.0));\n            let color = mix(vec3f(0.0, 0.1, 0.5), vec3f(0.2, 0.9, 1.0), depthFactor);\n            \n            textureStore(outTex, coords, vec4f(color * (depthFactor * 3.0), 1.0));\n        }\n    ",2e4).addPass("trails","\n        @fragment fn main(in: VSOut) -> @location(0) vec4f {\n            let dots = textureSample(computeTex0, samp, in.uv).rgb;\n            let oldTrails = textureSample(prev_trails, samp, in.uv).rgb;\n            let fade = oldTrails * 0.4;\n            return vec4f(dots + fade, 1.0);\n        }\n    ").addPass("background","\n        @fragment fn main(in: VSOut) -> @location(0) vec4f {\n            let uv = in.uv * 2.0 - 1.0;\n            let d = length(uv);\n            let glow = 0.005 / pow(d, 1.5);\n            return vec4f(glow * vec3f(0.1, 0.2, 0.5), 1.0);\n        }\n    ").main("\n        @fragment fn main(in: VSOut) -> @location(0) vec4f {\n            let uv = in.uv;\n            let centerDist = length(uv - 0.5);\n            \n            let shift = centerDist * 0.012;\n            let r = textureSample(trails, samp, uv + vec2f(shift, 0.0)).r;\n            let g = textureSample(trails, samp, uv).g;\n            let b = textureSample(trails, samp, uv - vec2f(shift, 0.0)).b;\n            \n            let combined = textureSample(background, samp, uv).rgb + vec3f(r, g, b);\n\n            let x = max(vec3f(0.0), combined - 0.004);\n            let mapped = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n\n            return vec4f(mapped * smoothstep(1.0, 0.2, centerDist), 1.0);\n        }\n    ")).run(n)})})()})();