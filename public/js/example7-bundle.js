(()=>{"use strict";var e={549:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TinyShade=void 0;const i=n(524),r=e=>{let t=1;for(;2*t<=e;)t*=2;return t};class s{device;context;canvas;uniforms;uniformBuffer;audioPlugin;startTime=0;frameCounter=0;globalTextures=new Map;commonWGSL="";passes=[];passLayouts=[];mainPassShader="";mainPipeline;isCompiled=!1;startedAudio=!1;workgroupSize={x:8,y:8,z:1,str:"@workgroup_size(8, 8, 1)"};constructor(e){this.canvas=e,this.uniforms=new i.UniformLayout([this.canvas.width,this.canvas.height,window.devicePixelRatio])}static async create(e){const t=document.getElementById(e),n=new s(t);return await n.initWebGPU(),n}async initWebGPU(){const e=await(navigator.gpu?.requestAdapter());if(!e)throw"WebGPU not supported";const t=[];e.features.has("bgra8unorm-storage")&&t.push("bgra8unorm-storage"),e.features.has("timestamp-query")&&t.push("timestamp-query"),this.device=await e.requestDevice({requiredFeatures:t}),this.workgroupSize=(e=>{const t=Math.min(16,r(e.maxComputeWorkgroupSizeX)),n=Math.min(16,r(e.maxComputeWorkgroupSizeY));return{x:t,y:n,z:1,str:`@workgroup_size(${t}, ${n}, 1)`}})(e.limits),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}),this.startTime=performance.now()}addAudio(e){return this.audioPlugin=e,console.log(this.audioPlugin),this}addCommon(e){return this.commonWGSL+=`\n${e}\n`,this}async addTexture(e,t){let n;if("string"==typeof t){const e=new Image;e.src=t,await e.decode(),n=await createImageBitmap(e)}else n=t;const i=this.device.createTexture({size:[n.width,n.height],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return this.device.queue.copyExternalImageToTexture({source:n},{texture:i},[n.width,n.height]),this.globalTextures.set(e,i),this}setUniforms(e){return e&&e(this.uniforms),this.uniformBuffer=this.device.createBuffer({size:this.uniforms.byteSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this}addCompute(e,t,n=0){const i=this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING});let r;return n>0&&(r=this.device.createBuffer({size:4*n,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})),this.passes.push({name:e,type:"compute",shader:t,textures:[i],storageBuffer:r,pipelines:[]}),this}addAtomicCompute(e,t,n){const i=this.device.createBuffer({size:4*n,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});return this.passes.push({name:e,type:"compute",shader:t,storageBuffer:i,isAtomic:!0,pipelines:[],textures:[]}),this}addPass(e,t){const n=()=>this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"bgra8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT});return this.passes.push({name:e,type:"fragment",shader:t,textures:[n(),n()],pipelines:[]}),this}async main(e){return this.mainPassShader=e,this.compile(),this}compile(){this.uniformBuffer||this.setUniforms(),[...this.passes,{name:"main",type:"fragment",shader:this.mainPassShader,isMain:!0,textures:[],pipelines:[]}].forEach((e,t)=>{let n=1;const i=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}];let r=`${this.uniforms.wgslStruct}\n@group(0) @binding(0) var<uniform> u: Uniforms;\n`;this.globalTextures.forEach((e,t)=>{r+=`@group(0) @binding(${n}) var ${t}: texture_2d<f32>;\n`,i.push({binding:n++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}})}),r+=`@group(0) @binding(${n}) var samp: sampler;\n`,i.push({binding:n++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,sampler:{}}),this.passes.forEach(t=>{if("compute"===t.type){if(t.textures.length>0&&(e===t?(r+=`@group(0) @binding(${n}) var outTex: texture_storage_2d<rgba8unorm, write>;\n`,i.push({binding:n++,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",access:"write-only"}})):(r+=`@group(0) @binding(${n}) var ${t.name}: texture_2d<f32>;\n`,i.push({binding:n++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}}))),t.storageBuffer){const s=e===t,a=t.isAtomic?"array<atomic<u32>>":"array<f32>",o=s?"data":`${t.name}_data`;r+=`@group(0) @binding(${n}) var<storage, read_write> ${o}: ${a};\n`,i.push({binding:n++,visibility:GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT,buffer:{type:"storage"}})}}else r+=`@group(0) @binding(${n}) var ${t.name}: texture_2d<f32>;\n`,i.push({binding:n++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}}),r+=`@group(0) @binding(${n}) var prev_${t.name}: texture_2d<f32>;\n`,i.push({binding:n++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}})});const s=this.device.createBindGroupLayout({entries:i});this.passLayouts[t]=s;const a=("fragment"===e.type?"\n        struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\n        @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\n            var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\n            return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\n        }\n    ":"")+r+this.commonWGSL+("compute"===e.type?e.shader.replace("##WORKGROUP_SIZE",`@compute ${this.workgroupSize.str}`):e.shader),o=this.device.createShaderModule({code:a}),u=this.device.createPipelineLayout({bindGroupLayouts:[s]});"compute"===e.type?e.pipelines[0]=this.device.createComputePipeline({layout:u,compute:{module:o,entryPoint:"main"}}):(e.pipelines[0]=this.device.createRenderPipeline({layout:u,vertex:{module:o,entryPoint:"vs"},fragment:{module:o,entryPoint:"main",targets:[{format:e.isMain?navigator.gpu.getPreferredCanvasFormat():"bgra8unorm"}]}}),e.isMain&&(this.mainPipeline=e.pipelines[0]))}),this.isCompiled=!0}createBindGroup(e,t){const n=1-t,i=[{binding:0,resource:{buffer:this.uniformBuffer}}];let r=1;return this.globalTextures.forEach(e=>i.push({binding:r++,resource:e.createView()})),i.push({binding:r++,resource:this.device.createSampler({magFilter:"linear",minFilter:"linear"})}),this.passes.forEach((s,a)=>{"compute"===s.type?(s.textures.length>0&&i.push({binding:r++,resource:s.textures[0].createView()}),s.storageBuffer&&i.push({binding:r++,resource:{buffer:s.storageBuffer}})):a===e?(i.push({binding:r++,resource:s.textures[n].createView()}),i.push({binding:r++,resource:s.textures[n].createView()})):(i.push({binding:r++,resource:s.textures[t].createView()}),i.push({binding:r++,resource:s.textures[n].createView()}))}),this.device.createBindGroup({layout:this.passLayouts[e],entries:i})}run(e){const t=n=>{if(!this.isCompiled)return;this.audioPlugin&&!this.startedAudio&&(this.audioPlugin.play(),this.startedAudio=!0);const i=this.audioPlugin&&this.audioPlugin.isPlaying?this.audioPlugin.getTime():(n-this.startTime)/1e3,r=this.frameCounter%2;this.uniforms.update(i),((e,t,n,i=0)=>{e.queue.writeBuffer(t,i,n.buffer,n.byteOffset,n.byteLength)})(this.device,this.uniformBuffer,this.uniforms.float32Array);const s=this.device.createCommandEncoder(),a=[];let o;if(e&&e.reset(),this.passes.forEach((t,n)=>{t.isAtomic&&t.storageBuffer&&s.clearBuffer(t.storageBuffer);const i=this.createBindGroup(n,r);let o;if(e){const n=e.allocateIndices();n&&(o={querySet:e.querySet,beginningOfPassWriteIndex:n.start,endOfPassWriteIndex:n.end},a.push({name:t.name,...n}))}if("compute"===t.type){const e=s.beginComputePass({timestampWrites:o});e.setPipeline(t.pipelines[0]),e.setBindGroup(0,i),e.dispatchWorkgroups(Math.ceil(this.canvas.width/this.workgroupSize.x),Math.ceil(this.canvas.height/this.workgroupSize.y),1),e.end()}else{const e=s.beginRenderPass({colorAttachments:[{view:t.textures[r].createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}],timestampWrites:o});e.setPipeline(t.pipelines[0]),e.setBindGroup(0,i),e.draw(3),e.end()}}),e){const t=e.allocateIndices();t&&(o={querySet:e.querySet,beginningOfPassWriteIndex:t.start,endOfPassWriteIndex:t.end},a.push({name:"main",...t}))}const u=s.beginRenderPass({colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}],timestampWrites:o});u.setPipeline(this.mainPipeline),u.setBindGroup(0,this.createBindGroup(this.passes.length,r)),u.draw(3),u.end(),this.device.queue.submit([s.finish()]),e&&e.resolve(a),this.frameCounter++,requestAnimationFrame(t)};return requestAnimationFrame(t),this}}t.TinyShade=s},524:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.UniformLayout=void 0,t.UniformLayout=class{entries=[];size=0;_cache=null;frameCount=0;currentTime=0;constructor(e){this.addUniform({name:"resolution",value:e}),this.addUniform({name:"time",value:0})}addUniform({name:e,value:t}){const{type:n,size:i,align:r}=this.inferType(t),s=Math.ceil(this.size/r)*r;return this.entries.push({name:e,type:n,size:i,align:r,offset:s,value:t}),this.size=s+i,this._cache=null,this}update(e){this.currentTime=e,this.frameCount++}get byteSize(){return 16*Math.ceil(this.size/16)}get wgslStruct(){return`struct Uniforms {\n${this.entries.map(e=>`  ${e.name}: ${e.type},`).join("\n")}\n};`}get float32Array(){this._cache||(this._cache=new Float32Array(this.byteSize/4));for(const e of this.entries){let t;t="time"===e.name?this.currentTime:"function"==typeof e.value?e.value(this.currentTime,this.frameCount):e.value;const n=e.offset/4;if("number"==typeof t)this._cache[n]=t;else for(let e=0;e<t.length;e++)this._cache[n+e]=t[e]}return this._cache}inferType(e){const t="function"==typeof e?e(0,0):e;if("number"==typeof t)return{type:"f32",size:4,align:4};const n=t.length;switch(n){case 2:return{type:"vec2f",size:8,align:8};case 3:return{type:"vec3f",size:12,align:16};case 4:return{type:"vec4f",size:16,align:16};default:throw new Error(`Uniform array length ${n} not supported.`)}}}},649:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.SWEET_DREAMS_WGSL=t.GPUSynth=void 0,t.GPUSynth=class{ctx;device;pipeline;storageBuffer;readBuffer;uniformBuffer;bindGroup;sampleRate;bufferSamples=16384;absoluteSampleCount=0;nextScheduleTime=0;constructor(e,t){this.device=e,this.ctx=new AudioContext,this.sampleRate=this.ctx.sampleRate;const n=4*this.bufferSamples;this.storageBuffer=e.createBuffer({size:n,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),this.readBuffer=e.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),this.uniformBuffer=e.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const i=e.createShaderModule({code:t});this.pipeline=e.createComputePipeline({layout:"auto",compute:{module:i,entryPoint:"main"}}),this.bindGroup=e.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:{buffer:this.storageBuffer}}]})}isPlaying=!1;getTime(){return this.ctx.currentTime}async generateChunk(e,t){const n=new Float32Array([e,this.sampleRate,t,0]);this.device.queue.writeBuffer(this.uniformBuffer,0,n);const i=this.device.createCommandEncoder(),r=i.beginComputePass();r.setPipeline(this.pipeline),r.setBindGroup(0,this.bindGroup),r.dispatchWorkgroups(Math.ceil(this.bufferSamples/64)),r.end(),i.copyBufferToBuffer(this.storageBuffer,0,this.readBuffer,0,this.readBuffer.size),this.device.queue.submit([i.finish()]),await this.readBuffer.mapAsync(GPUMapMode.READ);const s=new Float32Array(this.readBuffer.getMappedRange()).slice();return this.readBuffer.unmap(),s}async play(e){"suspended"===this.ctx.state&&await this.ctx.resume(),this.isPlaying=!0,this.nextScheduleTime=this.ctx.currentTime+.1;const t=async()=>{if(this.ctx){for(;this.nextScheduleTime<this.ctx.currentTime+.5;){const e=this.absoluteSampleCount/this.sampleRate,t=await this.generateChunk(e,0),n=await this.generateChunk(e,1),i=this.ctx.createBuffer(2,this.bufferSamples,this.sampleRate);i.copyToChannel(t,0),i.copyToChannel(n,1);const r=this.ctx.createBufferSource();r.buffer=i,r.connect(this.ctx.destination),r.start(this.nextScheduleTime),this.nextScheduleTime+=this.bufferSamples/this.sampleRate,this.absoluteSampleCount+=this.bufferSamples}setTimeout(t,100)}};t(),e&&e()}},t.SWEET_DREAMS_WGSL="\n\nstruct AudioUniforms {\n    bufferTime: f32,\n    sampleRate: f32,\n    channel: f32,\n    _pad: f32,\n};\n\n@group(0) @binding(0) var<uniform> u: AudioUniforms;\n@group(0) @binding(1) var<storage, read_write> output: array<f32>;\n\nconst PI: f32 = 3.14159265359;\nconst BPS: f32 = 2.1;\n\nfn noteToFreq(n: f32) -> f32 {\n    return pow(2.0, (n - 49.0) / 12.0) * 440.0;\n}\n\nfn adsr(t_abs: f32, env: vec4f, start: f32, duration: f32) -> f32 {\n    let t = t_abs - start;\n    let sustain = env.z;\n    let t1 = env.x;\n    let t2 = t1 + env.y;\n    let t3 = max(t2, duration);\n    let t4 = t3 + env.w;\n\n    if (t < 0.0 || t > t4) { return 0.0; }\n    if (t <= t1) { return smoothstep(0.0, t1, t); }\n    if (t <= t2) { return sustain + smoothstep(t2, t1, t) * (1.0 - sustain); }\n    if (t <= t3) { return sustain; }\n    return sustain * smoothstep(t4, t3, t);\n}\n\nfn tri(t: f32, x: f32) -> f32 {\n    return abs(1.0 - ((2.0 * t * x) % 2.0)) * 2.0 - 1.0;\n}\n\nfn synth(t: f32, f: f32) -> f32 {\n    var time = t;\n    // Stereo phase shift based on channel\n    time += select(0.2, 0.6, u.channel > 0.5) * sin(t * 2.0) / f;\n    return 0.3 * tri(time, f / 2.0) + 0.2 * tri(time, f / 4.0);\n}\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) id: vec3u) {\n    let idx = id.x;\n    if (idx >= arrayLength(&output)) { return; }\n\n    let t = u.bufferTime + f32(idx) / u.sampleRate;\n    let m = (t * BPS * 2.0) % 16.0;\n    \n    var notes = array<f32, 16>(24., 24., 36., 48., 39., 51., 36., 48., 32., 32., 44., 48., 31., 31., 46., 48.);\n    var sound: f32 = 0.0;\n\n    for (var i: i32 = 0; i < 16; i = i + 1) {\n        let is_second_half = ((t * BPS * 2.0) % 32.0) > 16.0;\n        let pitch_factor = select(2.0, 1.0, is_second_half);\n        \n        sound += synth(t, pitch_factor * noteToFreq(notes[i])) * adsr(m, vec4f(0.1, 0.2, 0.7, 0.8), f32(i), 0.6);\n    }\n\n    // Add a simple kick drum pulse\n    let beat_t = (t * BPS) % 2.0;\n    let kick = tri(beat_t, 60.0 * smoothstep(0.4, 0.0, beat_t)) * adsr(beat_t, vec4f(0.01, 0.1, 0.0, 0.2), 0.0, 0.2);\n\n    output[idx] = clamp((sound * 0.4) + (kick * 0.5), -1.0, 1.0);\n}"}},t={};function n(i){var r=t[i];if(void 0!==r)return r.exports;var s=t[i]={exports:{}};return e[i](s,s.exports,n),s.exports}(()=>{const e=n(649),t=n(549);(async()=>{const n=await t.TinyShade.create("canvas"),i=new e.GPUSynth(n.device,e.SWEET_DREAMS_WGSL);await n.addAudio(i).setUniforms().addCommon('\n            const MAT_GROUND = 1.0;\n            const MAT_TORUS = 2.0;\n            const MAT_SPHERE = 3.0;\n\n            fn rot(a: f32) -> mat2x2f {\n                let s = sin(a); let c = cos(a);\n                return mat2x2f(c, -s, s, c);\n            }\n\n            fn sdfScene(p: vec3f) -> vec2f {\n                let ground = p.y + 1.5;\n                \n                // FIXED: No LHS swizzling. Reconstruct vector for rotation.\n                let rotatedXZ = rot(u.time * 0.5) * p.xz;\n                let tp = vec3f(rotatedXZ.x, p.y, rotatedXZ.y);\n                \n                let q = vec2f(length(tp.xz) - 4.5, tp.y);\n                let torus = length(q) - 0.2;\n                \n                let sPos = vec3f(0.0, 0.5 + sin(u.time * 1.5) * 0.5, 0.0);\n                let sphere = length(p - sPos) - (1.2 + sin(u.time * 4.0) * 0.05);\n                \n                var res = vec2f(ground, MAT_GROUND);\n                if (torus < res.x) { res = vec2f(torus, MAT_TORUS); }\n                if (sphere < res.x) { res = vec2f(sphere, MAT_SPHERE); }\n                return res;\n            }\n\n            // High-quality Sky with a distinct "Sun Dot" as the main source\n            fn getSky(rd: vec3f, lightDir: vec3f) -> vec3f {\n                let sun = max(dot(rd, lightDir), 0.0);\n                // Deep atmosphere gradient\n                var col = mix(vec3f(0.005, 0.01, 0.03), vec3f(0.1, 0.25, 0.5), pow(1.0 - max(rd.y, 0.0), 3.0));\n                // Sun Disk (Intense core)\n                col += vec3f(1.0, 0.9, 0.7) * pow(sun, 1024.0) * 20.0; \n                // Sun Halo (Soft glow)\n                col += vec3f(0.8, 0.4, 0.2) * pow(sun, 32.0) * 0.6; \n                return col;\n            }\n\n            // Soft shadows for depth\n            fn getShadow(ro: vec3f, rd: vec3f) -> f32 {\n                var res = 1.0;\n                var t = 0.02;\n                for(var i=0; i<32; i++) {\n                    let h = sdfScene(ro + rd * t).x;\n                    res = min(res, 12.0 * h / t); // 12.0 is the softness factor\n                    t += clamp(h, 0.01, 0.2);\n                    if(res < 0.001 || t > 15.0) { break; }\n                }\n                return clamp(res, 0.0, 1.0);\n            }\n        ').addPass("pass0","\n            @fragment fn main(in: VSOut) -> @location(0) vec4f {\n                let uv = vec2f(in.uv.x * 2.0 - 1.0, (1.0 - in.uv.y) * 2.0 - 1.0);\n                let p_uv = vec2f(uv.x * u.resolution.z, uv.y);\n\n                // Camera Logic\n                let camTime = u.time * 0.2;\n                let ro = vec3f(cos(camTime) * 12.0, 4.0, sin(camTime) * 12.0);\n                let tar = vec3f(0.0, 0.0, 0.0);\n                let ww = normalize(tar - ro);\n                let uu = normalize(cross(ww, vec3f(0.0, 1.0, 0.0)));\n                let vv = normalize(cross(uu, ww));\n                let rd = normalize(p_uv.x * uu + p_uv.y * vv + 1.8 * ww);\n                \n                // Main Sun Direction\n                let lightDir = normalize(vec3f(0.7, 0.7, 0.3)); \n                \n                var t = 0.0; var m = -1.0;\n                for(var i=0; i<100; i++) {\n                    let h = sdfScene(ro + rd * t);\n                    if(h.x < 0.001 || t > 50.0) { break; }\n                    t += h.x; m = h.y;\n                }\n\n                var col: vec3f;\n                if(t > 50.0) {\n                    col = getSky(rd, lightDir);\n                } else {\n                    let p = ro + rd * t;\n                    let e = vec2f(0.001, 0.0);\n                    let n = normalize(vec3f(\n                        sdfScene(p + e.xyy).x - sdfScene(p - e.xyy).x,\n                        sdfScene(p + e.yxy).x - sdfScene(p - e.yxy).x,\n                        sdfScene(p + e.yyx).x - sdfScene(p - e.yyx).x\n                    ));\n                    \n                    let shadow = getShadow(p, lightDir);\n                    let diff = max(dot(n, lightDir), 0.0) * shadow;\n                    let amb = 0.05 * (n.y * 0.5 + 0.5); // Ambient sky light\n                    \n                    var baseCol = vec3f(0.5);\n                    if (m == MAT_GROUND) {\n                         let grid = smoothstep(-0.1, 0.1, sin(p.x * 1.5) * sin(p.z * 1.5));\n                         baseCol = mix(vec3f(0.01), vec3f(0.04), grid);\n                    } else if (m == MAT_TORUS) { \n                        baseCol = vec3f(0.9, 0.05, 0.1); \n                    } else if (m == MAT_SPHERE) { \n                        baseCol = vec3f(0.05, 0.5, 1.0); \n                    }\n\n                    // Specular Highlight\n                    let reflectDir = reflect(rd, n);\n                    let spec = pow(max(dot(reflectDir, lightDir), 0.0), 128.0) * shadow;\n                    \n                    // Fresnel rim lighting\n                    let fre = pow(clamp(1.0 + dot(rd, n), 0.0, 1.0), 5.0);\n                    \n                    col = baseCol * (diff + amb) + spec + (fre * 0.5 * getSky(reflectDir, lightDir));\n                }\n\n                // Smooth exponential fog\n                col = mix(col, getSky(rd, lightDir), 1.0 - exp(-0.0001 * t * t * t));\n                return vec4f(col, 1.0);\n            }\n        ").main("\n            @fragment fn main(in: VSOut) -> @location(0) vec4f {\n                let scene = textureSample(pass0, samp, in.uv).rgb;\n                \n                // Filmic Bloom: Only glow the brightest highlights\n                var bloom = vec3f(0.0);\n                let samples = 8;\n                for(var i=0; i<samples; i++) {\n                    let angle = f32(i) * 6.28 / f32(samples);\n                    let off = vec2f(cos(angle), sin(angle)) * 0.005;\n                    bloom += max(textureSample(pass0, samp, in.uv + off).rgb - 0.7, vec3f(0.0));\n                }\n                bloom /= f32(samples);\n\n                // Chromatic Aberration\n                let offset = length(in.uv - 0.5) * 0.004;\n                let r = textureSample(pass0, samp, in.uv + vec2f(offset, 0.0)).r;\n                let g = scene.g;\n                let b = textureSample(pass0, samp, in.uv - vec2f(offset, 0.0)).b;\n                \n                let fin = vec3f(r, g, b) + bloom * 2.0;\n                \n                // ACES-ish Tonemapping and Gamma\n                let mapped = fin / (fin + 1.0);\n                return vec4f(pow(mapped, vec3f(0.4545)), 1.0);\n            }\n        ");const r=document.querySelector("button");r.addEventListener("click",()=>{r.classList.add("d-none"),n.run()},{once:!0})})()})()})();