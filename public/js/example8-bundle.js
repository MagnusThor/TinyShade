(()=>{"use strict";var e={549:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TinyShade=void 0;const n=r(524),i=e=>{let t=1;for(;2*t<=e;)t*=2;return t};class s{device;context;canvas;uniforms;uniformBuffer;audioPlugin;startTime=0;frameCounter=0;globalTextures=new Map;commonWGSL="";passes=[];passLayouts=[];mainPassShader="";mainPipeline;isCompiled=!1;startedAudio=!1;workgroupSize={x:8,y:8,z:1,str:"@workgroup_size(8, 8, 1)"};constructor(e){this.canvas=e,this.uniforms=new n.UniformLayout([this.canvas.width,this.canvas.height,window.devicePixelRatio])}static async create(e){const t=document.getElementById(e),r=new s(t);return await r.initWebGPU(),r}async initWebGPU(){const e=await(navigator.gpu?.requestAdapter());if(!e)throw"WebGPU not supported";const t=[];e.features.has("bgra8unorm-storage")&&t.push("bgra8unorm-storage"),e.features.has("timestamp-query")&&t.push("timestamp-query"),this.device=await e.requestDevice({requiredFeatures:t}),this.workgroupSize=(e=>{const t=Math.min(16,i(e.maxComputeWorkgroupSizeX)),r=Math.min(16,i(e.maxComputeWorkgroupSizeY));return{x:t,y:r,z:1,str:`@workgroup_size(${t}, ${r}, 1)`}})(e.limits),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}),this.startTime=performance.now()}addAudio(e){return this.audioPlugin=e,console.log(this.audioPlugin),this}addCommon(e){return this.commonWGSL+=`\n${e}\n`,this}async addTexture(e,t){let r;if("string"==typeof t){const e=new Image;e.src=t,await e.decode(),r=await createImageBitmap(e)}else r=t;const n=this.device.createTexture({size:[r.width,r.height],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return this.device.queue.copyExternalImageToTexture({source:r},{texture:n},[r.width,r.height]),this.globalTextures.set(e,n),this}setUniforms(e){return e&&e(this.uniforms),this.uniformBuffer=this.device.createBuffer({size:this.uniforms.byteSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this}addCompute(e,t,r=0){const n=this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING});let i;return r>0&&(i=this.device.createBuffer({size:4*r,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})),this.passes.push({name:e,type:"compute",shader:t,textures:[n],storageBuffer:i,pipelines:[]}),this}addAtomicCompute(e,t,r){const n=this.device.createBuffer({size:4*r,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});return this.passes.push({name:e,type:"compute",shader:t,storageBuffer:n,isAtomic:!0,pipelines:[],textures:[]}),this}addPass(e,t){const r=()=>this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"bgra8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT});return this.passes.push({name:e,type:"fragment",shader:t,textures:[r(),r()],pipelines:[]}),this}async main(e){return this.mainPassShader=e,this.compile(),this}compile(){this.uniformBuffer||this.setUniforms(),[...this.passes,{name:"main",type:"fragment",shader:this.mainPassShader,isMain:!0,textures:[],pipelines:[]}].forEach((e,t)=>{let r=1;const n=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}];let i=`${this.uniforms.wgslStruct}\n@group(0) @binding(0) var<uniform> u: Uniforms;\n`;this.globalTextures.forEach((e,t)=>{i+=`@group(0) @binding(${r}) var ${t}: texture_2d<f32>;\n`,n.push({binding:r++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}})}),i+=`@group(0) @binding(${r}) var samp: sampler;\n`,n.push({binding:r++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,sampler:{}}),this.passes.forEach(t=>{if("compute"===t.type){if(t.textures.length>0&&(e===t?(i+=`@group(0) @binding(${r}) var outTex: texture_storage_2d<rgba8unorm, write>;\n`,n.push({binding:r++,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",access:"write-only"}})):(i+=`@group(0) @binding(${r}) var ${t.name}: texture_2d<f32>;\n`,n.push({binding:r++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}}))),t.storageBuffer){const s=e===t,a=t.isAtomic?"array<atomic<u32>>":"array<f32>",o=s?"data":`${t.name}_data`;i+=`@group(0) @binding(${r}) var<storage, read_write> ${o}: ${a};\n`,n.push({binding:r++,visibility:GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT,buffer:{type:"storage"}})}}else i+=`@group(0) @binding(${r}) var ${t.name}: texture_2d<f32>;\n`,n.push({binding:r++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}}),i+=`@group(0) @binding(${r}) var prev_${t.name}: texture_2d<f32>;\n`,n.push({binding:r++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}})});const s=this.device.createBindGroupLayout({entries:n});this.passLayouts[t]=s;const a=("fragment"===e.type?"\n        struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\n        @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\n            var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\n            return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\n        }\n    ":"")+i+this.commonWGSL+("compute"===e.type?e.shader.replace("##WORKGROUP_SIZE",`@compute ${this.workgroupSize.str}`):e.shader),o=this.device.createShaderModule({code:a}),u=this.device.createPipelineLayout({bindGroupLayouts:[s]});"compute"===e.type?e.pipelines[0]=this.device.createComputePipeline({layout:u,compute:{module:o,entryPoint:"main"}}):(e.pipelines[0]=this.device.createRenderPipeline({layout:u,vertex:{module:o,entryPoint:"vs"},fragment:{module:o,entryPoint:"main",targets:[{format:e.isMain?navigator.gpu.getPreferredCanvasFormat():"bgra8unorm"}]}}),e.isMain&&(this.mainPipeline=e.pipelines[0]))}),this.isCompiled=!0}createBindGroup(e,t){const r=1-t,n=[{binding:0,resource:{buffer:this.uniformBuffer}}];let i=1;return this.globalTextures.forEach(e=>n.push({binding:i++,resource:e.createView()})),n.push({binding:i++,resource:this.device.createSampler({magFilter:"linear",minFilter:"linear"})}),this.passes.forEach((s,a)=>{"compute"===s.type?(s.textures.length>0&&n.push({binding:i++,resource:s.textures[0].createView()}),s.storageBuffer&&n.push({binding:i++,resource:{buffer:s.storageBuffer}})):a===e?(n.push({binding:i++,resource:s.textures[r].createView()}),n.push({binding:i++,resource:s.textures[r].createView()})):(n.push({binding:i++,resource:s.textures[t].createView()}),n.push({binding:i++,resource:s.textures[r].createView()}))}),this.device.createBindGroup({layout:this.passLayouts[e],entries:n})}run(e){const t=r=>{if(!this.isCompiled)return;this.audioPlugin&&!this.startedAudio&&(this.audioPlugin.play(),this.startedAudio=!0);const n=this.audioPlugin&&this.audioPlugin.isPlaying?this.audioPlugin.getTime():(r-this.startTime)/1e3,i=this.frameCounter%2;this.uniforms.update(n),((e,t,r,n=0)=>{e.queue.writeBuffer(t,n,r.buffer,r.byteOffset,r.byteLength)})(this.device,this.uniformBuffer,this.uniforms.float32Array);const s=this.device.createCommandEncoder(),a=[];let o;if(e&&e.reset(),this.passes.forEach((t,r)=>{t.isAtomic&&t.storageBuffer&&s.clearBuffer(t.storageBuffer);const n=this.createBindGroup(r,i);let o;if(e){const r=e.allocateIndices();r&&(o={querySet:e.querySet,beginningOfPassWriteIndex:r.start,endOfPassWriteIndex:r.end},a.push({name:t.name,...r}))}if("compute"===t.type){const e=s.beginComputePass({timestampWrites:o});e.setPipeline(t.pipelines[0]),e.setBindGroup(0,n),e.dispatchWorkgroups(Math.ceil(this.canvas.width/this.workgroupSize.x),Math.ceil(this.canvas.height/this.workgroupSize.y),1),e.end()}else{const e=s.beginRenderPass({colorAttachments:[{view:t.textures[i].createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}],timestampWrites:o});e.setPipeline(t.pipelines[0]),e.setBindGroup(0,n),e.draw(3),e.end()}}),e){const t=e.allocateIndices();t&&(o={querySet:e.querySet,beginningOfPassWriteIndex:t.start,endOfPassWriteIndex:t.end},a.push({name:"main",...t}))}const u=s.beginRenderPass({colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}],timestampWrites:o});u.setPipeline(this.mainPipeline),u.setBindGroup(0,this.createBindGroup(this.passes.length,i)),u.draw(3),u.end(),this.device.queue.submit([s.finish()]),e&&e.resolve(a),this.frameCounter++,requestAnimationFrame(t)};return requestAnimationFrame(t),this}}t.TinyShade=s},380:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TinyShadeBake=void 0;class r{static async downloadSelfContained(e,t="demo.html",n){const i=new r,s=await i.collectGraphData(e);let a=n=n?n.trim():await fetch("assets/runnerCode.js").then(e=>e.text());a.startsWith("class")&&(a="const TinyShadeRunner = "+a),a=a.replace(/^export\s+/,"");const o=JSON.parse(JSON.stringify(s));o.passes.forEach(e=>e.shader=i.minify(e.shader));const u=`(async()=>{\n            const g=${JSON.stringify(o)};\n            ${a};\n            const c=document.createElement('canvas');\n            c.id='w';c.width=${o.canvasSize.width};c.height=${o.canvasSize.height};\n            c.style="max-width: 100vw;max-height: 100vh;width: 100vw;height: auto;aspect-ratio: 16 / 9;";\n            document.body.appendChild(c);\n            const r=new TinyShadeRunner(c,g);\n            await r.init();\n            r.run();\n        })()`,c=(new TextEncoder).encode(u),h=`<!DOCTYPE html><html><body style="margin:0;background:#000;overflow:hidden">\n            <img src="${await i.generatePNG(c)}" style="display:none" onload="\n                (function(i){\n                    var c=document.createElement('canvas'),\n                    w=c.width=i.width,h=c.height=i.height,\n                    x=c.getContext('2d');\n                    x.drawImage(i,0,0);\n                    var d=x.getImageData(0,0,w,h).data,b='',j=0;\n                    for(;j<d.length;j++)if(j%4!=3&&d[j])b+=String.fromCharCode(d[j]);\n                    (0,eval)(b);\n                })(this);\n            "></body></html>`;i.triggerDownload(new Blob([h],{type:"text/html"}),t)}static async downloadGraph(e,t="graph.json"){const n=new r,i=await n.collectGraphData(e);i.passes.forEach(e=>e.shader=n.minify(e.shader)),i.common&&(i.common=n.minify(i.common));const s=JSON.stringify(i);n.triggerDownload(new Blob([s],{type:"application/json"}),t)}triggerDownload(e,t){const r=URL.createObjectURL(e),n=document.createElement("a");n.href=r,n.download=t,n.click(),setTimeout(()=>URL.revokeObjectURL(r),100)}async collectGraphData(e){const t=e,r=[],n=t.textureSources;if(n)for(const[e,t]of n)r.push({name:e,data:this.toBase64(t)});const i=[...t.passes];i.push({name:"main",type:"fragment",isMain:!0,shader:t.mainPassShader,textures:[]});const s=await Promise.all(i.map(async t=>({name:t.name,type:t.type,shader:await this.assembleShader(e,t),storageBufferSize:t.storageBuffer?.size,isAtomic:t.isAtomic,isMain:t.isMain})));return{canvasSize:{width:e.canvas.width,height:e.canvas.height},uniforms:{byteSize:t.uniforms.byteSize,struct:t.uniforms.wgslStruct},textures:r,passes:s,workgroupSize:t.workgroupSize.str,common:t.commonWGSL}}async generatePNG(e){for(;e.length%3;)e=this.concat(e,new Uint8Array([0]));const t=Math.ceil(Math.sqrt(e.length/3)),r=new Uint8Array(t*t*3);r.set(e);const n=new Uint8Array(t*(3*t+1));for(let e=0;e<t;e++)n[e*(3*t+1)]=0,n.set(r.subarray(e*t*3,(e+1)*t*3),e*(3*t+1)+1);const i=await this.deflate(n),s=this.concat(this.pngSig(),this.chunk("IHDR",this.IHDR(t)),this.chunk("IDAT",i),this.chunk("IEND",new Uint8Array));return"data:image/png;base64,"+this.toBase64PNG(s)}toBase64PNG(e){let t="";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return btoa(t)}async assembleShader(e,t){const r=e,n=t.shader;let i=0,s=`${r.uniforms.wgslStruct}\n@group(0) @binding(${i++}) var<uniform> u: Uniforms;\n`;r.globalTextures.forEach((e,t)=>{n.includes(t)&&(s+=`@group(0) @binding(${i++}) var ${t}: texture_2d<f32>;\n`)}),n.includes("samp")&&(s+=`@group(0) @binding(${i++}) var samp: sampler;\n`),r.passes.forEach(e=>{e.isMain||("compute"===e.type?t===e&&n.includes("outTex")?s+=`@group(0) @binding(${i++}) var outTex: texture_storage_2d<rgba8unorm, write>;\n`:n.includes(e.name)&&(s+=`@group(0) @binding(${i++}) var ${e.name}: texture_2d<f32>;\n`):(n.includes(e.name)&&(s+=`@group(0) @binding(${i++}) var ${e.name}: texture_2d<f32>;\n`),n.includes(`prev_${e.name}`)&&(s+=`@group(0) @binding(${i++}) var prev_${e.name}: texture_2d<f32>;\n`)))});let a=("fragment"===t.type?"struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\n@vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\n    var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\n    return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\n}\n":"")+s+r.commonWGSL+n;return"compute"===t.type?a.replace("##WORKGROUP_SIZE",`@compute ${r.workgroupSize.str}`):a}minify(e){return e.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g,"").replace(/\s+/g," ").trim()}toBase64(e){const t=document.createElement("canvas");return t.width=e.width,t.height=e.height,t.getContext("2d").drawImage(e,0,0),t.toDataURL("image/png")}pngSig(){return new Uint8Array([137,80,78,71,13,10,26,10])}IHDR(e){return this.concat(this.u32(e),this.u32(e),new Uint8Array([8,2,0,0,0]))}async deflate(e){const t=new CompressionStream("deflate"),r=t.writable.getWriter();return r.write(e),r.close(),new Uint8Array(await new Response(t.readable).arrayBuffer())}u32(e){return new Uint8Array([e>>>24&255,e>>>16&255,e>>>8&255,255&e])}concat(...e){const t=e.reduce((e,t)=>e+t.length,0),r=new Uint8Array(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return r}crc32(e){let t=-1;for(let r=0;r<e.length;r++){t^=e[r];for(let e=0;e<8;e++)t=1&t?3988292384^t>>>1:t>>>1}return~t>>>0}chunk(e,t){const r=(new TextEncoder).encode(e);return this.concat(this.u32(t.length),r,t,this.u32(this.crc32(this.concat(r,t))))}}t.TinyShadeBake=r},53:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TinyShadeRunner=void 0,t.TinyShadeRunner=class{canvas;graph;d;c;u;p=new Map;l=new Map;t=new Map;s;constructor(e,t){this.canvas=e,this.graph=t}async init(){const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("");this.d=await e.requestDevice(),this.c=this.canvas.getContext("webgpu");const t=navigator.gpu.getPreferredCanvasFormat();this.c.configure({device:this.d,format:t,usage:16}),this.s=this.d.createSampler({magFilter:"linear",minFilter:"linear"}),this.u=this.d.createBuffer({size:this.graph.uniforms.byteSize,usage:72});for(const e of this.graph.passes){const r=[this.graph.canvasSize.width,this.graph.canvasSize.height];if("compute"!==e.type||e.isMain){if(!e.isMain){const t=()=>this.d.createTexture({size:r,format:"bgra8unorm",usage:20});this.t.set(e.name,[t(),t()])}}else this.t.set(e.name,[this.d.createTexture({size:r,format:"rgba8unorm",usage:12})]);const n=[],i=/@binding\s*\(\s*(\d+)\s*\)\s+var\s*(?:<([^>]+)>)?\s*([\w\d_]+)/g;let s;const a="compute"===e.type?4:2;for(;null!==(s=i.exec(e.shader));){const e=parseInt(s[1]),t=s[2]||"",r=s[3];t.includes("uniform")?n.push({binding:e,visibility:a,buffer:{type:"uniform"}}):t.includes("storage")||"outTex"===r?n.push({binding:e,visibility:a,storageTexture:{format:"rgba8unorm",access:"write-only"}}):"samp"===r?n.push({binding:e,visibility:a,sampler:{type:"filtering"}}):n.push({binding:e,visibility:a,texture:{sampleType:"float"}})}const o=this.d.createBindGroupLayout({entries:n});this.l.set(e.name,o);const u=this.d.createShaderModule({code:e.shader}),c=this.d.createPipelineLayout({bindGroupLayouts:[o]});"compute"===e.type?this.p.set(e.name,this.d.createComputePipeline({layout:c,compute:{module:u,entryPoint:"main"}})):this.p.set(e.name,this.d.createRenderPipeline({layout:c,vertex:{module:u,entryPoint:"vs"},fragment:{module:u,entryPoint:"main",targets:[{format:e.isMain?t:"bgra8unorm"}]}}))}}createBindGroup(e,t){const r=this.l.get(e.name),n=1-t,i=new Map;i.set("u",{buffer:this.u}),i.set("samp",this.s);for(const r of this.graph.passes){if(r.isMain)continue;const s=this.t.get(r.name);"compute"===r.type?(r.name===e.name&&i.set("outTex",s[0].createView()),i.set(r.name,s[0].createView())):r.name===e.name?(i.set(r.name,s[n].createView()),i.set(`prev_${r.name}`,s[n].createView())):i.set(r.name,s[t].createView())}const s=[],a=/@binding\s*\(\s*(\d+)\s*\)\s+var\s*(?:<([^>]+)>)?\s*([\w\d_]+)/g;let o;for(;null!==(o=a.exec(e.shader));){const e=parseInt(o[1]),t=i.get(o[3]);t&&s.push({binding:e,resource:t})}return this.d.createBindGroup({layout:r,entries:s})}run(){let e=0;const t=r=>{e++;const n=e%2,i=new Float32Array([this.canvas.width,this.canvas.height,0,r/1e3]);this.d.queue.writeBuffer(this.u,0,i);const s=this.d.createCommandEncoder();for(const e of this.graph.passes){const t=this.createBindGroup(e,n);if("compute"===e.type){const r=s.beginComputePass();r.setPipeline(this.p.get(e.name)),r.setBindGroup(0,t),r.dispatchWorkgroups(Math.ceil(this.canvas.width/16),Math.ceil(this.canvas.height/16)),r.end()}else{const r=e.isMain?this.c.getCurrentTexture().createView():this.t.get(e.name)[n].createView(),i=s.beginRenderPass({colorAttachments:[{view:r,loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}]});i.setPipeline(this.p.get(e.name)),i.setBindGroup(0,t),i.draw(3),i.end()}}this.d.queue.submit([s.finish()]),requestAnimationFrame(t)};requestAnimationFrame(t)}}},524:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.UniformLayout=void 0,t.UniformLayout=class{entries=[];size=0;_cache=null;frameCount=0;currentTime=0;constructor(e){this.addUniform({name:"resolution",value:e}),this.addUniform({name:"time",value:0})}addUniform({name:e,value:t}){const{type:r,size:n,align:i}=this.inferType(t),s=Math.ceil(this.size/i)*i;return this.entries.push({name:e,type:r,size:n,align:i,offset:s,value:t}),this.size=s+n,this._cache=null,this}update(e){this.currentTime=e,this.frameCount++}get byteSize(){return 16*Math.ceil(this.size/16)}get wgslStruct(){return`struct Uniforms {\n${this.entries.map(e=>`  ${e.name}: ${e.type},`).join("\n")}\n};`}get float32Array(){this._cache||(this._cache=new Float32Array(this.byteSize/4));for(const e of this.entries){let t;t="time"===e.name?this.currentTime:"function"==typeof e.value?e.value(this.currentTime,this.frameCount):e.value;const r=e.offset/4;if("number"==typeof t)this._cache[r]=t;else for(let e=0;e<t.length;e++)this._cache[r+e]=t[e]}return this._cache}inferType(e){const t="function"==typeof e?e(0,0):e;if("number"==typeof t)return{type:"f32",size:4,align:4};const r=t.length;switch(r){case 2:return{type:"vec2f",size:8,align:8};case 3:return{type:"vec3f",size:12,align:16};case 4:return{type:"vec4f",size:16,align:16};default:throw new Error(`Uniform array length ${r} not supported.`)}}}}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}(()=>{const e=r(549),t=r(380),n=r(53);(async()=>{const r=await e.TinyShade.create("canvas");document.querySelector("canvas")?.addEventListener("click",async()=>{console.info(n.TinyShadeRunner.toString()),await t.TinyShadeBake.downloadSelfContained(r,"release_demo.html")}),(await r.setUniforms().addCommon("\n            const PI: f32 = 3.141592654;\n            const TAU: f32 = 6.283185307;\n\n            fn ray_unitsphere(ro: vec3f, rd: vec3f) -> f32 {\n                let b = dot(ro, rd);\n                let c = dot(ro, ro) - 1.0;\n                let h = b*b - c;\n                if(h < 0.0) { return -1.0; }\n                return -b - sqrt(h);\n            }\n\n            fn hash21(p: vec2f) -> f32 {\n                return fract(sin(dot(p, vec2f(12.9898, 58.233))) * 43758.5453);\n            }\n\n            fn orth_base(n: vec3f) -> mat3x3f {\n                let up = select(vec3f(0,1,0), vec3f(0,0,1), abs(n.y) > 0.999);\n                let x = normalize(cross(up, n));\n                let y = cross(n, x);\n                return mat3x3f(x, y, n);\n            }\n\n            fn uniform_lambert(n: vec3f, seed: ptr<function, u32>) -> vec3f {\n                let r1 = rand(seed);\n                let r2 = rand(seed);\n                let p = TAU * r1;\n                let cost = sqrt(r2);\n                let sint = sqrt(1.0 - r2);\n                return orth_base(n) * vec3f(cos(p)*sint, sin(p)*sint, cost);\n            }\n\n            fn pcg_hash(input: u32) -> u32 {\n                var state = input * 747796405u + 2891336453u;\n                var word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n                return (word >> 22u) ^ word;\n            }\n\n            fn rand(seed: ptr<function, u32>) -> f32 {\n                *seed = pcg_hash(*seed);\n                return f32(*seed) / f32(0xffffffffu);\n            }\n        ").addCompute("computeTex0","\n            ##WORKGROUP_SIZE\n            //@compute workgroup_size(8, 8, 1)\n            fn main(@builtin(global_invocation_id) id: vec3u) {\n                let res = u.resolution.xy;\n                if (f32(id.x) >= res.x || f32(id.y) >= res.y) { return; }\n\n                var seed = pcg_hash(id.x + id.y * u32(res.x) + u32(u.time * 1000.0));\n                \n                // Camera Settings\n                let ro = vec3f(4.0, 4.0, -6.0);\n                let la = vec3f(0.0, 0.5, -2.0);\n                let cam_fwd = normalize(la - ro);\n                let cam_right = normalize(cross(cam_fwd, vec3f(0,1,0)));\n                let cam_up = cross(cam_right, cam_fwd);\n\n                // Sphere animation\n                var bounce = fract(u.time);\n                bounce -= 0.5;\n                bounce *= 2.0 * bounce;\n                var sphere_center = la;\n                sphere_center.y -= bounce;\n                sphere_center.x += sin(u.time * 0.5);\n                sphere_center.z += sin(u.time * 0.3535);\n\n                var total_radiance = vec3f(0.0);\n                \n                // --- THE BIG LOOP ---\n                // We trace 128 paths per frame for high detail\n                let samples_per_frame = 128;\n                for (var s = 0; s < samples_per_frame; s++) {\n                    \n                    let jitter = vec2f(rand(&seed), rand(&seed)) - 0.5;\n                    let p = (vec2f(f32(id.x), res.y - f32(id.y)) + jitter) * 2.0 / res.y - vec2f(res.x/res.y, 1.0);\n                    let rd = normalize(-p.x * cam_right + p.y * cam_up + 2.0 * cam_fwd);\n\n                    var radiance = vec3f(0.0);\n                    var throughput = vec3f(1.0);\n                    var curr_ro = ro;\n                    var curr_rd = rd;\n\n                    // Trace path (Max 4 bounces for performance inside the 128 loop)\n                    for (var i = 0; i < 4; i++) {\n                        let t_floor = (-1.0 - curr_ro.y) / curr_rd.y;\n                        let t_wall = (1.0 - curr_ro.z) / curr_rd.z;\n                        let t_sphere = ray_unitsphere(curr_ro - sphere_center, curr_rd);\n\n                        var t = 1e3;\n                        var normal = vec3f(0.0);\n                        var hit_obj = 0;\n\n                        if (t_floor > 0.001) { t = t_floor; normal = vec3f(0,1,0); hit_obj = 1; }\n                        if (t_wall > 0.001 && t_wall < t) { t = t_wall; normal = vec3f(0,0,-1); hit_obj = 2; }\n                        if (t_sphere > 0.001 && t_sphere < t) { \n                            t = t_sphere; \n                            normal = normalize(curr_ro + curr_rd * t_sphere - sphere_center); \n                            hit_obj = 3; \n                        }\n\n                        if (hit_obj == 0 || t == 1e3) { break; }\n\n                        let pos = curr_ro + curr_rd * t;\n                        let wall_pos = pos.xy - vec2f(u.time, 0.5);\n                        let cell_idx = floor(wall_pos + 0.5);\n                        let cell_h = hash21(cell_idx * 123.4);\n\n                        // Light Hits\n                        if (hit_obj == 2 && cell_h > 0.9) {\n                            let cell_uv = wall_pos - cell_idx;\n                            radiance += throughput * (1.1 - length(cell_uv) + sin(vec3f(2,1,0) + TAU * fract(8667.0 * cell_h)));\n                            break;\n                        }\n                        if (hit_obj == 1 && abs(pos.z + 2.0) < 0.1 && sin(wall_pos.x) > 0.0) {\n                            radiance += throughput * vec3f(1.0, 0.5, 0.0);\n                            break;\n                        }\n\n                        // Reflection Math\n                        let fresnel = pow(1.0 + dot(curr_rd, normal), 5.0);\n                        let is_mirror_wall = (hit_obj == 2 && fract(cell_h * 7677.0) > 0.5);\n                        \n                        if (rand(&seed) < fresnel || is_mirror_wall || hit_obj == 3) {\n                            curr_rd = reflect(curr_rd, normal);\n                            throughput *= 0.9;\n                        } else {\n                            curr_rd = uniform_lambert(normal, &seed);\n                            throughput *= 0.4;\n                        }\n                        curr_ro = pos + normal * 0.001;\n                    }\n                    total_radiance += radiance;\n                }\n\n                textureStore(outTex, id.xy, vec4f(total_radiance / f32(samples_per_frame), 1.0));\n            }\n        ",0).addPass("pass1","\n            @fragment fn main(in: VSOut) -> @location(0) vec4f {\n                let current = textureSample(computeTex0, samp, in.uv).rgb;\n                let history = textureSample(prev_pass1, samp, in.uv).rgb;\n                return vec4f(mix(current, history, 0.5), 1.0);\n            }\n        ").main("\n            @fragment fn main(in: VSOut) -> @location(0) vec4f {\n                let col = textureSample(pass1, samp, in.uv).rgb;\n                return vec4f(sqrt(col), 1.0);\n            }\n        ")).run()})()})()})();