/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"
/*!**********************************************************************!*\
  !*** ./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js ***!
  \**********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {

eval("{/* module decorator */ module = __webpack_require__.nmd(module);\n(function (global, factory) {\n  if (true) {\n    factory(module, __webpack_require__(/*! @jridgewell/sourcemap-codec */ \"./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js\"), __webpack_require__(/*! @jridgewell/trace-mapping */ \"./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js\"));\n    module.exports = def(module);\n  } else // removed by dead control flow\n{}\n  function def(m) { return 'default' in m.exports ? m.exports.default : m.exports; }\n})(this, (function (module, require_sourcemapCodec, require_traceMapping) {\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// umd:@jridgewell/sourcemap-codec\nvar require_sourcemap_codec = __commonJS({\n  \"umd:@jridgewell/sourcemap-codec\"(exports, module2) {\n    module2.exports = require_sourcemapCodec;\n  }\n});\n\n// umd:@jridgewell/trace-mapping\nvar require_trace_mapping = __commonJS({\n  \"umd:@jridgewell/trace-mapping\"(exports, module2) {\n    module2.exports = require_traceMapping;\n  }\n});\n\n// src/gen-mapping.ts\nvar gen_mapping_exports = {};\n__export(gen_mapping_exports, {\n  GenMapping: () => GenMapping,\n  addMapping: () => addMapping,\n  addSegment: () => addSegment,\n  allMappings: () => allMappings,\n  fromMap: () => fromMap,\n  maybeAddMapping: () => maybeAddMapping,\n  maybeAddSegment: () => maybeAddSegment,\n  setIgnore: () => setIgnore,\n  setSourceContent: () => setSourceContent,\n  toDecodedMap: () => toDecodedMap,\n  toEncodedMap: () => toEncodedMap\n});\nmodule.exports = __toCommonJS(gen_mapping_exports);\n\n// src/set-array.ts\nvar SetArray = class {\n  constructor() {\n    this._indexes = { __proto__: null };\n    this.array = [];\n  }\n};\nfunction cast(set) {\n  return set;\n}\nfunction get(setarr, key) {\n  return cast(setarr)._indexes[key];\n}\nfunction put(setarr, key) {\n  const index = get(setarr, key);\n  if (index !== void 0) return index;\n  const { array, _indexes: indexes } = cast(setarr);\n  const length = array.push(key);\n  return indexes[key] = length - 1;\n}\nfunction remove(setarr, key) {\n  const index = get(setarr, key);\n  if (index === void 0) return;\n  const { array, _indexes: indexes } = cast(setarr);\n  for (let i = index + 1; i < array.length; i++) {\n    const k = array[i];\n    array[i - 1] = k;\n    indexes[k]--;\n  }\n  indexes[key] = void 0;\n  array.pop();\n}\n\n// src/gen-mapping.ts\nvar import_sourcemap_codec = __toESM(require_sourcemap_codec());\nvar import_trace_mapping = __toESM(require_trace_mapping());\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\n\n// src/gen-mapping.ts\nvar NO_NAME = -1;\nvar GenMapping = class {\n  constructor({ file, sourceRoot } = {}) {\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n    this._ignoreList = new SetArray();\n  }\n};\nfunction cast2(map) {\n  return map;\n}\nfunction addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n  return addSegmentInternal(\n    false,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content\n  );\n}\nfunction addMapping(map, mapping) {\n  return addMappingInternal(false, map, mapping);\n}\nvar maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n  return addSegmentInternal(\n    true,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content\n  );\n};\nvar maybeAddMapping = (map, mapping) => {\n  return addMappingInternal(true, map, mapping);\n};\nfunction setSourceContent(map, source, content) {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const index = put(sources, source);\n  sourcesContent[index] = content;\n}\nfunction setIgnore(map, source, ignore = true) {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _ignoreList: ignoreList\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  if (ignore) put(ignoreList, index);\n  else remove(ignoreList, index);\n}\nfunction toDecodedMap(map) {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    _ignoreList: ignoreList\n    // _originalScopes: originalScopes,\n    // _generatedRanges: generatedRanges,\n  } = cast2(map);\n  removeEmptyFinalLines(mappings);\n  return {\n    version: 3,\n    file: map.file || void 0,\n    names: names.array,\n    sourceRoot: map.sourceRoot || void 0,\n    sources: sources.array,\n    sourcesContent,\n    mappings,\n    // originalScopes,\n    // generatedRanges,\n    ignoreList: ignoreList.array\n  };\n}\nfunction toEncodedMap(map) {\n  const decoded = toDecodedMap(map);\n  return Object.assign({}, decoded, {\n    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),\n    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),\n    mappings: (0, import_sourcemap_codec.encode)(decoded.mappings)\n  });\n}\nfunction fromMap(input) {\n  const map = new import_trace_mapping.TraceMap(input);\n  const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n  putAll(cast2(gen)._names, map.names);\n  putAll(cast2(gen)._sources, map.sources);\n  cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n  cast2(gen)._mappings = (0, import_trace_mapping.decodedMappings)(map);\n  if (map.ignoreList) putAll(cast2(gen)._ignoreList, map.ignoreList);\n  return gen;\n}\nfunction allMappings(map) {\n  const out = [];\n  const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);\n  for (let i = 0; i < mappings.length; i++) {\n    const line = mappings[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const generated = { line: i + 1, column: seg[COLUMN] };\n      let source = void 0;\n      let original = void 0;\n      let name = void 0;\n      if (seg.length !== 1) {\n        source = sources.array[seg[SOURCES_INDEX]];\n        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n      }\n      out.push({ generated, source, original, name });\n    }\n  }\n  return out;\n}\nfunction addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const line = getIndex(mappings, genLine);\n  const index = getColumnIndex(line, genColumn);\n  if (!source) {\n    if (skipable && skipSourceless(line, index)) return;\n    return insert(line, index, [genColumn]);\n  }\n  assert(sourceLine);\n  assert(sourceColumn);\n  const sourcesIndex = put(sources, source);\n  const namesIndex = name ? put(names, name) : NO_NAME;\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n    return;\n  }\n  return insert(\n    line,\n    index,\n    name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]\n  );\n}\nfunction assert(_val) {\n}\nfunction getIndex(arr, index) {\n  for (let i = arr.length; i <= index; i++) {\n    arr[i] = [];\n  }\n  return arr[index];\n}\nfunction getColumnIndex(line, genColumn) {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\nfunction insert(array, index, value) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\nfunction putAll(setarr, array) {\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n  if (index === 0) return true;\n  const prev = line[index - 1];\n  return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n  if (index === 0) return false;\n  const prev = line[index - 1];\n  if (prev.length === 1) return false;\n  return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n}\nfunction addMappingInternal(skipable, map, mapping) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null\n    );\n  }\n  assert(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    source,\n    original.line - 1,\n    original.column,\n    name,\n    content\n  );\n}\n}));\n//# sourceMappingURL=gen-mapping.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvZ2VuLW1hcHBpbmcvZGlzdC9nZW4tbWFwcGluZy51bWQuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0EsTUFBTSxJQUE0RDtBQUNsRSxvQkFBb0IsbUJBQU8sQ0FBQywyR0FBNkIsR0FBRyxtQkFBTyxDQUFDLHFHQUEyQjtBQUMvRjtBQUNBLElBQUksS0FBSztBQUFBLEVBVU47QUFDSCxvQkFBb0I7QUFDcEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckMsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUIsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRDQUE0QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUF3RDtBQUNsRSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkNBQTZDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW55c2hhZGUvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvZ2VuLW1hcHBpbmcvZGlzdC9nZW4tbWFwcGluZy51bWQuanM/OWIyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmFjdG9yeShtb2R1bGUsIHJlcXVpcmUoJ0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYycpLCByZXF1aXJlKCdAanJpZGdld2VsbC90cmFjZS1tYXBwaW5nJykpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZGVmKG1vZHVsZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnbW9kdWxlJywgJ0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYycsICdAanJpZGdld2VsbC90cmFjZS1tYXBwaW5nJ10sIGZ1bmN0aW9uKG1vZCkge1xuICAgICAgZmFjdG9yeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgbW9kLmV4cG9ydHMgPSBkZWYobW9kKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtb2QgPSB7IGV4cG9ydHM6IHt9IH07XG4gICAgZmFjdG9yeShtb2QsIGdsb2JhbC5zb3VyY2VtYXBDb2RlYywgZ2xvYmFsLnRyYWNlTWFwcGluZyk7XG4gICAgZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmO1xuICAgIGdsb2JhbC5nZW5NYXBwaW5nID0gZGVmKG1vZCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVmKG0pIHsgcmV0dXJuICdkZWZhdWx0JyBpbiBtLmV4cG9ydHMgPyBtLmV4cG9ydHMuZGVmYXVsdCA6IG0uZXhwb3J0czsgfVxufSkodGhpcywgKGZ1bmN0aW9uIChtb2R1bGUsIHJlcXVpcmVfc291cmNlbWFwQ29kZWMsIHJlcXVpcmVfdHJhY2VNYXBwaW5nKSB7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gdW1kOkBqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlY1xudmFyIHJlcXVpcmVfc291cmNlbWFwX2NvZGVjID0gX19jb21tb25KUyh7XG4gIFwidW1kOkBqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlY1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX3NvdXJjZW1hcENvZGVjO1xuICB9XG59KTtcblxuLy8gdW1kOkBqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmdcbnZhciByZXF1aXJlX3RyYWNlX21hcHBpbmcgPSBfX2NvbW1vbkpTKHtcbiAgXCJ1bWQ6QGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZ1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX3RyYWNlTWFwcGluZztcbiAgfVxufSk7XG5cbi8vIHNyYy9nZW4tbWFwcGluZy50c1xudmFyIGdlbl9tYXBwaW5nX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGdlbl9tYXBwaW5nX2V4cG9ydHMsIHtcbiAgR2VuTWFwcGluZzogKCkgPT4gR2VuTWFwcGluZyxcbiAgYWRkTWFwcGluZzogKCkgPT4gYWRkTWFwcGluZyxcbiAgYWRkU2VnbWVudDogKCkgPT4gYWRkU2VnbWVudCxcbiAgYWxsTWFwcGluZ3M6ICgpID0+IGFsbE1hcHBpbmdzLFxuICBmcm9tTWFwOiAoKSA9PiBmcm9tTWFwLFxuICBtYXliZUFkZE1hcHBpbmc6ICgpID0+IG1heWJlQWRkTWFwcGluZyxcbiAgbWF5YmVBZGRTZWdtZW50OiAoKSA9PiBtYXliZUFkZFNlZ21lbnQsXG4gIHNldElnbm9yZTogKCkgPT4gc2V0SWdub3JlLFxuICBzZXRTb3VyY2VDb250ZW50OiAoKSA9PiBzZXRTb3VyY2VDb250ZW50LFxuICB0b0RlY29kZWRNYXA6ICgpID0+IHRvRGVjb2RlZE1hcCxcbiAgdG9FbmNvZGVkTWFwOiAoKSA9PiB0b0VuY29kZWRNYXBcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZ2VuX21hcHBpbmdfZXhwb3J0cyk7XG5cbi8vIHNyYy9zZXQtYXJyYXkudHNcbnZhciBTZXRBcnJheSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5kZXhlcyA9IHsgX19wcm90b19fOiBudWxsIH07XG4gICAgdGhpcy5hcnJheSA9IFtdO1xuICB9XG59O1xuZnVuY3Rpb24gY2FzdChzZXQpIHtcbiAgcmV0dXJuIHNldDtcbn1cbmZ1bmN0aW9uIGdldChzZXRhcnIsIGtleSkge1xuICByZXR1cm4gY2FzdChzZXRhcnIpLl9pbmRleGVzW2tleV07XG59XG5mdW5jdGlvbiBwdXQoc2V0YXJyLCBrZXkpIHtcbiAgY29uc3QgaW5kZXggPSBnZXQoc2V0YXJyLCBrZXkpO1xuICBpZiAoaW5kZXggIT09IHZvaWQgMCkgcmV0dXJuIGluZGV4O1xuICBjb25zdCB7IGFycmF5LCBfaW5kZXhlczogaW5kZXhlcyB9ID0gY2FzdChzZXRhcnIpO1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5wdXNoKGtleSk7XG4gIHJldHVybiBpbmRleGVzW2tleV0gPSBsZW5ndGggLSAxO1xufVxuZnVuY3Rpb24gcmVtb3ZlKHNldGFyciwga2V5KSB7XG4gIGNvbnN0IGluZGV4ID0gZ2V0KHNldGFyciwga2V5KTtcbiAgaWYgKGluZGV4ID09PSB2b2lkIDApIHJldHVybjtcbiAgY29uc3QgeyBhcnJheSwgX2luZGV4ZXM6IGluZGV4ZXMgfSA9IGNhc3Qoc2V0YXJyKTtcbiAgZm9yIChsZXQgaSA9IGluZGV4ICsgMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgayA9IGFycmF5W2ldO1xuICAgIGFycmF5W2kgLSAxXSA9IGs7XG4gICAgaW5kZXhlc1trXS0tO1xuICB9XG4gIGluZGV4ZXNba2V5XSA9IHZvaWQgMDtcbiAgYXJyYXkucG9wKCk7XG59XG5cbi8vIHNyYy9nZW4tbWFwcGluZy50c1xudmFyIGltcG9ydF9zb3VyY2VtYXBfY29kZWMgPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlbWFwX2NvZGVjKCkpO1xudmFyIGltcG9ydF90cmFjZV9tYXBwaW5nID0gX190b0VTTShyZXF1aXJlX3RyYWNlX21hcHBpbmcoKSk7XG5cbi8vIHNyYy9zb3VyY2VtYXAtc2VnbWVudC50c1xudmFyIENPTFVNTiA9IDA7XG52YXIgU09VUkNFU19JTkRFWCA9IDE7XG52YXIgU09VUkNFX0xJTkUgPSAyO1xudmFyIFNPVVJDRV9DT0xVTU4gPSAzO1xudmFyIE5BTUVTX0lOREVYID0gNDtcblxuLy8gc3JjL2dlbi1tYXBwaW5nLnRzXG52YXIgTk9fTkFNRSA9IC0xO1xudmFyIEdlbk1hcHBpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHsgZmlsZSwgc291cmNlUm9vdCB9ID0ge30pIHtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBTZXRBcnJheSgpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgU2V0QXJyYXkoKTtcbiAgICB0aGlzLl9zb3VyY2VzQ29udGVudCA9IFtdO1xuICAgIHRoaXMuX21hcHBpbmdzID0gW107XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICAgIHRoaXMuX2lnbm9yZUxpc3QgPSBuZXcgU2V0QXJyYXkoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNhc3QyKG1hcCkge1xuICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gYWRkU2VnbWVudChtYXAsIGdlbkxpbmUsIGdlbkNvbHVtbiwgc291cmNlLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWUsIGNvbnRlbnQpIHtcbiAgcmV0dXJuIGFkZFNlZ21lbnRJbnRlcm5hbChcbiAgICBmYWxzZSxcbiAgICBtYXAsXG4gICAgZ2VuTGluZSxcbiAgICBnZW5Db2x1bW4sXG4gICAgc291cmNlLFxuICAgIHNvdXJjZUxpbmUsXG4gICAgc291cmNlQ29sdW1uLFxuICAgIG5hbWUsXG4gICAgY29udGVudFxuICApO1xufVxuZnVuY3Rpb24gYWRkTWFwcGluZyhtYXAsIG1hcHBpbmcpIHtcbiAgcmV0dXJuIGFkZE1hcHBpbmdJbnRlcm5hbChmYWxzZSwgbWFwLCBtYXBwaW5nKTtcbn1cbnZhciBtYXliZUFkZFNlZ21lbnQgPSAobWFwLCBnZW5MaW5lLCBnZW5Db2x1bW4sIHNvdXJjZSwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lLCBjb250ZW50KSA9PiB7XG4gIHJldHVybiBhZGRTZWdtZW50SW50ZXJuYWwoXG4gICAgdHJ1ZSxcbiAgICBtYXAsXG4gICAgZ2VuTGluZSxcbiAgICBnZW5Db2x1bW4sXG4gICAgc291cmNlLFxuICAgIHNvdXJjZUxpbmUsXG4gICAgc291cmNlQ29sdW1uLFxuICAgIG5hbWUsXG4gICAgY29udGVudFxuICApO1xufTtcbnZhciBtYXliZUFkZE1hcHBpbmcgPSAobWFwLCBtYXBwaW5nKSA9PiB7XG4gIHJldHVybiBhZGRNYXBwaW5nSW50ZXJuYWwodHJ1ZSwgbWFwLCBtYXBwaW5nKTtcbn07XG5mdW5jdGlvbiBzZXRTb3VyY2VDb250ZW50KG1hcCwgc291cmNlLCBjb250ZW50KSB7XG4gIGNvbnN0IHtcbiAgICBfc291cmNlczogc291cmNlcyxcbiAgICBfc291cmNlc0NvbnRlbnQ6IHNvdXJjZXNDb250ZW50XG4gICAgLy8gX29yaWdpbmFsU2NvcGVzOiBvcmlnaW5hbFNjb3BlcyxcbiAgfSA9IGNhc3QyKG1hcCk7XG4gIGNvbnN0IGluZGV4ID0gcHV0KHNvdXJjZXMsIHNvdXJjZSk7XG4gIHNvdXJjZXNDb250ZW50W2luZGV4XSA9IGNvbnRlbnQ7XG59XG5mdW5jdGlvbiBzZXRJZ25vcmUobWFwLCBzb3VyY2UsIGlnbm9yZSA9IHRydWUpIHtcbiAgY29uc3Qge1xuICAgIF9zb3VyY2VzOiBzb3VyY2VzLFxuICAgIF9zb3VyY2VzQ29udGVudDogc291cmNlc0NvbnRlbnQsXG4gICAgX2lnbm9yZUxpc3Q6IGlnbm9yZUxpc3RcbiAgICAvLyBfb3JpZ2luYWxTY29wZXM6IG9yaWdpbmFsU2NvcGVzLFxuICB9ID0gY2FzdDIobWFwKTtcbiAgY29uc3QgaW5kZXggPSBwdXQoc291cmNlcywgc291cmNlKTtcbiAgaWYgKGluZGV4ID09PSBzb3VyY2VzQ29udGVudC5sZW5ndGgpIHNvdXJjZXNDb250ZW50W2luZGV4XSA9IG51bGw7XG4gIGlmIChpZ25vcmUpIHB1dChpZ25vcmVMaXN0LCBpbmRleCk7XG4gIGVsc2UgcmVtb3ZlKGlnbm9yZUxpc3QsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIHRvRGVjb2RlZE1hcChtYXApIHtcbiAgY29uc3Qge1xuICAgIF9tYXBwaW5nczogbWFwcGluZ3MsXG4gICAgX3NvdXJjZXM6IHNvdXJjZXMsXG4gICAgX3NvdXJjZXNDb250ZW50OiBzb3VyY2VzQ29udGVudCxcbiAgICBfbmFtZXM6IG5hbWVzLFxuICAgIF9pZ25vcmVMaXN0OiBpZ25vcmVMaXN0XG4gICAgLy8gX29yaWdpbmFsU2NvcGVzOiBvcmlnaW5hbFNjb3BlcyxcbiAgICAvLyBfZ2VuZXJhdGVkUmFuZ2VzOiBnZW5lcmF0ZWRSYW5nZXMsXG4gIH0gPSBjYXN0MihtYXApO1xuICByZW1vdmVFbXB0eUZpbmFsTGluZXMobWFwcGluZ3MpO1xuICByZXR1cm4ge1xuICAgIHZlcnNpb246IDMsXG4gICAgZmlsZTogbWFwLmZpbGUgfHwgdm9pZCAwLFxuICAgIG5hbWVzOiBuYW1lcy5hcnJheSxcbiAgICBzb3VyY2VSb290OiBtYXAuc291cmNlUm9vdCB8fCB2b2lkIDAsXG4gICAgc291cmNlczogc291cmNlcy5hcnJheSxcbiAgICBzb3VyY2VzQ29udGVudCxcbiAgICBtYXBwaW5ncyxcbiAgICAvLyBvcmlnaW5hbFNjb3BlcyxcbiAgICAvLyBnZW5lcmF0ZWRSYW5nZXMsXG4gICAgaWdub3JlTGlzdDogaWdub3JlTGlzdC5hcnJheVxuICB9O1xufVxuZnVuY3Rpb24gdG9FbmNvZGVkTWFwKG1hcCkge1xuICBjb25zdCBkZWNvZGVkID0gdG9EZWNvZGVkTWFwKG1hcCk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWNvZGVkLCB7XG4gICAgLy8gb3JpZ2luYWxTY29wZXM6IGRlY29kZWQub3JpZ2luYWxTY29wZXMubWFwKChvcykgPT4gZW5jb2RlT3JpZ2luYWxTY29wZXMob3MpKSxcbiAgICAvLyBnZW5lcmF0ZWRSYW5nZXM6IGVuY29kZUdlbmVyYXRlZFJhbmdlcyhkZWNvZGVkLmdlbmVyYXRlZFJhbmdlcyBhcyBHZW5lcmF0ZWRSYW5nZVtdKSxcbiAgICBtYXBwaW5nczogKDAsIGltcG9ydF9zb3VyY2VtYXBfY29kZWMuZW5jb2RlKShkZWNvZGVkLm1hcHBpbmdzKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZyb21NYXAoaW5wdXQpIHtcbiAgY29uc3QgbWFwID0gbmV3IGltcG9ydF90cmFjZV9tYXBwaW5nLlRyYWNlTWFwKGlucHV0KTtcbiAgY29uc3QgZ2VuID0gbmV3IEdlbk1hcHBpbmcoeyBmaWxlOiBtYXAuZmlsZSwgc291cmNlUm9vdDogbWFwLnNvdXJjZVJvb3QgfSk7XG4gIHB1dEFsbChjYXN0MihnZW4pLl9uYW1lcywgbWFwLm5hbWVzKTtcbiAgcHV0QWxsKGNhc3QyKGdlbikuX3NvdXJjZXMsIG1hcC5zb3VyY2VzKTtcbiAgY2FzdDIoZ2VuKS5fc291cmNlc0NvbnRlbnQgPSBtYXAuc291cmNlc0NvbnRlbnQgfHwgbWFwLnNvdXJjZXMubWFwKCgpID0+IG51bGwpO1xuICBjYXN0MihnZW4pLl9tYXBwaW5ncyA9ICgwLCBpbXBvcnRfdHJhY2VfbWFwcGluZy5kZWNvZGVkTWFwcGluZ3MpKG1hcCk7XG4gIGlmIChtYXAuaWdub3JlTGlzdCkgcHV0QWxsKGNhc3QyKGdlbikuX2lnbm9yZUxpc3QsIG1hcC5pZ25vcmVMaXN0KTtcbiAgcmV0dXJuIGdlbjtcbn1cbmZ1bmN0aW9uIGFsbE1hcHBpbmdzKG1hcCkge1xuICBjb25zdCBvdXQgPSBbXTtcbiAgY29uc3QgeyBfbWFwcGluZ3M6IG1hcHBpbmdzLCBfc291cmNlczogc291cmNlcywgX25hbWVzOiBuYW1lcyB9ID0gY2FzdDIobWFwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBtYXBwaW5nc1tpXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHNlZyA9IGxpbmVbal07XG4gICAgICBjb25zdCBnZW5lcmF0ZWQgPSB7IGxpbmU6IGkgKyAxLCBjb2x1bW46IHNlZ1tDT0xVTU5dIH07XG4gICAgICBsZXQgc291cmNlID0gdm9pZCAwO1xuICAgICAgbGV0IG9yaWdpbmFsID0gdm9pZCAwO1xuICAgICAgbGV0IG5hbWUgPSB2b2lkIDA7XG4gICAgICBpZiAoc2VnLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBzb3VyY2UgPSBzb3VyY2VzLmFycmF5W3NlZ1tTT1VSQ0VTX0lOREVYXV07XG4gICAgICAgIG9yaWdpbmFsID0geyBsaW5lOiBzZWdbU09VUkNFX0xJTkVdICsgMSwgY29sdW1uOiBzZWdbU09VUkNFX0NPTFVNTl0gfTtcbiAgICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDUpIG5hbWUgPSBuYW1lcy5hcnJheVtzZWdbTkFNRVNfSU5ERVhdXTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKHsgZ2VuZXJhdGVkLCBzb3VyY2UsIG9yaWdpbmFsLCBuYW1lIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gYWRkU2VnbWVudEludGVybmFsKHNraXBhYmxlLCBtYXAsIGdlbkxpbmUsIGdlbkNvbHVtbiwgc291cmNlLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWUsIGNvbnRlbnQpIHtcbiAgY29uc3Qge1xuICAgIF9tYXBwaW5nczogbWFwcGluZ3MsXG4gICAgX3NvdXJjZXM6IHNvdXJjZXMsXG4gICAgX3NvdXJjZXNDb250ZW50OiBzb3VyY2VzQ29udGVudCxcbiAgICBfbmFtZXM6IG5hbWVzXG4gICAgLy8gX29yaWdpbmFsU2NvcGVzOiBvcmlnaW5hbFNjb3BlcyxcbiAgfSA9IGNhc3QyKG1hcCk7XG4gIGNvbnN0IGxpbmUgPSBnZXRJbmRleChtYXBwaW5ncywgZ2VuTGluZSk7XG4gIGNvbnN0IGluZGV4ID0gZ2V0Q29sdW1uSW5kZXgobGluZSwgZ2VuQ29sdW1uKTtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICBpZiAoc2tpcGFibGUgJiYgc2tpcFNvdXJjZWxlc3MobGluZSwgaW5kZXgpKSByZXR1cm47XG4gICAgcmV0dXJuIGluc2VydChsaW5lLCBpbmRleCwgW2dlbkNvbHVtbl0pO1xuICB9XG4gIGFzc2VydChzb3VyY2VMaW5lKTtcbiAgYXNzZXJ0KHNvdXJjZUNvbHVtbik7XG4gIGNvbnN0IHNvdXJjZXNJbmRleCA9IHB1dChzb3VyY2VzLCBzb3VyY2UpO1xuICBjb25zdCBuYW1lc0luZGV4ID0gbmFtZSA/IHB1dChuYW1lcywgbmFtZSkgOiBOT19OQU1FO1xuICBpZiAoc291cmNlc0luZGV4ID09PSBzb3VyY2VzQ29udGVudC5sZW5ndGgpIHNvdXJjZXNDb250ZW50W3NvdXJjZXNJbmRleF0gPSBjb250ZW50ICE9IG51bGwgPyBjb250ZW50IDogbnVsbDtcbiAgaWYgKHNraXBhYmxlICYmIHNraXBTb3VyY2UobGluZSwgaW5kZXgsIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc0luZGV4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gaW5zZXJ0KFxuICAgIGxpbmUsXG4gICAgaW5kZXgsXG4gICAgbmFtZSA/IFtnZW5Db2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc0luZGV4XSA6IFtnZW5Db2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uXVxuICApO1xufVxuZnVuY3Rpb24gYXNzZXJ0KF92YWwpIHtcbn1cbmZ1bmN0aW9uIGdldEluZGV4KGFyciwgaW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGg7IGkgPD0gaW5kZXg7IGkrKykge1xuICAgIGFycltpXSA9IFtdO1xuICB9XG4gIHJldHVybiBhcnJbaW5kZXhdO1xufVxuZnVuY3Rpb24gZ2V0Q29sdW1uSW5kZXgobGluZSwgZ2VuQ29sdW1uKSB7XG4gIGxldCBpbmRleCA9IGxpbmUubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gaW5kZXggLSAxOyBpID49IDA7IGluZGV4ID0gaS0tKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGxpbmVbaV07XG4gICAgaWYgKGdlbkNvbHVtbiA+PSBjdXJyZW50W0NPTFVNTl0pIGJyZWFrO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGluc2VydChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGg7IGkgPiBpbmRleDsgaS0tKSB7XG4gICAgYXJyYXlbaV0gPSBhcnJheVtpIC0gMV07XG4gIH1cbiAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG59XG5mdW5jdGlvbiByZW1vdmVFbXB0eUZpbmFsTGluZXMobWFwcGluZ3MpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IG1hcHBpbmdzO1xuICBsZXQgbGVuID0gbGVuZ3RoO1xuICBmb3IgKGxldCBpID0gbGVuIC0gMTsgaSA+PSAwOyBsZW4gPSBpLCBpLS0pIHtcbiAgICBpZiAobWFwcGluZ3NbaV0ubGVuZ3RoID4gMCkgYnJlYWs7XG4gIH1cbiAgaWYgKGxlbiA8IGxlbmd0aCkgbWFwcGluZ3MubGVuZ3RoID0gbGVuO1xufVxuZnVuY3Rpb24gcHV0QWxsKHNldGFyciwgYXJyYXkpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgcHV0KHNldGFyciwgYXJyYXlbaV0pO1xufVxuZnVuY3Rpb24gc2tpcFNvdXJjZWxlc3MobGluZSwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgcHJldiA9IGxpbmVbaW5kZXggLSAxXTtcbiAgcmV0dXJuIHByZXYubGVuZ3RoID09PSAxO1xufVxuZnVuY3Rpb24gc2tpcFNvdXJjZShsaW5lLCBpbmRleCwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWVzSW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByZXYgPSBsaW5lW2luZGV4IC0gMV07XG4gIGlmIChwcmV2Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc291cmNlc0luZGV4ID09PSBwcmV2W1NPVVJDRVNfSU5ERVhdICYmIHNvdXJjZUxpbmUgPT09IHByZXZbU09VUkNFX0xJTkVdICYmIHNvdXJjZUNvbHVtbiA9PT0gcHJldltTT1VSQ0VfQ09MVU1OXSAmJiBuYW1lc0luZGV4ID09PSAocHJldi5sZW5ndGggPT09IDUgPyBwcmV2W05BTUVTX0lOREVYXSA6IE5PX05BTUUpO1xufVxuZnVuY3Rpb24gYWRkTWFwcGluZ0ludGVybmFsKHNraXBhYmxlLCBtYXAsIG1hcHBpbmcpIHtcbiAgY29uc3QgeyBnZW5lcmF0ZWQsIHNvdXJjZSwgb3JpZ2luYWwsIG5hbWUsIGNvbnRlbnQgfSA9IG1hcHBpbmc7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIGFkZFNlZ21lbnRJbnRlcm5hbChcbiAgICAgIHNraXBhYmxlLFxuICAgICAgbWFwLFxuICAgICAgZ2VuZXJhdGVkLmxpbmUgLSAxLFxuICAgICAgZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICBudWxsXG4gICAgKTtcbiAgfVxuICBhc3NlcnQob3JpZ2luYWwpO1xuICByZXR1cm4gYWRkU2VnbWVudEludGVybmFsKFxuICAgIHNraXBhYmxlLFxuICAgIG1hcCxcbiAgICBnZW5lcmF0ZWQubGluZSAtIDEsXG4gICAgZ2VuZXJhdGVkLmNvbHVtbixcbiAgICBzb3VyY2UsXG4gICAgb3JpZ2luYWwubGluZSAtIDEsXG4gICAgb3JpZ2luYWwuY29sdW1uLFxuICAgIG5hbWUsXG4gICAgY29udGVudFxuICApO1xufVxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuLW1hcHBpbmcudW1kLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js\n\n}");

/***/ },

/***/ "./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"
/*!**********************************************************************!*\
  !*** ./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js ***!
  \**********************************************************************/
(module) {

eval("{(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    // Matches the scheme of a URL, eg \"http://\"\n    const schemeRegex = /^[\\w+.-]+:\\/\\//;\n    /**\n     * Matches the parts of a URL:\n     * 1. Scheme, including \":\", guaranteed.\n     * 2. User/password, including \"@\", optional.\n     * 3. Host, guaranteed.\n     * 4. Port, including \":\", optional.\n     * 5. Path, including \"/\", optional.\n     * 6. Query, including \"?\", optional.\n     * 7. Hash, including \"#\", optional.\n     */\n    const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n    /**\n     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n     *\n     * 1. Host, optional.\n     * 2. Path, which may include \"/\", guaranteed.\n     * 3. Query, including \"?\", optional.\n     * 4. Hash, including \"#\", optional.\n     */\n    const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n    function isAbsoluteUrl(input) {\n        return schemeRegex.test(input);\n    }\n    function isSchemeRelativeUrl(input) {\n        return input.startsWith('//');\n    }\n    function isAbsolutePath(input) {\n        return input.startsWith('/');\n    }\n    function isFileUrl(input) {\n        return input.startsWith('file:');\n    }\n    function isRelative(input) {\n        return /^[.?#]/.test(input);\n    }\n    function parseAbsoluteUrl(input) {\n        const match = urlRegex.exec(input);\n        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n    }\n    function parseFileUrl(input) {\n        const match = fileRegex.exec(input);\n        const path = match[2];\n        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n    }\n    function makeUrl(scheme, user, host, port, path, query, hash) {\n        return {\n            scheme,\n            user,\n            host,\n            port,\n            path,\n            query,\n            hash,\n            type: 7 /* Absolute */,\n        };\n    }\n    function parseUrl(input) {\n        if (isSchemeRelativeUrl(input)) {\n            const url = parseAbsoluteUrl('http:' + input);\n            url.scheme = '';\n            url.type = 6 /* SchemeRelative */;\n            return url;\n        }\n        if (isAbsolutePath(input)) {\n            const url = parseAbsoluteUrl('http://foo.com' + input);\n            url.scheme = '';\n            url.host = '';\n            url.type = 5 /* AbsolutePath */;\n            return url;\n        }\n        if (isFileUrl(input))\n            return parseFileUrl(input);\n        if (isAbsoluteUrl(input))\n            return parseAbsoluteUrl(input);\n        const url = parseAbsoluteUrl('http://foo.com/' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = input\n            ? input.startsWith('?')\n                ? 3 /* Query */\n                : input.startsWith('#')\n                    ? 2 /* Hash */\n                    : 4 /* RelativePath */\n            : 1 /* Empty */;\n        return url;\n    }\n    function stripPathFilename(path) {\n        // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n        // paths. It's not a file, so we can't strip it.\n        if (path.endsWith('/..'))\n            return path;\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n    function mergePaths(url, base) {\n        normalizePath(base, base.type);\n        // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n        // path).\n        if (url.path === '/') {\n            url.path = base.path;\n        }\n        else {\n            // Resolution happens relative to the base path's directory, not the file.\n            url.path = stripPathFilename(base.path) + url.path;\n        }\n    }\n    /**\n     * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n     * \"foo/.\". We need to normalize to a standard representation.\n     */\n    function normalizePath(url, type) {\n        const rel = type <= 4 /* RelativePath */;\n        const pieces = url.path.split('/');\n        // We need to preserve the first piece always, so that we output a leading slash. The item at\n        // pieces[0] is an empty string.\n        let pointer = 1;\n        // Positive is the number of real directories we've output, used for popping a parent directory.\n        // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n        let positive = 0;\n        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n        // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n        // real directory, we won't need to append, unless the other conditions happen again.\n        let addTrailingSlash = false;\n        for (let i = 1; i < pieces.length; i++) {\n            const piece = pieces[i];\n            // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n            if (!piece) {\n                addTrailingSlash = true;\n                continue;\n            }\n            // If we encounter a real directory, then we don't need to append anymore.\n            addTrailingSlash = false;\n            // A current directory, which we can always drop.\n            if (piece === '.')\n                continue;\n            // A parent directory, we need to see if there are any real directories we can pop. Else, we\n            // have an excess of parents, and we'll need to keep the \"..\".\n            if (piece === '..') {\n                if (positive) {\n                    addTrailingSlash = true;\n                    positive--;\n                    pointer--;\n                }\n                else if (rel) {\n                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                    pieces[pointer++] = piece;\n                }\n                continue;\n            }\n            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n            // any popped or dropped directories.\n            pieces[pointer++] = piece;\n            positive++;\n        }\n        let path = '';\n        for (let i = 1; i < pointer; i++) {\n            path += '/' + pieces[i];\n        }\n        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n            path += '/';\n        }\n        url.path = path;\n    }\n    /**\n     * Attempts to resolve `input` URL/path relative to `base`.\n     */\n    function resolve(input, base) {\n        if (!input && !base)\n            return '';\n        const url = parseUrl(input);\n        let inputType = url.type;\n        if (base && inputType !== 7 /* Absolute */) {\n            const baseUrl = parseUrl(base);\n            const baseType = baseUrl.type;\n            switch (inputType) {\n                case 1 /* Empty */:\n                    url.hash = baseUrl.hash;\n                // fall through\n                case 2 /* Hash */:\n                    url.query = baseUrl.query;\n                // fall through\n                case 3 /* Query */:\n                case 4 /* RelativePath */:\n                    mergePaths(url, baseUrl);\n                // fall through\n                case 5 /* AbsolutePath */:\n                    // The host, user, and port are joined, you can't copy one without the others.\n                    url.user = baseUrl.user;\n                    url.host = baseUrl.host;\n                    url.port = baseUrl.port;\n                // fall through\n                case 6 /* SchemeRelative */:\n                    // The input doesn't have a schema at least, so we need to copy at least that over.\n                    url.scheme = baseUrl.scheme;\n            }\n            if (baseType > inputType)\n                inputType = baseType;\n        }\n        normalizePath(url, inputType);\n        const queryHash = url.query + url.hash;\n        switch (inputType) {\n            // This is impossible, because of the empty checks at the start of the function.\n            // case UrlType.Empty:\n            case 2 /* Hash */:\n            case 3 /* Query */:\n                return queryHash;\n            case 4 /* RelativePath */: {\n                // The first char is always a \"/\", and we need it to be relative.\n                const path = url.path.slice(1);\n                if (!path)\n                    return queryHash || '.';\n                if (isRelative(base || input) && !isRelative(path)) {\n                    // If base started with a leading \".\", or there is no base and input started with a \".\",\n                    // then we need to ensure that the relative path starts with a \".\". We don't know if\n                    // relative starts with a \"..\", though, so check before prepending.\n                    return './' + path + queryHash;\n                }\n                return path + queryHash;\n            }\n            case 5 /* AbsolutePath */:\n                return url.path + queryHash;\n            default:\n                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n        }\n    }\n\n    return resolve;\n\n}));\n//# sourceMappingURL=resolve-uri.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvcmVzb2x2ZS11cmkvZGlzdC9yZXNvbHZlLXVyaS51bWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLEtBQTREO0FBQ2hFLElBQUksQ0FDeUc7QUFDN0csQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW55c2hhZGUvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvcmVzb2x2ZS11cmkvZGlzdC9yZXNvbHZlLXVyaS51bWQuanM/ZGNiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5yZXNvbHZlVVJJID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIE1hdGNoZXMgdGhlIHNjaGVtZSBvZiBhIFVSTCwgZWcgXCJodHRwOi8vXCJcbiAgICBjb25zdCBzY2hlbWVSZWdleCA9IC9eW1xcdysuLV0rOlxcL1xcLy87XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyB0aGUgcGFydHMgb2YgYSBVUkw6XG4gICAgICogMS4gU2NoZW1lLCBpbmNsdWRpbmcgXCI6XCIsIGd1YXJhbnRlZWQuXG4gICAgICogMi4gVXNlci9wYXNzd29yZCwgaW5jbHVkaW5nIFwiQFwiLCBvcHRpb25hbC5cbiAgICAgKiAzLiBIb3N0LCBndWFyYW50ZWVkLlxuICAgICAqIDQuIFBvcnQsIGluY2x1ZGluZyBcIjpcIiwgb3B0aW9uYWwuXG4gICAgICogNS4gUGF0aCwgaW5jbHVkaW5nIFwiL1wiLCBvcHRpb25hbC5cbiAgICAgKiA2LiBRdWVyeSwgaW5jbHVkaW5nIFwiP1wiLCBvcHRpb25hbC5cbiAgICAgKiA3LiBIYXNoLCBpbmNsdWRpbmcgXCIjXCIsIG9wdGlvbmFsLlxuICAgICAqL1xuICAgIGNvbnN0IHVybFJlZ2V4ID0gL14oW1xcdysuLV0rOilcXC9cXC8oW15ALyM/XSpAKT8oW146LyM/XSopKDpcXGQrKT8oXFwvW14jP10qKT8oXFw/W14jXSopPygjLiopPy87XG4gICAgLyoqXG4gICAgICogRmlsZSBVUkxzIGFyZSB3ZWlyZC4gVGhleSBkb250JyBuZWVkIHRoZSByZWd1bGFyIGAvL2AgaW4gdGhlIHNjaGVtZSwgdGhleSBtYXkgb3IgbWF5IG5vdCBzdGFydFxuICAgICAqIHdpdGggYSBsZWFkaW5nIGAvYCwgdGhleSBjYW4gaGF2ZSBhIGRvbWFpbiAoYnV0IG9ubHkgaWYgdGhleSBkb24ndCBzdGFydCB3aXRoIGEgV2luZG93cyBkcml2ZSkuXG4gICAgICpcbiAgICAgKiAxLiBIb3N0LCBvcHRpb25hbC5cbiAgICAgKiAyLiBQYXRoLCB3aGljaCBtYXkgaW5jbHVkZSBcIi9cIiwgZ3VhcmFudGVlZC5cbiAgICAgKiAzLiBRdWVyeSwgaW5jbHVkaW5nIFwiP1wiLCBvcHRpb25hbC5cbiAgICAgKiA0LiBIYXNoLCBpbmNsdWRpbmcgXCIjXCIsIG9wdGlvbmFsLlxuICAgICAqL1xuICAgIGNvbnN0IGZpbGVSZWdleCA9IC9eZmlsZTooPzpcXC9cXC8oKD8hW2Etel06KVteLyM/XSopPyk/KFxcLz9bXiM/XSopKFxcP1teI10qKT8oIy4qKT8vaTtcbiAgICBmdW5jdGlvbiBpc0Fic29sdXRlVXJsKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzY2hlbWVSZWdleC50ZXN0KGlucHV0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTY2hlbWVSZWxhdGl2ZVVybChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuc3RhcnRzV2l0aCgnLy8nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBYnNvbHV0ZVBhdGgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnN0YXJ0c1dpdGgoJy8nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNGaWxlVXJsKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5zdGFydHNXaXRoKCdmaWxlOicpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbGF0aXZlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAvXlsuPyNdLy50ZXN0KGlucHV0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VBYnNvbHV0ZVVybChpbnB1dCkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHVybFJlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgICAgICByZXR1cm4gbWFrZVVybChtYXRjaFsxXSwgbWF0Y2hbMl0gfHwgJycsIG1hdGNoWzNdLCBtYXRjaFs0XSB8fCAnJywgbWF0Y2hbNV0gfHwgJy8nLCBtYXRjaFs2XSB8fCAnJywgbWF0Y2hbN10gfHwgJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUZpbGVVcmwoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBmaWxlUmVnZXguZXhlYyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBtYXRjaFsyXTtcbiAgICAgICAgcmV0dXJuIG1ha2VVcmwoJ2ZpbGU6JywgJycsIG1hdGNoWzFdIHx8ICcnLCAnJywgaXNBYnNvbHV0ZVBhdGgocGF0aCkgPyBwYXRoIDogJy8nICsgcGF0aCwgbWF0Y2hbM10gfHwgJycsIG1hdGNoWzRdIHx8ICcnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVVybChzY2hlbWUsIHVzZXIsIGhvc3QsIHBvcnQsIHBhdGgsIHF1ZXJ5LCBoYXNoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWUsXG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgdHlwZTogNyAvKiBBYnNvbHV0ZSAqLyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVcmwoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlzU2NoZW1lUmVsYXRpdmVVcmwoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBwYXJzZUFic29sdXRlVXJsKCdodHRwOicgKyBpbnB1dCk7XG4gICAgICAgICAgICB1cmwuc2NoZW1lID0gJyc7XG4gICAgICAgICAgICB1cmwudHlwZSA9IDYgLyogU2NoZW1lUmVsYXRpdmUgKi87XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Fic29sdXRlUGF0aChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHBhcnNlQWJzb2x1dGVVcmwoJ2h0dHA6Ly9mb28uY29tJyArIGlucHV0KTtcbiAgICAgICAgICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICAgICAgICAgIHVybC5ob3N0ID0gJyc7XG4gICAgICAgICAgICB1cmwudHlwZSA9IDUgLyogQWJzb2x1dGVQYXRoICovO1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGaWxlVXJsKGlucHV0KSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZpbGVVcmwoaW5wdXQpO1xuICAgICAgICBpZiAoaXNBYnNvbHV0ZVVybChpbnB1dCkpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VBYnNvbHV0ZVVybChpbnB1dCk7XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcnNlQWJzb2x1dGVVcmwoJ2h0dHA6Ly9mb28uY29tLycgKyBpbnB1dCk7XG4gICAgICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICAgICAgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgdXJsLnR5cGUgPSBpbnB1dFxuICAgICAgICAgICAgPyBpbnB1dC5zdGFydHNXaXRoKCc/JylcbiAgICAgICAgICAgICAgICA/IDMgLyogUXVlcnkgKi9cbiAgICAgICAgICAgICAgICA6IGlucHV0LnN0YXJ0c1dpdGgoJyMnKVxuICAgICAgICAgICAgICAgICAgICA/IDIgLyogSGFzaCAqL1xuICAgICAgICAgICAgICAgICAgICA6IDQgLyogUmVsYXRpdmVQYXRoICovXG4gICAgICAgICAgICA6IDEgLyogRW1wdHkgKi87XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmlwUGF0aEZpbGVuYW1lKHBhdGgpIHtcbiAgICAgICAgLy8gSWYgYSBwYXRoIGVuZHMgd2l0aCBhIHBhcmVudCBkaXJlY3RvcnkgXCIuLlwiLCB0aGVuIGl0J3MgYSByZWxhdGl2ZSBwYXRoIHdpdGggZXhjZXNzIHBhcmVudFxuICAgICAgICAvLyBwYXRocy4gSXQncyBub3QgYSBmaWxlLCBzbyB3ZSBjYW4ndCBzdHJpcCBpdC5cbiAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy8uLicpKVxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBpbmRleCArIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZVBhdGhzKHVybCwgYmFzZSkge1xuICAgICAgICBub3JtYWxpemVQYXRoKGJhc2UsIGJhc2UudHlwZSk7XG4gICAgICAgIC8vIElmIHRoZSBwYXRoIGlzIGp1c3QgYSBcIi9cIiwgdGhlbiBpdCB3YXMgYW4gZW1wdHkgcGF0aCB0byBiZWdpbiB3aXRoIChyZW1lbWJlciwgd2UncmUgYSByZWxhdGl2ZVxuICAgICAgICAvLyBwYXRoKS5cbiAgICAgICAgaWYgKHVybC5wYXRoID09PSAnLycpIHtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzb2x1dGlvbiBoYXBwZW5zIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHBhdGgncyBkaXJlY3RvcnksIG5vdCB0aGUgZmlsZS5cbiAgICAgICAgICAgIHVybC5wYXRoID0gc3RyaXBQYXRoRmlsZW5hbWUoYmFzZS5wYXRoKSArIHVybC5wYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwYXRoIGNhbiBoYXZlIGVtcHR5IGRpcmVjdG9yaWVzIFwiLy9cIiwgdW5uZWVkZWQgcGFyZW50cyBcImZvby8uLlwiLCBvciBjdXJyZW50IGRpcmVjdG9yeVxuICAgICAqIFwiZm9vLy5cIi4gV2UgbmVlZCB0byBub3JtYWxpemUgdG8gYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHVybCwgdHlwZSkge1xuICAgICAgICBjb25zdCByZWwgPSB0eXBlIDw9IDQgLyogUmVsYXRpdmVQYXRoICovO1xuICAgICAgICBjb25zdCBwaWVjZXMgPSB1cmwucGF0aC5zcGxpdCgnLycpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHByZXNlcnZlIHRoZSBmaXJzdCBwaWVjZSBhbHdheXMsIHNvIHRoYXQgd2Ugb3V0cHV0IGEgbGVhZGluZyBzbGFzaC4gVGhlIGl0ZW0gYXRcbiAgICAgICAgLy8gcGllY2VzWzBdIGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgbGV0IHBvaW50ZXIgPSAxO1xuICAgICAgICAvLyBQb3NpdGl2ZSBpcyB0aGUgbnVtYmVyIG9mIHJlYWwgZGlyZWN0b3JpZXMgd2UndmUgb3V0cHV0LCB1c2VkIGZvciBwb3BwaW5nIGEgcGFyZW50IGRpcmVjdG9yeS5cbiAgICAgICAgLy8gRWcsIFwiZm9vL2Jhci8uLlwiIHdpbGwgaGF2ZSBhIHBvc2l0aXZlIDIsIGFuZCB3ZSBjYW4gZGVjcmVtZW50IHRvIGJlIGxlZnQgd2l0aCBqdXN0IFwiZm9vXCIuXG4gICAgICAgIGxldCBwb3NpdGl2ZSA9IDA7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8ga2VlcCBhIHRyYWlsaW5nIHNsYXNoIGlmIHdlIGVuY291bnRlciBhbiBlbXB0eSBkaXJlY3RvcnkgKGVnLCBzcGxpdHRpbmcgXCJmb28vXCIgd2lsbFxuICAgICAgICAvLyBnZW5lcmF0ZSBgW1wiZm9vXCIsIFwiXCJdYCBwaWVjZXMpLiBBbmQsIGlmIHdlIHBvcCBhIHBhcmVudCBkaXJlY3RvcnkuIEJ1dCBvbmNlIHdlIGVuY291bnRlciBhXG4gICAgICAgIC8vIHJlYWwgZGlyZWN0b3J5LCB3ZSB3b24ndCBuZWVkIHRvIGFwcGVuZCwgdW5sZXNzIHRoZSBvdGhlciBjb25kaXRpb25zIGhhcHBlbiBhZ2Fpbi5cbiAgICAgICAgbGV0IGFkZFRyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2ldO1xuICAgICAgICAgICAgLy8gQW4gZW1wdHkgZGlyZWN0b3J5LCBjb3VsZCBiZSBhIHRyYWlsaW5nIHNsYXNoLCBvciBqdXN0IGEgZG91YmxlIFwiLy9cIiBpbiB0aGUgcGF0aC5cbiAgICAgICAgICAgIGlmICghcGllY2UpIHtcbiAgICAgICAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhIHJlYWwgZGlyZWN0b3J5LCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYXBwZW5kIGFueW1vcmUuXG4gICAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBBIGN1cnJlbnQgZGlyZWN0b3J5LCB3aGljaCB3ZSBjYW4gYWx3YXlzIGRyb3AuXG4gICAgICAgICAgICBpZiAocGllY2UgPT09ICcuJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIEEgcGFyZW50IGRpcmVjdG9yeSwgd2UgbmVlZCB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSByZWFsIGRpcmVjdG9yaWVzIHdlIGNhbiBwb3AuIEVsc2UsIHdlXG4gICAgICAgICAgICAvLyBoYXZlIGFuIGV4Y2VzcyBvZiBwYXJlbnRzLCBhbmQgd2UnbGwgbmVlZCB0byBrZWVwIHRoZSBcIi4uXCIuXG4gICAgICAgICAgICBpZiAocGllY2UgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlLS07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIGEgcmVsYXRpdmVQYXRoLCB0aGVuIHdlIG5lZWQgdG8ga2VlcCB0aGUgZXhjZXNzIHBhcmVudHMuIEVsc2UsIGluIGFuIGFic29sdXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIFVSTCwgcHJvdG9jb2wgcmVsYXRpdmUgVVJMLCBvciBhbiBhYnNvbHV0ZSBwYXRoLCB3ZSBkb24ndCBuZWVkIHRvIGtlZXAgZXhjZXNzLlxuICAgICAgICAgICAgICAgICAgICBwaWVjZXNbcG9pbnRlcisrXSA9IHBpZWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlJ3ZlIGVuY291bnRlcmVkIGEgcmVhbCBkaXJlY3RvcnkuIE1vdmUgaXQgdG8gdGhlIG5leHQgaW5zZXJ0aW9uIHBvaW50ZXIsIHdoaWNoIGFjY291bnRzIGZvclxuICAgICAgICAgICAgLy8gYW55IHBvcHBlZCBvciBkcm9wcGVkIGRpcmVjdG9yaWVzLlxuICAgICAgICAgICAgcGllY2VzW3BvaW50ZXIrK10gPSBwaWVjZTtcbiAgICAgICAgICAgIHBvc2l0aXZlKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludGVyOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGggKz0gJy8nICsgcGllY2VzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF0aCB8fCAoYWRkVHJhaWxpbmdTbGFzaCAmJiAhcGF0aC5lbmRzV2l0aCgnLy4uJykpKSB7XG4gICAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgICAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHJlc29sdmUgYGlucHV0YCBVUkwvcGF0aCByZWxhdGl2ZSB0byBgYmFzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZShpbnB1dCwgYmFzZSkge1xuICAgICAgICBpZiAoIWlucHV0ICYmICFiYXNlKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjb25zdCB1cmwgPSBwYXJzZVVybChpbnB1dCk7XG4gICAgICAgIGxldCBpbnB1dFR5cGUgPSB1cmwudHlwZTtcbiAgICAgICAgaWYgKGJhc2UgJiYgaW5wdXRUeXBlICE9PSA3IC8qIEFic29sdXRlICovKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gcGFyc2VVcmwoYmFzZSk7XG4gICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IGJhc2VVcmwudHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIEVtcHR5ICovOlxuICAgICAgICAgICAgICAgICAgICB1cmwuaGFzaCA9IGJhc2VVcmwuaGFzaDtcbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogSGFzaCAqLzpcbiAgICAgICAgICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZVVybC5xdWVyeTtcbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogUXVlcnkgKi86XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFJlbGF0aXZlUGF0aCAqLzpcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VQYXRocyh1cmwsIGJhc2VVcmwpO1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBBYnNvbHV0ZVBhdGggKi86XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3N0LCB1c2VyLCBhbmQgcG9ydCBhcmUgam9pbmVkLCB5b3UgY2FuJ3QgY29weSBvbmUgd2l0aG91dCB0aGUgb3RoZXJzLlxuICAgICAgICAgICAgICAgICAgICB1cmwudXNlciA9IGJhc2VVcmwudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlVXJsLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZVVybC5wb3J0O1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgNiAvKiBTY2hlbWVSZWxhdGl2ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlucHV0IGRvZXNuJ3QgaGF2ZSBhIHNjaGVtYSBhdCBsZWFzdCwgc28gd2UgbmVlZCB0byBjb3B5IGF0IGxlYXN0IHRoYXQgb3Zlci5cbiAgICAgICAgICAgICAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2VVcmwuc2NoZW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJhc2VUeXBlID4gaW5wdXRUeXBlKVxuICAgICAgICAgICAgICAgIGlucHV0VHlwZSA9IGJhc2VUeXBlO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVBhdGgodXJsLCBpbnB1dFR5cGUpO1xuICAgICAgICBjb25zdCBxdWVyeUhhc2ggPSB1cmwucXVlcnkgKyB1cmwuaGFzaDtcbiAgICAgICAgc3dpdGNoIChpbnB1dFR5cGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3NzaWJsZSwgYmVjYXVzZSBvZiB0aGUgZW1wdHkgY2hlY2tzIGF0IHRoZSBzdGFydCBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyBjYXNlIFVybFR5cGUuRW1wdHk6XG4gICAgICAgICAgICBjYXNlIDIgLyogSGFzaCAqLzpcbiAgICAgICAgICAgIGNhc2UgMyAvKiBRdWVyeSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlIYXNoO1xuICAgICAgICAgICAgY2FzZSA0IC8qIFJlbGF0aXZlUGF0aCAqLzoge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBjaGFyIGlzIGFsd2F5cyBhIFwiL1wiLCBhbmQgd2UgbmVlZCBpdCB0byBiZSByZWxhdGl2ZS5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gdXJsLnBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlIYXNoIHx8ICcuJztcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWxhdGl2ZShiYXNlIHx8IGlucHV0KSAmJiAhaXNSZWxhdGl2ZShwYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBiYXNlIHN0YXJ0ZWQgd2l0aCBhIGxlYWRpbmcgXCIuXCIsIG9yIHRoZXJlIGlzIG5vIGJhc2UgYW5kIGlucHV0IHN0YXJ0ZWQgd2l0aCBhIFwiLlwiLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHJlbGF0aXZlIHBhdGggc3RhcnRzIHdpdGggYSBcIi5cIi4gV2UgZG9uJ3Qga25vdyBpZlxuICAgICAgICAgICAgICAgICAgICAvLyByZWxhdGl2ZSBzdGFydHMgd2l0aCBhIFwiLi5cIiwgdGhvdWdoLCBzbyBjaGVjayBiZWZvcmUgcHJlcGVuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcuLycgKyBwYXRoICsgcXVlcnlIYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aCArIHF1ZXJ5SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNSAvKiBBYnNvbHV0ZVBhdGggKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybC5wYXRoICsgcXVlcnlIYXNoO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsLnNjaGVtZSArICcvLycgKyB1cmwudXNlciArIHVybC5ob3N0ICsgdXJsLnBvcnQgKyB1cmwucGF0aCArIHF1ZXJ5SGFzaDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLXVyaS51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js\n\n}");

/***/ },

/***/ "./node_modules/@jridgewell/source-map/dist/source-map.umd.js"
/*!********************************************************************!*\
  !*** ./node_modules/@jridgewell/source-map/dist/source-map.umd.js ***!
  \********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {

eval("{/* module decorator */ module = __webpack_require__.nmd(module);\n(function (global, factory) {\n  if (true) {\n    factory(module, __webpack_require__(/*! @jridgewell/gen-mapping */ \"./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js\"), __webpack_require__(/*! @jridgewell/trace-mapping */ \"./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js\"));\n    module.exports = def(module);\n  } else // removed by dead control flow\n{}\n  function def(m) { return 'default' in m.exports ? m.exports.default : m.exports; }\n})(this, (function (module, require_genMapping, require_traceMapping) {\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// umd:@jridgewell/trace-mapping\nvar require_trace_mapping = __commonJS({\n  \"umd:@jridgewell/trace-mapping\"(exports, module2) {\n    module2.exports = require_traceMapping;\n  }\n});\n\n// umd:@jridgewell/gen-mapping\nvar require_gen_mapping = __commonJS({\n  \"umd:@jridgewell/gen-mapping\"(exports, module2) {\n    module2.exports = require_genMapping;\n  }\n});\n\n// src/source-map.ts\nvar source_map_exports = {};\n__export(source_map_exports, {\n  SourceMapConsumer: () => SourceMapConsumer,\n  SourceMapGenerator: () => SourceMapGenerator\n});\nmodule.exports = __toCommonJS(source_map_exports);\nvar import_trace_mapping = __toESM(require_trace_mapping());\nvar import_gen_mapping = __toESM(require_gen_mapping());\nvar SourceMapConsumer = class _SourceMapConsumer {\n  constructor(map, mapUrl) {\n    const trace = this._map = new import_trace_mapping.AnyMap(map, mapUrl);\n    this.file = trace.file;\n    this.names = trace.names;\n    this.sourceRoot = trace.sourceRoot;\n    this.sources = trace.resolvedSources;\n    this.sourcesContent = trace.sourcesContent;\n    this.version = trace.version;\n  }\n  static fromSourceMap(map, mapUrl) {\n    if (map.toDecodedMap) {\n      return new _SourceMapConsumer(map.toDecodedMap(), mapUrl);\n    }\n    return new _SourceMapConsumer(map.toJSON(), mapUrl);\n  }\n  get mappings() {\n    return (0, import_trace_mapping.encodedMappings)(this._map);\n  }\n  originalPositionFor(needle) {\n    return (0, import_trace_mapping.originalPositionFor)(this._map, needle);\n  }\n  generatedPositionFor(originalPosition) {\n    return (0, import_trace_mapping.generatedPositionFor)(this._map, originalPosition);\n  }\n  allGeneratedPositionsFor(originalPosition) {\n    return (0, import_trace_mapping.allGeneratedPositionsFor)(this._map, originalPosition);\n  }\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent || this.sourcesContent.length !== this.sources.length) {\n      return false;\n    }\n    for (const content of this.sourcesContent) {\n      if (content == null) {\n        return false;\n      }\n    }\n    return true;\n  }\n  sourceContentFor(source, nullOnMissing) {\n    const sourceContent = (0, import_trace_mapping.sourceContentFor)(this._map, source);\n    if (sourceContent != null) {\n      return sourceContent;\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error(`\"${source}\" is not in the SourceMap.`);\n  }\n  eachMapping(callback, context) {\n    (0, import_trace_mapping.eachMapping)(this._map, context ? callback.bind(context) : callback);\n  }\n  destroy() {\n  }\n};\nvar SourceMapGenerator = class _SourceMapGenerator {\n  constructor(opts) {\n    this._map = opts instanceof import_gen_mapping.GenMapping ? opts : new import_gen_mapping.GenMapping(opts);\n  }\n  static fromSourceMap(consumer) {\n    return new _SourceMapGenerator((0, import_gen_mapping.fromMap)(consumer));\n  }\n  addMapping(mapping) {\n    (0, import_gen_mapping.maybeAddMapping)(this._map, mapping);\n  }\n  setSourceContent(source, content) {\n    (0, import_gen_mapping.setSourceContent)(this._map, source, content);\n  }\n  toJSON() {\n    return (0, import_gen_mapping.toEncodedMap)(this._map);\n  }\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n  toDecodedMap() {\n    return (0, import_gen_mapping.toDecodedMap)(this._map);\n  }\n};\n}));\n//# sourceMappingURL=source-map.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvc291cmNlLW1hcC9kaXN0L3NvdXJjZS1tYXAudW1kLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBLE1BQU0sSUFBNEQ7QUFDbEUsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQXlCLEdBQUcsbUJBQU8sQ0FBQyxxR0FBMkI7QUFDM0Y7QUFDQSxJQUFJLEtBQUs7QUFBQSxFQVVOO0FBQ0gsb0JBQW9CO0FBQ3BCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RpbnlzaGFkZS8uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9zb3VyY2UtbWFwL2Rpc3Qvc291cmNlLW1hcC51bWQuanM/ZDU3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmFjdG9yeShtb2R1bGUsIHJlcXVpcmUoJ0BqcmlkZ2V3ZWxsL2dlbi1tYXBwaW5nJyksIHJlcXVpcmUoJ0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcnKSk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWYobW9kdWxlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydtb2R1bGUnLCAnQGpyaWRnZXdlbGwvZ2VuLW1hcHBpbmcnLCAnQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZyddLCBmdW5jdGlvbihtb2QpIHtcbiAgICAgIGZhY3RvcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIG1vZC5leHBvcnRzID0gZGVmKG1vZCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbW9kID0geyBleHBvcnRzOiB7fSB9O1xuICAgIGZhY3RvcnkobW9kLCBnbG9iYWwuZ2VuTWFwcGluZywgZ2xvYmFsLnRyYWNlTWFwcGluZyk7XG4gICAgZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmO1xuICAgIGdsb2JhbC5zb3VyY2VNYXAgPSBkZWYobW9kKTtcbiAgfVxuICBmdW5jdGlvbiBkZWYobSkgeyByZXR1cm4gJ2RlZmF1bHQnIGluIG0uZXhwb3J0cyA/IG0uZXhwb3J0cy5kZWZhdWx0IDogbS5leHBvcnRzOyB9XG59KSh0aGlzLCAoZnVuY3Rpb24gKG1vZHVsZSwgcmVxdWlyZV9nZW5NYXBwaW5nLCByZXF1aXJlX3RyYWNlTWFwcGluZykge1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHVtZDpAanJpZGdld2VsbC90cmFjZS1tYXBwaW5nXG52YXIgcmVxdWlyZV90cmFjZV9tYXBwaW5nID0gX19jb21tb25KUyh7XG4gIFwidW1kOkBqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmdcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV90cmFjZU1hcHBpbmc7XG4gIH1cbn0pO1xuXG4vLyB1bWQ6QGpyaWRnZXdlbGwvZ2VuLW1hcHBpbmdcbnZhciByZXF1aXJlX2dlbl9tYXBwaW5nID0gX19jb21tb25KUyh7XG4gIFwidW1kOkBqcmlkZ2V3ZWxsL2dlbi1tYXBwaW5nXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHJlcXVpcmVfZ2VuTWFwcGluZztcbiAgfVxufSk7XG5cbi8vIHNyYy9zb3VyY2UtbWFwLnRzXG52YXIgc291cmNlX21hcF9leHBvcnRzID0ge307XG5fX2V4cG9ydChzb3VyY2VfbWFwX2V4cG9ydHMsIHtcbiAgU291cmNlTWFwQ29uc3VtZXI6ICgpID0+IFNvdXJjZU1hcENvbnN1bWVyLFxuICBTb3VyY2VNYXBHZW5lcmF0b3I6ICgpID0+IFNvdXJjZU1hcEdlbmVyYXRvclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzb3VyY2VfbWFwX2V4cG9ydHMpO1xudmFyIGltcG9ydF90cmFjZV9tYXBwaW5nID0gX190b0VTTShyZXF1aXJlX3RyYWNlX21hcHBpbmcoKSk7XG52YXIgaW1wb3J0X2dlbl9tYXBwaW5nID0gX190b0VTTShyZXF1aXJlX2dlbl9tYXBwaW5nKCkpO1xudmFyIFNvdXJjZU1hcENvbnN1bWVyID0gY2xhc3MgX1NvdXJjZU1hcENvbnN1bWVyIHtcbiAgY29uc3RydWN0b3IobWFwLCBtYXBVcmwpIHtcbiAgICBjb25zdCB0cmFjZSA9IHRoaXMuX21hcCA9IG5ldyBpbXBvcnRfdHJhY2VfbWFwcGluZy5BbnlNYXAobWFwLCBtYXBVcmwpO1xuICAgIHRoaXMuZmlsZSA9IHRyYWNlLmZpbGU7XG4gICAgdGhpcy5uYW1lcyA9IHRyYWNlLm5hbWVzO1xuICAgIHRoaXMuc291cmNlUm9vdCA9IHRyYWNlLnNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzID0gdHJhY2UucmVzb2x2ZWRTb3VyY2VzO1xuICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSB0cmFjZS5zb3VyY2VzQ29udGVudDtcbiAgICB0aGlzLnZlcnNpb24gPSB0cmFjZS52ZXJzaW9uO1xuICB9XG4gIHN0YXRpYyBmcm9tU291cmNlTWFwKG1hcCwgbWFwVXJsKSB7XG4gICAgaWYgKG1hcC50b0RlY29kZWRNYXApIHtcbiAgICAgIHJldHVybiBuZXcgX1NvdXJjZU1hcENvbnN1bWVyKG1hcC50b0RlY29kZWRNYXAoKSwgbWFwVXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfU291cmNlTWFwQ29uc3VtZXIobWFwLnRvSlNPTigpLCBtYXBVcmwpO1xuICB9XG4gIGdldCBtYXBwaW5ncygpIHtcbiAgICByZXR1cm4gKDAsIGltcG9ydF90cmFjZV9tYXBwaW5nLmVuY29kZWRNYXBwaW5ncykodGhpcy5fbWFwKTtcbiAgfVxuICBvcmlnaW5hbFBvc2l0aW9uRm9yKG5lZWRsZSkge1xuICAgIHJldHVybiAoMCwgaW1wb3J0X3RyYWNlX21hcHBpbmcub3JpZ2luYWxQb3NpdGlvbkZvcikodGhpcy5fbWFwLCBuZWVkbGUpO1xuICB9XG4gIGdlbmVyYXRlZFBvc2l0aW9uRm9yKG9yaWdpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gKDAsIGltcG9ydF90cmFjZV9tYXBwaW5nLmdlbmVyYXRlZFBvc2l0aW9uRm9yKSh0aGlzLl9tYXAsIG9yaWdpbmFsUG9zaXRpb24pO1xuICB9XG4gIGFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihvcmlnaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfdHJhY2VfbWFwcGluZy5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IpKHRoaXMuX21hcCwgb3JpZ2luYWxQb3NpdGlvbik7XG4gIH1cbiAgaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50IHx8IHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoICE9PSB0aGlzLnNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29udGVudCBvZiB0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc291cmNlQ29udGVudEZvcihzb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBjb25zdCBzb3VyY2VDb250ZW50ID0gKDAsIGltcG9ydF90cmFjZV9tYXBwaW5nLnNvdXJjZUNvbnRlbnRGb3IpKHRoaXMuX21hcCwgc291cmNlKTtcbiAgICBpZiAoc291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc291cmNlQ29udGVudDtcbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtzb3VyY2V9XCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuYCk7XG4gIH1cbiAgZWFjaE1hcHBpbmcoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAoMCwgaW1wb3J0X3RyYWNlX21hcHBpbmcuZWFjaE1hcHBpbmcpKHRoaXMuX21hcCwgY29udGV4dCA/IGNhbGxiYWNrLmJpbmQoY29udGV4dCkgOiBjYWxsYmFjayk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxufTtcbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSBjbGFzcyBfU291cmNlTWFwR2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMuX21hcCA9IG9wdHMgaW5zdGFuY2VvZiBpbXBvcnRfZ2VuX21hcHBpbmcuR2VuTWFwcGluZyA/IG9wdHMgOiBuZXcgaW1wb3J0X2dlbl9tYXBwaW5nLkdlbk1hcHBpbmcob3B0cyk7XG4gIH1cbiAgc3RhdGljIGZyb21Tb3VyY2VNYXAoY29uc3VtZXIpIHtcbiAgICByZXR1cm4gbmV3IF9Tb3VyY2VNYXBHZW5lcmF0b3IoKDAsIGltcG9ydF9nZW5fbWFwcGluZy5mcm9tTWFwKShjb25zdW1lcikpO1xuICB9XG4gIGFkZE1hcHBpbmcobWFwcGluZykge1xuICAgICgwLCBpbXBvcnRfZ2VuX21hcHBpbmcubWF5YmVBZGRNYXBwaW5nKSh0aGlzLl9tYXAsIG1hcHBpbmcpO1xuICB9XG4gIHNldFNvdXJjZUNvbnRlbnQoc291cmNlLCBjb250ZW50KSB7XG4gICAgKDAsIGltcG9ydF9nZW5fbWFwcGluZy5zZXRTb3VyY2VDb250ZW50KSh0aGlzLl9tYXAsIHNvdXJjZSwgY29udGVudCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiAoMCwgaW1wb3J0X2dlbl9tYXBwaW5nLnRvRW5jb2RlZE1hcCkodGhpcy5fbWFwKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gIH1cbiAgdG9EZWNvZGVkTWFwKCkge1xuICAgIHJldHVybiAoMCwgaW1wb3J0X2dlbl9tYXBwaW5nLnRvRGVjb2RlZE1hcCkodGhpcy5fbWFwKTtcbiAgfVxufTtcbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvdXJjZS1tYXAudW1kLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@jridgewell/source-map/dist/source-map.umd.js\n\n}");

/***/ },

/***/ "./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"
/*!******************************************************************************!*\
  !*** ./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js ***!
  \******************************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {

eval("{/* module decorator */ module = __webpack_require__.nmd(module);\n(function (global, factory) {\n  if (true) {\n    factory(module);\n    module.exports = def(module);\n  } else // removed by dead control flow\n{}\n  function def(m) { return 'default' in m.exports ? m.exports.default : m.exports; }\n})(this, (function (module) {\n\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/sourcemap-codec.ts\nvar sourcemap_codec_exports = {};\n__export(sourcemap_codec_exports, {\n  decode: () => decode,\n  decodeGeneratedRanges: () => decodeGeneratedRanges,\n  decodeOriginalScopes: () => decodeOriginalScopes,\n  encode: () => encode,\n  encodeGeneratedRanges: () => encodeGeneratedRanges,\n  encodeOriginalScopes: () => encodeOriginalScopes\n});\nmodule.exports = __toCommonJS(sourcemap_codec_exports);\n\n// src/vlq.ts\nvar comma = \",\".charCodeAt(0);\nvar semicolon = \";\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value & 1;\n  value >>>= 1;\n  if (shouldNegate) {\n    value = -2147483648 | -value;\n  }\n  return relative + value;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nfunction hasMoreVlq(reader, max) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n\n// src/strings.ts\nvar bufLength = 1024 * 16;\nvar td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nvar StringWriter = class {\n  constructor() {\n    this.pos = 0;\n    this.out = \"\";\n    this.buffer = new Uint8Array(bufLength);\n  }\n  write(v) {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n  flush() {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n};\nvar StringReader = class {\n  constructor(buffer) {\n    this.pos = 0;\n    this.buffer = buffer;\n  }\n  next() {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.pos);\n  }\n  indexOf(char) {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n};\n\n// src/scopes.ts\nvar EMPTY = [];\nfunction decodeOriginalScopes(input) {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes = [];\n  const stack = [];\n  let line = 0;\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop();\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 1;\n    const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];\n    let vars = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n    scopes.push(scope);\n    stack.push(scope);\n  }\n  return scopes;\n}\nfunction encodeOriginalScopes(scopes) {\n  const writer = new StringWriter();\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n  return writer.flush();\n}\nfunction _encodeOriginalScopes(scopes, index, writer, state) {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n  if (index > 0) writer.write(comma);\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n  const fields = scope.length === 6 ? 1 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n  return index;\n}\nfunction decodeGeneratedRanges(input) {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges = [];\n  const stack = [];\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    let genColumn = 0;\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop();\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 1;\n      const hasCallsite = fields & 2;\n      const hasScope = fields & 4;\n      let callsite = null;\n      let bindings = EMPTY;\n      let range;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0\n        );\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];\n      } else {\n        range = [genLine, genColumn, 0, 0];\n      }\n      range.isScope = !!hasScope;\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0\n        );\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges;\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n      ranges.push(range);\n      stack.push(range);\n    }\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n  return ranges;\n}\nfunction encodeGeneratedRanges(ranges) {\n  if (ranges.length === 0) return \"\";\n  const writer = new StringWriter();\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n  return writer.flush();\n}\nfunction _encodeGeneratedRanges(ranges, index, writer, state) {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings\n  } = range;\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, range[1], state[1]);\n  const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);\n  encodeInteger(writer, fields, 0);\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);\n        encodeInteger(writer, expRange[0], 0);\n      }\n    }\n  }\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n  return index;\n}\nfunction catchupLine(writer, lastLine, line) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n\n// src/sourcemap-codec.ts\nfunction decode(mappings) {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    const line = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n    while (reader.pos < semi) {\n      let seg;\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n      line.push(seg);\n      reader.pos++;\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n  return decoded;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\n}));\n//# sourceMappingURL=sourcemap-codec.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjL2Rpc3Qvc291cmNlbWFwLWNvZGVjLnVtZC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQSxNQUFNLElBQTREO0FBQ2xFO0FBQ0E7QUFDQSxJQUFJLEtBQUs7QUFBQSxFQVVOO0FBQ0gsb0JBQW9CO0FBQ3BCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0VBQXdFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RpbnlzaGFkZS8uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMvZGlzdC9zb3VyY2VtYXAtY29kZWMudW1kLmpzP2ZiZTQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZhY3RvcnkobW9kdWxlKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZihtb2R1bGUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ21vZHVsZSddLCBmdW5jdGlvbihtb2QpIHtcbiAgICAgIGZhY3RvcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIG1vZC5leHBvcnRzID0gZGVmKG1vZCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbW9kID0geyBleHBvcnRzOiB7fSB9O1xuICAgIGZhY3RvcnkobW9kKTtcbiAgICBnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGY7XG4gICAgZ2xvYmFsLnNvdXJjZW1hcENvZGVjID0gZGVmKG1vZCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVmKG0pIHsgcmV0dXJuICdkZWZhdWx0JyBpbiBtLmV4cG9ydHMgPyBtLmV4cG9ydHMuZGVmYXVsdCA6IG0uZXhwb3J0czsgfVxufSkodGhpcywgKGZ1bmN0aW9uIChtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL3NvdXJjZW1hcC1jb2RlYy50c1xudmFyIHNvdXJjZW1hcF9jb2RlY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzb3VyY2VtYXBfY29kZWNfZXhwb3J0cywge1xuICBkZWNvZGU6ICgpID0+IGRlY29kZSxcbiAgZGVjb2RlR2VuZXJhdGVkUmFuZ2VzOiAoKSA9PiBkZWNvZGVHZW5lcmF0ZWRSYW5nZXMsXG4gIGRlY29kZU9yaWdpbmFsU2NvcGVzOiAoKSA9PiBkZWNvZGVPcmlnaW5hbFNjb3BlcyxcbiAgZW5jb2RlOiAoKSA9PiBlbmNvZGUsXG4gIGVuY29kZUdlbmVyYXRlZFJhbmdlczogKCkgPT4gZW5jb2RlR2VuZXJhdGVkUmFuZ2VzLFxuICBlbmNvZGVPcmlnaW5hbFNjb3BlczogKCkgPT4gZW5jb2RlT3JpZ2luYWxTY29wZXNcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc291cmNlbWFwX2NvZGVjX2V4cG9ydHMpO1xuXG4vLyBzcmMvdmxxLnRzXG52YXIgY29tbWEgPSBcIixcIi5jaGFyQ29kZUF0KDApO1xudmFyIHNlbWljb2xvbiA9IFwiO1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbnZhciBpbnRUb0NoYXIgPSBuZXcgVWludDhBcnJheSg2NCk7XG52YXIgY2hhclRvSW50ID0gbmV3IFVpbnQ4QXJyYXkoMTI4KTtcbmZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgYyA9IGNoYXJzLmNoYXJDb2RlQXQoaSk7XG4gIGludFRvQ2hhcltpXSA9IGM7XG4gIGNoYXJUb0ludFtjXSA9IGk7XG59XG5mdW5jdGlvbiBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgcmVsYXRpdmUpIHtcbiAgbGV0IHZhbHVlID0gMDtcbiAgbGV0IHNoaWZ0ID0gMDtcbiAgbGV0IGludGVnZXIgPSAwO1xuICBkbyB7XG4gICAgY29uc3QgYyA9IHJlYWRlci5uZXh0KCk7XG4gICAgaW50ZWdlciA9IGNoYXJUb0ludFtjXTtcbiAgICB2YWx1ZSB8PSAoaW50ZWdlciAmIDMxKSA8PCBzaGlmdDtcbiAgICBzaGlmdCArPSA1O1xuICB9IHdoaWxlIChpbnRlZ2VyICYgMzIpO1xuICBjb25zdCBzaG91bGROZWdhdGUgPSB2YWx1ZSAmIDE7XG4gIHZhbHVlID4+Pj0gMTtcbiAgaWYgKHNob3VsZE5lZ2F0ZSkge1xuICAgIHZhbHVlID0gLTIxNDc0ODM2NDggfCAtdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlbGF0aXZlICsgdmFsdWU7XG59XG5mdW5jdGlvbiBlbmNvZGVJbnRlZ2VyKGJ1aWxkZXIsIG51bSwgcmVsYXRpdmUpIHtcbiAgbGV0IGRlbHRhID0gbnVtIC0gcmVsYXRpdmU7XG4gIGRlbHRhID0gZGVsdGEgPCAwID8gLWRlbHRhIDw8IDEgfCAxIDogZGVsdGEgPDwgMTtcbiAgZG8ge1xuICAgIGxldCBjbGFtcGVkID0gZGVsdGEgJiAzMTtcbiAgICBkZWx0YSA+Pj49IDU7XG4gICAgaWYgKGRlbHRhID4gMCkgY2xhbXBlZCB8PSAzMjtcbiAgICBidWlsZGVyLndyaXRlKGludFRvQ2hhcltjbGFtcGVkXSk7XG4gIH0gd2hpbGUgKGRlbHRhID4gMCk7XG4gIHJldHVybiBudW07XG59XG5mdW5jdGlvbiBoYXNNb3JlVmxxKHJlYWRlciwgbWF4KSB7XG4gIGlmIChyZWFkZXIucG9zID49IG1heCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gcmVhZGVyLnBlZWsoKSAhPT0gY29tbWE7XG59XG5cbi8vIHNyYy9zdHJpbmdzLnRzXG52YXIgYnVmTGVuZ3RoID0gMTAyNCAqIDE2O1xudmFyIHRkID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiID8gLyogQF9fUFVSRV9fICovIG5ldyBUZXh0RGVjb2RlcigpIDogdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiA/IHtcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGNvbnN0IG91dCA9IEJ1ZmZlci5mcm9tKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIG91dC50b1N0cmluZygpO1xuICB9XG59IDoge1xuICBkZWNvZGUoYnVmKSB7XG4gICAgbGV0IG91dCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn07XG52YXIgU3RyaW5nV3JpdGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5vdXQgPSBcIlwiO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmTGVuZ3RoKTtcbiAgfVxuICB3cml0ZSh2KSB7XG4gICAgY29uc3QgeyBidWZmZXIgfSA9IHRoaXM7XG4gICAgYnVmZmVyW3RoaXMucG9zKytdID0gdjtcbiAgICBpZiAodGhpcy5wb3MgPT09IGJ1Zkxlbmd0aCkge1xuICAgICAgdGhpcy5vdXQgKz0gdGQuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHsgYnVmZmVyLCBvdXQsIHBvcyB9ID0gdGhpcztcbiAgICByZXR1cm4gcG9zID4gMCA/IG91dCArIHRkLmRlY29kZShidWZmZXIuc3ViYXJyYXkoMCwgcG9zKSkgOiBvdXQ7XG4gIH1cbn07XG52YXIgU3RyaW5nUmVhZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuY2hhckNvZGVBdCh0aGlzLnBvcysrKTtcbiAgfVxuICBwZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgfVxuICBpbmRleE9mKGNoYXIpIHtcbiAgICBjb25zdCB7IGJ1ZmZlciwgcG9zIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlkeCA9IGJ1ZmZlci5pbmRleE9mKGNoYXIsIHBvcyk7XG4gICAgcmV0dXJuIGlkeCA9PT0gLTEgPyBidWZmZXIubGVuZ3RoIDogaWR4O1xuICB9XG59O1xuXG4vLyBzcmMvc2NvcGVzLnRzXG52YXIgRU1QVFkgPSBbXTtcbmZ1bmN0aW9uIGRlY29kZU9yaWdpbmFsU2NvcGVzKGlucHV0KSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBpbnB1dDtcbiAgY29uc3QgcmVhZGVyID0gbmV3IFN0cmluZ1JlYWRlcihpbnB1dCk7XG4gIGNvbnN0IHNjb3BlcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgbGluZSA9IDA7XG4gIGZvciAoOyByZWFkZXIucG9zIDwgbGVuZ3RoOyByZWFkZXIucG9zKyspIHtcbiAgICBsaW5lID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIGxpbmUpO1xuICAgIGNvbnN0IGNvbHVtbiA9IGRlY29kZUludGVnZXIocmVhZGVyLCAwKTtcbiAgICBpZiAoIWhhc01vcmVWbHEocmVhZGVyLCBsZW5ndGgpKSB7XG4gICAgICBjb25zdCBsYXN0ID0gc3RhY2sucG9wKCk7XG4gICAgICBsYXN0WzJdID0gbGluZTtcbiAgICAgIGxhc3RbM10gPSBjb2x1bW47XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga2luZCA9IGRlY29kZUludGVnZXIocmVhZGVyLCAwKTtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgY29uc3QgaGFzTmFtZSA9IGZpZWxkcyAmIDE7XG4gICAgY29uc3Qgc2NvcGUgPSBoYXNOYW1lID8gW2xpbmUsIGNvbHVtbiwgMCwgMCwga2luZCwgZGVjb2RlSW50ZWdlcihyZWFkZXIsIDApXSA6IFtsaW5lLCBjb2x1bW4sIDAsIDAsIGtpbmRdO1xuICAgIGxldCB2YXJzID0gRU1QVFk7XG4gICAgaWYgKGhhc01vcmVWbHEocmVhZGVyLCBsZW5ndGgpKSB7XG4gICAgICB2YXJzID0gW107XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IHZhcnNJbmRleCA9IGRlY29kZUludGVnZXIocmVhZGVyLCAwKTtcbiAgICAgICAgdmFycy5wdXNoKHZhcnNJbmRleCk7XG4gICAgICB9IHdoaWxlIChoYXNNb3JlVmxxKHJlYWRlciwgbGVuZ3RoKSk7XG4gICAgfVxuICAgIHNjb3BlLnZhcnMgPSB2YXJzO1xuICAgIHNjb3Blcy5wdXNoKHNjb3BlKTtcbiAgICBzdGFjay5wdXNoKHNjb3BlKTtcbiAgfVxuICByZXR1cm4gc2NvcGVzO1xufVxuZnVuY3Rpb24gZW5jb2RlT3JpZ2luYWxTY29wZXMoc2NvcGVzKSB7XG4gIGNvbnN0IHdyaXRlciA9IG5ldyBTdHJpbmdXcml0ZXIoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY29wZXMubGVuZ3RoOyApIHtcbiAgICBpID0gX2VuY29kZU9yaWdpbmFsU2NvcGVzKHNjb3BlcywgaSwgd3JpdGVyLCBbMF0pO1xuICB9XG4gIHJldHVybiB3cml0ZXIuZmx1c2goKTtcbn1cbmZ1bmN0aW9uIF9lbmNvZGVPcmlnaW5hbFNjb3BlcyhzY29wZXMsIGluZGV4LCB3cml0ZXIsIHN0YXRlKSB7XG4gIGNvbnN0IHNjb3BlID0gc2NvcGVzW2luZGV4XTtcbiAgY29uc3QgeyAwOiBzdGFydExpbmUsIDE6IHN0YXJ0Q29sdW1uLCAyOiBlbmRMaW5lLCAzOiBlbmRDb2x1bW4sIDQ6IGtpbmQsIHZhcnMgfSA9IHNjb3BlO1xuICBpZiAoaW5kZXggPiAwKSB3cml0ZXIud3JpdGUoY29tbWEpO1xuICBzdGF0ZVswXSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzdGFydExpbmUsIHN0YXRlWzBdKTtcbiAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIHN0YXJ0Q29sdW1uLCAwKTtcbiAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIGtpbmQsIDApO1xuICBjb25zdCBmaWVsZHMgPSBzY29wZS5sZW5ndGggPT09IDYgPyAxIDogMDtcbiAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIGZpZWxkcywgMCk7XG4gIGlmIChzY29wZS5sZW5ndGggPT09IDYpIGVuY29kZUludGVnZXIod3JpdGVyLCBzY29wZVs1XSwgMCk7XG4gIGZvciAoY29uc3QgdiBvZiB2YXJzKSB7XG4gICAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIHYsIDApO1xuICB9XG4gIGZvciAoaW5kZXgrKzsgaW5kZXggPCBzY29wZXMubGVuZ3RoOyApIHtcbiAgICBjb25zdCBuZXh0ID0gc2NvcGVzW2luZGV4XTtcbiAgICBjb25zdCB7IDA6IGwsIDE6IGMgfSA9IG5leHQ7XG4gICAgaWYgKGwgPiBlbmRMaW5lIHx8IGwgPT09IGVuZExpbmUgJiYgYyA+PSBlbmRDb2x1bW4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCA9IF9lbmNvZGVPcmlnaW5hbFNjb3BlcyhzY29wZXMsIGluZGV4LCB3cml0ZXIsIHN0YXRlKTtcbiAgfVxuICB3cml0ZXIud3JpdGUoY29tbWEpO1xuICBzdGF0ZVswXSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBlbmRMaW5lLCBzdGF0ZVswXSk7XG4gIGVuY29kZUludGVnZXIod3JpdGVyLCBlbmRDb2x1bW4sIDApO1xuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBkZWNvZGVHZW5lcmF0ZWRSYW5nZXMoaW5wdXQpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGlucHV0O1xuICBjb25zdCByZWFkZXIgPSBuZXcgU3RyaW5nUmVhZGVyKGlucHV0KTtcbiAgY29uc3QgcmFuZ2VzID0gW107XG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGxldCBnZW5MaW5lID0gMDtcbiAgbGV0IGRlZmluaXRpb25Tb3VyY2VzSW5kZXggPSAwO1xuICBsZXQgZGVmaW5pdGlvblNjb3BlSW5kZXggPSAwO1xuICBsZXQgY2FsbHNpdGVTb3VyY2VzSW5kZXggPSAwO1xuICBsZXQgY2FsbHNpdGVMaW5lID0gMDtcbiAgbGV0IGNhbGxzaXRlQ29sdW1uID0gMDtcbiAgbGV0IGJpbmRpbmdMaW5lID0gMDtcbiAgbGV0IGJpbmRpbmdDb2x1bW4gPSAwO1xuICBkbyB7XG4gICAgY29uc3Qgc2VtaSA9IHJlYWRlci5pbmRleE9mKFwiO1wiKTtcbiAgICBsZXQgZ2VuQ29sdW1uID0gMDtcbiAgICBmb3IgKDsgcmVhZGVyLnBvcyA8IHNlbWk7IHJlYWRlci5wb3MrKykge1xuICAgICAgZ2VuQ29sdW1uID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIGdlbkNvbHVtbik7XG4gICAgICBpZiAoIWhhc01vcmVWbHEocmVhZGVyLCBzZW1pKSkge1xuICAgICAgICBjb25zdCBsYXN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGxhc3RbMl0gPSBnZW5MaW5lO1xuICAgICAgICBsYXN0WzNdID0gZ2VuQ29sdW1uO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZUludGVnZXIocmVhZGVyLCAwKTtcbiAgICAgIGNvbnN0IGhhc0RlZmluaXRpb24gPSBmaWVsZHMgJiAxO1xuICAgICAgY29uc3QgaGFzQ2FsbHNpdGUgPSBmaWVsZHMgJiAyO1xuICAgICAgY29uc3QgaGFzU2NvcGUgPSBmaWVsZHMgJiA0O1xuICAgICAgbGV0IGNhbGxzaXRlID0gbnVsbDtcbiAgICAgIGxldCBiaW5kaW5ncyA9IEVNUFRZO1xuICAgICAgbGV0IHJhbmdlO1xuICAgICAgaWYgKGhhc0RlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3QgZGVmU291cmNlc0luZGV4ID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIGRlZmluaXRpb25Tb3VyY2VzSW5kZXgpO1xuICAgICAgICBkZWZpbml0aW9uU2NvcGVJbmRleCA9IGRlY29kZUludGVnZXIoXG4gICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgIGRlZmluaXRpb25Tb3VyY2VzSW5kZXggPT09IGRlZlNvdXJjZXNJbmRleCA/IGRlZmluaXRpb25TY29wZUluZGV4IDogMFxuICAgICAgICApO1xuICAgICAgICBkZWZpbml0aW9uU291cmNlc0luZGV4ID0gZGVmU291cmNlc0luZGV4O1xuICAgICAgICByYW5nZSA9IFtnZW5MaW5lLCBnZW5Db2x1bW4sIDAsIDAsIGRlZlNvdXJjZXNJbmRleCwgZGVmaW5pdGlvblNjb3BlSW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBbZ2VuTGluZSwgZ2VuQ29sdW1uLCAwLCAwXTtcbiAgICAgIH1cbiAgICAgIHJhbmdlLmlzU2NvcGUgPSAhIWhhc1Njb3BlO1xuICAgICAgaWYgKGhhc0NhbGxzaXRlKSB7XG4gICAgICAgIGNvbnN0IHByZXZDc2kgPSBjYWxsc2l0ZVNvdXJjZXNJbmRleDtcbiAgICAgICAgY29uc3QgcHJldkxpbmUgPSBjYWxsc2l0ZUxpbmU7XG4gICAgICAgIGNhbGxzaXRlU291cmNlc0luZGV4ID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIGNhbGxzaXRlU291cmNlc0luZGV4KTtcbiAgICAgICAgY29uc3Qgc2FtZVNvdXJjZSA9IHByZXZDc2kgPT09IGNhbGxzaXRlU291cmNlc0luZGV4O1xuICAgICAgICBjYWxsc2l0ZUxpbmUgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgc2FtZVNvdXJjZSA/IGNhbGxzaXRlTGluZSA6IDApO1xuICAgICAgICBjYWxsc2l0ZUNvbHVtbiA9IGRlY29kZUludGVnZXIoXG4gICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgIHNhbWVTb3VyY2UgJiYgcHJldkxpbmUgPT09IGNhbGxzaXRlTGluZSA/IGNhbGxzaXRlQ29sdW1uIDogMFxuICAgICAgICApO1xuICAgICAgICBjYWxsc2l0ZSA9IFtjYWxsc2l0ZVNvdXJjZXNJbmRleCwgY2FsbHNpdGVMaW5lLCBjYWxsc2l0ZUNvbHVtbl07XG4gICAgICB9XG4gICAgICByYW5nZS5jYWxsc2l0ZSA9IGNhbGxzaXRlO1xuICAgICAgaWYgKGhhc01vcmVWbHEocmVhZGVyLCBzZW1pKSkge1xuICAgICAgICBiaW5kaW5ncyA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgYmluZGluZ0xpbmUgPSBnZW5MaW5lO1xuICAgICAgICAgIGJpbmRpbmdDb2x1bW4gPSBnZW5Db2x1bW47XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbnNDb3VudCA9IGRlY29kZUludGVnZXIocmVhZGVyLCAwKTtcbiAgICAgICAgICBsZXQgZXhwcmVzc2lvblJhbmdlcztcbiAgICAgICAgICBpZiAoZXhwcmVzc2lvbnNDb3VudCA8IC0xKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uUmFuZ2VzID0gW1tkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCldXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAtMTsgaSA+IGV4cHJlc3Npb25zQ291bnQ7IGktLSkge1xuICAgICAgICAgICAgICBjb25zdCBwcmV2QmwgPSBiaW5kaW5nTGluZTtcbiAgICAgICAgICAgICAgYmluZGluZ0xpbmUgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgYmluZGluZ0xpbmUpO1xuICAgICAgICAgICAgICBiaW5kaW5nQ29sdW1uID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIGJpbmRpbmdMaW5lID09PSBwcmV2QmwgPyBiaW5kaW5nQ29sdW1uIDogMCk7XG4gICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb25SYW5nZXMucHVzaChbZXhwcmVzc2lvbiwgYmluZGluZ0xpbmUsIGJpbmRpbmdDb2x1bW5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwcmVzc2lvblJhbmdlcyA9IFtbZXhwcmVzc2lvbnNDb3VudF1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaW5kaW5ncy5wdXNoKGV4cHJlc3Npb25SYW5nZXMpO1xuICAgICAgICB9IHdoaWxlIChoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpO1xuICAgICAgfVxuICAgICAgcmFuZ2UuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgIHN0YWNrLnB1c2gocmFuZ2UpO1xuICAgIH1cbiAgICBnZW5MaW5lKys7XG4gICAgcmVhZGVyLnBvcyA9IHNlbWkgKyAxO1xuICB9IHdoaWxlIChyZWFkZXIucG9zIDwgbGVuZ3RoKTtcbiAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGVuY29kZUdlbmVyYXRlZFJhbmdlcyhyYW5nZXMpIHtcbiAgaWYgKHJhbmdlcy5sZW5ndGggPT09IDApIHJldHVybiBcIlwiO1xuICBjb25zdCB3cml0ZXIgPSBuZXcgU3RyaW5nV3JpdGVyKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgKSB7XG4gICAgaSA9IF9lbmNvZGVHZW5lcmF0ZWRSYW5nZXMocmFuZ2VzLCBpLCB3cml0ZXIsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gIH1cbiAgcmV0dXJuIHdyaXRlci5mbHVzaCgpO1xufVxuZnVuY3Rpb24gX2VuY29kZUdlbmVyYXRlZFJhbmdlcyhyYW5nZXMsIGluZGV4LCB3cml0ZXIsIHN0YXRlKSB7XG4gIGNvbnN0IHJhbmdlID0gcmFuZ2VzW2luZGV4XTtcbiAgY29uc3Qge1xuICAgIDA6IHN0YXJ0TGluZSxcbiAgICAxOiBzdGFydENvbHVtbixcbiAgICAyOiBlbmRMaW5lLFxuICAgIDM6IGVuZENvbHVtbixcbiAgICBpc1Njb3BlLFxuICAgIGNhbGxzaXRlLFxuICAgIGJpbmRpbmdzXG4gIH0gPSByYW5nZTtcbiAgaWYgKHN0YXRlWzBdIDwgc3RhcnRMaW5lKSB7XG4gICAgY2F0Y2h1cExpbmUod3JpdGVyLCBzdGF0ZVswXSwgc3RhcnRMaW5lKTtcbiAgICBzdGF0ZVswXSA9IHN0YXJ0TGluZTtcbiAgICBzdGF0ZVsxXSA9IDA7XG4gIH0gZWxzZSBpZiAoaW5kZXggPiAwKSB7XG4gICAgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgfVxuICBzdGF0ZVsxXSA9IGVuY29kZUludGVnZXIod3JpdGVyLCByYW5nZVsxXSwgc3RhdGVbMV0pO1xuICBjb25zdCBmaWVsZHMgPSAocmFuZ2UubGVuZ3RoID09PSA2ID8gMSA6IDApIHwgKGNhbGxzaXRlID8gMiA6IDApIHwgKGlzU2NvcGUgPyA0IDogMCk7XG4gIGVuY29kZUludGVnZXIod3JpdGVyLCBmaWVsZHMsIDApO1xuICBpZiAocmFuZ2UubGVuZ3RoID09PSA2KSB7XG4gICAgY29uc3QgeyA0OiBzb3VyY2VzSW5kZXgsIDU6IHNjb3Blc0luZGV4IH0gPSByYW5nZTtcbiAgICBpZiAoc291cmNlc0luZGV4ICE9PSBzdGF0ZVsyXSkge1xuICAgICAgc3RhdGVbM10gPSAwO1xuICAgIH1cbiAgICBzdGF0ZVsyXSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzb3VyY2VzSW5kZXgsIHN0YXRlWzJdKTtcbiAgICBzdGF0ZVszXSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzY29wZXNJbmRleCwgc3RhdGVbM10pO1xuICB9XG4gIGlmIChjYWxsc2l0ZSkge1xuICAgIGNvbnN0IHsgMDogc291cmNlc0luZGV4LCAxOiBjYWxsTGluZSwgMjogY2FsbENvbHVtbiB9ID0gcmFuZ2UuY2FsbHNpdGU7XG4gICAgaWYgKHNvdXJjZXNJbmRleCAhPT0gc3RhdGVbNF0pIHtcbiAgICAgIHN0YXRlWzVdID0gMDtcbiAgICAgIHN0YXRlWzZdID0gMDtcbiAgICB9IGVsc2UgaWYgKGNhbGxMaW5lICE9PSBzdGF0ZVs1XSkge1xuICAgICAgc3RhdGVbNl0gPSAwO1xuICAgIH1cbiAgICBzdGF0ZVs0XSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzb3VyY2VzSW5kZXgsIHN0YXRlWzRdKTtcbiAgICBzdGF0ZVs1XSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBjYWxsTGluZSwgc3RhdGVbNV0pO1xuICAgIHN0YXRlWzZdID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIGNhbGxDb2x1bW4sIHN0YXRlWzZdKTtcbiAgfVxuICBpZiAoYmluZGluZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgYmluZGluZ3MpIHtcbiAgICAgIGlmIChiaW5kaW5nLmxlbmd0aCA+IDEpIGVuY29kZUludGVnZXIod3JpdGVyLCAtYmluZGluZy5sZW5ndGgsIDApO1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGJpbmRpbmdbMF1bMF07XG4gICAgICBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZXhwcmVzc2lvbiwgMCk7XG4gICAgICBsZXQgYmluZGluZ1N0YXJ0TGluZSA9IHN0YXJ0TGluZTtcbiAgICAgIGxldCBiaW5kaW5nU3RhcnRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYmluZGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBleHBSYW5nZSA9IGJpbmRpbmdbaV07XG4gICAgICAgIGJpbmRpbmdTdGFydExpbmUgPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZXhwUmFuZ2VbMV0sIGJpbmRpbmdTdGFydExpbmUpO1xuICAgICAgICBiaW5kaW5nU3RhcnRDb2x1bW4gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZXhwUmFuZ2VbMl0sIGJpbmRpbmdTdGFydENvbHVtbik7XG4gICAgICAgIGVuY29kZUludGVnZXIod3JpdGVyLCBleHBSYW5nZVswXSwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoaW5kZXgrKzsgaW5kZXggPCByYW5nZXMubGVuZ3RoOyApIHtcbiAgICBjb25zdCBuZXh0ID0gcmFuZ2VzW2luZGV4XTtcbiAgICBjb25zdCB7IDA6IGwsIDE6IGMgfSA9IG5leHQ7XG4gICAgaWYgKGwgPiBlbmRMaW5lIHx8IGwgPT09IGVuZExpbmUgJiYgYyA+PSBlbmRDb2x1bW4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCA9IF9lbmNvZGVHZW5lcmF0ZWRSYW5nZXMocmFuZ2VzLCBpbmRleCwgd3JpdGVyLCBzdGF0ZSk7XG4gIH1cbiAgaWYgKHN0YXRlWzBdIDwgZW5kTGluZSkge1xuICAgIGNhdGNodXBMaW5lKHdyaXRlciwgc3RhdGVbMF0sIGVuZExpbmUpO1xuICAgIHN0YXRlWzBdID0gZW5kTGluZTtcbiAgICBzdGF0ZVsxXSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgfVxuICBzdGF0ZVsxXSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBlbmRDb2x1bW4sIHN0YXRlWzFdKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gY2F0Y2h1cExpbmUod3JpdGVyLCBsYXN0TGluZSwgbGluZSkge1xuICBkbyB7XG4gICAgd3JpdGVyLndyaXRlKHNlbWljb2xvbik7XG4gIH0gd2hpbGUgKCsrbGFzdExpbmUgPCBsaW5lKTtcbn1cblxuLy8gc3JjL3NvdXJjZW1hcC1jb2RlYy50c1xuZnVuY3Rpb24gZGVjb2RlKG1hcHBpbmdzKSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBtYXBwaW5ncztcbiAgY29uc3QgcmVhZGVyID0gbmV3IFN0cmluZ1JlYWRlcihtYXBwaW5ncyk7XG4gIGNvbnN0IGRlY29kZWQgPSBbXTtcbiAgbGV0IGdlbkNvbHVtbiA9IDA7XG4gIGxldCBzb3VyY2VzSW5kZXggPSAwO1xuICBsZXQgc291cmNlTGluZSA9IDA7XG4gIGxldCBzb3VyY2VDb2x1bW4gPSAwO1xuICBsZXQgbmFtZXNJbmRleCA9IDA7XG4gIGRvIHtcbiAgICBjb25zdCBzZW1pID0gcmVhZGVyLmluZGV4T2YoXCI7XCIpO1xuICAgIGNvbnN0IGxpbmUgPSBbXTtcbiAgICBsZXQgc29ydGVkID0gdHJ1ZTtcbiAgICBsZXQgbGFzdENvbCA9IDA7XG4gICAgZ2VuQ29sdW1uID0gMDtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IHNlbWkpIHtcbiAgICAgIGxldCBzZWc7XG4gICAgICBnZW5Db2x1bW4gPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgZ2VuQ29sdW1uKTtcbiAgICAgIGlmIChnZW5Db2x1bW4gPCBsYXN0Q29sKSBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgIGxhc3RDb2wgPSBnZW5Db2x1bW47XG4gICAgICBpZiAoaGFzTW9yZVZscShyZWFkZXIsIHNlbWkpKSB7XG4gICAgICAgIHNvdXJjZXNJbmRleCA9IGRlY29kZUludGVnZXIocmVhZGVyLCBzb3VyY2VzSW5kZXgpO1xuICAgICAgICBzb3VyY2VMaW5lID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHNvdXJjZUxpbmUpO1xuICAgICAgICBzb3VyY2VDb2x1bW4gPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgc291cmNlQ29sdW1uKTtcbiAgICAgICAgaWYgKGhhc01vcmVWbHEocmVhZGVyLCBzZW1pKSkge1xuICAgICAgICAgIG5hbWVzSW5kZXggPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgbmFtZXNJbmRleCk7XG4gICAgICAgICAgc2VnID0gW2dlbkNvbHVtbiwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWVzSW5kZXhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZyA9IFtnZW5Db2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VnID0gW2dlbkNvbHVtbl07XG4gICAgICB9XG4gICAgICBsaW5lLnB1c2goc2VnKTtcbiAgICAgIHJlYWRlci5wb3MrKztcbiAgICB9XG4gICAgaWYgKCFzb3J0ZWQpIHNvcnQobGluZSk7XG4gICAgZGVjb2RlZC5wdXNoKGxpbmUpO1xuICAgIHJlYWRlci5wb3MgPSBzZW1pICsgMTtcbiAgfSB3aGlsZSAocmVhZGVyLnBvcyA8PSBsZW5ndGgpO1xuICByZXR1cm4gZGVjb2RlZDtcbn1cbmZ1bmN0aW9uIHNvcnQobGluZSkge1xuICBsaW5lLnNvcnQoc29ydENvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gc29ydENvbXBhcmF0b3IoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF07XG59XG5mdW5jdGlvbiBlbmNvZGUoZGVjb2RlZCkge1xuICBjb25zdCB3cml0ZXIgPSBuZXcgU3RyaW5nV3JpdGVyKCk7XG4gIGxldCBzb3VyY2VzSW5kZXggPSAwO1xuICBsZXQgc291cmNlTGluZSA9IDA7XG4gIGxldCBzb3VyY2VDb2x1bW4gPSAwO1xuICBsZXQgbmFtZXNJbmRleCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgIGlmIChpID4gMCkgd3JpdGVyLndyaXRlKHNlbWljb2xvbik7XG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICBsZXQgZ2VuQ29sdW1uID0gMDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHNlZ21lbnQgPSBsaW5lW2pdO1xuICAgICAgaWYgKGogPiAwKSB3cml0ZXIud3JpdGUoY29tbWEpO1xuICAgICAgZ2VuQ29sdW1uID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNlZ21lbnRbMF0sIGdlbkNvbHVtbik7XG4gICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDEpIGNvbnRpbnVlO1xuICAgICAgc291cmNlc0luZGV4ID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNlZ21lbnRbMV0sIHNvdXJjZXNJbmRleCk7XG4gICAgICBzb3VyY2VMaW5lID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNlZ21lbnRbMl0sIHNvdXJjZUxpbmUpO1xuICAgICAgc291cmNlQ29sdW1uID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNlZ21lbnRbM10sIHNvdXJjZUNvbHVtbik7XG4gICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDQpIGNvbnRpbnVlO1xuICAgICAgbmFtZXNJbmRleCA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzRdLCBuYW1lc0luZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdyaXRlci5mbHVzaCgpO1xufVxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c291cmNlbWFwLWNvZGVjLnVtZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js\n\n}");

/***/ },

/***/ "./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"
/*!**************************************************************************!*\
  !*** ./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js ***!
  \**************************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {

eval("{/* module decorator */ module = __webpack_require__.nmd(module);\n(function (global, factory) {\n  if (true) {\n    factory(module, __webpack_require__(/*! @jridgewell/resolve-uri */ \"./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js\"), __webpack_require__(/*! @jridgewell/sourcemap-codec */ \"./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js\"));\n    module.exports = def(module);\n  } else // removed by dead control flow\n{}\n  function def(m) { return 'default' in m.exports ? m.exports.default : m.exports; }\n})(this, (function (module, require_resolveURI, require_sourcemapCodec) {\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// umd:@jridgewell/sourcemap-codec\nvar require_sourcemap_codec = __commonJS({\n  \"umd:@jridgewell/sourcemap-codec\"(exports, module2) {\n    module2.exports = require_sourcemapCodec;\n  }\n});\n\n// umd:@jridgewell/resolve-uri\nvar require_resolve_uri = __commonJS({\n  \"umd:@jridgewell/resolve-uri\"(exports, module2) {\n    module2.exports = require_resolveURI;\n  }\n});\n\n// src/trace-mapping.ts\nvar trace_mapping_exports = {};\n__export(trace_mapping_exports, {\n  AnyMap: () => FlattenMap,\n  FlattenMap: () => FlattenMap,\n  GREATEST_LOWER_BOUND: () => GREATEST_LOWER_BOUND,\n  LEAST_UPPER_BOUND: () => LEAST_UPPER_BOUND,\n  TraceMap: () => TraceMap,\n  allGeneratedPositionsFor: () => allGeneratedPositionsFor,\n  decodedMap: () => decodedMap,\n  decodedMappings: () => decodedMappings,\n  eachMapping: () => eachMapping,\n  encodedMap: () => encodedMap,\n  encodedMappings: () => encodedMappings,\n  generatedPositionFor: () => generatedPositionFor,\n  isIgnored: () => isIgnored,\n  originalPositionFor: () => originalPositionFor,\n  presortedDecodedMap: () => presortedDecodedMap,\n  sourceContentFor: () => sourceContentFor,\n  traceSegment: () => traceSegment\n});\nmodule.exports = __toCommonJS(trace_mapping_exports);\nvar import_sourcemap_codec = __toESM(require_sourcemap_codec());\n\n// src/resolve.ts\nvar import_resolve_uri = __toESM(require_resolve_uri());\n\n// src/strip-filename.ts\nfunction stripFilename(path) {\n  if (!path) return \"\";\n  const index = path.lastIndexOf(\"/\");\n  return path.slice(0, index + 1);\n}\n\n// src/resolve.ts\nfunction resolver(mapUrl, sourceRoot) {\n  const from = stripFilename(mapUrl);\n  const prefix = sourceRoot ? sourceRoot + \"/\" : \"\";\n  return (source) => (0, import_resolve_uri.default)(prefix + (source || \"\"), from);\n}\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\nvar REV_GENERATED_LINE = 1;\nvar REV_GENERATED_COLUMN = 2;\n\n// src/sort.ts\nfunction maybeSort(mappings, owned) {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n  if (!owned) mappings = mappings.slice();\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\nfunction isSorted(line) {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction sortSegments(line, owned) {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[COLUMN] - b[COLUMN];\n}\n\n// src/by-source.ts\nfunction buildBySources(decoded, memos) {\n  const sources = memos.map(() => []);\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n      const sourceIndex2 = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const source = sources[sourceIndex2];\n      const segs = source[sourceLine] || (source[sourceLine] = []);\n      segs.push([sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    for (let j = 0; j < source.length; j++) {\n      const line = source[j];\n      if (line) line.sort(sortComparator);\n    }\n  }\n  return sources;\n}\n\n// src/binary-search.ts\nvar found = false;\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const { lastKey, lastNeedle, lastIndex } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n\n// src/types.ts\nfunction parse(map) {\n  return typeof map === \"string\" ? JSON.parse(map) : map;\n}\n\n// src/flatten-map.ts\nvar FlattenMap = function(map, mapUrl) {\n  const parsed = parse(map);\n  if (!(\"sections\" in parsed)) {\n    return new TraceMap(parsed, mapUrl);\n  }\n  const mappings = [];\n  const sources = [];\n  const sourcesContent = [];\n  const names = [];\n  const ignoreList = [];\n  recurse(\n    parsed,\n    mapUrl,\n    mappings,\n    sources,\n    sourcesContent,\n    names,\n    ignoreList,\n    0,\n    0,\n    Infinity,\n    Infinity\n  );\n  const joined = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList\n  };\n  return presortedDecodedMap(joined);\n};\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      ignoreList,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc\n    );\n  }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const parsed = parse(input);\n  if (\"sections\" in parsed) return recurse(...arguments);\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n    if (lineI > stopLine) return;\n    const out = getLine(mappings, lineI);\n    const cOffset = i === 0 ? columnOffset : 0;\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n      if (lineI === stopLine && column >= stopColumn) return;\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]\n      );\n    }\n  }\n}\nfunction append(arr, other) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n\n// src/trace-mapping.ts\nvar LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\";\nvar COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\";\nvar LEAST_UPPER_BOUND = -1;\nvar GREATEST_LOWER_BOUND = 1;\nvar TraceMap = class {\n  constructor(map, mapUrl) {\n    const isString = typeof map === \"string\";\n    if (!isString && map._decodedMemo) return map;\n    const parsed = parse(map);\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;\n    const resolve = resolver(mapUrl, sourceRoot);\n    this.resolvedSources = sources.map(resolve);\n    const { mappings } = parsed;\n    if (typeof mappings === \"string\") {\n      this._encoded = mappings;\n      this._decoded = void 0;\n    } else if (Array.isArray(mappings)) {\n      this._encoded = void 0;\n      this._decoded = maybeSort(mappings, isString);\n    } else if (parsed.sections) {\n      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);\n    } else {\n      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);\n    }\n    this._decodedMemo = memoizedState();\n    this._bySources = void 0;\n    this._bySourceMemos = void 0;\n  }\n};\nfunction cast(map) {\n  return map;\n}\nfunction encodedMappings(map) {\n  var _a, _b;\n  return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0, import_sourcemap_codec.encode)(cast(map)._decoded);\n}\nfunction decodedMappings(map) {\n  var _a;\n  return (_a = cast(map))._decoded || (_a._decoded = (0, import_sourcemap_codec.decode)(cast(map)._encoded));\n}\nfunction traceSegment(map, line, column) {\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return null;\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    GREATEST_LOWER_BOUND\n  );\n  return index === -1 ? null : segments[index];\n}\nfunction originalPositionFor(map, needle) {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND\n  );\n  if (index === -1) return OMapping(null, null, null, null);\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null\n  );\n}\nfunction generatedPositionFor(map, needle) {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\nfunction allGeneratedPositionsFor(map, needle) {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\nfunction eachMapping(map, cb) {\n  const decoded = decodedMappings(map);\n  const { names, resolvedSources } = map;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name\n      });\n    }\n  }\n}\nfunction sourceIndex(map, source) {\n  const { sources, resolvedSources } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\nfunction sourceContentFor(map, source) {\n  const { sourcesContent } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\nfunction isIgnored(map, source) {\n  const { ignoreList } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\nfunction presortedDecodedMap(map, mapUrl) {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\nfunction decodedMap(map) {\n  return clone(map, decodedMappings(map));\n}\nfunction encodedMap(map) {\n  return clone(map, encodedMappings(map));\n}\nfunction clone(map, mappings) {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || map.x_google_ignoreList\n  };\n}\nfunction OMapping(source, line, column, name) {\n  return { source, line, column, name };\n}\nfunction GMapping(line, column) {\n  return { line, column };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n  if (!found && bias === LEAST_UPPER_BOUND) min++;\n  if (min === -1 || min === segments.length) return [];\n  const matchedColumn = found ? column : segments[min][COLUMN];\n  if (!found) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\nfunction generatedPosition(map, source, line, column, bias, all) {\n  var _a, _b;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const { sources, resolvedSources } = map;\n  let sourceIndex2 = sources.indexOf(source);\n  if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);\n  if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);\n  const bySourceMemos = (_a = cast(map))._bySourceMemos || (_a._bySourceMemos = sources.map(memoizedState));\n  const generated = (_b = cast(map))._bySources || (_b._bySources = buildBySources(decodedMappings(map), bySourceMemos));\n  const segments = generated[sourceIndex2][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n  const memo = bySourceMemos[sourceIndex2];\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n}));\n//# sourceMappingURL=trace-mapping.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9kaXN0L3RyYWNlLW1hcHBpbmcudW1kLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBLE1BQU0sSUFBNEQ7QUFDbEUsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQXlCLEdBQUcsbUJBQU8sQ0FBQywyR0FBNkI7QUFDN0Y7QUFDQSxJQUFJLEtBQUs7QUFBQSxFQVVOO0FBQ0gsb0JBQW9CO0FBQ3BCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCLGtCQUFrQixxQkFBcUI7QUFDdkMsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpRUFBaUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25ELGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUE0RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sNkNBQTZDLHVCQUF1QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUJBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkMsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RpbnlzaGFkZS8uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC90cmFjZS1tYXBwaW5nL2Rpc3QvdHJhY2UtbWFwcGluZy51bWQuanM/YWFhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmFjdG9yeShtb2R1bGUsIHJlcXVpcmUoJ0BqcmlkZ2V3ZWxsL3Jlc29sdmUtdXJpJyksIHJlcXVpcmUoJ0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYycpKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZihtb2R1bGUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ21vZHVsZScsICdAanJpZGdld2VsbC9yZXNvbHZlLXVyaScsICdAanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMnXSwgZnVuY3Rpb24obW9kKSB7XG4gICAgICBmYWN0b3J5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBtb2QuZXhwb3J0cyA9IGRlZihtb2QpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1vZCA9IHsgZXhwb3J0czoge30gfTtcbiAgICBmYWN0b3J5KG1vZCwgZ2xvYmFsLnJlc29sdmVVUkksIGdsb2JhbC5zb3VyY2VtYXBDb2RlYyk7XG4gICAgZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmO1xuICAgIGdsb2JhbC50cmFjZU1hcHBpbmcgPSBkZWYobW9kKTtcbiAgfVxuICBmdW5jdGlvbiBkZWYobSkgeyByZXR1cm4gJ2RlZmF1bHQnIGluIG0uZXhwb3J0cyA/IG0uZXhwb3J0cy5kZWZhdWx0IDogbS5leHBvcnRzOyB9XG59KSh0aGlzLCAoZnVuY3Rpb24gKG1vZHVsZSwgcmVxdWlyZV9yZXNvbHZlVVJJLCByZXF1aXJlX3NvdXJjZW1hcENvZGVjKSB7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gdW1kOkBqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlY1xudmFyIHJlcXVpcmVfc291cmNlbWFwX2NvZGVjID0gX19jb21tb25KUyh7XG4gIFwidW1kOkBqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlY1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX3NvdXJjZW1hcENvZGVjO1xuICB9XG59KTtcblxuLy8gdW1kOkBqcmlkZ2V3ZWxsL3Jlc29sdmUtdXJpXG52YXIgcmVxdWlyZV9yZXNvbHZlX3VyaSA9IF9fY29tbW9uSlMoe1xuICBcInVtZDpAanJpZGdld2VsbC9yZXNvbHZlLXVyaVwiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX3Jlc29sdmVVUkk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvdHJhY2UtbWFwcGluZy50c1xudmFyIHRyYWNlX21hcHBpbmdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHJhY2VfbWFwcGluZ19leHBvcnRzLCB7XG4gIEFueU1hcDogKCkgPT4gRmxhdHRlbk1hcCxcbiAgRmxhdHRlbk1hcDogKCkgPT4gRmxhdHRlbk1hcCxcbiAgR1JFQVRFU1RfTE9XRVJfQk9VTkQ6ICgpID0+IEdSRUFURVNUX0xPV0VSX0JPVU5ELFxuICBMRUFTVF9VUFBFUl9CT1VORDogKCkgPT4gTEVBU1RfVVBQRVJfQk9VTkQsXG4gIFRyYWNlTWFwOiAoKSA9PiBUcmFjZU1hcCxcbiAgYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yOiAoKSA9PiBhbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IsXG4gIGRlY29kZWRNYXA6ICgpID0+IGRlY29kZWRNYXAsXG4gIGRlY29kZWRNYXBwaW5nczogKCkgPT4gZGVjb2RlZE1hcHBpbmdzLFxuICBlYWNoTWFwcGluZzogKCkgPT4gZWFjaE1hcHBpbmcsXG4gIGVuY29kZWRNYXA6ICgpID0+IGVuY29kZWRNYXAsXG4gIGVuY29kZWRNYXBwaW5nczogKCkgPT4gZW5jb2RlZE1hcHBpbmdzLFxuICBnZW5lcmF0ZWRQb3NpdGlvbkZvcjogKCkgPT4gZ2VuZXJhdGVkUG9zaXRpb25Gb3IsXG4gIGlzSWdub3JlZDogKCkgPT4gaXNJZ25vcmVkLFxuICBvcmlnaW5hbFBvc2l0aW9uRm9yOiAoKSA9PiBvcmlnaW5hbFBvc2l0aW9uRm9yLFxuICBwcmVzb3J0ZWREZWNvZGVkTWFwOiAoKSA9PiBwcmVzb3J0ZWREZWNvZGVkTWFwLFxuICBzb3VyY2VDb250ZW50Rm9yOiAoKSA9PiBzb3VyY2VDb250ZW50Rm9yLFxuICB0cmFjZVNlZ21lbnQ6ICgpID0+IHRyYWNlU2VnbWVudFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyh0cmFjZV9tYXBwaW5nX2V4cG9ydHMpO1xudmFyIGltcG9ydF9zb3VyY2VtYXBfY29kZWMgPSBfX3RvRVNNKHJlcXVpcmVfc291cmNlbWFwX2NvZGVjKCkpO1xuXG4vLyBzcmMvcmVzb2x2ZS50c1xudmFyIGltcG9ydF9yZXNvbHZlX3VyaSA9IF9fdG9FU00ocmVxdWlyZV9yZXNvbHZlX3VyaSgpKTtcblxuLy8gc3JjL3N0cmlwLWZpbGVuYW1lLnRzXG5mdW5jdGlvbiBzdHJpcEZpbGVuYW1lKHBhdGgpIHtcbiAgaWYgKCFwYXRoKSByZXR1cm4gXCJcIjtcbiAgY29uc3QgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgaW5kZXggKyAxKTtcbn1cblxuLy8gc3JjL3Jlc29sdmUudHNcbmZ1bmN0aW9uIHJlc29sdmVyKG1hcFVybCwgc291cmNlUm9vdCkge1xuICBjb25zdCBmcm9tID0gc3RyaXBGaWxlbmFtZShtYXBVcmwpO1xuICBjb25zdCBwcmVmaXggPSBzb3VyY2VSb290ID8gc291cmNlUm9vdCArIFwiL1wiIDogXCJcIjtcbiAgcmV0dXJuIChzb3VyY2UpID0+ICgwLCBpbXBvcnRfcmVzb2x2ZV91cmkuZGVmYXVsdCkocHJlZml4ICsgKHNvdXJjZSB8fCBcIlwiKSwgZnJvbSk7XG59XG5cbi8vIHNyYy9zb3VyY2VtYXAtc2VnbWVudC50c1xudmFyIENPTFVNTiA9IDA7XG52YXIgU09VUkNFU19JTkRFWCA9IDE7XG52YXIgU09VUkNFX0xJTkUgPSAyO1xudmFyIFNPVVJDRV9DT0xVTU4gPSAzO1xudmFyIE5BTUVTX0lOREVYID0gNDtcbnZhciBSRVZfR0VORVJBVEVEX0xJTkUgPSAxO1xudmFyIFJFVl9HRU5FUkFURURfQ09MVU1OID0gMjtcblxuLy8gc3JjL3NvcnQudHNcbmZ1bmN0aW9uIG1heWJlU29ydChtYXBwaW5ncywgb3duZWQpIHtcbiAgY29uc3QgdW5zb3J0ZWRJbmRleCA9IG5leHRVbnNvcnRlZFNlZ21lbnRMaW5lKG1hcHBpbmdzLCAwKTtcbiAgaWYgKHVuc29ydGVkSW5kZXggPT09IG1hcHBpbmdzLmxlbmd0aCkgcmV0dXJuIG1hcHBpbmdzO1xuICBpZiAoIW93bmVkKSBtYXBwaW5ncyA9IG1hcHBpbmdzLnNsaWNlKCk7XG4gIGZvciAobGV0IGkgPSB1bnNvcnRlZEluZGV4OyBpIDwgbWFwcGluZ3MubGVuZ3RoOyBpID0gbmV4dFVuc29ydGVkU2VnbWVudExpbmUobWFwcGluZ3MsIGkgKyAxKSkge1xuICAgIG1hcHBpbmdzW2ldID0gc29ydFNlZ21lbnRzKG1hcHBpbmdzW2ldLCBvd25lZCk7XG4gIH1cbiAgcmV0dXJuIG1hcHBpbmdzO1xufVxuZnVuY3Rpb24gbmV4dFVuc29ydGVkU2VnbWVudExpbmUobWFwcGluZ3MsIHN0YXJ0KSB7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG1hcHBpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFpc1NvcnRlZChtYXBwaW5nc1tpXSkpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiBtYXBwaW5ncy5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc1NvcnRlZChsaW5lKSB7XG4gIGZvciAobGV0IGogPSAxOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgIGlmIChsaW5lW2pdW0NPTFVNTl0gPCBsaW5lW2ogLSAxXVtDT0xVTU5dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc29ydFNlZ21lbnRzKGxpbmUsIG93bmVkKSB7XG4gIGlmICghb3duZWQpIGxpbmUgPSBsaW5lLnNsaWNlKCk7XG4gIHJldHVybiBsaW5lLnNvcnQoc29ydENvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gc29ydENvbXBhcmF0b3IoYSwgYikge1xuICByZXR1cm4gYVtDT0xVTU5dIC0gYltDT0xVTU5dO1xufVxuXG4vLyBzcmMvYnktc291cmNlLnRzXG5mdW5jdGlvbiBidWlsZEJ5U291cmNlcyhkZWNvZGVkLCBtZW1vcykge1xuICBjb25zdCBzb3VyY2VzID0gbWVtb3MubWFwKCgpID0+IFtdKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IGRlY29kZWRbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBzZWcgPSBsaW5lW2pdO1xuICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDEpIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc291cmNlSW5kZXgyID0gc2VnW1NPVVJDRVNfSU5ERVhdO1xuICAgICAgY29uc3Qgc291cmNlTGluZSA9IHNlZ1tTT1VSQ0VfTElORV07XG4gICAgICBjb25zdCBzb3VyY2VDb2x1bW4gPSBzZWdbU09VUkNFX0NPTFVNTl07XG4gICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW3NvdXJjZUluZGV4Ml07XG4gICAgICBjb25zdCBzZWdzID0gc291cmNlW3NvdXJjZUxpbmVdIHx8IChzb3VyY2Vbc291cmNlTGluZV0gPSBbXSk7XG4gICAgICBzZWdzLnB1c2goW3NvdXJjZUNvbHVtbiwgaSwgc2VnW0NPTFVNTl1dKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNvdXJjZS5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgbGluZSA9IHNvdXJjZVtqXTtcbiAgICAgIGlmIChsaW5lKSBsaW5lLnNvcnQoc29ydENvbXBhcmF0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc291cmNlcztcbn1cblxuLy8gc3JjL2JpbmFyeS1zZWFyY2gudHNcbnZhciBmb3VuZCA9IGZhbHNlO1xuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIGxvdywgaGlnaCkge1xuICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICBjb25zdCBtaWQgPSBsb3cgKyAoaGlnaCAtIGxvdyA+PiAxKTtcbiAgICBjb25zdCBjbXAgPSBoYXlzdGFja1ttaWRdW0NPTFVNTl0gLSBuZWVkbGU7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gICAgaWYgKGNtcCA8IDApIHtcbiAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgIH1cbiAgfVxuICBmb3VuZCA9IGZhbHNlO1xuICByZXR1cm4gbG93IC0gMTtcbn1cbmZ1bmN0aW9uIHVwcGVyQm91bmQoaGF5c3RhY2ssIG5lZWRsZSwgaW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IGluZGV4ICsgMTsgaSA8IGhheXN0YWNrLmxlbmd0aDsgaW5kZXggPSBpKyspIHtcbiAgICBpZiAoaGF5c3RhY2tbaV1bQ09MVU1OXSAhPT0gbmVlZGxlKSBicmVhaztcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBsb3dlckJvdW5kKGhheXN0YWNrLCBuZWVkbGUsIGluZGV4KSB7XG4gIGZvciAobGV0IGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaW5kZXggPSBpLS0pIHtcbiAgICBpZiAoaGF5c3RhY2tbaV1bQ09MVU1OXSAhPT0gbmVlZGxlKSBicmVhaztcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBtZW1vaXplZFN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIGxhc3RLZXk6IC0xLFxuICAgIGxhc3ROZWVkbGU6IC0xLFxuICAgIGxhc3RJbmRleDogLTFcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVkQmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIHN0YXRlLCBrZXkpIHtcbiAgY29uc3QgeyBsYXN0S2V5LCBsYXN0TmVlZGxlLCBsYXN0SW5kZXggfSA9IHN0YXRlO1xuICBsZXQgbG93ID0gMDtcbiAgbGV0IGhpZ2ggPSBoYXlzdGFjay5sZW5ndGggLSAxO1xuICBpZiAoa2V5ID09PSBsYXN0S2V5KSB7XG4gICAgaWYgKG5lZWRsZSA9PT0gbGFzdE5lZWRsZSkge1xuICAgICAgZm91bmQgPSBsYXN0SW5kZXggIT09IC0xICYmIGhheXN0YWNrW2xhc3RJbmRleF1bQ09MVU1OXSA9PT0gbmVlZGxlO1xuICAgICAgcmV0dXJuIGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKG5lZWRsZSA+PSBsYXN0TmVlZGxlKSB7XG4gICAgICBsb3cgPSBsYXN0SW5kZXggPT09IC0xID8gMCA6IGxhc3RJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlnaCA9IGxhc3RJbmRleDtcbiAgICB9XG4gIH1cbiAgc3RhdGUubGFzdEtleSA9IGtleTtcbiAgc3RhdGUubGFzdE5lZWRsZSA9IG5lZWRsZTtcbiAgcmV0dXJuIHN0YXRlLmxhc3RJbmRleCA9IGJpbmFyeVNlYXJjaChoYXlzdGFjaywgbmVlZGxlLCBsb3csIGhpZ2gpO1xufVxuXG4vLyBzcmMvdHlwZXMudHNcbmZ1bmN0aW9uIHBhcnNlKG1hcCkge1xuICByZXR1cm4gdHlwZW9mIG1hcCA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UobWFwKSA6IG1hcDtcbn1cblxuLy8gc3JjL2ZsYXR0ZW4tbWFwLnRzXG52YXIgRmxhdHRlbk1hcCA9IGZ1bmN0aW9uKG1hcCwgbWFwVXJsKSB7XG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlKG1hcCk7XG4gIGlmICghKFwic2VjdGlvbnNcIiBpbiBwYXJzZWQpKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFjZU1hcChwYXJzZWQsIG1hcFVybCk7XG4gIH1cbiAgY29uc3QgbWFwcGluZ3MgPSBbXTtcbiAgY29uc3Qgc291cmNlcyA9IFtdO1xuICBjb25zdCBzb3VyY2VzQ29udGVudCA9IFtdO1xuICBjb25zdCBuYW1lcyA9IFtdO1xuICBjb25zdCBpZ25vcmVMaXN0ID0gW107XG4gIHJlY3Vyc2UoXG4gICAgcGFyc2VkLFxuICAgIG1hcFVybCxcbiAgICBtYXBwaW5ncyxcbiAgICBzb3VyY2VzLFxuICAgIHNvdXJjZXNDb250ZW50LFxuICAgIG5hbWVzLFxuICAgIGlnbm9yZUxpc3QsXG4gICAgMCxcbiAgICAwLFxuICAgIEluZmluaXR5LFxuICAgIEluZmluaXR5XG4gICk7XG4gIGNvbnN0IGpvaW5lZCA9IHtcbiAgICB2ZXJzaW9uOiAzLFxuICAgIGZpbGU6IHBhcnNlZC5maWxlLFxuICAgIG5hbWVzLFxuICAgIHNvdXJjZXMsXG4gICAgc291cmNlc0NvbnRlbnQsXG4gICAgbWFwcGluZ3MsXG4gICAgaWdub3JlTGlzdFxuICB9O1xuICByZXR1cm4gcHJlc29ydGVkRGVjb2RlZE1hcChqb2luZWQpO1xufTtcbmZ1bmN0aW9uIHJlY3Vyc2UoaW5wdXQsIG1hcFVybCwgbWFwcGluZ3MsIHNvdXJjZXMsIHNvdXJjZXNDb250ZW50LCBuYW1lcywgaWdub3JlTGlzdCwgbGluZU9mZnNldCwgY29sdW1uT2Zmc2V0LCBzdG9wTGluZSwgc3RvcENvbHVtbikge1xuICBjb25zdCB7IHNlY3Rpb25zIH0gPSBpbnB1dDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHsgbWFwLCBvZmZzZXQgfSA9IHNlY3Rpb25zW2ldO1xuICAgIGxldCBzbCA9IHN0b3BMaW5lO1xuICAgIGxldCBzYyA9IHN0b3BDb2x1bW47XG4gICAgaWYgKGkgKyAxIDwgc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXh0T2Zmc2V0ID0gc2VjdGlvbnNbaSArIDFdLm9mZnNldDtcbiAgICAgIHNsID0gTWF0aC5taW4oc3RvcExpbmUsIGxpbmVPZmZzZXQgKyBuZXh0T2Zmc2V0LmxpbmUpO1xuICAgICAgaWYgKHNsID09PSBzdG9wTGluZSkge1xuICAgICAgICBzYyA9IE1hdGgubWluKHN0b3BDb2x1bW4sIGNvbHVtbk9mZnNldCArIG5leHRPZmZzZXQuY29sdW1uKTtcbiAgICAgIH0gZWxzZSBpZiAoc2wgPCBzdG9wTGluZSkge1xuICAgICAgICBzYyA9IGNvbHVtbk9mZnNldCArIG5leHRPZmZzZXQuY29sdW1uO1xuICAgICAgfVxuICAgIH1cbiAgICBhZGRTZWN0aW9uKFxuICAgICAgbWFwLFxuICAgICAgbWFwVXJsLFxuICAgICAgbWFwcGluZ3MsXG4gICAgICBzb3VyY2VzLFxuICAgICAgc291cmNlc0NvbnRlbnQsXG4gICAgICBuYW1lcyxcbiAgICAgIGlnbm9yZUxpc3QsXG4gICAgICBsaW5lT2Zmc2V0ICsgb2Zmc2V0LmxpbmUsXG4gICAgICBjb2x1bW5PZmZzZXQgKyBvZmZzZXQuY29sdW1uLFxuICAgICAgc2wsXG4gICAgICBzY1xuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFNlY3Rpb24oaW5wdXQsIG1hcFVybCwgbWFwcGluZ3MsIHNvdXJjZXMsIHNvdXJjZXNDb250ZW50LCBuYW1lcywgaWdub3JlTGlzdCwgbGluZU9mZnNldCwgY29sdW1uT2Zmc2V0LCBzdG9wTGluZSwgc3RvcENvbHVtbikge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZShpbnB1dCk7XG4gIGlmIChcInNlY3Rpb25zXCIgaW4gcGFyc2VkKSByZXR1cm4gcmVjdXJzZSguLi5hcmd1bWVudHMpO1xuICBjb25zdCBtYXAgPSBuZXcgVHJhY2VNYXAocGFyc2VkLCBtYXBVcmwpO1xuICBjb25zdCBzb3VyY2VzT2Zmc2V0ID0gc291cmNlcy5sZW5ndGg7XG4gIGNvbnN0IG5hbWVzT2Zmc2V0ID0gbmFtZXMubGVuZ3RoO1xuICBjb25zdCBkZWNvZGVkID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gIGNvbnN0IHsgcmVzb2x2ZWRTb3VyY2VzLCBzb3VyY2VzQ29udGVudDogY29udGVudHMsIGlnbm9yZUxpc3Q6IGlnbm9yZXMgfSA9IG1hcDtcbiAgYXBwZW5kKHNvdXJjZXMsIHJlc29sdmVkU291cmNlcyk7XG4gIGFwcGVuZChuYW1lcywgbWFwLm5hbWVzKTtcbiAgaWYgKGNvbnRlbnRzKSBhcHBlbmQoc291cmNlc0NvbnRlbnQsIGNvbnRlbnRzKTtcbiAgZWxzZSBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkU291cmNlcy5sZW5ndGg7IGkrKykgc291cmNlc0NvbnRlbnQucHVzaChudWxsKTtcbiAgaWYgKGlnbm9yZXMpIGZvciAobGV0IGkgPSAwOyBpIDwgaWdub3Jlcy5sZW5ndGg7IGkrKykgaWdub3JlTGlzdC5wdXNoKGlnbm9yZXNbaV0gKyBzb3VyY2VzT2Zmc2V0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZUkgPSBsaW5lT2Zmc2V0ICsgaTtcbiAgICBpZiAobGluZUkgPiBzdG9wTGluZSkgcmV0dXJuO1xuICAgIGNvbnN0IG91dCA9IGdldExpbmUobWFwcGluZ3MsIGxpbmVJKTtcbiAgICBjb25zdCBjT2Zmc2V0ID0gaSA9PT0gMCA/IGNvbHVtbk9mZnNldCA6IDA7XG4gICAgY29uc3QgbGluZSA9IGRlY29kZWRbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBzZWcgPSBsaW5lW2pdO1xuICAgICAgY29uc3QgY29sdW1uID0gY09mZnNldCArIHNlZ1tDT0xVTU5dO1xuICAgICAgaWYgKGxpbmVJID09PSBzdG9wTGluZSAmJiBjb2x1bW4gPj0gc3RvcENvbHVtbikgcmV0dXJuO1xuICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgb3V0LnB1c2goW2NvbHVtbl0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNvdXJjZXNJbmRleCA9IHNvdXJjZXNPZmZzZXQgKyBzZWdbU09VUkNFU19JTkRFWF07XG4gICAgICBjb25zdCBzb3VyY2VMaW5lID0gc2VnW1NPVVJDRV9MSU5FXTtcbiAgICAgIGNvbnN0IHNvdXJjZUNvbHVtbiA9IHNlZ1tTT1VSQ0VfQ09MVU1OXTtcbiAgICAgIG91dC5wdXNoKFxuICAgICAgICBzZWcubGVuZ3RoID09PSA0ID8gW2NvbHVtbiwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW5dIDogW2NvbHVtbiwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWVzT2Zmc2V0ICsgc2VnW05BTUVTX0lOREVYXV1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBlbmQoYXJyLCBvdGhlcikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyLmxlbmd0aDsgaSsrKSBhcnIucHVzaChvdGhlcltpXSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lKGFyciwgaW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGg7IGkgPD0gaW5kZXg7IGkrKykgYXJyW2ldID0gW107XG4gIHJldHVybiBhcnJbaW5kZXhdO1xufVxuXG4vLyBzcmMvdHJhY2UtbWFwcGluZy50c1xudmFyIExJTkVfR1RSX1pFUk8gPSBcImBsaW5lYCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIChsaW5lcyBzdGFydCBhdCBsaW5lIDEpXCI7XG52YXIgQ09MX0dUUl9FUV9aRVJPID0gXCJgY29sdW1uYCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwIChjb2x1bW5zIHN0YXJ0IGF0IGNvbHVtbiAwKVwiO1xudmFyIExFQVNUX1VQUEVSX0JPVU5EID0gLTE7XG52YXIgR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xudmFyIFRyYWNlTWFwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtYXAsIG1hcFVybCkge1xuICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIG1hcCA9PT0gXCJzdHJpbmdcIjtcbiAgICBpZiAoIWlzU3RyaW5nICYmIG1hcC5fZGVjb2RlZE1lbW8pIHJldHVybiBtYXA7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2UobWFwKTtcbiAgICBjb25zdCB7IHZlcnNpb24sIGZpbGUsIG5hbWVzLCBzb3VyY2VSb290LCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCB9ID0gcGFyc2VkO1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICB0aGlzLm5hbWVzID0gbmFtZXMgfHwgW107XG4gICAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgICB0aGlzLmlnbm9yZUxpc3QgPSBwYXJzZWQuaWdub3JlTGlzdCB8fCBwYXJzZWQueF9nb29nbGVfaWdub3JlTGlzdCB8fCB2b2lkIDA7XG4gICAgY29uc3QgcmVzb2x2ZSA9IHJlc29sdmVyKG1hcFVybCwgc291cmNlUm9vdCk7XG4gICAgdGhpcy5yZXNvbHZlZFNvdXJjZXMgPSBzb3VyY2VzLm1hcChyZXNvbHZlKTtcbiAgICBjb25zdCB7IG1hcHBpbmdzIH0gPSBwYXJzZWQ7XG4gICAgaWYgKHR5cGVvZiBtYXBwaW5ncyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5fZW5jb2RlZCA9IG1hcHBpbmdzO1xuICAgICAgdGhpcy5fZGVjb2RlZCA9IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWFwcGluZ3MpKSB7XG4gICAgICB0aGlzLl9lbmNvZGVkID0gdm9pZCAwO1xuICAgICAgdGhpcy5fZGVjb2RlZCA9IG1heWJlU29ydChtYXBwaW5ncywgaXNTdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnNlY3Rpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYWNlTWFwIHBhc3NlZCBzZWN0aW9uZWQgc291cmNlIG1hcCwgcGxlYXNlIHVzZSBGbGF0dGVuTWFwIGV4cG9ydCBpbnN0ZWFkYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzb3VyY2UgbWFwOiAke0pTT04uc3RyaW5naWZ5KHBhcnNlZCl9YCk7XG4gICAgfVxuICAgIHRoaXMuX2RlY29kZWRNZW1vID0gbWVtb2l6ZWRTdGF0ZSgpO1xuICAgIHRoaXMuX2J5U291cmNlcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9ieVNvdXJjZU1lbW9zID0gdm9pZCAwO1xuICB9XG59O1xuZnVuY3Rpb24gY2FzdChtYXApIHtcbiAgcmV0dXJuIG1hcDtcbn1cbmZ1bmN0aW9uIGVuY29kZWRNYXBwaW5ncyhtYXApIHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuIChfYiA9IChfYSA9IGNhc3QobWFwKSkuX2VuY29kZWQpICE9IG51bGwgPyBfYiA6IF9hLl9lbmNvZGVkID0gKDAsIGltcG9ydF9zb3VyY2VtYXBfY29kZWMuZW5jb2RlKShjYXN0KG1hcCkuX2RlY29kZWQpO1xufVxuZnVuY3Rpb24gZGVjb2RlZE1hcHBpbmdzKG1hcCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBjYXN0KG1hcCkpLl9kZWNvZGVkIHx8IChfYS5fZGVjb2RlZCA9ICgwLCBpbXBvcnRfc291cmNlbWFwX2NvZGVjLmRlY29kZSkoY2FzdChtYXApLl9lbmNvZGVkKSk7XG59XG5mdW5jdGlvbiB0cmFjZVNlZ21lbnQobWFwLCBsaW5lLCBjb2x1bW4pIHtcbiAgY29uc3QgZGVjb2RlZCA9IGRlY29kZWRNYXBwaW5ncyhtYXApO1xuICBpZiAobGluZSA+PSBkZWNvZGVkLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHNlZ21lbnRzID0gZGVjb2RlZFtsaW5lXTtcbiAgY29uc3QgaW5kZXggPSB0cmFjZVNlZ21lbnRJbnRlcm5hbChcbiAgICBzZWdtZW50cyxcbiAgICBjYXN0KG1hcCkuX2RlY29kZWRNZW1vLFxuICAgIGxpbmUsXG4gICAgY29sdW1uLFxuICAgIEdSRUFURVNUX0xPV0VSX0JPVU5EXG4gICk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyBudWxsIDogc2VnbWVudHNbaW5kZXhdO1xufVxuZnVuY3Rpb24gb3JpZ2luYWxQb3NpdGlvbkZvcihtYXAsIG5lZWRsZSkge1xuICBsZXQgeyBsaW5lLCBjb2x1bW4sIGJpYXMgfSA9IG5lZWRsZTtcbiAgbGluZS0tO1xuICBpZiAobGluZSA8IDApIHRocm93IG5ldyBFcnJvcihMSU5FX0dUUl9aRVJPKTtcbiAgaWYgKGNvbHVtbiA8IDApIHRocm93IG5ldyBFcnJvcihDT0xfR1RSX0VRX1pFUk8pO1xuICBjb25zdCBkZWNvZGVkID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gIGlmIChsaW5lID49IGRlY29kZWQubGVuZ3RoKSByZXR1cm4gT01hcHBpbmcobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIGNvbnN0IHNlZ21lbnRzID0gZGVjb2RlZFtsaW5lXTtcbiAgY29uc3QgaW5kZXggPSB0cmFjZVNlZ21lbnRJbnRlcm5hbChcbiAgICBzZWdtZW50cyxcbiAgICBjYXN0KG1hcCkuX2RlY29kZWRNZW1vLFxuICAgIGxpbmUsXG4gICAgY29sdW1uLFxuICAgIGJpYXMgfHwgR1JFQVRFU1RfTE9XRVJfQk9VTkRcbiAgKTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIE9NYXBwaW5nKG51bGwsIG51bGwsIG51bGwsIG51bGwpO1xuICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDEpIHJldHVybiBPTWFwcGluZyhudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgY29uc3QgeyBuYW1lcywgcmVzb2x2ZWRTb3VyY2VzIH0gPSBtYXA7XG4gIHJldHVybiBPTWFwcGluZyhcbiAgICByZXNvbHZlZFNvdXJjZXNbc2VnbWVudFtTT1VSQ0VTX0lOREVYXV0sXG4gICAgc2VnbWVudFtTT1VSQ0VfTElORV0gKyAxLFxuICAgIHNlZ21lbnRbU09VUkNFX0NPTFVNTl0sXG4gICAgc2VnbWVudC5sZW5ndGggPT09IDUgPyBuYW1lc1tzZWdtZW50W05BTUVTX0lOREVYXV0gOiBudWxsXG4gICk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkZvcihtYXAsIG5lZWRsZSkge1xuICBjb25zdCB7IHNvdXJjZSwgbGluZSwgY29sdW1uLCBiaWFzIH0gPSBuZWVkbGU7XG4gIHJldHVybiBnZW5lcmF0ZWRQb3NpdGlvbihtYXAsIHNvdXJjZSwgbGluZSwgY29sdW1uLCBiaWFzIHx8IEdSRUFURVNUX0xPV0VSX0JPVU5ELCBmYWxzZSk7XG59XG5mdW5jdGlvbiBhbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IobWFwLCBuZWVkbGUpIHtcbiAgY29uc3QgeyBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcyB9ID0gbmVlZGxlO1xuICByZXR1cm4gZ2VuZXJhdGVkUG9zaXRpb24obWFwLCBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcyB8fCBMRUFTVF9VUFBFUl9CT1VORCwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBlYWNoTWFwcGluZyhtYXAsIGNiKSB7XG4gIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVkTWFwcGluZ3MobWFwKTtcbiAgY29uc3QgeyBuYW1lcywgcmVzb2x2ZWRTb3VyY2VzIH0gPSBtYXA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qgc2VnID0gbGluZVtqXTtcbiAgICAgIGNvbnN0IGdlbmVyYXRlZExpbmUgPSBpICsgMTtcbiAgICAgIGNvbnN0IGdlbmVyYXRlZENvbHVtbiA9IHNlZ1swXTtcbiAgICAgIGxldCBzb3VyY2UgPSBudWxsO1xuICAgICAgbGV0IG9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgICBsZXQgb3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgICAgbGV0IG5hbWUgPSBudWxsO1xuICAgICAgaWYgKHNlZy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgc291cmNlID0gcmVzb2x2ZWRTb3VyY2VzW3NlZ1sxXV07XG4gICAgICAgIG9yaWdpbmFsTGluZSA9IHNlZ1syXSArIDE7XG4gICAgICAgIG9yaWdpbmFsQ29sdW1uID0gc2VnWzNdO1xuICAgICAgfVxuICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDUpIG5hbWUgPSBuYW1lc1tzZWdbNF1dO1xuICAgICAgY2Ioe1xuICAgICAgICBnZW5lcmF0ZWRMaW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWxMaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbixcbiAgICAgICAgbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzb3VyY2VJbmRleChtYXAsIHNvdXJjZSkge1xuICBjb25zdCB7IHNvdXJjZXMsIHJlc29sdmVkU291cmNlcyB9ID0gbWFwO1xuICBsZXQgaW5kZXggPSBzb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgaWYgKGluZGV4ID09PSAtMSkgaW5kZXggPSByZXNvbHZlZFNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzb3VyY2VDb250ZW50Rm9yKG1hcCwgc291cmNlKSB7XG4gIGNvbnN0IHsgc291cmNlc0NvbnRlbnQgfSA9IG1hcDtcbiAgaWYgKHNvdXJjZXNDb250ZW50ID09IG51bGwpIHJldHVybiBudWxsO1xuICBjb25zdCBpbmRleCA9IHNvdXJjZUluZGV4KG1hcCwgc291cmNlKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiBzb3VyY2VzQ29udGVudFtpbmRleF07XG59XG5mdW5jdGlvbiBpc0lnbm9yZWQobWFwLCBzb3VyY2UpIHtcbiAgY29uc3QgeyBpZ25vcmVMaXN0IH0gPSBtYXA7XG4gIGlmIChpZ25vcmVMaXN0ID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgaW5kZXggPSBzb3VyY2VJbmRleChtYXAsIHNvdXJjZSk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyBmYWxzZSA6IGlnbm9yZUxpc3QuaW5jbHVkZXMoaW5kZXgpO1xufVxuZnVuY3Rpb24gcHJlc29ydGVkRGVjb2RlZE1hcChtYXAsIG1hcFVybCkge1xuICBjb25zdCB0cmFjZXIgPSBuZXcgVHJhY2VNYXAoY2xvbmUobWFwLCBbXSksIG1hcFVybCk7XG4gIGNhc3QodHJhY2VyKS5fZGVjb2RlZCA9IG1hcC5tYXBwaW5ncztcbiAgcmV0dXJuIHRyYWNlcjtcbn1cbmZ1bmN0aW9uIGRlY29kZWRNYXAobWFwKSB7XG4gIHJldHVybiBjbG9uZShtYXAsIGRlY29kZWRNYXBwaW5ncyhtYXApKTtcbn1cbmZ1bmN0aW9uIGVuY29kZWRNYXAobWFwKSB7XG4gIHJldHVybiBjbG9uZShtYXAsIGVuY29kZWRNYXBwaW5ncyhtYXApKTtcbn1cbmZ1bmN0aW9uIGNsb25lKG1hcCwgbWFwcGluZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiBtYXAudmVyc2lvbixcbiAgICBmaWxlOiBtYXAuZmlsZSxcbiAgICBuYW1lczogbWFwLm5hbWVzLFxuICAgIHNvdXJjZVJvb3Q6IG1hcC5zb3VyY2VSb290LFxuICAgIHNvdXJjZXM6IG1hcC5zb3VyY2VzLFxuICAgIHNvdXJjZXNDb250ZW50OiBtYXAuc291cmNlc0NvbnRlbnQsXG4gICAgbWFwcGluZ3MsXG4gICAgaWdub3JlTGlzdDogbWFwLmlnbm9yZUxpc3QgfHwgbWFwLnhfZ29vZ2xlX2lnbm9yZUxpc3RcbiAgfTtcbn1cbmZ1bmN0aW9uIE9NYXBwaW5nKHNvdXJjZSwgbGluZSwgY29sdW1uLCBuYW1lKSB7XG4gIHJldHVybiB7IHNvdXJjZSwgbGluZSwgY29sdW1uLCBuYW1lIH07XG59XG5mdW5jdGlvbiBHTWFwcGluZyhsaW5lLCBjb2x1bW4pIHtcbiAgcmV0dXJuIHsgbGluZSwgY29sdW1uIH07XG59XG5mdW5jdGlvbiB0cmFjZVNlZ21lbnRJbnRlcm5hbChzZWdtZW50cywgbWVtbywgbGluZSwgY29sdW1uLCBiaWFzKSB7XG4gIGxldCBpbmRleCA9IG1lbW9pemVkQmluYXJ5U2VhcmNoKHNlZ21lbnRzLCBjb2x1bW4sIG1lbW8sIGxpbmUpO1xuICBpZiAoZm91bmQpIHtcbiAgICBpbmRleCA9IChiaWFzID09PSBMRUFTVF9VUFBFUl9CT1VORCA/IHVwcGVyQm91bmQgOiBsb3dlckJvdW5kKShzZWdtZW50cywgY29sdW1uLCBpbmRleCk7XG4gIH0gZWxzZSBpZiAoYmlhcyA9PT0gTEVBU1RfVVBQRVJfQk9VTkQpIGluZGV4Kys7XG4gIGlmIChpbmRleCA9PT0gLTEgfHwgaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCkgcmV0dXJuIC0xO1xuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzbGljZUdlbmVyYXRlZFBvc2l0aW9ucyhzZWdtZW50cywgbWVtbywgbGluZSwgY29sdW1uLCBiaWFzKSB7XG4gIGxldCBtaW4gPSB0cmFjZVNlZ21lbnRJbnRlcm5hbChzZWdtZW50cywgbWVtbywgbGluZSwgY29sdW1uLCBHUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gIGlmICghZm91bmQgJiYgYmlhcyA9PT0gTEVBU1RfVVBQRVJfQk9VTkQpIG1pbisrO1xuICBpZiAobWluID09PSAtMSB8fCBtaW4gPT09IHNlZ21lbnRzLmxlbmd0aCkgcmV0dXJuIFtdO1xuICBjb25zdCBtYXRjaGVkQ29sdW1uID0gZm91bmQgPyBjb2x1bW4gOiBzZWdtZW50c1ttaW5dW0NPTFVNTl07XG4gIGlmICghZm91bmQpIG1pbiA9IGxvd2VyQm91bmQoc2VnbWVudHMsIG1hdGNoZWRDb2x1bW4sIG1pbik7XG4gIGNvbnN0IG1heCA9IHVwcGVyQm91bmQoc2VnbWVudHMsIG1hdGNoZWRDb2x1bW4sIG1pbik7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKDsgbWluIDw9IG1heDsgbWluKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbbWluXTtcbiAgICByZXN1bHQucHVzaChHTWFwcGluZyhzZWdtZW50W1JFVl9HRU5FUkFURURfTElORV0gKyAxLCBzZWdtZW50W1JFVl9HRU5FUkFURURfQ09MVU1OXSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbihtYXAsIHNvdXJjZSwgbGluZSwgY29sdW1uLCBiaWFzLCBhbGwpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGluZS0tO1xuICBpZiAobGluZSA8IDApIHRocm93IG5ldyBFcnJvcihMSU5FX0dUUl9aRVJPKTtcbiAgaWYgKGNvbHVtbiA8IDApIHRocm93IG5ldyBFcnJvcihDT0xfR1RSX0VRX1pFUk8pO1xuICBjb25zdCB7IHNvdXJjZXMsIHJlc29sdmVkU291cmNlcyB9ID0gbWFwO1xuICBsZXQgc291cmNlSW5kZXgyID0gc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gIGlmIChzb3VyY2VJbmRleDIgPT09IC0xKSBzb3VyY2VJbmRleDIgPSByZXNvbHZlZFNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuICBpZiAoc291cmNlSW5kZXgyID09PSAtMSkgcmV0dXJuIGFsbCA/IFtdIDogR01hcHBpbmcobnVsbCwgbnVsbCk7XG4gIGNvbnN0IGJ5U291cmNlTWVtb3MgPSAoX2EgPSBjYXN0KG1hcCkpLl9ieVNvdXJjZU1lbW9zIHx8IChfYS5fYnlTb3VyY2VNZW1vcyA9IHNvdXJjZXMubWFwKG1lbW9pemVkU3RhdGUpKTtcbiAgY29uc3QgZ2VuZXJhdGVkID0gKF9iID0gY2FzdChtYXApKS5fYnlTb3VyY2VzIHx8IChfYi5fYnlTb3VyY2VzID0gYnVpbGRCeVNvdXJjZXMoZGVjb2RlZE1hcHBpbmdzKG1hcCksIGJ5U291cmNlTWVtb3MpKTtcbiAgY29uc3Qgc2VnbWVudHMgPSBnZW5lcmF0ZWRbc291cmNlSW5kZXgyXVtsaW5lXTtcbiAgaWYgKHNlZ21lbnRzID09IG51bGwpIHJldHVybiBhbGwgPyBbXSA6IEdNYXBwaW5nKG51bGwsIG51bGwpO1xuICBjb25zdCBtZW1vID0gYnlTb3VyY2VNZW1vc1tzb3VyY2VJbmRleDJdO1xuICBpZiAoYWxsKSByZXR1cm4gc2xpY2VHZW5lcmF0ZWRQb3NpdGlvbnMoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcyk7XG4gIGNvbnN0IGluZGV4ID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcyk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBHTWFwcGluZyhudWxsLCBudWxsKTtcbiAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgcmV0dXJuIEdNYXBwaW5nKHNlZ21lbnRbUkVWX0dFTkVSQVRFRF9MSU5FXSArIDEsIHNlZ21lbnRbUkVWX0dFTkVSQVRFRF9DT0xVTU5dKTtcbn1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNlLW1hcHBpbmcudW1kLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js\n\n}");

/***/ },

/***/ "./node_modules/acorn/dist/acorn.js"
/*!******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.js ***!
  \******************************************/
(__unused_webpack_module, exports) {

eval("{(function (global, factory) {\n   true ? factory(exports) :\n  0;\n})(this, (function (exports) { 'use strict';\n\n  // This file was generated. Do not modify manually!\n  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\n  // This file was generated. Do not modify manually!\n  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\n\n  // This file was generated. Do not modify manually!\n  var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\n\n  // This file was generated. Do not modify manually!\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7cd\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7dc\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n\n  // These are a run-length and offset encoded representation of the\n  // >0xffff code points that are a valid part of identifiers. The\n  // offset starts at 0x10000, and each pair of numbers represents an\n  // offset to the next range, and then a size of the range.\n\n  // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n  };\n\n  // And the keywords\n\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\n  var keywords$1 = {\n    5: ecma5AndLessKeywords,\n    \"5module\": ecma5AndLessKeywords + \" export import\",\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n  };\n\n  var keywordRelationalOperator = /^in(stanceof)?$/;\n\n  // ## Character categories\n\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n  function isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i];\n      if (pos > code) { return false }\n      pos += set[i + 1];\n      if (pos >= code) { return true }\n    }\n    return false\n  }\n\n  // Test whether a given character code starts an identifier.\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) { return code === 36 }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes)\n  }\n\n  // Test whether a given character is part of an identifier.\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) { return code === 36 }\n    if (code < 58) { return true }\n    if (code < 65) { return false }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n  }\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var TokenType = function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n  // Map keyword names to token types.\n\n  var keywords = {};\n\n  // Succinct definitions of keyword token types\n  function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords[name] = new TokenType(name, options)\n  }\n\n  var types$1 = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    privateId: new TokenType(\"privateId\", startsExpr),\n    eof: new TokenType(\"eof\"),\n\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    questionDot: new TokenType(\"?.\"),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n\n    eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n    assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n    incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n    prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {beforeExpr: true}),\n    coalesce: binop(\"??\", 1),\n\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {isLoop: true}),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {isLoop: true}),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\", startsExpr),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n    _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n    _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n  };\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n  function isNewLine(code) {\n    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n  }\n\n  function nextLineBreak(code, from, end) {\n    if ( end === void 0 ) end = code.length;\n\n    for (var i = from; i < end; i++) {\n      var next = code.charCodeAt(i);\n      if (isNewLine(next))\n        { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }\n    }\n    return -1\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n  var ref = Object.prototype;\n  var hasOwnProperty = ref.hasOwnProperty;\n  var toString = ref.toString;\n\n  var hasOwn = Object.hasOwn || (function (obj, propName) { return (\n    hasOwnProperty.call(obj, propName)\n  ); });\n\n  var isArray = Array.isArray || (function (obj) { return (\n    toString.call(obj) === \"[object Array]\"\n  ); });\n\n  var regexpCache = Object.create(null);\n\n  function wordsRegexp(words) {\n    return regexpCache[words] || (regexpCache[words] = new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\"))\n  }\n\n  function codePointToString(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) { return String.fromCharCode(code) }\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n  }\n\n  var loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n\n  // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n  var Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n  };\n\n  Position.prototype.offset = function offset (n) {\n    return new Position(this.line, this.column + n)\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) { this.source = p.sourceFile; }\n  };\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      var nextBreak = nextLineBreak(input, cur, offset);\n      if (nextBreak < 0) { return new Position(line, offset - cur) }\n      ++line;\n      cur = nextBreak;\n    }\n  }\n\n  // A second argument must be given to configure the parser process.\n  // These options are recognized (only `ecmaVersion` is required):\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n    // (the latest version the library supports). This influences\n    // support for strict mode, the set of reserved words, and support\n    // for new syntax features.\n    ecmaVersion: null,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called when\n    // a semicolon is automatically inserted. It will be passed the\n    // position of the inserted semicolon as an offset, and if\n    // `locations` is enabled, it is given the location as a `{line,\n    // column}` object as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program, and an import.meta expression\n    // in a script isn't considered an error.\n    allowImportExportEverywhere: false,\n    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: null,\n    // When enabled, super identifiers are not constrained to\n    // appearing in methods and do not raise an error when they appear elsewhere.\n    allowSuperOutsideMethod: null,\n    // When enabled, hashbang directive in the beginning of file is\n    // allowed and treated as a line comment. Enabled by default when\n    // `ecmaVersion` >= 2023.\n    allowHashBang: false,\n    // By default, the parser will verify that private properties are\n    // only used in places where they are valid and have been declared.\n    // Set this to false to turn such checks off.\n    checkPrivateFields: true,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callbackthat will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callbackthat will corrupt its internal state.\n    // When this option has an array as value, objects representing the\n    // comments are pushed to it.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n  };\n\n  // Interpret and default an options object\n\n  var warnedAboutEcmaVersion = false;\n\n  function getOptions(opts) {\n    var options = {};\n\n    for (var opt in defaultOptions)\n      { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n    if (options.ecmaVersion === \"latest\") {\n      options.ecmaVersion = 1e8;\n    } else if (options.ecmaVersion == null) {\n      if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n        warnedAboutEcmaVersion = true;\n        console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n      }\n      options.ecmaVersion = 11;\n    } else if (options.ecmaVersion >= 2015) {\n      options.ecmaVersion -= 2009;\n    }\n\n    if (options.allowReserved == null)\n      { options.allowReserved = options.ecmaVersion < 5; }\n\n    if (!opts || opts.allowHashBang == null)\n      { options.allowHashBang = options.ecmaVersion >= 14; }\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken;\n      options.onToken = function (token) { return tokens.push(token); };\n    }\n    if (isArray(options.onComment))\n      { options.onComment = pushComment(options, options.onComment); }\n\n    return options\n  }\n\n  function pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text,\n        start: start,\n        end: end\n      };\n      if (options.locations)\n        { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n      if (options.ranges)\n        { comment.range = [start, end]; }\n      array.push(comment);\n    }\n  }\n\n  // Each scope gets a bitset that may contain these flags\n  var\n      SCOPE_TOP = 1,\n      SCOPE_FUNCTION = 2,\n      SCOPE_ASYNC = 4,\n      SCOPE_GENERATOR = 8,\n      SCOPE_ARROW = 16,\n      SCOPE_SIMPLE_CATCH = 32,\n      SCOPE_SUPER = 64,\n      SCOPE_DIRECT_SUPER = 128,\n      SCOPE_CLASS_STATIC_BLOCK = 256,\n      SCOPE_CLASS_FIELD_INIT = 512,\n      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\n\n  function functionFlags(async, generator) {\n    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n  }\n\n  // Used in checkLVal* and declareName to determine the type of a binding\n  var\n      BIND_NONE = 0, // Not a binding\n      BIND_VAR = 1, // Var-style binding\n      BIND_LEXICAL = 2, // Let- or const-style binding\n      BIND_FUNCTION = 3, // Function declaration\n      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n      reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n      if (options.sourceType === \"module\") { reserved += \" await\"; }\n    }\n    this.reservedWords = wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input);\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = types$1.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n    this.potentialArrowInForAwait = false;\n\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = Object.create(null);\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n      { this.skipLineComment(2); }\n\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope(SCOPE_TOP);\n\n    // For RegExp validation\n    this.regexpState = null;\n\n    // The stack of private names.\n    // Each element has two properties: 'declared' and 'used'.\n    // When it exited from the outermost class definition, all used private names must be declared.\n    this.privateNameStack = [];\n  };\n\n  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };\n\n  Parser.prototype.parse = function parse () {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node)\n  };\n\n  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n\n  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n\n  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n\n  prototypeAccessors.canAwait.get = function () {\n    for (var i = this.scopeStack.length - 1; i >= 0; i--) {\n      var ref = this.scopeStack[i];\n        var flags = ref.flags;\n      if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) { return false }\n      if (flags & SCOPE_FUNCTION) { return (flags & SCOPE_ASYNC) > 0 }\n    }\n    return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction\n  };\n\n  prototypeAccessors.allowSuper.get = function () {\n    var ref = this.currentThisScope();\n      var flags = ref.flags;\n    return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod\n  };\n\n  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n\n  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n  prototypeAccessors.allowNewDotTarget.get = function () {\n    for (var i = this.scopeStack.length - 1; i >= 0; i--) {\n      var ref = this.scopeStack[i];\n        var flags = ref.flags;\n      if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) ||\n          ((flags & SCOPE_FUNCTION) && !(flags & SCOPE_ARROW))) { return true }\n    }\n    return false\n  };\n\n  prototypeAccessors.inClassStaticBlock.get = function () {\n    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0\n  };\n\n  Parser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  Parser.parse = function parse (input, options) {\n    return new this(options, input).parse()\n  };\n\n  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression()\n  };\n\n  Parser.tokenizer = function tokenizer (input, options) {\n    return new this(options, input)\n  };\n\n  Object.defineProperties( Parser.prototype, prototypeAccessors );\n\n  var pp$9 = Parser.prototype;\n\n  // ## Parser utilities\n\n  var literal = /^(?:'((?:\\\\[^]|[^'\\\\])*?)'|\"((?:\\\\[^]|[^\"\\\\])*?)\")/;\n  pp$9.strictDirective = function(start) {\n    if (this.options.ecmaVersion < 5) { return false }\n    for (;;) {\n      // Try to find string literal.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      var match = literal.exec(this.input.slice(start));\n      if (!match) { return false }\n      if ((match[1] || match[2]) === \"use strict\") {\n        skipWhiteSpace.lastIndex = start + match[0].length;\n        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n        var next = this.input.charAt(end);\n        return next === \";\" || next === \"}\" ||\n          (lineBreak.test(spaceAfter[0]) &&\n           !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\"))\n      }\n      start += match[0].length;\n\n      // Skip semicolon, if any.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      if (this.input[start] === \";\")\n        { start++; }\n    }\n  };\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  pp$9.eat = function(type) {\n    if (this.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  // Tests whether parsed token is a contextual keyword.\n\n  pp$9.isContextual = function(name) {\n    return this.type === types$1.name && this.value === name && !this.containsEsc\n  };\n\n  // Consumes contextual keyword if possible.\n\n  pp$9.eatContextual = function(name) {\n    if (!this.isContextual(name)) { return false }\n    this.next();\n    return true\n  };\n\n  // Asserts that following token is given contextual keyword.\n\n  pp$9.expectContextual = function(name) {\n    if (!this.eatContextual(name)) { this.unexpected(); }\n  };\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  pp$9.canInsertSemicolon = function() {\n    return this.type === types$1.eof ||\n      this.type === types$1.braceR ||\n      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  pp$9.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon)\n        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n      return true\n    }\n  };\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  pp$9.semicolon = function() {\n    if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }\n  };\n\n  pp$9.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n      if (this.options.onTrailingComma)\n        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n      if (!notNext)\n        { this.next(); }\n      return true\n    }\n  };\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  pp$9.expect = function(type) {\n    this.eat(type) || this.unexpected();\n  };\n\n  // Raise an unexpected token error.\n\n  pp$9.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n  };\n\n  var DestructuringErrors = function DestructuringErrors() {\n    this.shorthandAssign =\n    this.trailingComma =\n    this.parenthesizedAssign =\n    this.parenthesizedBind =\n    this.doubleProto =\n      -1;\n  };\n\n  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) { return }\n    if (refDestructuringErrors.trailingComma > -1)\n      { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) { this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\"); }\n  };\n\n  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) { return false }\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n    if (shorthandAssign >= 0)\n      { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n    if (doubleProto >= 0)\n      { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n  };\n\n  pp$9.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n      { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n    if (this.awaitPos)\n      { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n  };\n\n  pp$9.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\")\n      { return this.isSimpleAssignTarget(expr.expression) }\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n  };\n\n  var pp$8 = Parser.prototype;\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$8.parseTopLevel = function(node) {\n    var exports = Object.create(null);\n    if (!node.body) { node.body = []; }\n    while (this.type !== types$1.eof) {\n      var stmt = this.parseStatement(null, true, exports);\n      node.body.push(stmt);\n    }\n    if (this.inModule)\n      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n        {\n          var name = list[i];\n\n          this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n        } }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\")\n  };\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  pp$8.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91 || nextCh === 92) { return true } // '[', '\\'\n    if (context) { return false }\n\n    if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral\n    if (isIdentifierStart(nextCh, true)) {\n      var pos = next + 1;\n      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }\n      if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }\n      var ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) { return true }\n    }\n    return false\n  };\n\n  // check 'async [no LineTerminator here] function'\n  // - 'async /*foo*/ function' is OK.\n  // - 'async /*\\n*/ function' is invalid.\n  pp$8.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n      { return false }\n\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, after;\n    return !lineBreak.test(this.input.slice(this.pos, next)) &&\n      this.input.slice(next, next + 8) === \"function\" &&\n      (next + 8 === this.input.length ||\n       !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))\n  };\n\n  pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {\n    if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? \"await\" : \"using\"))\n      { return false }\n\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length;\n\n    if (lineBreak.test(this.input.slice(this.pos, next))) { return false }\n\n    if (isAwaitUsing) {\n      var awaitEndPos = next + 5 /* await */, after;\n      if (this.input.slice(next, awaitEndPos) !== \"using\" ||\n        awaitEndPos === this.input.length ||\n        isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) ||\n        (after > 0xd7ff && after < 0xdc00)\n      ) { return false }\n\n      skipWhiteSpace.lastIndex = awaitEndPos;\n      var skipAfterUsing = skipWhiteSpace.exec(this.input);\n      if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) { return false }\n    }\n\n    if (isFor) {\n      var ofEndPos = next + 2 /* of */, after$1;\n      if (this.input.slice(next, ofEndPos) === \"of\") {\n        if (ofEndPos === this.input.length ||\n          (!isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 0xd7ff && after$1 < 0xdc00))) { return false }\n      }\n    }\n\n    var ch = this.input.charCodeAt(next);\n    return isIdentifierStart(ch, true) || ch === 92 // '\\'\n  };\n\n  pp$8.isAwaitUsing = function(isFor) {\n    return this.isUsingKeyword(true, isFor)\n  };\n\n  pp$8.isUsing = function(isFor) {\n    return this.isUsingKeyword(false, isFor)\n  };\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n  pp$8.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n\n    if (this.isLet(context)) {\n      starttype = types$1._var;\n      kind = \"let\";\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n    case types$1._debugger: return this.parseDebuggerStatement(node)\n    case types$1._do: return this.parseDoStatement(node)\n    case types$1._for: return this.parseForStatement(node)\n    case types$1._function:\n      // Function as sole body of either an if statement or a labeled statement\n      // works, but not when it is part of a labeled statement that is the sole\n      // body of an if statement.\n      if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n      return this.parseFunctionStatement(node, false, !context)\n    case types$1._class:\n      if (context) { this.unexpected(); }\n      return this.parseClass(node, true)\n    case types$1._if: return this.parseIfStatement(node)\n    case types$1._return: return this.parseReturnStatement(node)\n    case types$1._switch: return this.parseSwitchStatement(node)\n    case types$1._throw: return this.parseThrowStatement(node)\n    case types$1._try: return this.parseTryStatement(node)\n    case types$1._const: case types$1._var:\n      kind = kind || this.value;\n      if (context && kind !== \"var\") { this.unexpected(); }\n      return this.parseVarStatement(node, kind)\n    case types$1._while: return this.parseWhileStatement(node)\n    case types$1._with: return this.parseWithStatement(node)\n    case types$1.braceL: return this.parseBlock(true, node)\n    case types$1.semi: return this.parseEmptyStatement(node)\n    case types$1._export:\n    case types$1._import:\n      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        if (nextCh === 40 || nextCh === 46) // '(' or '.'\n          { return this.parseExpressionStatement(node, this.parseExpression()) }\n      }\n\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel)\n          { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n        if (!this.inModule)\n          { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n      }\n      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n    default:\n      if (this.isAsyncFunction()) {\n        if (context) { this.unexpected(); }\n        this.next();\n        return this.parseFunctionStatement(node, true, !context)\n      }\n\n      var usingKind = this.isAwaitUsing(false) ? \"await using\" : this.isUsing(false) ? \"using\" : null;\n      if (usingKind) {\n        if (topLevel && this.options.sourceType === \"script\") {\n          this.raise(this.start, \"Using declaration cannot appear in the top level when source type is `script`\");\n        }\n        if (usingKind === \"await using\") {\n          if (!this.canAwait) {\n            this.raise(this.start, \"Await using cannot appear outside of async function\");\n          }\n          this.next();\n        }\n        this.next();\n        this.parseVar(node, false, usingKind);\n        this.semicolon();\n        return this.finishNode(node, \"VariableDeclaration\")\n      }\n\n      var maybeName = this.value, expr = this.parseExpression();\n      if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon))\n        { return this.parseLabeledStatement(node, maybeName, expr, context) }\n      else { return this.parseExpressionStatement(node, expr) }\n    }\n  };\n\n  pp$8.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }\n    else if (this.type !== types$1.name) { this.unexpected(); }\n    else {\n      node.label = this.parseIdent();\n      this.semicolon();\n    }\n\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for (; i < this.labels.length; ++i) {\n      var lab = this.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n        if (node.label && isBreak) { break }\n      }\n    }\n    if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n  };\n\n  pp$8.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\")\n  };\n\n  pp$8.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect(types$1._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6)\n      { this.eat(types$1.semi); }\n    else\n      { this.semicolon(); }\n    return this.finishNode(node, \"DoWhileStatement\")\n  };\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  pp$8.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterScope(0);\n    this.expect(types$1.parenL);\n    if (this.type === types$1.semi) {\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, null)\n    }\n    var isLet = this.isLet();\n    if (this.type === types$1._var || this.type === types$1._const || isLet) {\n      var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n      this.next();\n      this.parseVar(init$1, true, kind);\n      this.finishNode(init$1, \"VariableDeclaration\");\n      return this.parseForAfterInit(node, init$1, awaitAt)\n    }\n    var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n\n    var usingKind = this.isUsing(true) ? \"using\" : this.isAwaitUsing(true) ? \"await using\" : null;\n    if (usingKind) {\n      var init$2 = this.startNode();\n      this.next();\n      if (usingKind === \"await using\") { this.next(); }\n      this.parseVar(init$2, true, usingKind);\n      this.finishNode(init$2, \"VariableDeclaration\");\n      return this.parseForAfterInit(node, init$2, awaitAt)\n    }\n    var containsEsc = this.containsEsc;\n    var refDestructuringErrors = new DestructuringErrors;\n    var initPos = this.start;\n    var init = awaitAt > -1\n      ? this.parseExprSubscripts(refDestructuringErrors, \"await\")\n      : this.parseExpression(true, refDestructuringErrors);\n    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      if (awaitAt > -1) { // implies `ecmaVersion >= 9` (see declaration of awaitAt)\n        if (this.type === types$1._in) { this.unexpected(awaitAt); }\n        node.await = true;\n      } else if (isForOf && this.options.ecmaVersion >= 8) {\n        if (init.start === initPos && !containsEsc && init.type === \"Identifier\" && init.name === \"async\") { this.unexpected(); }\n        else if (this.options.ecmaVersion >= 9) { node.await = false; }\n      }\n      if (startsWithLet && isForOf) { this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\"); }\n      this.toAssignable(init, false, refDestructuringErrors);\n      this.checkLValPattern(init);\n      return this.parseForIn(node, init)\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init)\n  };\n\n  // Helper method to parse for loop after variable initialization\n  pp$8.parseForAfterInit = function(node, init, awaitAt) {\n    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init.declarations.length === 1) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types$1._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init)\n  };\n\n  pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n  };\n\n  pp$8.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\")\n  };\n\n  pp$8.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n      { this.raise(this.start, \"'return' outside of function\"); }\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }\n    else { node.argument = this.parseExpression(); this.semicolon(); }\n    return this.finishNode(node, \"ReturnStatement\")\n  };\n\n  pp$8.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types$1.braceL);\n    this.labels.push(switchLabel);\n    this.enterScope(0);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    var cur;\n    for (var sawDefault = false; this.type !== types$1.braceR;) {\n      if (this.type === types$1._case || this.type === types$1._default) {\n        var isCase = this.type === types$1._case;\n        if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n        node.cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(types$1.colon);\n      } else {\n        if (!cur) { this.unexpected(); }\n        cur.consequent.push(this.parseStatement(null));\n      }\n    }\n    this.exitScope();\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\")\n  };\n\n  pp$8.parseThrowStatement = function(node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n      { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\")\n  };\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty$1 = [];\n\n  pp$8.parseCatchClauseParam = function() {\n    var param = this.parseBindingAtom();\n    var simple = param.type === \"Identifier\";\n    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n    this.expect(types$1.parenR);\n\n    return param\n  };\n\n  pp$8.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === types$1._catch) {\n      var clause = this.startNode();\n      this.next();\n      if (this.eat(types$1.parenL)) {\n        clause.param = this.parseCatchClauseParam();\n      } else {\n        if (this.options.ecmaVersion < 10) { this.unexpected(); }\n        clause.param = null;\n        this.enterScope(0);\n      }\n      clause.body = this.parseBlock(false);\n      this.exitScope();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer)\n      { this.raise(node.start, \"Missing catch or finally clause\"); }\n    return this.finishNode(node, \"TryStatement\")\n  };\n\n  pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  pp$8.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\")\n  };\n\n  pp$8.parseWithStatement = function(node) {\n    if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\")\n  };\n\n  pp$8.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\")\n  };\n\n  pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n      {\n      var label = list[i$1];\n\n      if (label.name === maybeName)\n        { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    } }\n    var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n    for (var i = this.labels.length - 1; i >= 0; i--) {\n      var label$1 = this.labels[i];\n      if (label$1.statementStart === node.start) {\n        // Update information about previous labels on this node\n        label$1.statementStart = this.start;\n        label$1.kind = kind;\n      } else { break }\n    }\n    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\")\n  };\n\n  pp$8.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\")\n  };\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n    if ( node === void 0 ) node = this.startNode();\n\n    node.body = [];\n    this.expect(types$1.braceL);\n    if (createNewLexicalScope) { this.enterScope(0); }\n    while (this.type !== types$1.braceR) {\n      var stmt = this.parseStatement(null);\n      node.body.push(stmt);\n    }\n    if (exitStrict) { this.strict = false; }\n    this.next();\n    if (createNewLexicalScope) { this.exitScope(); }\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  pp$8.parseFor = function(node, init) {\n    node.init = init;\n    this.expect(types$1.semi);\n    node.test = this.type === types$1.semi ? null : this.parseExpression();\n    this.expect(types$1.semi);\n    node.update = this.type === types$1.parenR ? null : this.parseExpression();\n    this.expect(types$1.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  pp$8.parseForIn = function(node, init) {\n    var isForIn = this.type === types$1._in;\n    this.next();\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (\n        !isForIn ||\n        this.options.ecmaVersion < 8 ||\n        this.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\"\n      )\n    ) {\n      this.raise(\n        init.start,\n        ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n      );\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types$1.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n  };\n\n  // Parse a list of variable declarations.\n\n  pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n    node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      var decl = this.startNode();\n      this.parseVarId(decl, kind);\n      if (this.eat(types$1.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else if (!allowMissingInitializer && kind === \"const\" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n        this.unexpected();\n      } else if (!allowMissingInitializer && (kind === \"using\" || kind === \"await using\") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual(\"of\")) {\n        this.raise(this.lastTokEnd, (\"Missing initializer in \" + kind + \" declaration\"));\n      } else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n        this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n      } else {\n        decl.init = null;\n      }\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types$1.comma)) { break }\n    }\n    return node\n  };\n\n  pp$8.parseVarId = function(decl, kind) {\n    decl.id = kind === \"using\" || kind === \"await using\"\n      ? this.parseIdent()\n      : this.parseBindingAtom();\n\n    this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n  };\n\n  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n  // Parse a function declaration or literal (depending on the\n  // `statement & FUNC_STATEMENT`).\n\n  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n  pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n      if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))\n        { this.unexpected(); }\n      node.generator = this.eat(types$1.star);\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    if (statement & FUNC_STATEMENT) {\n      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();\n      if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n        // If it is a regular function declaration in sloppy mode, then it is\n        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n        // mode depends on properties of the current scope (see\n        // treatFunctionsAsVar).\n        { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n    }\n\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(node.async, node.generator));\n\n    if (!(statement & FUNC_STATEMENT))\n      { node.id = this.type === types$1.name ? this.parseIdent() : null; }\n\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  pp$8.parseFunctionParams = function(node) {\n    this.expect(types$1.parenL);\n    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n  };\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  pp$8.parseClass = function(node, isStatement) {\n    this.next();\n\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var privateNameMap = this.enterClassBody();\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types$1.braceL);\n    while (this.type !== types$1.braceR) {\n      var element = this.parseClassElement(node.superClass !== null);\n      if (element) {\n        classBody.body.push(element);\n        if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n          if (hadConstructor) { this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\"); }\n          hadConstructor = true;\n        } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n          this.raiseRecoverable(element.key.start, (\"Identifier '#\" + (element.key.name) + \"' has already been declared\"));\n        }\n      }\n    }\n    this.strict = oldStrict;\n    this.next();\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.exitClassBody();\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  pp$8.parseClassElement = function(constructorAllowsSuper) {\n    if (this.eat(types$1.semi)) { return null }\n\n    var ecmaVersion = this.options.ecmaVersion;\n    var node = this.startNode();\n    var keyName = \"\";\n    var isGenerator = false;\n    var isAsync = false;\n    var kind = \"method\";\n    var isStatic = false;\n\n    if (this.eatContextual(\"static\")) {\n      // Parse static init block\n      if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n        this.parseClassStaticBlock(node);\n        return node\n      }\n      if (this.isClassElementNameStart() || this.type === types$1.star) {\n        isStatic = true;\n      } else {\n        keyName = \"static\";\n      }\n    }\n    node.static = isStatic;\n    if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n        isAsync = true;\n      } else {\n        keyName = \"async\";\n      }\n    }\n    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n      isGenerator = true;\n    }\n    if (!keyName && !isAsync && !isGenerator) {\n      var lastValue = this.value;\n      if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n        if (this.isClassElementNameStart()) {\n          kind = lastValue;\n        } else {\n          keyName = lastValue;\n        }\n      }\n    }\n\n    // Parse element name\n    if (keyName) {\n      // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n      // The last token is any of those. Make it the element name.\n      node.computed = false;\n      node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n      node.key.name = keyName;\n      this.finishNode(node.key, \"Identifier\");\n    } else {\n      this.parseClassElementName(node);\n    }\n\n    // Parse element value\n    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n      var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n      var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n      // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n      if (isConstructor && kind !== \"method\") { this.raise(node.key.start, \"Constructor can't have get/set modifier\"); }\n      node.kind = isConstructor ? \"constructor\" : kind;\n      this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n    } else {\n      this.parseClassField(node);\n    }\n\n    return node\n  };\n\n  pp$8.isClassElementNameStart = function() {\n    return (\n      this.type === types$1.name ||\n      this.type === types$1.privateId ||\n      this.type === types$1.num ||\n      this.type === types$1.string ||\n      this.type === types$1.bracketL ||\n      this.type.keyword\n    )\n  };\n\n  pp$8.parseClassElementName = function(element) {\n    if (this.type === types$1.privateId) {\n      if (this.value === \"constructor\") {\n        this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n      }\n      element.computed = false;\n      element.key = this.parsePrivateIdent();\n    } else {\n      this.parsePropertyName(element);\n    }\n  };\n\n  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    // Check key and flags\n    var key = method.key;\n    if (method.kind === \"constructor\") {\n      if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n      if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    } else if (method.static && checkKeyName(method, \"prototype\")) {\n      this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n\n    // Parse value\n    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n\n    // Check value\n    if (method.kind === \"get\" && value.params.length !== 0)\n      { this.raiseRecoverable(value.start, \"getter should have no params\"); }\n    if (method.kind === \"set\" && value.params.length !== 1)\n      { this.raiseRecoverable(value.start, \"setter should have exactly one param\"); }\n    if (method.kind === \"set\" && value.params[0].type === \"RestElement\")\n      { this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\"); }\n\n    return this.finishNode(method, \"MethodDefinition\")\n  };\n\n  pp$8.parseClassField = function(field) {\n    if (checkKeyName(field, \"constructor\")) {\n      this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n    } else if (field.static && checkKeyName(field, \"prototype\")) {\n      this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n    }\n\n    if (this.eat(types$1.eq)) {\n      // To raise SyntaxError if 'arguments' exists in the initializer.\n      this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);\n      field.value = this.parseMaybeAssign();\n      this.exitScope();\n    } else {\n      field.value = null;\n    }\n    this.semicolon();\n\n    return this.finishNode(field, \"PropertyDefinition\")\n  };\n\n  pp$8.parseClassStaticBlock = function(node) {\n    node.body = [];\n\n    var oldLabels = this.labels;\n    this.labels = [];\n    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n    while (this.type !== types$1.braceR) {\n      var stmt = this.parseStatement(null);\n      node.body.push(stmt);\n    }\n    this.next();\n    this.exitScope();\n    this.labels = oldLabels;\n\n    return this.finishNode(node, \"StaticBlock\")\n  };\n\n  pp$8.parseClassId = function(node, isStatement) {\n    if (this.type === types$1.name) {\n      node.id = this.parseIdent();\n      if (isStatement)\n        { this.checkLValSimple(node.id, BIND_LEXICAL, false); }\n    } else {\n      if (isStatement === true)\n        { this.unexpected(); }\n      node.id = null;\n    }\n  };\n\n  pp$8.parseClassSuper = function(node) {\n    node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;\n  };\n\n  pp$8.enterClassBody = function() {\n    var element = {declared: Object.create(null), used: []};\n    this.privateNameStack.push(element);\n    return element.declared\n  };\n\n  pp$8.exitClassBody = function() {\n    var ref = this.privateNameStack.pop();\n    var declared = ref.declared;\n    var used = ref.used;\n    if (!this.options.checkPrivateFields) { return }\n    var len = this.privateNameStack.length;\n    var parent = len === 0 ? null : this.privateNameStack[len - 1];\n    for (var i = 0; i < used.length; ++i) {\n      var id = used[i];\n      if (!hasOwn(declared, id.name)) {\n        if (parent) {\n          parent.used.push(id);\n        } else {\n          this.raiseRecoverable(id.start, (\"Private field '#\" + (id.name) + \"' must be declared in an enclosing class\"));\n        }\n      }\n    }\n  };\n\n  function isPrivateNameConflicted(privateNameMap, element) {\n    var name = element.key.name;\n    var curr = privateNameMap[name];\n\n    var next = \"true\";\n    if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n      next = (element.static ? \"s\" : \"i\") + element.kind;\n    }\n\n    // `class { get #a(){}; static set #a(_){} }` is also conflict.\n    if (\n      curr === \"iget\" && next === \"iset\" ||\n      curr === \"iset\" && next === \"iget\" ||\n      curr === \"sget\" && next === \"sset\" ||\n      curr === \"sset\" && next === \"sget\"\n    ) {\n      privateNameMap[name] = \"true\";\n      return false\n    } else if (!curr) {\n      privateNameMap[name] = next;\n      return false\n    } else {\n      return true\n    }\n  }\n\n  function checkKeyName(node, name) {\n    var computed = node.computed;\n    var key = node.key;\n    return !computed && (\n      key.type === \"Identifier\" && key.name === name ||\n      key.type === \"Literal\" && key.value === name\n    )\n  }\n\n  // Parses module export declaration.\n\n  pp$8.parseExportAllDeclaration = function(node, exports) {\n    if (this.options.ecmaVersion >= 11) {\n      if (this.eatContextual(\"as\")) {\n        node.exported = this.parseModuleExportName();\n        this.checkExport(exports, node.exported, this.lastTokStart);\n      } else {\n        node.exported = null;\n      }\n    }\n    this.expectContextual(\"from\");\n    if (this.type !== types$1.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    if (this.options.ecmaVersion >= 16)\n      { node.attributes = this.parseWithClause(); }\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  };\n\n  pp$8.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat(types$1.star)) {\n      return this.parseExportAllDeclaration(node, exports)\n    }\n    if (this.eat(types$1._default)) { // export default ...\n      this.checkExport(exports, \"default\", this.lastTokStart);\n      node.declaration = this.parseExportDefaultDeclaration();\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseExportDeclaration(node);\n      if (node.declaration.type === \"VariableDeclaration\")\n        { this.checkVariableExport(exports, node.declaration.declarations); }\n      else\n        { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }\n      node.specifiers = [];\n      node.source = null;\n      if (this.options.ecmaVersion >= 16)\n        { node.attributes = []; }\n    } else { // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers(exports);\n      if (this.eatContextual(\"from\")) {\n        if (this.type !== types$1.string) { this.unexpected(); }\n        node.source = this.parseExprAtom();\n        if (this.options.ecmaVersion >= 16)\n          { node.attributes = this.parseWithClause(); }\n      } else {\n        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n          // check for keywords used as local names\n          var spec = list[i];\n\n          this.checkUnreserved(spec.local);\n          // check if export is defined\n          this.checkLocalExport(spec.local);\n\n          if (spec.local.type === \"Literal\") {\n            this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n          }\n        }\n\n        node.source = null;\n        if (this.options.ecmaVersion >= 16)\n          { node.attributes = []; }\n      }\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  pp$8.parseExportDeclaration = function(node) {\n    return this.parseStatement(null)\n  };\n\n  pp$8.parseExportDefaultDeclaration = function() {\n    var isAsync;\n    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)\n    } else if (this.type === types$1._class) {\n      var cNode = this.startNode();\n      return this.parseClass(cNode, \"nullableID\")\n    } else {\n      var declaration = this.parseMaybeAssign();\n      this.semicolon();\n      return declaration\n    }\n  };\n\n  pp$8.checkExport = function(exports, name, pos) {\n    if (!exports) { return }\n    if (typeof name !== \"string\")\n      { name = name.type === \"Identifier\" ? name.name : name.value; }\n    if (hasOwn(exports, name))\n      { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n    exports[name] = true;\n  };\n\n  pp$8.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\")\n      { this.checkExport(exports, pat, pat.start); }\n    else if (type === \"ObjectPattern\")\n      { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n        {\n          var prop = list[i];\n\n          this.checkPatternExport(exports, prop);\n        } }\n    else if (type === \"ArrayPattern\")\n      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n        var elt = list$1[i$1];\n\n          if (elt) { this.checkPatternExport(exports, elt); }\n      } }\n    else if (type === \"Property\")\n      { this.checkPatternExport(exports, pat.value); }\n    else if (type === \"AssignmentPattern\")\n      { this.checkPatternExport(exports, pat.left); }\n    else if (type === \"RestElement\")\n      { this.checkPatternExport(exports, pat.argument); }\n  };\n\n  pp$8.checkVariableExport = function(exports, decls) {\n    if (!exports) { return }\n    for (var i = 0, list = decls; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      this.checkPatternExport(exports, decl.id);\n    }\n  };\n\n  pp$8.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" ||\n      this.type.keyword === \"const\" ||\n      this.type.keyword === \"class\" ||\n      this.type.keyword === \"function\" ||\n      this.isLet() ||\n      this.isAsyncFunction()\n  };\n\n  // Parses a comma-separated list of module exports.\n\n  pp$8.parseExportSpecifier = function(exports) {\n    var node = this.startNode();\n    node.local = this.parseModuleExportName();\n\n    node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n    this.checkExport(\n      exports,\n      node.exported,\n      node.exported.start\n    );\n\n    return this.finishNode(node, \"ExportSpecifier\")\n  };\n\n  pp$8.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect(types$1.braceL);\n    while (!this.eat(types$1.braceR)) {\n      if (!first) {\n        this.expect(types$1.comma);\n        if (this.afterTrailingComma(types$1.braceR)) { break }\n      } else { first = false; }\n\n      nodes.push(this.parseExportSpecifier(exports));\n    }\n    return nodes\n  };\n\n  // Parses import declaration.\n\n  pp$8.parseImport = function(node) {\n    this.next();\n\n    // import '...'\n    if (this.type === types$1.string) {\n      node.specifiers = empty$1;\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = this.parseImportSpecifiers();\n      this.expectContextual(\"from\");\n      node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n    }\n    if (this.options.ecmaVersion >= 16)\n      { node.attributes = this.parseWithClause(); }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  // Parses a comma-separated list of module imports.\n\n  pp$8.parseImportSpecifier = function() {\n    var node = this.startNode();\n    node.imported = this.parseModuleExportName();\n\n    if (this.eatContextual(\"as\")) {\n      node.local = this.parseIdent();\n    } else {\n      this.checkUnreserved(node.imported);\n      node.local = node.imported;\n    }\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n\n    return this.finishNode(node, \"ImportSpecifier\")\n  };\n\n  pp$8.parseImportDefaultSpecifier = function() {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportDefaultSpecifier\")\n  };\n\n  pp$8.parseImportNamespaceSpecifier = function() {\n    var node = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node.local = this.parseIdent();\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportNamespaceSpecifier\")\n  };\n\n  pp$8.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === types$1.name) {\n      nodes.push(this.parseImportDefaultSpecifier());\n      if (!this.eat(types$1.comma)) { return nodes }\n    }\n    if (this.type === types$1.star) {\n      nodes.push(this.parseImportNamespaceSpecifier());\n      return nodes\n    }\n    this.expect(types$1.braceL);\n    while (!this.eat(types$1.braceR)) {\n      if (!first) {\n        this.expect(types$1.comma);\n        if (this.afterTrailingComma(types$1.braceR)) { break }\n      } else { first = false; }\n\n      nodes.push(this.parseImportSpecifier());\n    }\n    return nodes\n  };\n\n  pp$8.parseWithClause = function() {\n    var nodes = [];\n    if (!this.eat(types$1._with)) {\n      return nodes\n    }\n    this.expect(types$1.braceL);\n    var attributeKeys = {};\n    var first = true;\n    while (!this.eat(types$1.braceR)) {\n      if (!first) {\n        this.expect(types$1.comma);\n        if (this.afterTrailingComma(types$1.braceR)) { break }\n      } else { first = false; }\n\n      var attr = this.parseImportAttribute();\n      var keyName = attr.key.type === \"Identifier\" ? attr.key.name : attr.key.value;\n      if (hasOwn(attributeKeys, keyName))\n        { this.raiseRecoverable(attr.key.start, \"Duplicate attribute key '\" + keyName + \"'\"); }\n      attributeKeys[keyName] = true;\n      nodes.push(attr);\n    }\n    return nodes\n  };\n\n  pp$8.parseImportAttribute = function() {\n    var node = this.startNode();\n    node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n    this.expect(types$1.colon);\n    if (this.type !== types$1.string) {\n      this.unexpected();\n    }\n    node.value = this.parseExprAtom();\n    return this.finishNode(node, \"ImportAttribute\")\n  };\n\n  pp$8.parseModuleExportName = function() {\n    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n      var stringLiteral = this.parseLiteral(this.value);\n      if (loneSurrogate.test(stringLiteral.value)) {\n        this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n      }\n      return stringLiteral\n    }\n    return this.parseIdent(true)\n  };\n\n  // Set `ExpressionStatement#directive` property for directive prologues.\n  pp$8.adaptDirectivePrologue = function(statements) {\n    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n      statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n  };\n  pp$8.isDirectiveCandidate = function(statement) {\n    return (\n      this.options.ecmaVersion >= 5 &&\n      statement.type === \"ExpressionStatement\" &&\n      statement.expression.type === \"Literal\" &&\n      typeof statement.expression.value === \"string\" &&\n      // Reject parenthesized strings.\n      (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n    )\n  };\n\n  var pp$7 = Parser.prototype;\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n      case \"Identifier\":\n        if (this.inAsync && node.name === \"await\")\n          { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n        break\n\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\n          var prop = list[i];\n\n        this.toAssignable(prop, isBinding);\n          // Early error:\n          //   AssignmentRestProperty[Yield, Await] :\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\n          //\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n          if (\n            prop.type === \"RestElement\" &&\n            (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n          ) {\n            this.raise(prop.argument.start, \"Unexpected token\");\n          }\n        }\n        break\n\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n        this.toAssignable(node.value, isBinding);\n        break\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        this.toAssignableList(node.elements, isBinding);\n        break\n\n      case \"SpreadElement\":\n        node.type = \"RestElement\";\n        this.toAssignable(node.argument, isBinding);\n        if (node.argument.type === \"AssignmentPattern\")\n          { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n        break\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n        break\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n        break\n\n      case \"ChainExpression\":\n        this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n        break\n\n      case \"MemberExpression\":\n        if (!isBinding) { break }\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n      }\n    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n    return node\n  };\n\n  // Convert list of expression atoms to binding list.\n\n  pp$7.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n      if (elt) { this.toAssignable(elt, isBinding); }\n    }\n    if (end) {\n      var last = exprList[end - 1];\n      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n        { this.unexpected(last.argument.start); }\n    }\n    return exprList\n  };\n\n  // Parses spread element.\n\n  pp$7.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\")\n  };\n\n  pp$7.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== types$1.name)\n      { this.unexpected(); }\n\n    node.argument = this.parseBindingAtom();\n\n    return this.finishNode(node, \"RestElement\")\n  };\n\n  // Parses lvalue (assignable) atom.\n\n  pp$7.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) {\n      switch (this.type) {\n      case types$1.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(types$1.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\")\n\n      case types$1.braceL:\n        return this.parseObj(true)\n      }\n    }\n    return this.parseIdent()\n  };\n\n  pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (first) { first = false; }\n      else { this.expect(types$1.comma); }\n      if (allowEmpty && this.type === types$1.comma) {\n        elts.push(null);\n      } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n        break\n      } else if (this.type === types$1.ellipsis) {\n        var rest = this.parseRestBinding();\n        this.parseBindingListItem(rest);\n        elts.push(rest);\n        if (this.type === types$1.comma) { this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\"); }\n        this.expect(close);\n        break\n      } else {\n        elts.push(this.parseAssignableListItem(allowModifiers));\n      }\n    }\n    return elts\n  };\n\n  pp$7.parseAssignableListItem = function(allowModifiers) {\n    var elem = this.parseMaybeDefault(this.start, this.startLoc);\n    this.parseBindingListItem(elem);\n    return elem\n  };\n\n  pp$7.parseBindingListItem = function(param) {\n    return param\n  };\n\n  // Parses assignment pattern around given atom if possible.\n\n  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\")\n  };\n\n  // The following three functions all verify that a node is an lvalue \n  // something that can be bound, or assigned to. In order to do so, they perform\n  // a variety of checks:\n  //\n  // - Check that none of the bound/assigned-to identifiers are reserved words.\n  // - Record name declarations for bindings in the appropriate scope.\n  // - Check duplicate argument names, if checkClashes is set.\n  //\n  // If a complex binding pattern is encountered (e.g., object and array\n  // destructuring), the entire pattern is recursively checked.\n  //\n  // There are three versions of checkLVal*() appropriate for different\n  // circumstances:\n  //\n  // - checkLValSimple() shall be used if the syntactic construct supports\n  //   nothing other than identifiers and member expressions. Parenthesized\n  //   expressions are also correctly handled. This is generally appropriate for\n  //   constructs for which the spec says\n  //\n  //   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n  //   > simple.\n  //\n  //   It is also appropriate for checking if an identifier is valid and not\n  //   defined elsewhere, like import declarations or function/class identifiers.\n  //\n  //   Examples where this is used include:\n  //     a += ;\n  //     import a from '';\n  //   where a is the node to be checked.\n  //\n  // - checkLValPattern() shall be used if the syntactic construct supports\n  //   anything checkLValSimple() supports, as well as object and array\n  //   destructuring patterns. This is generally appropriate for constructs for\n  //   which the spec says\n  //\n  //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n  //   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n  //   > simple.\n  //\n  //   Examples where this is used include:\n  //     (a = );\n  //     const a = ;\n  //     try {  } catch (a) {  }\n  //   where a is the node to be checked.\n  //\n  // - checkLValInnerPattern() shall be used if the syntactic construct supports\n  //   anything checkLValPattern() supports, as well as default assignment\n  //   patterns, rest elements, and other constructs that may appear within an\n  //   object or array destructuring pattern.\n  //\n  //   As a special case, function parameters also use checkLValInnerPattern(),\n  //   as they also support defaults and rest constructs.\n  //\n  // These functions deliberately support both assignment and binding constructs,\n  // as the logic for both is exceedingly similar. If the node is the target of\n  // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n  // should be set to the appropriate BIND_* constant, like BIND_VAR or\n  // BIND_LEXICAL.\n  //\n  // If the function is called with a non-BIND_NONE bindingType, then\n  // additionally a checkClashes object may be specified to allow checking for\n  // duplicate argument names. checkClashes is ignored if the provided construct\n  // is an assignment (i.e., bindingType is BIND_NONE).\n\n  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    var isBind = bindingType !== BIND_NONE;\n\n    switch (expr.type) {\n    case \"Identifier\":\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n        { this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n      if (isBind) {\n        if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n          { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n        if (checkClashes) {\n          if (hasOwn(checkClashes, expr.name))\n            { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n          checkClashes[expr.name] = true;\n        }\n        if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n      }\n      break\n\n    case \"ChainExpression\":\n      this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n      break\n\n    case \"MemberExpression\":\n      if (isBind) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n      break\n\n    case \"ParenthesizedExpression\":\n      if (isBind) { this.raiseRecoverable(expr.start, \"Binding parenthesized expression\"); }\n      return this.checkLValSimple(expr.expression, bindingType, checkClashes)\n\n    default:\n      this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n  };\n\n  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    switch (expr.type) {\n    case \"ObjectPattern\":\n      for (var i = 0, list = expr.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.checkLValInnerPattern(prop, bindingType, checkClashes);\n      }\n      break\n\n    case \"ArrayPattern\":\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n        var elem = list$1[i$1];\n\n      if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }\n      }\n      break\n\n    default:\n      this.checkLValSimple(expr, bindingType, checkClashes);\n    }\n  };\n\n  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    switch (expr.type) {\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n      break\n\n    case \"AssignmentPattern\":\n      this.checkLValPattern(expr.left, bindingType, checkClashes);\n      break\n\n    case \"RestElement\":\n      this.checkLValPattern(expr.argument, bindingType, checkClashes);\n      break\n\n    default:\n      this.checkLValPattern(expr, bindingType, checkClashes);\n    }\n  };\n\n  // The algorithm used to determine whether a regexp can appear at a\n  // given point in the program is loosely based on sweet.js' approach.\n  // See https://github.com/mozilla/sweet.js/wiki/design\n\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n\n  var types = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n  };\n\n  var pp$6 = Parser.prototype;\n\n  pp$6.initialContext = function() {\n    return [types.b_stat]\n  };\n\n  pp$6.curContext = function() {\n    return this.context[this.context.length - 1]\n  };\n\n  pp$6.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === types.f_expr || parent === types.f_stat)\n      { return true }\n    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))\n      { return !parent.isExpr }\n\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)\n      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)\n      { return true }\n    if (prevType === types$1.braceL)\n      { return parent === types.b_stat }\n    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)\n      { return false }\n    return !this.exprAllowed\n  };\n\n  pp$6.inGeneratorContext = function() {\n    for (var i = this.context.length - 1; i >= 1; i--) {\n      var context = this.context[i];\n      if (context.token === \"function\")\n        { return context.generator }\n    }\n    return false\n  };\n\n  pp$6.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === types$1.dot)\n      { this.exprAllowed = false; }\n    else if (update = type.updateContext)\n      { update.call(this, prevType); }\n    else\n      { this.exprAllowed = type.beforeExpr; }\n  };\n\n  // Used to handle edge cases when token context could not be inferred correctly during tokenization phase\n\n  pp$6.overrideContext = function(tokenCtx) {\n    if (this.curContext() !== tokenCtx) {\n      this.context[this.context.length - 1] = tokenCtx;\n    }\n  };\n\n  // Token-specific context update code\n\n  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n      this.exprAllowed = true;\n      return\n    }\n    var out = this.context.pop();\n    if (out === types.b_stat && this.curContext().token === \"function\") {\n      out = this.context.pop();\n    }\n    this.exprAllowed = !out.isExpr;\n  };\n\n  types$1.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n    this.exprAllowed = true;\n  };\n\n  types$1.dollarBraceL.updateContext = function() {\n    this.context.push(types.b_tmpl);\n    this.exprAllowed = true;\n  };\n\n  types$1.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n    this.context.push(statementParens ? types.p_stat : types.p_expr);\n    this.exprAllowed = true;\n  };\n\n  types$1.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n  };\n\n  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== types$1._else &&\n        !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&\n        !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n        !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))\n      { this.context.push(types.f_expr); }\n    else\n      { this.context.push(types.f_stat); }\n    this.exprAllowed = false;\n  };\n\n  types$1.colon.updateContext = function() {\n    if (this.curContext().token === \"function\") { this.context.pop(); }\n    this.exprAllowed = true;\n  };\n\n  types$1.backQuote.updateContext = function() {\n    if (this.curContext() === types.q_tmpl)\n      { this.context.pop(); }\n    else\n      { this.context.push(types.q_tmpl); }\n    this.exprAllowed = false;\n  };\n\n  types$1.star.updateContext = function(prevType) {\n    if (prevType === types$1._function) {\n      var index = this.context.length - 1;\n      if (this.context[index] === types.f_expr)\n        { this.context[index] = types.f_expr_gen; }\n      else\n        { this.context[index] = types.f_gen; }\n    }\n    this.exprAllowed = true;\n  };\n\n  types$1.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n      if (this.value === \"of\" && !this.exprAllowed ||\n          this.value === \"yield\" && this.inGeneratorContext())\n        { allowed = true; }\n    }\n    this.exprAllowed = allowed;\n  };\n\n  // A recursive descent parser operates by defining functions for all\n  // syntactic elements, and recursively calling those, each function\n  // advancing the input stream and returning an AST node. Precedence\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n  // instead of `(!x)[1]` is handled by the fact that the parser\n  // function that parses unary prefix operators is called first, and\n  // in turn calls the function that parses `[]` subscripts  that\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\n  // *that* in the unary operator node.\n  //\n  // Acorn uses an [operator precedence parser][opp] to handle binary\n  // operator precedence, because it is much more compact than using\n  // the technique outlined above, which uses different, nesting\n  // functions to specify precedence, for all of the ten binary\n  // precedence levels that JavaScript defines.\n  //\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n\n  var pp$5 = Parser.prototype;\n\n  // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash \n  // either with each other or with an init property  and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n      { return }\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n      { return }\n    var key = prop.key;\n    var name;\n    switch (key.type) {\n    case \"Identifier\": name = key.name; break\n    case \"Literal\": name = String(key.value); break\n    default: return\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) {\n          if (refDestructuringErrors) {\n            if (refDestructuringErrors.doubleProto < 0) {\n              refDestructuringErrors.doubleProto = key.start;\n            }\n          } else {\n            this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n          }\n        }\n        propHash.proto = true;\n      }\n      return\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n      var redefinition;\n      if (kind === \"init\") {\n        redefinition = this.strict && other.init || other.get || other.set;\n      } else {\n        redefinition = other.init || other[kind];\n      }\n      if (redefinition)\n        { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      };\n    }\n    other[kind] = true;\n  };\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n  pp$5.parseExpression = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n    if (this.type === types$1.comma) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n      while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n      if (this.inGenerator) { return this.parseYield(forInit) }\n      // The tokenizer will assume an expression is allowed after\n      // `yield`, but this isn't that kind of yield\n      else { this.exprAllowed = false; }\n    }\n\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n    if (refDestructuringErrors) {\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n      oldTrailingComma = refDestructuringErrors.trailingComma;\n      oldDoubleProto = refDestructuringErrors.doubleProto;\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n    } else {\n      refDestructuringErrors = new DestructuringErrors;\n      ownDestructuringErrors = true;\n    }\n\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === types$1.parenL || this.type === types$1.name) {\n      this.potentialArrowAt = this.start;\n      this.potentialArrowInForAwait = forInit === \"await\";\n    }\n    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n    if (this.type.isAssign) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.value;\n      if (this.type === types$1.eq)\n        { left = this.toAssignable(left, false, refDestructuringErrors); }\n      if (!ownDestructuringErrors) {\n        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n      }\n      if (refDestructuringErrors.shorthandAssign >= left.start)\n        { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly\n      if (this.type === types$1.eq)\n        { this.checkLValPattern(left); }\n      else\n        { this.checkLValSimple(left); }\n      node.left = left;\n      this.next();\n      node.right = this.parseMaybeAssign(forInit);\n      if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }\n      return this.finishNode(node, \"AssignmentExpression\")\n    } else {\n      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n    }\n    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n    return left\n  };\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(forInit, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    if (this.eat(types$1.question)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types$1.colon);\n      node.alternate = this.parseMaybeAssign(forInit);\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  // Start the precedence parser.\n\n  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)\n  };\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n    var prec = this.type.binop;\n    if (prec != null && (!forInit || this.type !== types$1._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n        var coalesce = this.type === types$1.coalesce;\n        if (coalesce) {\n          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n          prec = types$1.logicalAND.binop;\n        }\n        var op = this.value;\n        this.next();\n        var startPos = this.start, startLoc = this.startLoc;\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n        if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {\n          this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n        }\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)\n      }\n    }\n    return left\n  };\n\n  pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    if (right.type === \"PrivateIdentifier\") { this.raise(right.start, \"Private identifier can only be left side of binary expression\"); }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n  };\n\n  // Parse unary operators, both prefix and postfix.\n\n  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && this.canAwait) {\n      expr = this.parseAwait(forInit);\n      sawUnary = true;\n    } else if (this.type.prefix) {\n      var node = this.startNode(), update = this.type === types$1.incDec;\n      node.operator = this.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true, update, forInit);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      if (update) { this.checkLValSimple(node.argument); }\n      else if (this.strict && node.operator === \"delete\" && isLocalVariableAccess(node.argument))\n        { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n      else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument))\n        { this.raiseRecoverable(node.start, \"Private fields can not be deleted\"); }\n      else { sawUnary = true; }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (!sawUnary && this.type === types$1.privateId) {\n      if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }\n      expr = this.parsePrivateIdent();\n      // only could be private fields in 'in', such as #x in obj\n      if (this.type !== types$1._in) { this.unexpected(); }\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.operator = this.value;\n        node$1.prefix = false;\n        node$1.argument = expr;\n        this.checkLValSimple(expr);\n        this.next();\n        expr = this.finishNode(node$1, \"UpdateExpression\");\n      }\n    }\n\n    if (!incDec && this.eat(types$1.starstar)) {\n      if (sawUnary)\n        { this.unexpected(this.lastTokStart); }\n      else\n        { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false) }\n    } else {\n      return expr\n    }\n  };\n\n  function isLocalVariableAccess(node) {\n    return (\n      node.type === \"Identifier\" ||\n      node.type === \"ParenthesizedExpression\" && isLocalVariableAccess(node.expression)\n    )\n  }\n\n  function isPrivateFieldAccess(node) {\n    return (\n      node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" ||\n      node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression) ||\n      node.type === \"ParenthesizedExpression\" && isPrivateFieldAccess(node.expression)\n    )\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n    if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\n      { return expr }\n    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n      if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }\n    }\n    return result\n  };\n\n  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&\n        this.potentialArrowAt === base.start;\n    var optionalChained = false;\n\n    while (true) {\n      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n\n      if (element.optional) { optionalChained = true; }\n      if (element === base || element.type === \"ArrowFunctionExpression\") {\n        if (optionalChained) {\n          var chainNode = this.startNodeAt(startPos, startLoc);\n          chainNode.expression = element;\n          element = this.finishNode(chainNode, \"ChainExpression\");\n        }\n        return element\n      }\n\n      base = element;\n    }\n  };\n\n  pp$5.shouldParseAsyncArrow = function() {\n    return !this.canInsertSemicolon() && this.eat(types$1.arrow)\n  };\n\n  pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)\n  };\n\n  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n    var optionalSupported = this.options.ecmaVersion >= 11;\n    var optional = optionalSupported && this.eat(types$1.questionDot);\n    if (noCalls && optional) { this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\"); }\n\n    var computed = this.eat(types$1.bracketL);\n    if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      if (computed) {\n        node.property = this.parseExpression();\n        this.expect(types$1.bracketR);\n      } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n        node.property = this.parsePrivateIdent();\n      } else {\n        node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n      }\n      node.computed = !!computed;\n      if (optionalSupported) {\n        node.optional = optional;\n      }\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(types$1.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      this.awaitIdentPos = 0;\n      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        if (this.awaitIdentPos > 0)\n          { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)\n      }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      if (optionalSupported) {\n        node$1.optional = optional;\n      }\n      base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === types$1.backQuote) {\n      if (optional || optionalChained) {\n        this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n      }\n      var node$2 = this.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this.parseTemplate({isTagged: true});\n      base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base\n  };\n\n  // Parse an atomic expression  either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === types$1.slash) { this.readRegexp(); }\n\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch (this.type) {\n    case types$1._super:\n      if (!this.allowSuper)\n        { this.raise(this.start, \"'super' keyword outside a method\"); }\n      node = this.startNode();\n      this.next();\n      if (this.type === types$1.parenL && !this.allowDirectSuper)\n        { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n      // The `super` keyword can appear at below:\n      // SuperProperty:\n      //     super [ Expression ]\n      //     super . IdentifierName\n      // SuperCall:\n      //     super ( Arguments )\n      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)\n        { this.unexpected(); }\n      return this.finishNode(node, \"Super\")\n\n    case types$1._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\")\n\n    case types$1.name:\n      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n      var id = this.parseIdent(false);\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n        this.overrideContext(types.f_expr);\n        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)\n      }\n      if (canBeArrow && !this.canInsertSemicolon()) {\n        if (this.eat(types$1.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc &&\n            (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n          id = this.parseIdent(false);\n          if (this.canInsertSemicolon() || !this.eat(types$1.arrow))\n            { this.unexpected(); }\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)\n        }\n      }\n      return id\n\n    case types$1.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = {pattern: value.pattern, flags: value.flags};\n      return node\n\n    case types$1.num: case types$1.string:\n      return this.parseLiteral(this.value)\n\n    case types$1._null: case types$1._true: case types$1._false:\n      node = this.startNode();\n      node.value = this.type === types$1._null ? null : this.type === types$1._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case types$1.parenL:\n      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n      if (refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n          { refDestructuringErrors.parenthesizedAssign = start; }\n        if (refDestructuringErrors.parenthesizedBind < 0)\n          { refDestructuringErrors.parenthesizedBind = start; }\n      }\n      return expr\n\n    case types$1.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case types$1.braceL:\n      this.overrideContext(types.b_expr);\n      return this.parseObj(false, refDestructuringErrors)\n\n    case types$1._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, 0)\n\n    case types$1._class:\n      return this.parseClass(this.startNode(), false)\n\n    case types$1._new:\n      return this.parseNew()\n\n    case types$1.backQuote:\n      return this.parseTemplate()\n\n    case types$1._import:\n      if (this.options.ecmaVersion >= 11) {\n        return this.parseExprImport(forNew)\n      } else {\n        return this.unexpected()\n      }\n\n    default:\n      return this.parseExprAtomDefault()\n    }\n  };\n\n  pp$5.parseExprAtomDefault = function() {\n    this.unexpected();\n  };\n\n  pp$5.parseExprImport = function(forNew) {\n    var node = this.startNode();\n\n    // Consume `import` as an identifier for `import.meta`.\n    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"); }\n    this.next();\n\n    if (this.type === types$1.parenL && !forNew) {\n      return this.parseDynamicImport(node)\n    } else if (this.type === types$1.dot) {\n      var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n      meta.name = \"import\";\n      node.meta = this.finishNode(meta, \"Identifier\");\n      return this.parseImportMeta(node)\n    } else {\n      this.unexpected();\n    }\n  };\n\n  pp$5.parseDynamicImport = function(node) {\n    this.next(); // skip `(`\n\n    // Parse node.source.\n    node.source = this.parseMaybeAssign();\n\n    if (this.options.ecmaVersion >= 16) {\n      if (!this.eat(types$1.parenR)) {\n        this.expect(types$1.comma);\n        if (!this.afterTrailingComma(types$1.parenR)) {\n          node.options = this.parseMaybeAssign();\n          if (!this.eat(types$1.parenR)) {\n            this.expect(types$1.comma);\n            if (!this.afterTrailingComma(types$1.parenR)) {\n              this.unexpected();\n            }\n          }\n        } else {\n          node.options = null;\n        }\n      } else {\n        node.options = null;\n      }\n    } else {\n      // Verify ending.\n      if (!this.eat(types$1.parenR)) {\n        var errorPos = this.start;\n        if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n          this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n        } else {\n          this.unexpected(errorPos);\n        }\n      }\n    }\n\n    return this.finishNode(node, \"ImportExpression\")\n  };\n\n  pp$5.parseImportMeta = function(node) {\n    this.next(); // skip `.`\n\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n\n    if (node.property.name !== \"meta\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\"); }\n    if (containsEsc)\n      { this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\"); }\n    if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere)\n      { this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\"); }\n\n    return this.finishNode(node, \"MetaProperty\")\n  };\n\n  pp$5.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110)\n      { node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, \"\"); }\n    this.next();\n    return this.finishNode(node, \"Literal\")\n  };\n\n  pp$5.parseParenExpression = function() {\n    this.expect(types$1.parenL);\n    var val = this.parseExpression();\n    this.expect(types$1.parenR);\n    return val\n  };\n\n  pp$5.shouldParseArrow = function(exprList) {\n    return !this.canInsertSemicolon()\n  };\n\n  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n      this.next();\n\n      var innerStartPos = this.start, innerStartLoc = this.startLoc;\n      var exprList = [], first = true, lastIsComma = false;\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      // Do not save awaitIdentPos to allow checking awaits nested in parameters\n      while (this.type !== types$1.parenR) {\n        first ? first = false : this.expect(types$1.comma);\n        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n          lastIsComma = true;\n          break\n        } else if (this.type === types$1.ellipsis) {\n          spreadStart = this.start;\n          exprList.push(this.parseParenItem(this.parseRestBinding()));\n          if (this.type === types$1.comma) {\n            this.raiseRecoverable(\n              this.start,\n              \"Comma is not permitted after the rest element\"\n            );\n          }\n          break\n        } else {\n          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n        }\n      }\n      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n      this.expect(types$1.parenR);\n\n      if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        return this.parseParenArrowList(startPos, startLoc, exprList, forInit)\n      }\n\n      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n      if (spreadStart) { this.unexpected(spreadStart); }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\n        val.expressions = exprList;\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n      } else {\n        val = exprList[0];\n      }\n    } else {\n      val = this.parseParenExpression();\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc);\n      par.expression = val;\n      return this.finishNode(par, \"ParenthesizedExpression\")\n    } else {\n      return val\n    }\n  };\n\n  pp$5.parseParenItem = function(item) {\n    return item\n  };\n\n  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)\n  };\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call  at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n  var empty = [];\n\n  pp$5.parseNew = function() {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\n    var node = this.startNode();\n    this.next();\n    if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {\n      var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n      meta.name = \"new\";\n      node.meta = this.finishNode(meta, \"Identifier\");\n      this.next();\n      var containsEsc = this.containsEsc;\n      node.property = this.parseIdent(true);\n      if (node.property.name !== \"target\")\n        { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\"); }\n      if (containsEsc)\n        { this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\"); }\n      if (!this.allowNewDotTarget)\n        { this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\"); }\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n    if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }\n    else { node.arguments = empty; }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  // Parse template expression.\n\n  pp$5.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n\n    var elem = this.startNode();\n    if (this.type === types$1.invalidTemplate) {\n      if (!isTagged) {\n        this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n      }\n      elem.value = {\n        raw: this.value.replace(/\\r\\n?/g, \"\\n\"),\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.value\n      };\n    }\n    this.next();\n    elem.tail = this.type === types$1.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  pp$5.parseTemplate = function(ref) {\n    if ( ref === void 0 ) ref = {};\n    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({isTagged: isTagged});\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      if (this.type === types$1.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n      this.expect(types$1.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types$1.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  pp$5.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n      (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&\n      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  // Parse an object literal or binding pattern.\n\n  pp$5.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while (!this.eat(types$1.braceR)) {\n      if (!first) {\n        this.expect(types$1.comma);\n        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }\n      } else { first = false; }\n\n      var prop = this.parseProperty(isPattern, refDestructuringErrors);\n      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n      node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n  };\n\n  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n      if (isPattern) {\n        prop.argument = this.parseIdent(false);\n        if (this.type === types$1.comma) {\n          this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n        }\n        return this.finishNode(prop, \"RestElement\")\n      }\n      // Parse argument.\n      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n      // To disallow trailing comma via `this.toAssignable()`.\n      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this.start;\n      }\n      // Finish\n      return this.finishNode(prop, \"SpreadElement\")\n    }\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start;\n        startLoc = this.startLoc;\n      }\n      if (!isPattern)\n        { isGenerator = this.eat(types$1.star); }\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n      this.parsePropertyName(prop);\n    } else {\n      isAsync = false;\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\")\n  };\n\n  pp$5.parseGetterSetter = function(prop) {\n    var kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    prop.kind = kind;\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  };\n\n  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types$1.colon)\n      { this.unexpected(); }\n\n    if (this.eat(types$1.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n      prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n      if (isPattern) { this.unexpected(); }\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n      prop.kind = \"init\";\n    } else if (!isPattern && !containsEsc &&\n               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      this.parseGetterSetter(prop);\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      this.checkUnreserved(prop.key);\n      if (prop.key.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = startPos; }\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n      } else if (this.type === types$1.eq && refDestructuringErrors) {\n        if (refDestructuringErrors.shorthandAssign < 0)\n          { refDestructuringErrors.shorthandAssign = this.start; }\n        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n      } else {\n        prop.value = this.copyNode(prop.key);\n      }\n      prop.kind = \"init\";\n      prop.shorthand = true;\n    } else { this.unexpected(); }\n  };\n\n  pp$5.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(types$1.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseMaybeAssign();\n        this.expect(types$1.bracketR);\n        return prop.key\n      } else {\n        prop.computed = false;\n      }\n    }\n    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n  };\n\n  // Initialize empty function node.\n\n  pp$5.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n    if (this.options.ecmaVersion >= 8) { node.async = false; }\n  };\n\n  // Parse object or class method.\n\n  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n    this.expect(types$1.parenL);\n    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  // Parse arrow function expression with given parameters.\n\n  pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false, forInit);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  // Parse function body and check parameters.\n\n  pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n    var isExpression = isArrowFunction && this.type !== types$1.braceL;\n    var oldStrict = this.strict, useStrict = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign(forInit);\n      node.expression = true;\n      this.checkParams(node, false);\n    } else {\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n      if (!oldStrict || nonSimple) {\n        useStrict = this.strictDirective(this.end);\n        // If this is a strict mode function, verify that argument names\n        // are not repeated, and it does not try to bind the words `eval`\n        // or `arguments`.\n        if (useStrict && nonSimple)\n          { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n      }\n      // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n      var oldLabels = this.labels;\n      this.labels = [];\n      if (useStrict) { this.strict = true; }\n\n      // Add the params to varDeclaredNames to ensure that an error is thrown\n      // if a let/const declaration in the function clashes with one of the params.\n      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n      if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }\n      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n      node.expression = false;\n      this.adaptDirectivePrologue(node.body.body);\n      this.labels = oldLabels;\n    }\n    this.exitScope();\n  };\n\n  pp$5.isSimpleParamList = function(params) {\n    for (var i = 0, list = params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      if (param.type !== \"Identifier\") { return false\n    } }\n    return true\n  };\n\n  // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n  pp$5.checkParams = function(node, allowDuplicates) {\n    var nameHash = Object.create(null);\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n  };\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (!first) {\n        this.expect(types$1.comma);\n        if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n      } else { first = false; }\n\n      var elt = (void 0);\n      if (allowEmpty && this.type === types$1.comma)\n        { elt = null; }\n      else if (this.type === types$1.ellipsis) {\n        elt = this.parseSpread(refDestructuringErrors);\n        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)\n          { refDestructuringErrors.trailingComma = this.start; }\n      } else {\n        elt = this.parseMaybeAssign(false, refDestructuringErrors);\n      }\n      elts.push(elt);\n    }\n    return elts\n  };\n\n  pp$5.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n\n    if (this.inGenerator && name === \"yield\")\n      { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n    if (this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n    if (!(this.currentThisScope().flags & SCOPE_VAR) && name === \"arguments\")\n      { this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\"); }\n    if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\"))\n      { this.raise(start, (\"Cannot use \" + name + \" in class static initialization block\")); }\n    if (this.keywords.test(name))\n      { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n    if (this.options.ecmaVersion < 6 &&\n      this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n      if (!this.inAsync && name === \"await\")\n        { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n      this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n    }\n  };\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  pp$5.parseIdent = function(liberal) {\n    var node = this.parseIdentNode();\n    this.next(!!liberal);\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n      this.checkUnreserved(node);\n      if (node.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = node.start; }\n    }\n    return node\n  };\n\n  pp$5.parseIdentNode = function() {\n    var node = this.startNode();\n    if (this.type === types$1.name) {\n      node.name = this.value;\n    } else if (this.type.keyword) {\n      node.name = this.type.keyword;\n\n      // To fix https://github.com/acornjs/acorn/issues/575\n      // `class` and `function` keywords push new context into this.context.\n      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n      if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n        this.context.pop();\n      }\n      this.type = types$1.name;\n    } else {\n      this.unexpected();\n    }\n    return node\n  };\n\n  pp$5.parsePrivateIdent = function() {\n    var node = this.startNode();\n    if (this.type === types$1.privateId) {\n      node.name = this.value;\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    this.finishNode(node, \"PrivateIdentifier\");\n\n    // For validating existence\n    if (this.options.checkPrivateFields) {\n      if (this.privateNameStack.length === 0) {\n        this.raise(node.start, (\"Private field '#\" + (node.name) + \"' must be declared in an enclosing class\"));\n      } else {\n        this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n      }\n    }\n\n    return node\n  };\n\n  // Parses yield expression inside generator.\n\n  pp$5.parseYield = function(forInit) {\n    if (!this.yieldPos) { this.yieldPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types$1.star);\n      node.argument = this.parseMaybeAssign(forInit);\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  };\n\n  pp$5.parseAwait = function(forInit) {\n    if (!this.awaitPos) { this.awaitPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true, false, forInit);\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  var pp$4 = Parser.prototype;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    if (this.sourceFile) {\n      message += \" in \" + this.sourceFile;\n    }\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n    throw err\n  };\n\n  pp$4.raiseRecoverable = pp$4.raise;\n\n  pp$4.curPosition = function() {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart)\n    }\n  };\n\n  var pp$3 = Parser.prototype;\n\n  var Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n  };\n\n  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n  pp$3.enterScope = function(flags) {\n    this.scopeStack.push(new Scope(flags));\n  };\n\n  pp$3.exitScope = function() {\n    this.scopeStack.pop();\n  };\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  pp$3.treatFunctionsAsVarInScope = function(scope) {\n    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n  };\n\n  pp$3.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === BIND_LEXICAL) {\n      var scope = this.currentScope();\n      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n      scope.lexical.push(name);\n      if (this.inModule && (scope.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n    } else if (bindingType === BIND_SIMPLE_CATCH) {\n      var scope$1 = this.currentScope();\n      scope$1.lexical.push(name);\n    } else if (bindingType === BIND_FUNCTION) {\n      var scope$2 = this.currentScope();\n      if (this.treatFunctionsAsVar)\n        { redeclared = scope$2.lexical.indexOf(name) > -1; }\n      else\n        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n      scope$2.functions.push(name);\n    } else {\n      for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n        var scope$3 = this.scopeStack[i];\n        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n          redeclared = true;\n          break\n        }\n        scope$3.var.push(name);\n        if (this.inModule && (scope$3.flags & SCOPE_TOP))\n          { delete this.undefinedExports[name]; }\n        if (scope$3.flags & SCOPE_VAR) { break }\n      }\n    }\n    if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n  };\n\n  pp$3.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n        this.scopeStack[0].var.indexOf(id.name) === -1) {\n      this.undefinedExports[id.name] = id;\n    }\n  };\n\n  pp$3.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1]\n  };\n\n  pp$3.currentVarScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) { return scope }\n    }\n  };\n\n  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  pp$3.currentThisScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) &&\n          !(scope.flags & SCOPE_ARROW)) { return scope }\n    }\n  };\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations)\n      { this.loc = new SourceLocation(parser, loc); }\n    if (parser.options.directSourceFile)\n      { this.sourceFile = parser.options.directSourceFile; }\n    if (parser.options.ranges)\n      { this.range = [pos, 0]; }\n  };\n\n  // Start an AST node, attaching a start offset.\n\n  var pp$2 = Parser.prototype;\n\n  pp$2.startNode = function() {\n    return new Node(this, this.start, this.startLoc)\n  };\n\n  pp$2.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc)\n  };\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations)\n      { node.loc.end = loc; }\n    if (this.options.ranges)\n      { node.range[1] = pos; }\n    return node\n  }\n\n  pp$2.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n  };\n\n  // Finish node at given position\n\n  pp$2.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc)\n  };\n\n  pp$2.copyNode = function(node) {\n    var newNode = new Node(this, node.start, this.startLoc);\n    for (var prop in node) { newNode[prop] = node[prop]; }\n    return newNode\n  };\n\n  // This file was generated by \"bin/generate-unicode-script-values.js\". Do not modify manually!\n  var scriptValuesAddedInUnicode = \"Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz\";\n\n  // This file contains Unicode properties extracted from the ECMAScript specification.\n  // The lists are extracted like so:\n  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n  // #table-binary-unicode-properties\n  var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n  var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n  var ecma11BinaryProperties = ecma10BinaryProperties;\n  var ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\n  var ecma13BinaryProperties = ecma12BinaryProperties;\n  var ecma14BinaryProperties = ecma13BinaryProperties;\n\n  var unicodeBinaryProperties = {\n    9: ecma9BinaryProperties,\n    10: ecma10BinaryProperties,\n    11: ecma11BinaryProperties,\n    12: ecma12BinaryProperties,\n    13: ecma13BinaryProperties,\n    14: ecma14BinaryProperties\n  };\n\n  // #table-binary-unicode-properties-of-strings\n  var ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\n\n  var unicodeBinaryPropertiesOfStrings = {\n    9: \"\",\n    10: \"\",\n    11: \"\",\n    12: \"\",\n    13: \"\",\n    14: ecma14BinaryPropertiesOfStrings\n  };\n\n  // #table-unicode-general-category-values\n  var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n  // #table-unicode-script-values\n  var ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n  var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n  var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n  var ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\n  var ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\n  var ecma14ScriptValues = ecma13ScriptValues + \" \" + scriptValuesAddedInUnicode;\n\n  var unicodeScriptValues = {\n    9: ecma9ScriptValues,\n    10: ecma10ScriptValues,\n    11: ecma11ScriptValues,\n    12: ecma12ScriptValues,\n    13: ecma13ScriptValues,\n    14: ecma14ScriptValues\n  };\n\n  var data = {};\n  function buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n      binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n      nonBinary: {\n        General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n      }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n  }\n\n  for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {\n    var ecmaVersion = list[i];\n\n    buildUnicodeData(ecmaVersion);\n  }\n\n  var pp$1 = Parser.prototype;\n\n  // Track disjunction structure to determine whether a duplicate\n  // capture group name is allowed because it is in a separate branch.\n  var BranchID = function BranchID(parent, base) {\n    // Parent disjunction branch\n    this.parent = parent;\n    // Identifies this set of sibling branches\n    this.base = base || this;\n  };\n\n  BranchID.prototype.separatedFrom = function separatedFrom (alt) {\n    // A branch is separate from another branch if they or any of\n    // their parents are siblings in a given disjunction\n    for (var self = this; self; self = self.parent) {\n      for (var other = alt; other; other = other.parent) {\n        if (self.base === other.base && self !== other) { return true }\n      }\n    }\n    return false\n  };\n\n  BranchID.prototype.sibling = function sibling () {\n    return new BranchID(this.parent, this.base)\n  };\n\n  var RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n    this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchV = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = Object.create(null);\n    this.backReferenceNames = [];\n    this.branchID = null;\n  };\n\n  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n    var unicodeSets = flags.indexOf(\"v\") !== -1;\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n      this.switchU = true;\n      this.switchV = true;\n      this.switchN = true;\n    } else {\n      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n      this.switchV = false;\n      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n    }\n  };\n\n  RegExpValidationState.prototype.raise = function raise (message) {\n    this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n  };\n\n  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n  RegExpValidationState.prototype.at = function at (i, forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return -1\n    }\n    var c = s.charCodeAt(i);\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return c\n    }\n    var next = s.charCodeAt(i + 1);\n    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n  };\n\n  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return l\n    }\n    var c = s.charCodeAt(i), next;\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n      return i + 1\n    }\n    return i + 2\n  };\n\n  RegExpValidationState.prototype.current = function current (forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    return this.at(this.pos, forceU)\n  };\n\n  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    return this.at(this.nextIndex(this.pos, forceU), forceU)\n  };\n\n  RegExpValidationState.prototype.advance = function advance (forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    this.pos = this.nextIndex(this.pos, forceU);\n  };\n\n  RegExpValidationState.prototype.eat = function eat (ch, forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    if (this.current(forceU) === ch) {\n      this.advance(forceU);\n      return true\n    }\n    return false\n  };\n\n  RegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    var pos = this.pos;\n    for (var i = 0, list = chs; i < list.length; i += 1) {\n      var ch = list[i];\n\n        var current = this.at(pos, forceU);\n      if (current === -1 || current !== ch) {\n        return false\n      }\n      pos = this.nextIndex(pos, forceU);\n    }\n    this.pos = pos;\n    return true\n  };\n\n  /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$1.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n\n    var u = false;\n    var v = false;\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags.charAt(i);\n      if (validFlags.indexOf(flag) === -1) {\n        this.raise(state.start, \"Invalid regular expression flag\");\n      }\n      if (flags.indexOf(flag, i + 1) > -1) {\n        this.raise(state.start, \"Duplicate regular expression flag\");\n      }\n      if (flag === \"u\") { u = true; }\n      if (flag === \"v\") { v = true; }\n    }\n    if (this.options.ecmaVersion >= 15 && u && v) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n  };\n\n  function hasProp(obj) {\n    for (var _ in obj) { return true }\n    return false\n  }\n\n  /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$1.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {\n      state.switchN = true;\n      this.regexp_pattern(state);\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n  pp$1.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames = Object.create(null);\n    state.backReferenceNames.length = 0;\n    state.branchID = null;\n\n    this.regexp_disjunction(state);\n\n    if (state.pos !== state.source.length) {\n      // Make the same messages as V8.\n      if (state.eat(0x29 /* ) */)) {\n        state.raise(\"Unmatched ')'\");\n      }\n      if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {\n        state.raise(\"Lone quantifier brackets\");\n      }\n    }\n    if (state.maxBackReference > state.numCapturingParens) {\n      state.raise(\"Invalid escape\");\n    }\n    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n      var name = list[i];\n\n      if (!state.groupNames[name]) {\n        state.raise(\"Invalid named capture referenced\");\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n  pp$1.regexp_disjunction = function(state) {\n    var trackDisjunction = this.options.ecmaVersion >= 16;\n    if (trackDisjunction) { state.branchID = new BranchID(state.branchID, null); }\n    this.regexp_alternative(state);\n    while (state.eat(0x7C /* | */)) {\n      if (trackDisjunction) { state.branchID = state.branchID.sibling(); }\n      this.regexp_alternative(state);\n    }\n    if (trackDisjunction) { state.branchID = state.branchID.parent; }\n\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    if (state.eat(0x7B /* { */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n  pp$1.regexp_alternative = function(state) {\n    while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n  pp$1.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n      // Handle `QuantifiableAssertion Quantifier` alternative.\n      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n      // is a QuantifiableAssertion.\n      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n        // Make the same message as V8.\n        if (state.switchU) {\n          state.raise(\"Invalid quantifier\");\n        }\n      }\n      return true\n    }\n\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n      this.regexp_eatQuantifier(state);\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n  pp$1.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n\n    // ^, $\n    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n      return true\n    }\n\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */)) {\n      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n      var lookbehind = false;\n      if (this.options.ecmaVersion >= 9) {\n        lookbehind = state.eat(0x3C /* < */);\n      }\n      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n        this.regexp_disjunction(state);\n        if (!state.eat(0x29 /* ) */)) {\n          state.raise(\"Unterminated group\");\n        }\n        state.lastAssertionIsQuantifiable = !lookbehind;\n        return true\n      }\n    }\n\n    state.pos = start;\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n  pp$1.regexp_eatQuantifier = function(state, noError) {\n    if ( noError === void 0 ) noError = false;\n\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n      state.eat(0x3F /* ? */);\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n  pp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n    return (\n      state.eat(0x2A /* * */) ||\n      state.eat(0x2B /* + */) ||\n      state.eat(0x3F /* ? */) ||\n      this.regexp_eatBracedQuantifier(state, noError)\n    )\n  };\n  pp$1.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */)) {\n      var min = 0, max = -1;\n      if (this.regexp_eatDecimalDigits(state)) {\n        min = state.lastIntValue;\n        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n          max = state.lastIntValue;\n        }\n        if (state.eat(0x7D /* } */)) {\n          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n          if (max !== -1 && max < min && !noError) {\n            state.raise(\"numbers out of order in {} quantifier\");\n          }\n          return true\n        }\n      }\n      if (state.switchU && !noError) {\n        state.raise(\"Incomplete quantifier\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n  pp$1.regexp_eatAtom = function(state) {\n    return (\n      this.regexp_eatPatternCharacters(state) ||\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state)\n    )\n  };\n  pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatAtomEscape(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$1.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */)) {\n      if (state.eat(0x3F /* ? */)) {\n        if (this.options.ecmaVersion >= 16) {\n          var addModifiers = this.regexp_eatModifiers(state);\n          var hasHyphen = state.eat(0x2D /* - */);\n          if (addModifiers || hasHyphen) {\n            for (var i = 0; i < addModifiers.length; i++) {\n              var modifier = addModifiers.charAt(i);\n              if (addModifiers.indexOf(modifier, i + 1) > -1) {\n                state.raise(\"Duplicate regular expression modifiers\");\n              }\n            }\n            if (hasHyphen) {\n              var removeModifiers = this.regexp_eatModifiers(state);\n              if (!addModifiers && !removeModifiers && state.current() === 0x3A /* : */) {\n                state.raise(\"Invalid regular expression modifiers\");\n              }\n              for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {\n                var modifier$1 = removeModifiers.charAt(i$1);\n                if (\n                  removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 ||\n                  addModifiers.indexOf(modifier$1) > -1\n                ) {\n                  state.raise(\"Duplicate regular expression modifiers\");\n                }\n              }\n            }\n          }\n        }\n        if (state.eat(0x3A /* : */)) {\n          this.regexp_disjunction(state);\n          if (state.eat(0x29 /* ) */)) {\n            return true\n          }\n          state.raise(\"Unterminated group\");\n        }\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$1.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */)) {\n      if (this.options.ecmaVersion >= 9) {\n        this.regexp_groupSpecifier(state);\n      } else if (state.current() === 0x3F /* ? */) {\n        state.raise(\"Invalid group\");\n      }\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        state.numCapturingParens += 1;\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    return false\n  };\n  // RegularExpressionModifiers ::\n  //   [empty]\n  //   RegularExpressionModifiers RegularExpressionModifier\n  pp$1.regexp_eatModifiers = function(state) {\n    var modifiers = \"\";\n    var ch = 0;\n    while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {\n      modifiers += codePointToString(ch);\n      state.advance();\n    }\n    return modifiers\n  };\n  // RegularExpressionModifier :: one of\n  //   `i` `m` `s`\n  function isRegularExpressionModifier(ch) {\n    return ch === 0x69 /* i */ || ch === 0x6d /* m */ || ch === 0x73 /* s */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n  pp$1.regexp_eatExtendedAtom = function(state) {\n    return (\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state) ||\n      this.regexp_eatInvalidBracedQuantifier(state) ||\n      this.regexp_eatExtendedPatternCharacter(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n  pp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n  pp$1.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if (isSyntaxCharacter(ch)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isSyntaxCharacter(ch) {\n    return (\n      ch === 0x24 /* $ */ ||\n      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n      ch === 0x2E /* . */ ||\n      ch === 0x3F /* ? */ ||\n      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n      ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n  // But eat eager.\n  pp$1.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n      state.advance();\n    }\n    return state.pos !== start\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n  pp$1.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (\n      ch !== -1 &&\n      ch !== 0x24 /* $ */ &&\n      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n      ch !== 0x2E /* . */ &&\n      ch !== 0x3F /* ? */ &&\n      ch !== 0x5B /* [ */ &&\n      ch !== 0x5E /* ^ */ &&\n      ch !== 0x7C /* | */\n    ) {\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // GroupSpecifier ::\n  //   [empty]\n  //   `?` GroupName\n  pp$1.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */)) {\n      if (!this.regexp_eatGroupName(state)) { state.raise(\"Invalid group\"); }\n      var trackDisjunction = this.options.ecmaVersion >= 16;\n      var known = state.groupNames[state.lastStringValue];\n      if (known) {\n        if (trackDisjunction) {\n          for (var i = 0, list = known; i < list.length; i += 1) {\n            var altID = list[i];\n\n            if (!altID.separatedFrom(state.branchID))\n              { state.raise(\"Duplicate capture group name\"); }\n          }\n        } else {\n          state.raise(\"Duplicate capture group name\");\n        }\n      }\n      if (trackDisjunction) {\n        (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);\n      } else {\n        state.groupNames[state.lastStringValue] = true;\n      }\n    }\n  };\n\n  // GroupName ::\n  //   `<` RegExpIdentifierName `>`\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$1.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */)) {\n      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n        return true\n      }\n      state.raise(\"Invalid capture group name\");\n    }\n    return false\n  };\n\n  // RegExpIdentifierName ::\n  //   RegExpIdentifierStart\n  //   RegExpIdentifierName RegExpIdentifierPart\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$1.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n      while (this.regexp_eatRegExpIdentifierPart(state)) {\n        state.lastStringValue += codePointToString(state.lastIntValue);\n      }\n      return true\n    }\n    return false\n  };\n\n  // RegExpIdentifierStart ::\n  //   UnicodeIDStart\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[+U]\n  pp$1.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierStart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n  }\n\n  // RegExpIdentifierPart ::\n  //   UnicodeIDContinue\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[+U]\n  //   <ZWNJ>\n  //   <ZWJ>\n  pp$1.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierPart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n  pp$1.regexp_eatAtomEscape = function(state) {\n    if (\n      this.regexp_eatBackReference(state) ||\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state) ||\n      (state.switchN && this.regexp_eatKGroupName(state))\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      if (state.current() === 0x63 /* c */) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    return false\n  };\n  pp$1.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n      var n = state.lastIntValue;\n      if (state.switchU) {\n        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n        if (n > state.maxBackReference) {\n          state.maxBackReference = n;\n        }\n        return true\n      }\n      if (n <= state.numCapturingParens) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$1.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */)) {\n      if (this.regexp_eatGroupName(state)) {\n        state.backReferenceNames.push(state.lastStringValue);\n        return true\n      }\n      state.raise(\"Invalid named reference\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n  pp$1.regexp_eatCharacterEscape = function(state) {\n    return (\n      this.regexp_eatControlEscape(state) ||\n      this.regexp_eatCControlLetter(state) ||\n      this.regexp_eatZero(state) ||\n      this.regexp_eatHexEscapeSequence(state) ||\n      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||\n      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n      this.regexp_eatIdentityEscape(state)\n    )\n  };\n  pp$1.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */)) {\n      if (this.regexp_eatControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$1.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n      state.lastIntValue = 0;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n  pp$1.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */) {\n      state.lastIntValue = 0x09; /* \\t */\n      state.advance();\n      return true\n    }\n    if (ch === 0x6E /* n */) {\n      state.lastIntValue = 0x0A; /* \\n */\n      state.advance();\n      return true\n    }\n    if (ch === 0x76 /* v */) {\n      state.lastIntValue = 0x0B; /* \\v */\n      state.advance();\n      return true\n    }\n    if (ch === 0x66 /* f */) {\n      state.lastIntValue = 0x0C; /* \\f */\n      state.advance();\n      return true\n    }\n    if (ch === 0x72 /* r */) {\n      state.lastIntValue = 0x0D; /* \\r */\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n  pp$1.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if (isControlLetter(ch)) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isControlLetter(ch) {\n    return (\n      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n  pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n    var start = state.pos;\n    var switchU = forceU || state.switchU;\n\n    if (state.eat(0x75 /* u */)) {\n      if (this.regexp_eatFixedHexDigits(state, 4)) {\n        var lead = state.lastIntValue;\n        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n          var leadSurrogateEnd = state.pos;\n          if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n            var trail = state.lastIntValue;\n            if (trail >= 0xDC00 && trail <= 0xDFFF) {\n              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n              return true\n            }\n          }\n          state.pos = leadSurrogateEnd;\n          state.lastIntValue = lead;\n        }\n        return true\n      }\n      if (\n        switchU &&\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatHexDigits(state) &&\n        state.eat(0x7D /* } */) &&\n        isValidUnicode(state.lastIntValue)\n      ) {\n        return true\n      }\n      if (switchU) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.pos = start;\n    }\n\n    return false\n  };\n  function isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n  pp$1.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n      if (this.regexp_eatSyntaxCharacter(state)) {\n        return true\n      }\n      if (state.eat(0x2F /* / */)) {\n        state.lastIntValue = 0x2F; /* / */\n        return true\n      }\n      return false\n    }\n\n    var ch = state.current();\n    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n  pp$1.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n      do {\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n        state.advance();\n      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n      return true\n    }\n    return false\n  };\n\n  // Return values used by character set parsing methods, needed to\n  // forbid negation of sets that can match strings.\n  var CharSetNone = 0; // Nothing parsed\n  var CharSetOk = 1; // Construct parsed, cannot contain strings\n  var CharSetString = 2; // Construct parsed, can contain strings\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n  pp$1.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n\n    if (isCharacterClassEscape(ch)) {\n      state.lastIntValue = -1;\n      state.advance();\n      return CharSetOk\n    }\n\n    var negate = false;\n    if (\n      state.switchU &&\n      this.options.ecmaVersion >= 9 &&\n      ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)\n    ) {\n      state.lastIntValue = -1;\n      state.advance();\n      var result;\n      if (\n        state.eat(0x7B /* { */) &&\n        (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&\n        state.eat(0x7D /* } */)\n      ) {\n        if (negate && result === CharSetString) { state.raise(\"Invalid property name\"); }\n        return result\n      }\n      state.raise(\"Invalid property name\");\n    }\n\n    return CharSetNone\n  };\n\n  function isCharacterClassEscape(ch) {\n    return (\n      ch === 0x64 /* d */ ||\n      ch === 0x44 /* D */ ||\n      ch === 0x73 /* s */ ||\n      ch === 0x53 /* S */ ||\n      ch === 0x77 /* w */ ||\n      ch === 0x57 /* W */\n    )\n  }\n\n  // UnicodePropertyValueExpression ::\n  //   UnicodePropertyName `=` UnicodePropertyValue\n  //   LoneUnicodePropertyNameOrValue\n  pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n      var name = state.lastStringValue;\n      if (this.regexp_eatUnicodePropertyValue(state)) {\n        var value = state.lastStringValue;\n        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n        return CharSetOk\n      }\n    }\n    state.pos = start;\n\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n      var nameOrValue = state.lastStringValue;\n      return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)\n    }\n    return CharSetNone\n  };\n\n  pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!hasOwn(state.unicodeProperties.nonBinary, name))\n      { state.raise(\"Invalid property name\"); }\n    if (!state.unicodeProperties.nonBinary[name].test(value))\n      { state.raise(\"Invalid property value\"); }\n  };\n\n  pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }\n    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }\n    state.raise(\"Invalid property name\");\n  };\n\n  // UnicodePropertyName ::\n  //   UnicodePropertyNameCharacters\n  pp$1.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyNameCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n\n  function isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F /* _ */\n  }\n\n  // UnicodePropertyValue ::\n  //   UnicodePropertyValueCharacters\n  pp$1.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyValueCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n  }\n\n  // LoneUnicodePropertyNameOrValue ::\n  //   UnicodePropertyValueCharacters\n  pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state)\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n  pp$1.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */)) {\n      var negate = state.eat(0x5E /* ^ */);\n      var result = this.regexp_classContents(state);\n      if (!state.eat(0x5D /* ] */))\n        { state.raise(\"Unterminated character class\"); }\n      if (negate && result === CharSetString)\n        { state.raise(\"Negated character class may contain strings\"); }\n      return true\n    }\n    return false\n  };\n\n  // https://tc39.es/ecma262/#prod-ClassContents\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n  pp$1.regexp_classContents = function(state) {\n    if (state.current() === 0x5D /* ] */) { return CharSetOk }\n    if (state.switchV) { return this.regexp_classSetExpression(state) }\n    this.regexp_nonEmptyClassRanges(state);\n    return CharSetOk\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n  pp$1.regexp_nonEmptyClassRanges = function(state) {\n    while (this.regexp_eatClassAtom(state)) {\n      var left = state.lastIntValue;\n      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n        var right = state.lastIntValue;\n        if (state.switchU && (left === -1 || right === -1)) {\n          state.raise(\"Invalid character class\");\n        }\n        if (left !== -1 && right !== -1 && left > right) {\n          state.raise(\"Range out of order in character class\");\n        }\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n  pp$1.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatClassEscape(state)) {\n        return true\n      }\n      if (state.switchU) {\n        // Make the same message as V8.\n        var ch$1 = state.current();\n        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n          state.raise(\"Invalid class escape\");\n        }\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n\n    var ch = state.current();\n    if (ch !== 0x5D /* ] */) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n  pp$1.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x62 /* b */)) {\n      state.lastIntValue = 0x08; /* <BS> */\n      return true\n    }\n\n    if (state.switchU && state.eat(0x2D /* - */)) {\n      state.lastIntValue = 0x2D; /* - */\n      return true\n    }\n\n    if (!state.switchU && state.eat(0x63 /* c */)) {\n      if (this.regexp_eatClassControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    return (\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state)\n    )\n  };\n\n  // https://tc39.es/ecma262/#prod-ClassSetExpression\n  // https://tc39.es/ecma262/#prod-ClassUnion\n  // https://tc39.es/ecma262/#prod-ClassIntersection\n  // https://tc39.es/ecma262/#prod-ClassSubtraction\n  pp$1.regexp_classSetExpression = function(state) {\n    var result = CharSetOk, subResult;\n    if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {\n      if (subResult === CharSetString) { result = CharSetString; }\n      // https://tc39.es/ecma262/#prod-ClassIntersection\n      var start = state.pos;\n      while (state.eatChars([0x26, 0x26] /* && */)) {\n        if (\n          state.current() !== 0x26 /* & */ &&\n          (subResult = this.regexp_eatClassSetOperand(state))\n        ) {\n          if (subResult !== CharSetString) { result = CharSetOk; }\n          continue\n        }\n        state.raise(\"Invalid character in character class\");\n      }\n      if (start !== state.pos) { return result }\n      // https://tc39.es/ecma262/#prod-ClassSubtraction\n      while (state.eatChars([0x2D, 0x2D] /* -- */)) {\n        if (this.regexp_eatClassSetOperand(state)) { continue }\n        state.raise(\"Invalid character in character class\");\n      }\n      if (start !== state.pos) { return result }\n    } else {\n      state.raise(\"Invalid character in character class\");\n    }\n    // https://tc39.es/ecma262/#prod-ClassUnion\n    for (;;) {\n      if (this.regexp_eatClassSetRange(state)) { continue }\n      subResult = this.regexp_eatClassSetOperand(state);\n      if (!subResult) { return result }\n      if (subResult === CharSetString) { result = CharSetString; }\n    }\n  };\n\n  // https://tc39.es/ecma262/#prod-ClassSetRange\n  pp$1.regexp_eatClassSetRange = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatClassSetCharacter(state)) {\n      var left = state.lastIntValue;\n      if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {\n        var right = state.lastIntValue;\n        if (left !== -1 && right !== -1 && left > right) {\n          state.raise(\"Range out of order in character class\");\n        }\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://tc39.es/ecma262/#prod-ClassSetOperand\n  pp$1.regexp_eatClassSetOperand = function(state) {\n    if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }\n    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)\n  };\n\n  // https://tc39.es/ecma262/#prod-NestedClass\n  pp$1.regexp_eatNestedClass = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5B /* [ */)) {\n      var negate = state.eat(0x5E /* ^ */);\n      var result = this.regexp_classContents(state);\n      if (state.eat(0x5D /* ] */)) {\n        if (negate && result === CharSetString) {\n          state.raise(\"Negated character class may contain strings\");\n        }\n        return result\n      }\n      state.pos = start;\n    }\n    if (state.eat(0x5C /* \\ */)) {\n      var result$1 = this.regexp_eatCharacterClassEscape(state);\n      if (result$1) {\n        return result$1\n      }\n      state.pos = start;\n    }\n    return null\n  };\n\n  // https://tc39.es/ecma262/#prod-ClassStringDisjunction\n  pp$1.regexp_eatClassStringDisjunction = function(state) {\n    var start = state.pos;\n    if (state.eatChars([0x5C, 0x71] /* \\q */)) {\n      if (state.eat(0x7B /* { */)) {\n        var result = this.regexp_classStringDisjunctionContents(state);\n        if (state.eat(0x7D /* } */)) {\n          return result\n        }\n      } else {\n        // Make the same message as V8.\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n    return null\n  };\n\n  // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\n  pp$1.regexp_classStringDisjunctionContents = function(state) {\n    var result = this.regexp_classString(state);\n    while (state.eat(0x7C /* | */)) {\n      if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }\n    }\n    return result\n  };\n\n  // https://tc39.es/ecma262/#prod-ClassString\n  // https://tc39.es/ecma262/#prod-NonEmptyClassString\n  pp$1.regexp_classString = function(state) {\n    var count = 0;\n    while (this.regexp_eatClassSetCharacter(state)) { count++; }\n    return count === 1 ? CharSetOk : CharSetString\n  };\n\n  // https://tc39.es/ecma262/#prod-ClassSetCharacter\n  pp$1.regexp_eatClassSetCharacter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */)) {\n      if (\n        this.regexp_eatCharacterEscape(state) ||\n        this.regexp_eatClassSetReservedPunctuator(state)\n      ) {\n        return true\n      }\n      if (state.eat(0x62 /* b */)) {\n        state.lastIntValue = 0x08; /* <BS> */\n        return true\n      }\n      state.pos = start;\n      return false\n    }\n    var ch = state.current();\n    if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }\n    if (isClassSetSyntaxCharacter(ch)) { return false }\n    state.advance();\n    state.lastIntValue = ch;\n    return true\n  };\n\n  // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\n  function isClassSetReservedDoublePunctuatorCharacter(ch) {\n    return (\n      ch === 0x21 /* ! */ ||\n      ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||\n      ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||\n      ch === 0x2E /* . */ ||\n      ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||\n      ch === 0x5E /* ^ */ ||\n      ch === 0x60 /* ` */ ||\n      ch === 0x7E /* ~ */\n    )\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\n  function isClassSetSyntaxCharacter(ch) {\n    return (\n      ch === 0x28 /* ( */ ||\n      ch === 0x29 /* ) */ ||\n      ch === 0x2D /* - */ ||\n      ch === 0x2F /* / */ ||\n      ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||\n      ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n    )\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\n  pp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n    var ch = state.current();\n    if (isClassSetReservedPunctuator(ch)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\n  function isClassSetReservedPunctuator(ch) {\n    return (\n      ch === 0x21 /* ! */ ||\n      ch === 0x23 /* # */ ||\n      ch === 0x25 /* % */ ||\n      ch === 0x26 /* & */ ||\n      ch === 0x2C /* , */ ||\n      ch === 0x2D /* - */ ||\n      ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||\n      ch === 0x40 /* @ */ ||\n      ch === 0x60 /* ` */ ||\n      ch === 0x7E /* ~ */\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n  pp$1.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$1.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */)) {\n      if (this.regexp_eatFixedHexDigits(state, 2)) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n  pp$1.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isDecimalDigit(ch = state.current())) {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n  pp$1.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isHexDigit(ch = state.current())) {\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isHexDigit(ch) {\n    return (\n      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n    )\n  }\n  function hexToInt(ch) {\n    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n      return 10 + (ch - 0x41 /* A */)\n    }\n    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n      return 10 + (ch - 0x61 /* a */)\n    }\n    return ch - 0x30 /* 0 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n  // Allows only 0-377(octal) i.e. 0-255(decimal).\n  pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n      var n1 = state.lastIntValue;\n      if (this.regexp_eatOctalDigit(state)) {\n        var n2 = state.lastIntValue;\n        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n        } else {\n          state.lastIntValue = n1 * 8 + n2;\n        }\n      } else {\n        state.lastIntValue = n1;\n      }\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n  pp$1.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if (isOctalDigit(ch)) {\n      state.lastIntValue = ch - 0x30; /* 0 */\n      state.advance();\n      return true\n    }\n    state.lastIntValue = 0;\n    return false\n  };\n  function isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$1.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for (var i = 0; i < length; ++i) {\n      var ch = state.current();\n      if (!isHexDigit(ch)) {\n        state.pos = start;\n        return false\n      }\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return true\n  };\n\n  // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n  var Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations)\n      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n    if (p.options.ranges)\n      { this.range = [p.start, p.end]; }\n  };\n\n  // ## Tokenizer\n\n  var pp = Parser.prototype;\n\n  // Move to the next token\n\n  pp.next = function(ignoreEscapeSequenceInKeyword) {\n    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\n      { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\n    if (this.options.onToken)\n      { this.options.onToken(new Token(this)); }\n\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n  };\n\n  pp.getToken = function() {\n    this.next();\n    return new Token(this)\n  };\n\n  // If we're in an ES6 environment, make parsers iterable\n  if (typeof Symbol !== \"undefined\")\n    { pp[Symbol.iterator] = function() {\n      var this$1$1 = this;\n\n      return {\n        next: function () {\n          var token = this$1$1.getToken();\n          return {\n            done: token.type === types$1.eof,\n            value: token\n          }\n        }\n      }\n    }; }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  pp.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n    this.start = this.pos;\n    if (this.options.locations) { this.startLoc = this.curPosition(); }\n    if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }\n\n    if (curContext.override) { return curContext.override(this) }\n    else { this.readToken(this.fullCharCodeAtPos()); }\n  };\n\n  pp.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n      { return this.readWord() }\n\n    return this.getTokenFromCode(code)\n  };\n\n  pp.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xdc00) { return code }\n    var next = this.input.charCodeAt(this.pos + 1);\n    return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00\n  };\n\n  pp.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n    this.pos = end + 2;\n    if (this.options.locations) {\n      for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {\n        ++this.curLine;\n        pos = this.lineStart = nextBreak;\n      }\n    }\n    if (this.options.onComment)\n      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  pp.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while (this.pos < this.input.length && !isNewLine(ch)) {\n      ch = this.input.charCodeAt(++this.pos);\n    }\n    if (this.options.onComment)\n      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  pp.skipSpace = function() {\n    loop: while (this.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.pos);\n      switch (ch) {\n      case 32: case 160: // ' '\n        ++this.pos;\n        break\n      case 13:\n        if (this.input.charCodeAt(this.pos + 1) === 10) {\n          ++this.pos;\n        }\n      case 10: case 8232: case 8233:\n        ++this.pos;\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        break\n      case 47: // '/'\n        switch (this.input.charCodeAt(this.pos + 1)) {\n        case 42: // '*'\n          this.skipBlockComment();\n          break\n        case 47:\n          this.skipLineComment(2);\n          break\n        default:\n          break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this.pos;\n        } else {\n          break loop\n        }\n      }\n    }\n  };\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  pp.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) { this.endLoc = this.curPosition(); }\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n\n    this.updateContext(prevType);\n  };\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  pp.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) { return this.readNumber(true) }\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n      this.pos += 3;\n      return this.finishToken(types$1.ellipsis)\n    } else {\n      ++this.pos;\n      return this.finishToken(types$1.dot)\n    }\n  };\n\n  pp.readToken_slash = function() { // '/'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n    if (next === 61) { return this.finishOp(types$1.assign, 2) }\n    return this.finishOp(types$1.slash, 1)\n  };\n\n  pp.readToken_mult_modulo_exp = function(code) { // '%*'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types$1.star : types$1.modulo;\n\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n      ++size;\n      tokentype = types$1.starstar;\n      next = this.input.charCodeAt(this.pos + 2);\n    }\n\n    if (next === 61) { return this.finishOp(types$1.assign, size + 1) }\n    return this.finishOp(tokentype, size)\n  };\n\n  pp.readToken_pipe_amp = function(code) { // '|&'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n      if (this.options.ecmaVersion >= 12) {\n        var next2 = this.input.charCodeAt(this.pos + 2);\n        if (next2 === 61) { return this.finishOp(types$1.assign, 3) }\n      }\n      return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)\n    }\n    if (next === 61) { return this.finishOp(types$1.assign, 2) }\n    return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)\n  };\n\n  pp.readToken_caret = function() { // '^'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types$1.assign, 2) }\n    return this.finishOp(types$1.bitwiseXOR, 1)\n  };\n\n  pp.readToken_plus_min = function(code) { // '+-'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken()\n      }\n      return this.finishOp(types$1.incDec, 2)\n    }\n    if (next === 61) { return this.finishOp(types$1.assign, 2) }\n    return this.finishOp(types$1.plusMin, 1)\n  };\n\n  pp.readToken_lt_gt = function(code) { // '<>'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }\n      return this.finishOp(types$1.bitShift, size)\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n        this.input.charCodeAt(this.pos + 3) === 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    if (next === 61) { size = 2; }\n    return this.finishOp(types$1.relational, size)\n  };\n\n  pp.readToken_eq_excl = function(code) { // '=!'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n      this.pos += 2;\n      return this.finishToken(types$1.arrow)\n    }\n    return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)\n  };\n\n  pp.readToken_question = function() { // '?'\n    var ecmaVersion = this.options.ecmaVersion;\n    if (ecmaVersion >= 11) {\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 46) {\n        var next2 = this.input.charCodeAt(this.pos + 2);\n        if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }\n      }\n      if (next === 63) {\n        if (ecmaVersion >= 12) {\n          var next2$1 = this.input.charCodeAt(this.pos + 2);\n          if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }\n        }\n        return this.finishOp(types$1.coalesce, 2)\n      }\n    }\n    return this.finishOp(types$1.question, 1)\n  };\n\n  pp.readToken_numberSign = function() { // '#'\n    var ecmaVersion = this.options.ecmaVersion;\n    var code = 35; // '#'\n    if (ecmaVersion >= 13) {\n      ++this.pos;\n      code = this.fullCharCodeAtPos();\n      if (isIdentifierStart(code, true) || code === 92 /* '\\' */) {\n        return this.finishToken(types$1.privateId, this.readWord1())\n      }\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n  };\n\n  pp.getTokenFromCode = function(code) {\n    switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46: // '.'\n      return this.readToken_dot()\n\n    // Punctuation tokens.\n    case 40: ++this.pos; return this.finishToken(types$1.parenL)\n    case 41: ++this.pos; return this.finishToken(types$1.parenR)\n    case 59: ++this.pos; return this.finishToken(types$1.semi)\n    case 44: ++this.pos; return this.finishToken(types$1.comma)\n    case 91: ++this.pos; return this.finishToken(types$1.bracketL)\n    case 93: ++this.pos; return this.finishToken(types$1.bracketR)\n    case 123: ++this.pos; return this.finishToken(types$1.braceL)\n    case 125: ++this.pos; return this.finishToken(types$1.braceR)\n    case 58: ++this.pos; return this.finishToken(types$1.colon)\n\n    case 96: // '`'\n      if (this.options.ecmaVersion < 6) { break }\n      ++this.pos;\n      return this.finishToken(types$1.backQuote)\n\n    case 48: // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n      }\n\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return this.readNumber(false)\n\n    // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n    case 47: // '/'\n      return this.readToken_slash()\n\n    case 37: case 42: // '%*'\n      return this.readToken_mult_modulo_exp(code)\n\n    case 124: case 38: // '|&'\n      return this.readToken_pipe_amp(code)\n\n    case 94: // '^'\n      return this.readToken_caret()\n\n    case 43: case 45: // '+-'\n      return this.readToken_plus_min(code)\n\n    case 60: case 62: // '<>'\n      return this.readToken_lt_gt(code)\n\n    case 61: case 33: // '=!'\n      return this.readToken_eq_excl(code)\n\n    case 63: // '?'\n      return this.readToken_question()\n\n    case 126: // '~'\n      return this.finishOp(types$1.prefix, 1)\n\n    case 35: // '#'\n      return this.readToken_numberSign()\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n  };\n\n  pp.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str)\n  };\n\n  pp.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n      var ch = this.input.charAt(this.pos);\n      if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n      if (!escaped) {\n        if (ch === \"[\") { inClass = true; }\n        else if (ch === \"]\" && inClass) { inClass = false; }\n        else if (ch === \"/\" && !inClass) { break }\n        escaped = ch === \"\\\\\";\n      } else { escaped = false; }\n      ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) { this.unexpected(flagsStart); }\n\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n\n    // Create Literal#value property value.\n    var value = null;\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      // ESTree requires null if it failed to instantiate RegExp object.\n      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n\n    return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})\n  };\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n    // `len` is used for character escape sequences. In that case, disallow separators.\n    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n\n    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n    // and isn't fraction part nor exponent part. In that case, if the first digit\n    // is zero then disallow separators.\n    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n\n    var start = this.pos, total = 0, lastCode = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {\n      var code = this.input.charCodeAt(this.pos), val = (void 0);\n\n      if (allowSeparators && code === 95) {\n        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\"); }\n        if (lastCode === 95) { this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\"); }\n        if (i === 0) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\"); }\n        lastCode = code;\n        continue\n      }\n\n      if (code >= 97) { val = code - 97 + 10; } // a\n      else if (code >= 65) { val = code - 65 + 10; } // A\n      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n      else { val = Infinity; }\n      if (val >= radix) { break }\n      lastCode = code;\n      total = total * radix + val;\n    }\n\n    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\"); }\n    if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n    return total\n  };\n\n  function stringToNumber(str, isLegacyOctalNumericLiteral) {\n    if (isLegacyOctalNumericLiteral) {\n      return parseInt(str, 8)\n    }\n\n    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n    return parseFloat(str.replace(/_/g, \"\"))\n  }\n\n  function stringToBigInt(str) {\n    if (typeof BigInt !== \"function\") {\n      return null\n    }\n\n    // `BigInt(value)` throws syntax error if the string contains numeric separators.\n    return BigInt(str.replace(/_/g, \"\"))\n  }\n\n  pp.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n      val = stringToBigInt(this.input.slice(start, this.pos));\n      ++this.pos;\n    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types$1.num, val)\n  };\n\n  // Read an integer, octal integer, or floating-point number.\n\n  pp.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, \"Invalid number\"); }\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n      var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n      ++this.pos;\n      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n      return this.finishToken(types$1.num, val$1)\n    }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n    if (next === 46 && !octal) { // '.'\n      ++this.pos;\n      this.readInt(10);\n      next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) { // 'eE'\n      next = this.input.charCodeAt(++this.pos);\n      if (next === 43 || next === 45) { ++this.pos; } // '+-'\n      if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n    var val = stringToNumber(this.input.slice(start, this.pos), octal);\n    return this.finishToken(types$1.num, val)\n  };\n\n  // Read a string value, interpreting backslash-escapes.\n\n  pp.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n\n    if (ch === 123) { // '{'\n      if (this.options.ecmaVersion < 6) { this.unexpected(); }\n      var codePos = ++this.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n      ++this.pos;\n      if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n    } else {\n      code = this.readHexChar(4);\n    }\n    return code\n  };\n\n  pp.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === quote) { break }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.pos;\n      } else if (ch === 0x2028 || ch === 0x2029) {\n        if (this.options.ecmaVersion < 10) { this.raise(this.start, \"Unterminated string constant\"); }\n        ++this.pos;\n        if (this.options.locations) {\n          this.curLine++;\n          this.lineStart = this.pos;\n        }\n      } else {\n        if (isNewLine(ch)) { this.raise(this.start, \"Unterminated string constant\"); }\n        ++this.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types$1.string, out)\n  };\n\n  // Reads template string tokens.\n\n  var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\n  pp.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n      this.readTmplToken();\n    } catch (err) {\n      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n        this.readInvalidTemplateToken();\n      } else {\n        throw err\n      }\n    }\n\n    this.inTemplateElement = false;\n  };\n\n  pp.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n      throw INVALID_TEMPLATE_ESCAPE_ERROR\n    } else {\n      this.raise(position, message);\n    }\n  };\n\n  pp.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n        if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n          if (ch === 36) {\n            this.pos += 2;\n            return this.finishToken(types$1.dollarBraceL)\n          } else {\n            ++this.pos;\n            return this.finishToken(types$1.backQuote)\n          }\n        }\n        out += this.input.slice(chunkStart, this.pos);\n        return this.finishToken(types$1.template, out)\n      }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(true);\n        chunkStart = this.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.pos);\n        ++this.pos;\n        switch (ch) {\n        case 13:\n          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n        case 10:\n          out += \"\\n\";\n          break\n        default:\n          out += String.fromCharCode(ch);\n          break\n        }\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        chunkStart = this.pos;\n      } else {\n        ++this.pos;\n      }\n    }\n  };\n\n  // Reads a template token to search for the end, without validating any escape sequences\n  pp.readInvalidTemplateToken = function() {\n    for (; this.pos < this.input.length; this.pos++) {\n      switch (this.input[this.pos]) {\n      case \"\\\\\":\n        ++this.pos;\n        break\n\n      case \"$\":\n        if (this.input[this.pos + 1] !== \"{\") { break }\n        // fall through\n      case \"`\":\n        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))\n\n      case \"\\r\":\n        if (this.input[this.pos + 1] === \"\\n\") { ++this.pos; }\n        // fall through\n      case \"\\n\": case \"\\u2028\": case \"\\u2029\":\n        ++this.curLine;\n        this.lineStart = this.pos + 1;\n        break\n      }\n    }\n    this.raise(this.start, \"Unterminated template\");\n  };\n\n  // Used to read escaped characters\n\n  pp.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch (ch) {\n    case 110: return \"\\n\" // 'n' -> '\\n'\n    case 114: return \"\\r\" // 'r' -> '\\r'\n    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n    case 117: return codePointToString(this.readCodePoint()) // 'u'\n    case 116: return \"\\t\" // 't' -> '\\t'\n    case 98: return \"\\b\" // 'b' -> '\\b'\n    case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n    case 102: return \"\\f\" // 'f' -> '\\f'\n    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n    case 10: // ' \\n'\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n      return \"\"\n    case 56:\n    case 57:\n      if (this.strict) {\n        this.invalidStringToken(\n          this.pos - 1,\n          \"Invalid escape sequence\"\n        );\n      }\n      if (inTemplate) {\n        var codePos = this.pos - 1;\n\n        this.invalidStringToken(\n          codePos,\n          \"Invalid escape sequence in template string\"\n        );\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        this.pos += octalStr.length - 1;\n        ch = this.input.charCodeAt(this.pos);\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n          this.invalidStringToken(\n            this.pos - 1 - octalStr.length,\n            inTemplate\n              ? \"Octal literal in template string\"\n              : \"Octal literal in strict mode\"\n          );\n        }\n        return String.fromCharCode(octal)\n      }\n      if (isNewLine(ch)) {\n        // Unicode new line characters after \\ get removed from output in both\n        // template literals and strings\n        if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n        return \"\"\n      }\n      return String.fromCharCode(ch)\n    }\n  };\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  pp.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n    return n\n  };\n\n  // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  pp.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while (this.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n      if (isIdentifierChar(ch, astral)) {\n        this.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) { // \"\\\"\n        this.containsEsc = true;\n        word += this.input.slice(chunkStart, this.pos);\n        var escStart = this.pos;\n        if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n          { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n        ++this.pos;\n        var esc = this.readCodePoint();\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n          { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n        word += codePointToString(esc);\n        chunkStart = this.pos;\n      } else {\n        break\n      }\n      first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos)\n  };\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  pp.readWord = function() {\n    var word = this.readWord1();\n    var type = types$1.name;\n    if (this.keywords.test(word)) {\n      type = keywords[word];\n    }\n    return this.finishToken(type, word)\n  };\n\n  // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n  //\n  // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n  // various contributors and released under an MIT license.\n  //\n  // Git repositories for Acorn are available at\n  //\n  //     http://marijnhaverbeke.nl/git/acorn\n  //     https://github.com/acornjs/acorn.git\n  //\n  // Please use the [github bug tracker][ghbt] to report issues.\n  //\n  // [ghbt]: https://github.com/acornjs/acorn/issues\n\n\n  var version = \"8.15.0\";\n\n  Parser.acorn = {\n    Parser: Parser,\n    version: version,\n    defaultOptions: defaultOptions,\n    Position: Position,\n    SourceLocation: SourceLocation,\n    getLineInfo: getLineInfo,\n    Node: Node,\n    TokenType: TokenType,\n    tokTypes: types$1,\n    keywordTypes: keywords,\n    TokContext: TokContext,\n    tokContexts: types,\n    isIdentifierChar: isIdentifierChar,\n    isIdentifierStart: isIdentifierStart,\n    Token: Token,\n    isNewLine: isNewLine,\n    lineBreak: lineBreak,\n    lineBreakG: lineBreakG,\n    nonASCIIwhitespace: nonASCIIwhitespace\n  };\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and returns\n  // an abstract syntax tree as specified by the [ESTree spec][estree].\n  //\n  // [estree]: https://github.com/estree/estree\n\n  function parse(input, options) {\n    return Parser.parse(input, options)\n  }\n\n  // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n  function parseExpressionAt(input, pos, options) {\n    return Parser.parseExpressionAt(input, pos, options)\n  }\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n  function tokenizer(input, options) {\n    return Parser.tokenizer(input, options)\n  }\n\n  exports.Node = Node;\n  exports.Parser = Parser;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.TokContext = TokContext;\n  exports.Token = Token;\n  exports.TokenType = TokenType;\n  exports.defaultOptions = defaultOptions;\n  exports.getLineInfo = getLineInfo;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.isNewLine = isNewLine;\n  exports.keywordTypes = keywords;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n  exports.nonASCIIwhitespace = nonASCIIwhitespace;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokContexts = types;\n  exports.tokTypes = types$1;\n  exports.tokenizer = tokenizer;\n  exports.version = version;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxDQUNzRztBQUN4RyxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0Esb0JBQW9CLGlCQUFpQixnQkFBZ0I7O0FBRXJEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsbUNBQW1DO0FBQ3JFO0FBQ0EsNEJBQTRCLElBQUksbUNBQW1DO0FBQ25FLDRCQUE0QjtBQUM1QixnQ0FBZ0MsbUNBQW1DO0FBQ25FO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUksbUNBQW1DOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsaUNBQWlDO0FBQzdELGlDQUFpQyxpQ0FBaUM7QUFDbEUsb0NBQW9DLDhDQUE4QztBQUNsRixrQ0FBa0MsaURBQWlEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMkRBQTJEO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQSxxQkFBcUIsbUNBQW1DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMsbUNBQW1DLDJCQUEyQjtBQUM5RCwyQkFBMkIsaURBQWlEO0FBQzVFLHVCQUF1QixpREFBaUQ7QUFDeEUsMkJBQTJCLGlEQUFpRDtBQUM1RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBLE1BQU07O0FBRU4sbURBQW1EO0FBQ25EO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLFFBQVE7O0FBRVI7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixjQUFjLG9CQUFvQixnQkFBZ0Isb0JBQW9CLFlBQVksb0JBQW9CLGFBQWEsb0JBQW9CLGVBQWUsb0JBQW9CLHFCQUFxQixvQkFBb0Isd0JBQXdCLG9CQUFvQixzQkFBc0Isb0JBQW9CLHVCQUF1Qjs7QUFFN1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7O0FBRXBELHFEQUFxRDs7QUFFckQsaURBQWlEOztBQUVqRDtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekUsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRDs7QUFFMUQsNkRBQTZEOztBQUU3RDtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixvQkFBb0IsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLFFBQVE7QUFDUjtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQTJELGlCQUFpQjtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixhQUFhLGlCQUFpQjs7QUFFakQ7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RCxtQkFBbUI7O0FBRW5CLGdFQUFnRSxjQUFjLEtBQUs7QUFDbkY7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSxpRUFBaUU7QUFDakU7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EscUhBQXFIO0FBQ3JIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIO0FBQ3ZIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIseUNBQXlDO0FBQ3pDO0FBQ0EsUUFBUTtBQUNSLDZHQUE2RztBQUM3RyxrREFBa0Q7QUFDbEQ7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RCxXQUFXLHdDQUF3QztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyw2QkFBNkI7QUFDOUQ7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQSxzQkFBc0Isd0RBQXdEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVksb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNLE9BQU8sWUFBWSxZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsWUFBWTtBQUNaLFFBQVE7QUFDUixnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRLHVDQUF1QyxpQkFBaUI7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUF5QyxxQkFBcUI7QUFDdEU7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEIsa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQW1FO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsZ0RBQWdELGlCQUFpQjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtQ0FBbUM7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxJQUFJLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxxQkFBcUI7QUFDckU7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSwyREFBMkQsa0NBQWtDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtDQUErQztBQUN6RDtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxNQUFNO0FBQ04sb0NBQW9DO0FBQ3BDO0FBQ0EsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOLGdHQUFnRztBQUNoRztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE1BQU07QUFDTjtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEUsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQkFBbUI7QUFDL0Q7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSwyREFBMkQsbUJBQW1CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEYsUUFBUSxPQUFPOztBQUVmO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxNQUFNO0FBQ04sb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFlBQVk7QUFDWjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU07QUFDTiwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHlDQUF5QztBQUN6QztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLDJGQUEyRjtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxpQkFBaUI7QUFDbkU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDLDRCQUE0QixPQUFPO0FBQ25DLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhCQUE4QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQix5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsNERBQTREO0FBQzVELHNGQUFzRjtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsaURBQWlEO0FBQ2pEO0FBQ0Esd0JBQXdCO0FBQ3hCLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakcseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLElBQUk7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQSxrQ0FBa0M7QUFDbEMseUNBQXlDOztBQUV6QywrQkFBK0I7QUFDL0IsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0RBQWtELDREQUE0RDtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQSw0QkFBNEIsWUFBWTtBQUN4Qyx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLHlCQUF5Qjs7QUFFekI7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLGtDQUFrQztBQUMzRTtBQUNBLDJDQUEyQyxpQ0FBaUM7QUFDNUUsMENBQTBDLGlDQUFpQztBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMkNBQTJDO0FBQzNDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMEJBQTBCO0FBQzFCLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0M7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLDZDQUE2Qyw2Q0FBNkM7QUFDMUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix3QkFBd0I7QUFDaEQsNkJBQTZCLHdCQUF3QjtBQUNyRCwyQ0FBMkMsbUJBQW1CO0FBQzlELGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5Qyx5RUFBeUU7O0FBRXpFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0RBQXdEO0FBQzlEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLHdDQUF3QyxjQUFjO0FBQ3RELHVDQUF1QztBQUN2QztBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLEtBQUs7QUFDM0IsMENBQTBDO0FBQzFDO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsNkJBQTZCO0FBQzdCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLDJDQUEyQztBQUMzQztBQUNBLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMkNBQTJDO0FBQzNDO0FBQ0EsbUZBQW1GLFdBQVc7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW55c2hhZGUvLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5qcz9kNjNhIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuYWNvcm4gPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbiAgdmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksIDAsIDIyNywgMCwgMTUwLCA0LCAyOTQsIDksIDEzNjgsIDIsIDIsIDEsIDYsIDMsIDQxLCAyLCA1LCAwLCAxNjYsIDEsIDU3NCwgMywgOSwgOSwgNywgOSwgMzIsIDQsIDMxOCwgMSwgODAsIDMsIDcxLCAxMCwgNTAsIDMsIDEyMywgMiwgNTQsIDE0LCAzMiwgMTAsIDMsIDEsIDExLCAzLCA0NiwgMTAsIDgsIDAsIDQ2LCA5LCA3LCAyLCAzNywgMTMsIDIsIDksIDYsIDEsIDQ1LCAwLCAxMywgMiwgNDksIDEzLCA5LCAzLCAyLCAxMSwgODMsIDExLCA3LCAwLCAzLCAwLCAxNTgsIDExLCA2LCA5LCA3LCAzLCA1NiwgMSwgMiwgNiwgMywgMSwgMywgMiwgMTAsIDAsIDExLCAxLCAzLCA2LCA0LCA0LCA2OCwgOCwgMiwgMCwgMywgMCwgMiwgMywgMiwgNCwgMiwgMCwgMTUsIDEsIDgzLCAxNywgMTAsIDksIDUsIDAsIDgyLCAxOSwgMTMsIDksIDIxNCwgNiwgMywgOCwgMjgsIDEsIDgzLCAxNiwgMTYsIDksIDgyLCAxMiwgOSwgOSwgNywgMTksIDU4LCAxNCwgNSwgOSwgMjQzLCAxNCwgMTY2LCA5LCA3MSwgNSwgMiwgMSwgMywgMywgMiwgMCwgMiwgMSwgMTMsIDksIDEyMCwgNiwgMywgNiwgNCwgMCwgMjksIDksIDQxLCA2LCAyLCAzLCA5LCAwLCAxMCwgMTAsIDQ3LCAxNSwgMzQzLCA5LCA1NCwgNywgMiwgNywgMTcsIDksIDU3LCAyMSwgMiwgMTMsIDEyMywgNSwgNCwgMCwgMiwgMSwgMiwgNiwgMiwgMCwgOSwgOSwgNDksIDQsIDIsIDEsIDIsIDQsIDksIDksIDMzMCwgMywgMTAsIDEsIDIsIDAsIDQ5LCA2LCA0LCA0LCAxNCwgMTAsIDUzNTAsIDAsIDcsIDE0LCAxMTQ2NSwgMjcsIDIzNDMsIDksIDg3LCA5LCAzOSwgNCwgNjAsIDYsIDI2LCA5LCA1MzUsIDksIDQ3MCwgMCwgMiwgNTQsIDgsIDMsIDgyLCAwLCAxMiwgMSwgMTk2MjgsIDEsIDQxNzgsIDksIDUxOSwgNDUsIDMsIDIyLCA1NDMsIDQsIDQsIDUsIDksIDcsIDMsIDYsIDMxLCAzLCAxNDksIDIsIDE0MTgsIDQ5LCA1MTMsIDU0LCA1LCA0OSwgOSwgMCwgMTUsIDAsIDIzLCA0LCAyLCAxNCwgMTM2MSwgNiwgMiwgMTYsIDMsIDYsIDIsIDEsIDIsIDQsIDEwMSwgMCwgMTYxLCA2LCAxMCwgOSwgMzU3LCAwLCA2MiwgMTMsIDQ5OSwgMTMsIDI0NSwgMSwgMiwgOSwgNzI2LCA2LCAxMTAsIDYsIDYsIDksIDQ3NTksIDksIDc4NzcxOSwgMjM5XTtcblxuICAvLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbiAgdmFyIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNCwgMjksIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDEzLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDIsIDEwLCAyLCAxNCwgMiwgNiwgMiwgMSwgNCwgNTEsIDEzLCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyOCwgNDMsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCAxNCwgMzUsIDM5LCAyNywgMTAsIDIyLCAyNTEsIDQxLCA3LCAxLCAxNywgMiwgNjAsIDI4LCAxMSwgMCwgOSwgMjEsIDQzLCAxNywgNDcsIDIwLCAyOCwgMjIsIDEzLCA1MiwgNTgsIDEsIDMsIDAsIDE0LCA0NCwgMzMsIDI0LCAyNywgMzUsIDMwLCAwLCAzLCAwLCA5LCAzNCwgNCwgMCwgMTMsIDQ3LCAxNSwgMywgMjIsIDAsIDIsIDAsIDM2LCAxNywgMiwgMjQsIDIwLCAxLCA2NCwgNiwgMiwgMCwgMiwgMywgMiwgMTQsIDIsIDksIDgsIDQ2LCAzOSwgNywgMywgMSwgMywgMjEsIDIsIDYsIDIsIDEsIDIsIDQsIDQsIDAsIDE5LCAwLCAxMywgNCwgMzEsIDksIDIsIDAsIDMsIDAsIDIsIDM3LCAyLCAwLCAyNiwgMCwgMiwgMCwgNDUsIDUyLCAxOSwgMywgMjEsIDIsIDMxLCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDE0LCAwLCA3MiwgMjYsIDM4LCA2LCAxODYsIDQzLCAxMTcsIDYzLCAzMiwgNywgMywgMCwgMywgNywgMiwgMSwgMiwgMjMsIDE2LCAwLCAyLCAwLCA5NSwgNywgMywgMzgsIDE3LCAwLCAyLCAwLCAyOSwgMCwgMTEsIDM5LCA4LCAwLCAyMiwgMCwgMTIsIDQ1LCAyMCwgMCwgMTksIDcyLCAyMDAsIDMyLCAzMiwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDExMywgNiwgMiwgMSwgMiwgMzcsIDIyLCAwLCAyNiwgNSwgMiwgMSwgMiwgMzEsIDE1LCAwLCAzMjgsIDE4LCAxNiwgMCwgMiwgMTIsIDIsIDMzLCAxMjUsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNjM3LCA5NiwgMTYsIDEwNzEsIDE4LCA1LCAyNiwgMzk5NCwgNiwgNTgyLCA2ODQyLCAyOSwgMTc2MywgNTY4LCA4LCAzMCwgMTgsIDc4LCAxOCwgMjksIDE5LCA0NywgMTcsIDMsIDMyLCAyMCwgNiwgMTgsIDQzMywgNDQsIDIxMiwgNjMsIDEyOSwgNzQsIDYsIDAsIDY3LCAxMiwgNjUsIDEsIDIsIDAsIDI5LCA2MTM1LCA5LCAxMjM3LCA0MiwgOSwgODkzNiwgMywgMiwgNiwgMiwgMSwgMiwgMjkwLCAxNiwgMCwgMzAsIDIsIDMsIDAsIDE1LCAzLCA5LCAzOTUsIDIzMDksIDEwNiwgNiwgMTIsIDQsIDgsIDgsIDksIDU5OTEsIDg0LCAyLCA3MCwgMiwgMSwgMywgMCwgMywgMSwgMywgMywgMiwgMTEsIDIsIDAsIDIsIDYsIDIsIDY0LCAyLCAzLCAzLCA3LCAyLCA2LCAyLCAyNywgMiwgMywgMiwgNCwgMiwgMCwgNCwgNiwgMiwgMzM5LCAzLCAyNCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgNywgMTg0NSwgMzAsIDcsIDUsIDI2MiwgNjEsIDE0NywgNDQsIDExLCA2LCAxNywgMCwgMzIyLCAyOSwgMTksIDQzLCA0ODUsIDI3LCAyMjksIDI5LCAzLCAwLCA0OTYsIDYsIDIsIDMsIDIsIDEsIDIsIDE0LCAyLCAxOTYsIDYwLCA2NywgOCwgMCwgMTIwNSwgMywgMiwgMjYsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDksIDIsIDMsIDIsIDAsIDIsIDAsIDcsIDAsIDUsIDAsIDIsIDAsIDIsIDAsIDIsIDIsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDEsIDIsIDAsIDMsIDMsIDIsIDYsIDIsIDMsIDIsIDMsIDIsIDAsIDIsIDksIDIsIDE2LCA2LCAyLCAyLCA0LCAyLCAxNiwgNDQyMSwgNDI3MTksIDMzLCA0MTUzLCA3LCAyMjEsIDMsIDU3NjEsIDE1LCA3NDcyLCAxNiwgNjIxLCAyNDY3LCA1NDEsIDE1MDcsIDQ5MzgsIDYsIDQxOTFdO1xuXG4gIC8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkLiBEbyBub3QgbW9kaWZ5IG1hbnVhbGx5IVxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTIwMGNcXHUyMDBkXFx4YjdcXHUwMzAwLVxcdTAzNmZcXHUwMzg3XFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjY5XFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDZmMC1cXHUwNmY5XFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3YzAtXFx1MDdjOVxcdTA3ZWItXFx1MDdmM1xcdTA3ZmRcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODU5LVxcdTA4NWJcXHUwODk3LVxcdTA4OWZcXHUwOGNhLVxcdTA4ZTFcXHUwOGUzLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTA5ZTYtXFx1MDllZlxcdTA5ZmVcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBhZmEtXFx1MGFmZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTUtXFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAwLVxcdTBjMDRcXHUwYzNjXFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGNmM1xcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MS1cXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWJjXFx1MGVjOC1cXHUwZWNlXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNVxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgwZi1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFhYmYtXFx1MWFjZVxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1MzBmYlxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTgyY1xcdWE4ODBcXHVhODgxXFx1YThiNC1cXHVhOGM1XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGYxXFx1YThmZi1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUzXFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YTlkMC1cXHVhOWQ5XFx1YTllNVxcdWE5ZjAtXFx1YTlmOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2ItXFx1YWE3ZFxcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFhZWItXFx1YWFlZlxcdWFhZjVcXHVhYWY2XFx1YWJlMy1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXFx1ZmY2NVwiO1xuXG4gIC8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkLiBEbyBub3QgbW9kaWZ5IG1hbnVhbGx5IVxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwODcwLVxcdTA4ODdcXHUwODg5LVxcdTA4OGVcXHUwOGEwLVxcdTA4YzlcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM1ZFxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA0LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNTQtXFx1MGQ1NlxcdTBkNWYtXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODYtXFx1MGU4YVxcdTBlOGMtXFx1MGVhM1xcdTBlYTVcXHUwZWE3LVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNVxcdTEzZjgtXFx1MTNmZFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmOFxcdTE3MDAtXFx1MTcxMVxcdTE3MWYtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxZVxcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGNcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjODAtXFx1MWM4YVxcdTFjOTAtXFx1MWNiYVxcdTFjYmQtXFx1MWNiZlxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmM1xcdTFjZjVcXHUxY2Y2XFx1MWNmYVxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWItXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZlxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiZlxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiZlxcdTRlMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjlkXFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhN2NkXFx1YTdkMFxcdWE3ZDFcXHVhN2QzXFx1YTdkNS1cXHVhN2RjXFx1YTdmMi1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE4ZmRcXHVhOGZlXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWE5ZTAtXFx1YTllNFxcdWE5ZTYtXFx1YTllZlxcdWE5ZmEtXFx1YTlmZVxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTdlLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiMzAtXFx1YWI1YVxcdWFiNWMtXFx1YWI2OVxcdWFiNzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xuXG4gIC8vIFRoZXNlIGFyZSBhIHJ1bi1sZW5ndGggYW5kIG9mZnNldCBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAvLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4gIC8vIG9mZnNldCBzdGFydHMgYXQgMHgxMDAwMCwgYW5kIGVhY2ggcGFpciBvZiBudW1iZXJzIHJlcHJlc2VudHMgYW5cbiAgLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IHJhbmdlLCBhbmQgdGhlbiBhIHNpemUgb2YgdGhlIHJhbmdlLlxuXG4gIC8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbiAgdmFyIHJlc2VydmVkV29yZHMgPSB7XG4gICAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gICAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IFwiZW51bVwiLFxuICAgIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gICAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG4gIH07XG5cbiAgLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG4gIHZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbiAgdmFyIGtleXdvcmRzJDEgPSB7XG4gICAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gICAgXCI1bW9kdWxlXCI6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHN1cGVyXCJcbiAgfTtcblxuICB2YXIga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9eaW4oc3RhbmNlb2YpPyQvO1xuXG4gIC8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG4gIC8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbiAgLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuICAvLyByYXJlLlxuICBmdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICAgIHZhciBwb3MgPSAweDEwMDAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBwb3MgKz0gc2V0W2ldO1xuICAgICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgICAgaWYgKHBvcyA+PSBjb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlLCBhc3RyYWwpIHtcbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKVxuICB9XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUsIGFzdHJhbCkge1xuICAgIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgICBpZiAoY29kZSA8IDU4KSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gICAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpXG4gIH1cblxuICAvLyAjIyBUb2tlbiB0eXBlc1xuXG4gIC8vIFRoZSBhc3NpZ25tZW50IG9mIGZpbmUtZ3JhaW5lZCwgaW5mb3JtYXRpb24tY2FycnlpbmcgdHlwZSBvYmplY3RzXG4gIC8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuICAvLyB0b2tlbiBpbiBhIHdheSB0aGF0IGlzIHZlcnkgY2hlYXAgZm9yIHRoZSBwYXJzZXIgdG8gbG9vayB1cC5cblxuICAvLyBBbGwgdG9rZW4gdHlwZSB2YXJpYWJsZXMgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlLCB0byBtYWtlIHRoZW1cbiAgLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbiAgLy8gVGhlIGBiZWZvcmVFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuIHJlZ3VsYXJcbiAgLy8gZXhwcmVzc2lvbnMgYW5kIGRpdmlzaW9ucy4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGNhblxuICAvLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuICAvLyByZWd1bGFyIGV4cHJlc3Npb24pLlxuICAvL1xuICAvLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuICAvLyBgeWllbGRgIGV4cHJlc3Npb24uIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBlaXRoZXIgY2FuXG4gIC8vIGRpcmVjdGx5IHN0YXJ0IGFuIGV4cHJlc3Npb24gKGxpa2UgYSBxdW90YXRpb24gbWFyaykgb3IgY2FuXG4gIC8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuICAvL1xuICAvLyBgaXNMb29wYCBtYXJrcyBhIGtleXdvcmQgYXMgc3RhcnRpbmcgYSBsb29wLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbiAgLy8gY29udGludWUganVtcHMgdG8gdGhhdCBsYWJlbC5cblxuICB2YXIgVG9rZW5UeXBlID0gZnVuY3Rpb24gVG9rZW5UeXBlKGxhYmVsLCBjb25mKSB7XG4gICAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICAgIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICAgIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICAgIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICAgIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICAgIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICAgIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogcHJlY30pXG4gIH1cbiAgdmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cbiAgLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbiAgdmFyIGtleXdvcmRzID0ge307XG5cbiAgLy8gU3VjY2luY3QgZGVmaW5pdGlvbnMgb2Yga2V5d29yZCB0b2tlbiB0eXBlc1xuICBmdW5jdGlvbiBrdyhuYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuICAgIHJldHVybiBrZXl3b3Jkc1tuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciB0eXBlcyQxID0ge1xuICAgIG51bTogbmV3IFRva2VuVHlwZShcIm51bVwiLCBzdGFydHNFeHByKSxcbiAgICByZWdleHA6IG5ldyBUb2tlblR5cGUoXCJyZWdleHBcIiwgc3RhcnRzRXhwciksXG4gICAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHN0YXJ0c0V4cHIpLFxuICAgIG5hbWU6IG5ldyBUb2tlblR5cGUoXCJuYW1lXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHByaXZhdGVJZDogbmV3IFRva2VuVHlwZShcInByaXZhdGVJZFwiLCBzdGFydHNFeHByKSxcbiAgICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgICAvLyBQdW5jdHVhdGlvbiB0b2tlbiB0eXBlcy5cbiAgICBicmFja2V0TDogbmV3IFRva2VuVHlwZShcIltcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gICAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGJyYWNlUjogbmV3IFRva2VuVHlwZShcIn1cIiksXG4gICAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gICAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIGJlZm9yZUV4cHIpLFxuICAgIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICAgIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICAgIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgICBxdWVzdGlvbkRvdDogbmV3IFRva2VuVHlwZShcIj8uXCIpLFxuICAgIGFycm93OiBuZXcgVG9rZW5UeXBlKFwiPT5cIiwgYmVmb3JlRXhwciksXG4gICAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgICBpbnZhbGlkVGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJpbnZhbGlkVGVtcGxhdGVcIiksXG4gICAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgYmVmb3JlRXhwciksXG4gICAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG4gICAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gICAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gICAgLy9cbiAgICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgICAvLyBvcGVyYXRvciwgYW5kIHdpbGwgcmVmZXIgdG8gaXRzIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgICAvLyB1bmFyeSBvcGVyYXRvci5cbiAgICAvL1xuICAgIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gICAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gICAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwge3ByZWZpeDogdHJ1ZSwgcG9zdGZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHByZWZpeDogbmV3IFRva2VuVHlwZShcIiEvflwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICAgIGxvZ2ljYWxBTkQ6IGJpbm9wKFwiJiZcIiwgMiksXG4gICAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gICAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICAgIGJpdHdpc2VBTkQ6IGJpbm9wKFwiJlwiLCA1KSxcbiAgICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPS89PT0vIT09XCIsIDYpLFxuICAgIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICAgIGJpdFNoaWZ0OiBiaW5vcChcIjw8Lz4+Lz4+PlwiLCA4KSxcbiAgICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICAgIHN0YXI6IGJpbm9wKFwiKlwiLCAxMCksXG4gICAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gICAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuICAgIGNvYWxlc2NlOiBiaW5vcChcIj8/XCIsIDEpLFxuXG4gICAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgICBfYnJlYWs6IGt3KFwiYnJlYWtcIiksXG4gICAgX2Nhc2U6IGt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKSxcbiAgICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gICAgX2NvbnRpbnVlOiBrdyhcImNvbnRpbnVlXCIpLFxuICAgIF9kZWJ1Z2dlcjoga3coXCJkZWJ1Z2dlclwiKSxcbiAgICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICAgIF9kbzoga3coXCJkb1wiLCB7aXNMb29wOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSksXG4gICAgX2Vsc2U6IGt3KFwiZWxzZVwiLCBiZWZvcmVFeHByKSxcbiAgICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICAgIF9mb3I6IGt3KFwiZm9yXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgICBfZnVuY3Rpb246IGt3KFwiZnVuY3Rpb25cIiwgc3RhcnRzRXhwciksXG4gICAgX2lmOiBrdyhcImlmXCIpLFxuICAgIF9yZXR1cm46IGt3KFwicmV0dXJuXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9zd2l0Y2g6IGt3KFwic3dpdGNoXCIpLFxuICAgIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgICBfdHJ5OiBrdyhcInRyeVwiKSxcbiAgICBfdmFyOiBrdyhcInZhclwiKSxcbiAgICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gICAgX3doaWxlOiBrdyhcIndoaWxlXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgICBfd2l0aDoga3coXCJ3aXRoXCIpLFxuICAgIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX3RoaXM6IGt3KFwidGhpc1wiLCBzdGFydHNFeHByKSxcbiAgICBfc3VwZXI6IGt3KFwic3VwZXJcIiwgc3RhcnRzRXhwciksXG4gICAgX2NsYXNzOiBrdyhcImNsYXNzXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9leHRlbmRzOiBrdyhcImV4dGVuZHNcIiwgYmVmb3JlRXhwciksXG4gICAgX2V4cG9ydDoga3coXCJleHBvcnRcIiksXG4gICAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiwgc3RhcnRzRXhwciksXG4gICAgX251bGw6IGt3KFwibnVsbFwiLCBzdGFydHNFeHByKSxcbiAgICBfdHJ1ZToga3coXCJ0cnVlXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgICBfaW46IGt3KFwiaW5cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gICAgX2luc3RhbmNlb2Y6IGt3KFwiaW5zdGFuY2VvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX3ZvaWQ6IGt3KFwidm9pZFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX2RlbGV0ZToga3coXCJkZWxldGVcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pXG4gIH07XG5cbiAgLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuICAvLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuICB2YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG4gIHZhciBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5cbiAgZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT09IDB4MjAyOVxuICB9XG5cbiAgZnVuY3Rpb24gbmV4dExpbmVCcmVhayhjb2RlLCBmcm9tLCBlbmQpIHtcbiAgICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gY29kZS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGNvZGUuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChpc05ld0xpbmUobmV4dCkpXG4gICAgICAgIHsgcmV0dXJuIGkgPCBlbmQgLSAxICYmIG5leHQgPT09IDEzICYmIGNvZGUuY2hhckNvZGVBdChpICsgMSkgPT09IDEwID8gaSArIDIgOiBpICsgMSB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLztcblxuICB2YXIgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcblxuICB2YXIgcmVmID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gcmVmLmhhc093blByb3BlcnR5O1xuICB2YXIgdG9TdHJpbmcgPSByZWYudG9TdHJpbmc7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5oYXNPd24gfHwgKGZ1bmN0aW9uIChvYmosIHByb3BOYW1lKSB7IHJldHVybiAoXG4gICAgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BOYW1lKVxuICApOyB9KTtcblxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChcbiAgICB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIlxuICApOyB9KTtcblxuICB2YXIgcmVnZXhwQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIHdvcmRzUmVnZXhwKHdvcmRzKSB7XG4gICAgcmV0dXJuIHJlZ2V4cENhY2hlW3dvcmRzXSB8fCAocmVnZXhwQ2FjaGVbd29yZHNdID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLnJlcGxhY2UoLyAvZywgXCJ8XCIpICsgXCIpJFwiKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpIHtcbiAgICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgICBpZiAoY29kZSA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgfVxuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG4gIH1cblxuICB2YXIgbG9uZVN1cnJvZ2F0ZSA9IC8oPzpbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvO1xuXG4gIC8vIFRoZXNlIGFyZSB1c2VkIHdoZW4gYG9wdGlvbnMubG9jYXRpb25zYCBpcyBvbiwgZm9yIHRoZVxuICAvLyBgc3RhcnRMb2NgIGFuZCBgZW5kTG9jYCBwcm9wZXJ0aWVzLlxuXG4gIHZhciBQb3NpdGlvbiA9IGZ1bmN0aW9uIFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2w7XG4gIH07XG5cbiAgUG9zaXRpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCAobikge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lLCB0aGlzLmNvbHVtbiArIG4pXG4gIH07XG5cbiAgdmFyIFNvdXJjZUxvY2F0aW9uID0gZnVuY3Rpb24gU291cmNlTG9jYXRpb24ocCwgc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICBpZiAocC5zb3VyY2VGaWxlICE9PSBudWxsKSB7IHRoaXMuc291cmNlID0gcC5zb3VyY2VGaWxlOyB9XG4gIH07XG5cbiAgLy8gVGhlIGBnZXRMaW5lSW5mb2AgZnVuY3Rpb24gaXMgbW9zdGx5IHVzZWZ1bCB3aGVuIHRoZVxuICAvLyBgbG9jYXRpb25zYCBvcHRpb24gaXMgb2ZmIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykgYW5kIHlvdVxuICAvLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuICAvLyBvZmZzZXQuIGBpbnB1dGAgc2hvdWxkIGJlIHRoZSBjb2RlIHN0cmluZyB0aGF0IHRoZSBvZmZzZXQgcmVmZXJzXG4gIC8vIGludG8uXG5cbiAgZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICAgIGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICAgIHZhciBuZXh0QnJlYWsgPSBuZXh0TGluZUJyZWFrKGlucHV0LCBjdXIsIG9mZnNldCk7XG4gICAgICBpZiAobmV4dEJyZWFrIDwgMCkgeyByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cikgfVxuICAgICAgKytsaW5lO1xuICAgICAgY3VyID0gbmV4dEJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIEEgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgZ2l2ZW4gdG8gY29uZmlndXJlIHRoZSBwYXJzZXIgcHJvY2Vzcy5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBhcmUgcmVjb2duaXplZCAob25seSBgZWNtYVZlcnNpb25gIGlzIHJlcXVpcmVkKTpcblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdCBiZVxuICAgIC8vIGVpdGhlciAzLCA1LCA2IChvciAyMDE1KSwgNyAoMjAxNiksIDggKDIwMTcpLCA5ICgyMDE4KSwgMTBcbiAgICAvLyAoMjAxOSksIDExICgyMDIwKSwgMTIgKDIwMjEpLCAxMyAoMjAyMiksIDE0ICgyMDIzKSwgb3IgYFwibGF0ZXN0XCJgXG4gICAgLy8gKHRoZSBsYXRlc3QgdmVyc2lvbiB0aGUgbGlicmFyeSBzdXBwb3J0cykuIFRoaXMgaW5mbHVlbmNlc1xuICAgIC8vIHN1cHBvcnQgZm9yIHN0cmljdCBtb2RlLCB0aGUgc2V0IG9mIHJlc2VydmVkIHdvcmRzLCBhbmQgc3VwcG9ydFxuICAgIC8vIGZvciBuZXcgc3ludGF4IGZlYXR1cmVzLlxuICAgIGVjbWFWZXJzaW9uOiBudWxsLFxuICAgIC8vIGBzb3VyY2VUeXBlYCBpbmRpY2F0ZXMgdGhlIG1vZGUgdGhlIGNvZGUgc2hvdWxkIGJlIHBhcnNlZCBpbi5cbiAgICAvLyBDYW4gYmUgZWl0aGVyIGBcInNjcmlwdFwiYCBvciBgXCJtb2R1bGVcImAuIFRoaXMgaW5mbHVlbmNlcyBnbG9iYWxcbiAgICAvLyBzdHJpY3QgbW9kZSBhbmQgcGFyc2luZyBvZiBgaW1wb3J0YCBhbmQgYGV4cG9ydGAgZGVjbGFyYXRpb25zLlxuICAgIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gICAgLy8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gIGNhbiBiZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAgIC8vIGEgc2VtaWNvbG9uIGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuICAgIC8vIHBvc2l0aW9uIG9mIHRoZSBpbnNlcnRlZCBzZW1pY29sb24gYXMgYW4gb2Zmc2V0LCBhbmQgaWZcbiAgICAvLyBgbG9jYXRpb25zYCBpcyBlbmFibGVkLCBpdCBpcyBnaXZlbiB0aGUgbG9jYXRpb24gYXMgYSBge2xpbmUsXG4gICAgLy8gY29sdW1ufWAgb2JqZWN0IGFzIHNlY29uZCBhcmd1bWVudC5cbiAgICBvbkluc2VydGVkU2VtaWNvbG9uOiBudWxsLFxuICAgIC8vIGBvblRyYWlsaW5nQ29tbWFgIGlzIHNpbWlsYXIgdG8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gLCBidXQgZm9yXG4gICAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICAgIG9uVHJhaWxpbmdDb21tYTogbnVsbCxcbiAgICAvLyBCeSBkZWZhdWx0LCByZXNlcnZlZCB3b3JkcyBhcmUgb25seSBlbmZvcmNlZCBpZiBlY21hVmVyc2lvbiA+PSA1LlxuICAgIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gICAgLy8gYW4gb2ZmLiBXaGVuIHRoaXMgb3B0aW9uIGhhcyB0aGUgdmFsdWUgXCJuZXZlclwiLCByZXNlcnZlZCB3b3Jkc1xuICAgIC8vIGFuZCBrZXl3b3JkcyBjYW4gYWxzbyBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eSBuYW1lcy5cbiAgICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgYSByZXR1cm4gYXQgdGhlIHRvcCBsZXZlbCBpcyBub3QgY29uc2lkZXJlZCBhblxuICAgIC8vIGVycm9yLlxuICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIGltcG9ydC9leHBvcnQgc3RhdGVtZW50cyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gICAgLy8gYXBwZWFyaW5nIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW0sIGFuZCBhbiBpbXBvcnQubWV0YSBleHByZXNzaW9uXG4gICAgLy8gaW4gYSBzY3JpcHQgaXNuJ3QgY29uc2lkZXJlZCBhbiBlcnJvci5cbiAgICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IGZhbHNlLFxuICAgIC8vIEJ5IGRlZmF1bHQsIGF3YWl0IGlkZW50aWZpZXJzIGFyZSBhbGxvd2VkIHRvIGFwcGVhciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlIG9ubHkgaWYgZWNtYVZlcnNpb24gPj0gMjAyMi5cbiAgICAvLyBXaGVuIGVuYWJsZWQsIGF3YWl0IGlkZW50aWZpZXJzIGFyZSBhbGxvd2VkIHRvIGFwcGVhciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlLFxuICAgIC8vIGJ1dCB0aGV5IGFyZSBzdGlsbCBub3QgYWxsb3dlZCBpbiBub24tYXN5bmMgZnVuY3Rpb25zLlxuICAgIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IG51bGwsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBzdXBlciBpZGVudGlmaWVycyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gICAgLy8gYXBwZWFyaW5nIGluIG1ldGhvZHMgYW5kIGRvIG5vdCByYWlzZSBhbiBlcnJvciB3aGVuIHRoZXkgYXBwZWFyIGVsc2V3aGVyZS5cbiAgICBhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZDogbnVsbCxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIGhhc2hiYW5nIGRpcmVjdGl2ZSBpbiB0aGUgYmVnaW5uaW5nIG9mIGZpbGUgaXNcbiAgICAvLyBhbGxvd2VkIGFuZCB0cmVhdGVkIGFzIGEgbGluZSBjb21tZW50LiBFbmFibGVkIGJ5IGRlZmF1bHQgd2hlblxuICAgIC8vIGBlY21hVmVyc2lvbmAgPj0gMjAyMy5cbiAgICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgICAvLyBCeSBkZWZhdWx0LCB0aGUgcGFyc2VyIHdpbGwgdmVyaWZ5IHRoYXQgcHJpdmF0ZSBwcm9wZXJ0aWVzIGFyZVxuICAgIC8vIG9ubHkgdXNlZCBpbiBwbGFjZXMgd2hlcmUgdGhleSBhcmUgdmFsaWQgYW5kIGhhdmUgYmVlbiBkZWNsYXJlZC5cbiAgICAvLyBTZXQgdGhpcyB0byBmYWxzZSB0byB0dXJuIHN1Y2ggY2hlY2tzIG9mZi5cbiAgICBjaGVja1ByaXZhdGVGaWVsZHM6IHRydWUsXG4gICAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgYGxvY2AgcHJvcGVydGllcyBob2xkaW5nIG9iamVjdHMgd2l0aFxuICAgIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gICAgLy8gbGluZSBiZWluZyAxLWJhc2VkIGFuZCBjb2x1bW4gMC1iYXNlZCkgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGVcbiAgICAvLyBub2Rlcy5cbiAgICBsb2NhdGlvbnM6IGZhbHNlLFxuICAgIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Ub2tlbmAgb3B0aW9uLCB3aGljaCB3aWxsXG4gICAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggb2JqZWN0IGluIHRoZSBzYW1lXG4gICAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAgIC8vIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZSBwYXJzZXIgZnJvbSB0aGVcbiAgICAvLyBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgICBvblRva2VuOiBudWxsLFxuICAgIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Db21tZW50YCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBgKGJsb2NrLCB0ZXh0LCBzdGFydCxcbiAgICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgICAvLyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGlzIGEgYmxvY2sgKGAvKiAqL2ApIGNvbW1lbnQsXG4gICAgLy8gYHRleHRgIGlzIHRoZSBjb250ZW50IG9mIHRoZSBjb21tZW50LCBhbmQgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlXG4gICAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gICAgLy8gV2hlbiB0aGUgYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9uLCB0d28gbW9yZSBwYXJhbWV0ZXJzIGFyZVxuICAgIC8vIHBhc3NlZCwgdGhlIGZ1bGwgYHtsaW5lLCBjb2x1bW59YCBsb2NhdGlvbnMgb2YgdGhlIHN0YXJ0IGFuZFxuICAgIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gICAgLy8gcGFyc2VyIGZyb20gdGhlIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICAgIC8vIFdoZW4gdGhpcyBvcHRpb24gaGFzIGFuIGFycmF5IGFzIHZhbHVlLCBvYmplY3RzIHJlcHJlc2VudGluZyB0aGVcbiAgICAvLyBjb21tZW50cyBhcmUgcHVzaGVkIHRvIGl0LlxuICAgIG9uQ29tbWVudDogbnVsbCxcbiAgICAvLyBOb2RlcyBoYXZlIHRoZWlyIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVycyBvZmZzZXRzIHJlY29yZGVkIGluXG4gICAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyAoZGlyZWN0bHkgb24gdGhlIG5vZGUsIHJhdGhlciB0aGFuXG4gICAgLy8gdGhlIGBsb2NgIG9iamVjdCwgd2hpY2ggaG9sZHMgbGluZS9jb2x1bW4gZGF0YS4gVG8gYWxzbyBhZGQgYVxuICAgIC8vIFtzZW1pLXN0YW5kYXJkaXplZF1bcmFuZ2VdIGByYW5nZWAgcHJvcGVydHkgaG9sZGluZyBhIGBbc3RhcnQsXG4gICAgLy8gZW5kXWAgYXJyYXkgd2l0aCB0aGUgc2FtZSBudW1iZXJzLCBzZXQgdGhlIGByYW5nZXNgIG9wdGlvbiB0b1xuICAgIC8vIGB0cnVlYC5cbiAgICAvL1xuICAgIC8vIFtyYW5nZV06IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc0NTY3OFxuICAgIHJhbmdlczogZmFsc2UsXG4gICAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGFyc2UgbXVsdGlwbGUgZmlsZXMgaW50byBhIHNpbmdsZSBBU1QgYnlcbiAgICAvLyBwYXNzaW5nIHRoZSB0cmVlIHByb2R1Y2VkIGJ5IHBhcnNpbmcgdGhlIGZpcnN0IGZpbGUgYXNcbiAgICAvLyBgcHJvZ3JhbWAgb3B0aW9uIGluIHN1YnNlcXVlbnQgcGFyc2VzLiBUaGlzIHdpbGwgYWRkIHRoZVxuICAgIC8vIHRvcGxldmVsIGZvcm1zIG9mIHRoZSBwYXJzZWQgZmlsZSB0byB0aGUgYFByb2dyYW1gICh0b3ApIG5vZGVcbiAgICAvLyBvZiBhbiBleGlzdGluZyBwYXJzZSB0cmVlLlxuICAgIHByb2dyYW06IG51bGwsXG4gICAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgeW91IGNhbiBwYXNzIHRoaXMgdG8gcmVjb3JkIHRoZSBzb3VyY2VcbiAgICAvLyBmaWxlIGluIGV2ZXJ5IG5vZGUncyBgbG9jYCBvYmplY3QuXG4gICAgc291cmNlRmlsZTogbnVsbCxcbiAgICAvLyBUaGlzIHZhbHVlLCBpZiBnaXZlbiwgaXMgc3RvcmVkIGluIGV2ZXJ5IG5vZGUsIHdoZXRoZXJcbiAgICAvLyBgbG9jYXRpb25zYCBpcyBvbiBvciBvZmYuXG4gICAgZGlyZWN0U291cmNlRmlsZTogbnVsbCxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbnMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gICAgLy8gKG5vbi1zdGFuZGFyZCkgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gbm9kZXNcbiAgICBwcmVzZXJ2ZVBhcmVuczogZmFsc2VcbiAgfTtcblxuICAvLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxuICB2YXIgd2FybmVkQWJvdXRFY21hVmVyc2lvbiA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpXG4gICAgICB7IG9wdGlvbnNbb3B0XSA9IG9wdHMgJiYgaGFzT3duKG9wdHMsIG9wdCkgPyBvcHRzW29wdF0gOiBkZWZhdWx0T3B0aW9uc1tvcHRdOyB9XG5cbiAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gXCJsYXRlc3RcIikge1xuICAgICAgb3B0aW9ucy5lY21hVmVyc2lvbiA9IDFlODtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgaWYgKCF3YXJuZWRBYm91dEVjbWFWZXJzaW9uICYmIHR5cGVvZiBjb25zb2xlID09PSBcIm9iamVjdFwiICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICB3YXJuZWRBYm91dEVjbWFWZXJzaW9uID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS53YXJuKFwiU2luY2UgQWNvcm4gOC4wLjAsIG9wdGlvbnMuZWNtYVZlcnNpb24gaXMgcmVxdWlyZWQuXFxuRGVmYXVsdGluZyB0byAyMDIwLCBidXQgdGhpcyB3aWxsIHN0b3Agd29ya2luZyBpbiB0aGUgZnV0dXJlLlwiKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuZWNtYVZlcnNpb24gPSAxMTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMjAxNSkge1xuICAgICAgb3B0aW9ucy5lY21hVmVyc2lvbiAtPSAyMDA5O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gbnVsbClcbiAgICAgIHsgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID0gb3B0aW9ucy5lY21hVmVyc2lvbiA8IDU7IH1cblxuICAgIGlmICghb3B0cyB8fCBvcHRzLmFsbG93SGFzaEJhbmcgPT0gbnVsbClcbiAgICAgIHsgb3B0aW9ucy5hbGxvd0hhc2hCYW5nID0gb3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNDsgfVxuXG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgICAgdmFyIHRva2VucyA9IG9wdGlvbnMub25Ub2tlbjtcbiAgICAgIG9wdGlvbnMub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW5zLnB1c2godG9rZW4pOyB9O1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShvcHRpb25zLm9uQ29tbWVudCkpXG4gICAgICB7IG9wdGlvbnMub25Db21tZW50ID0gcHVzaENvbW1lbnQob3B0aW9ucywgb3B0aW9ucy5vbkNvbW1lbnQpOyB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaENvbW1lbnQob3B0aW9ucywgYXJyYXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICAgIHZhciBjb21tZW50ID0ge1xuICAgICAgICB0eXBlOiBibG9jayA/IFwiQmxvY2tcIiA6IFwiTGluZVwiLFxuICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucylcbiAgICAgICAgeyBjb21tZW50LmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBzdGFydExvYywgZW5kTG9jKTsgfVxuICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgICB7IGNvbW1lbnQucmFuZ2UgPSBbc3RhcnQsIGVuZF07IH1cbiAgICAgIGFycmF5LnB1c2goY29tbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRWFjaCBzY29wZSBnZXRzIGEgYml0c2V0IHRoYXQgbWF5IGNvbnRhaW4gdGhlc2UgZmxhZ3NcbiAgdmFyXG4gICAgICBTQ09QRV9UT1AgPSAxLFxuICAgICAgU0NPUEVfRlVOQ1RJT04gPSAyLFxuICAgICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgICAgU0NPUEVfR0VORVJBVE9SID0gOCxcbiAgICAgIFNDT1BFX0FSUk9XID0gMTYsXG4gICAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICAgIFNDT1BFX1NVUEVSID0gNjQsXG4gICAgICBTQ09QRV9ESVJFQ1RfU1VQRVIgPSAxMjgsXG4gICAgICBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgPSAyNTYsXG4gICAgICBTQ09QRV9DTEFTU19GSUVMRF9JTklUID0gNTEyLFxuICAgICAgU0NPUEVfVkFSID0gU0NPUEVfVE9QIHwgU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0s7XG5cbiAgZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhhc3luYywgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIFNDT1BFX0ZVTkNUSU9OIHwgKGFzeW5jID8gU0NPUEVfQVNZTkMgOiAwKSB8IChnZW5lcmF0b3IgPyBTQ09QRV9HRU5FUkFUT1IgOiAwKVxuICB9XG5cbiAgLy8gVXNlZCBpbiBjaGVja0xWYWwqIGFuZCBkZWNsYXJlTmFtZSB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYSBiaW5kaW5nXG4gIHZhclxuICAgICAgQklORF9OT05FID0gMCwgLy8gTm90IGEgYmluZGluZ1xuICAgICAgQklORF9WQVIgPSAxLCAvLyBWYXItc3R5bGUgYmluZGluZ1xuICAgICAgQklORF9MRVhJQ0FMID0gMiwgLy8gTGV0LSBvciBjb25zdC1zdHlsZSBiaW5kaW5nXG4gICAgICBCSU5EX0ZVTkNUSU9OID0gMywgLy8gRnVuY3Rpb24gZGVjbGFyYXRpb25cbiAgICAgIEJJTkRfU0lNUExFX0NBVENIID0gNCwgLy8gU2ltcGxlIChpZGVudGlmaWVyIHBhdHRlcm4pIGNhdGNoIGJpbmRpbmdcbiAgICAgIEJJTkRfT1VUU0lERSA9IDU7IC8vIFNwZWNpYWwgY2FzZSBmb3IgZnVuY3Rpb24gbmFtZXMgYXMgYm91bmQgaW5zaWRlIHRoZSBmdW5jdGlvblxuXG4gIHZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5zb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlO1xuICAgIHRoaXMua2V5d29yZHMgPSB3b3Jkc1JlZ2V4cChrZXl3b3JkcyQxW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIgPyBcIjVtb2R1bGVcIiA6IDVdKTtcbiAgICB2YXIgcmVzZXJ2ZWQgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IHRydWUpIHtcbiAgICAgIHJlc2VydmVkID0gcmVzZXJ2ZWRXb3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogb3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNSA/IDUgOiAzXTtcbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIpIHsgcmVzZXJ2ZWQgKz0gXCIgYXdhaXRcIjsgfVxuICAgIH1cbiAgICB0aGlzLnJlc2VydmVkV29yZHMgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZCk7XG4gICAgdmFyIHJlc2VydmVkU3RyaWN0ID0gKHJlc2VydmVkID8gcmVzZXJ2ZWQgKyBcIiBcIiA6IFwiXCIpICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3Q7XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0ID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QpO1xuICAgIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbiAgICB0aGlzLmlucHV0ID0gU3RyaW5nKGlucHV0KTtcblxuICAgIC8vIFVzZWQgdG8gc2lnbmFsIHRvIGNhbGxlcnMgb2YgYHJlYWRXb3JkMWAgd2hldGhlciB0aGUgd29yZFxuICAgIC8vIGNvbnRhaW5lZCBhbnkgZXNjYXBlIHNlcXVlbmNlcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB3b3JkcyB3aXRoXG4gICAgLy8gZXNjYXBlIHNlcXVlbmNlcyBtdXN0IG5vdCBiZSBpbnRlcnByZXRlZCBhcyBrZXl3b3Jkcy5cbiAgICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG5cbiAgICAvLyBTZXQgdXAgdG9rZW4gc3RhdGVcblxuICAgIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuICAgIGlmIChzdGFydFBvcykge1xuICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcztcbiAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcyAtIDEpICsgMTtcbiAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaW5wdXQuc2xpY2UoMCwgdGhpcy5saW5lU3RhcnQpLnNwbGl0KGxpbmVCcmVhaykubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvcyA9IHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICAgIHRoaXMuY3VyTGluZSA9IDE7XG4gICAgfVxuXG4gICAgLy8gUHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0b2tlbjpcbiAgICAvLyBJdHMgdHlwZVxuICAgIHRoaXMudHlwZSA9IHR5cGVzJDEuZW9mO1xuICAgIC8vIEZvciB0b2tlbnMgdGhhdCBpbmNsdWRlIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGVpciB0eXBlLCB0aGUgdmFsdWVcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgICAvLyBBbmQsIGlmIGxvY2F0aW9ucyBhcmUgdXNlZCwgdGhlIHtsaW5lLCBjb2x1bW59IG9iamVjdFxuICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICAgIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAgIC8vIFBvc2l0aW9uIGluZm9ybWF0aW9uIGZvciB0aGUgcHJldmlvdXMgdG9rZW5cbiAgICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLnBvcztcblxuICAgIC8vIFRoZSBjb250ZXh0IHN0YWNrIGlzIHVzZWQgdG8gc3VwZXJmaWNpYWxseSB0cmFjayBzeW50YWN0aWNcbiAgICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmluaXRpYWxDb250ZXh0KCk7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgICAvLyBGaWd1cmUgb3V0IGlmIGl0J3MgYSBtb2R1bGUgY29kZS5cbiAgICB0aGlzLmluTW9kdWxlID0gb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiO1xuICAgIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgICAvLyBVc2VkIHRvIHNpZ25pZnkgdGhlIHN0YXJ0IG9mIGEgcG90ZW50aWFsIGFycm93IGZ1bmN0aW9uXG4gICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gLTE7XG4gICAgdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgPSBmYWxzZTtcblxuICAgIC8vIFBvc2l0aW9ucyB0byBkZWxheWVkLWNoZWNrIHRoYXQgeWllbGQvYXdhaXQgZG9lcyBub3QgZXhpc3QgaW4gZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICAgIHRoaXMueWllbGRQb3MgPSB0aGlzLmF3YWl0UG9zID0gdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICAvLyBUaHVzLWZhciB1bmRlZmluZWQgZXhwb3J0cy5cbiAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gSWYgZW5hYmxlZCwgc2tpcCBsZWFkaW5nIGhhc2hiYW5nIGxpbmUuXG4gICAgaWYgKHRoaXMucG9zID09PSAwICYmIG9wdGlvbnMuYWxsb3dIYXNoQmFuZyAmJiB0aGlzLmlucHV0LnNsaWNlKDAsIDIpID09PSBcIiMhXCIpXG4gICAgICB7IHRoaXMuc2tpcExpbmVDb21tZW50KDIpOyB9XG5cbiAgICAvLyBTY29wZSB0cmFja2luZyBmb3IgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWVzIChzZWUgc2NvcGUuanMpXG4gICAgdGhpcy5zY29wZVN0YWNrID0gW107XG4gICAgdGhpcy5lbnRlclNjb3BlKFNDT1BFX1RPUCk7XG5cbiAgICAvLyBGb3IgUmVnRXhwIHZhbGlkYXRpb25cbiAgICB0aGlzLnJlZ2V4cFN0YXRlID0gbnVsbDtcblxuICAgIC8vIFRoZSBzdGFjayBvZiBwcml2YXRlIG5hbWVzLlxuICAgIC8vIEVhY2ggZWxlbWVudCBoYXMgdHdvIHByb3BlcnRpZXM6ICdkZWNsYXJlZCcgYW5kICd1c2VkJy5cbiAgICAvLyBXaGVuIGl0IGV4aXRlZCBmcm9tIHRoZSBvdXRlcm1vc3QgY2xhc3MgZGVmaW5pdGlvbiwgYWxsIHVzZWQgcHJpdmF0ZSBuYW1lcyBtdXN0IGJlIGRlY2xhcmVkLlxuICAgIHRoaXMucHJpdmF0ZU5hbWVTdGFjayA9IFtdO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGluRnVuY3Rpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5HZW5lcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5Bc3luYzogeyBjb25maWd1cmFibGU6IHRydWUgfSxjYW5Bd2FpdDogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd1N1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93RGlyZWN0U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sdHJlYXRGdW5jdGlvbnNBc1ZhcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd05ld0RvdFRhcmdldDogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkNsYXNzU3RhdGljQmxvY2s6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5vcHRpb25zLnByb2dyYW0gfHwgdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwobm9kZSlcbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5GdW5jdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA+IDAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5HZW5lcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9HRU5FUkFUT1IpID4gMCB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5jYW5Bd2FpdC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHJlZiA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgICAgdmFyIGZsYWdzID0gcmVmLmZsYWdzO1xuICAgICAgaWYgKGZsYWdzICYgKFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSyB8IFNDT1BFX0NMQVNTX0ZJRUxEX0lOSVQpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBpZiAoZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgeyByZXR1cm4gKGZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5pbk1vZHVsZSAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMpIHx8IHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmFsbG93U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWYgPSB0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKTtcbiAgICAgIHZhciBmbGFncyA9IHJlZi5mbGFncztcbiAgICByZXR1cm4gKGZsYWdzICYgU0NPUEVfU1VQRVIpID4gMCB8fCB0aGlzLm9wdGlvbnMuYWxsb3dTdXBlck91dHNpZGVNZXRob2RcbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dEaXJlY3RTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9ESVJFQ1RfU1VQRVIpID4gMCB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy50cmVhdEZ1bmN0aW9uc0FzVmFyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSkgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dOZXdEb3RUYXJnZXQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciByZWYgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIHZhciBmbGFncyA9IHJlZi5mbGFncztcbiAgICAgIGlmIChmbGFncyAmIChTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgfCBTQ09QRV9DTEFTU19GSUVMRF9JTklUKSB8fFxuICAgICAgICAgICgoZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgJiYgIShmbGFncyAmIFNDT1BFX0FSUk9XKSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5DbGFzc1N0YXRpY0Jsb2NrLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spID4gMFxuICB9O1xuXG4gIFBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKCkge1xuICAgICAgdmFyIHBsdWdpbnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBwbHVnaW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgY2xzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHsgY2xzID0gcGx1Z2luc1tpXShjbHMpOyB9XG4gICAgcmV0dXJuIGNsc1xuICB9O1xuXG4gIFBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCkucGFyc2UoKVxuICB9O1xuXG4gIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdCA9IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0IChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICAgIHBhcnNlci5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbigpXG4gIH07XG5cbiAgUGFyc2VyLnRva2VuaXplciA9IGZ1bmN0aW9uIHRva2VuaXplciAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFBhcnNlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHZhciBwcCQ5ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyAjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbiAgdmFyIGxpdGVyYWwgPSAvXig/OicoKD86XFxcXFteXXxbXidcXFxcXSkqPyknfFwiKCg/OlxcXFxbXl18W15cIlxcXFxdKSo/KVwiKS87XG4gIHBwJDkuc3RyaWN0RGlyZWN0aXZlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGZvciAoOzspIHtcbiAgICAgIC8vIFRyeSB0byBmaW5kIHN0cmluZyBsaXRlcmFsLlxuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICAgIHZhciBtYXRjaCA9IGxpdGVyYWwuZXhlYyh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0KSk7XG4gICAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHZhciBzcGFjZUFmdGVyID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KSwgZW5kID0gc3BhY2VBZnRlci5pbmRleCArIHNwYWNlQWZ0ZXJbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckF0KGVuZCk7XG4gICAgICAgIHJldHVybiBuZXh0ID09PSBcIjtcIiB8fCBuZXh0ID09PSBcIn1cIiB8fFxuICAgICAgICAgIChsaW5lQnJlYWsudGVzdChzcGFjZUFmdGVyWzBdKSAmJlxuICAgICAgICAgICAhKC9bKGAuWytcXC0vKiU8Pj0sP14mXS8udGVzdChuZXh0KSB8fCBuZXh0ID09PSBcIiFcIiAmJiB0aGlzLmlucHV0LmNoYXJBdChlbmQgKyAxKSA9PT0gXCI9XCIpKVxuICAgICAgfVxuICAgICAgc3RhcnQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuXG4gICAgICAvLyBTa2lwIHNlbWljb2xvbiwgaWYgYW55LlxuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmlucHV0W3N0YXJ0XSA9PT0gXCI7XCIpXG4gICAgICAgIHsgc3RhcnQrKzsgfVxuICAgIH1cbiAgfTtcblxuICAvLyBQcmVkaWNhdGUgdGhhdCB0ZXN0cyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlblxuICAvLyB0eXBlLCBhbmQgaWYgeWVzLCBjb25zdW1lcyBpdCBhcyBhIHNpZGUgZWZmZWN0LlxuXG4gIHBwJDkuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIC8vIFRlc3RzIHdoZXRoZXIgcGFyc2VkIHRva2VuIGlzIGEgY29udGV4dHVhbCBrZXl3b3JkLlxuXG4gIHBwJDkuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSAmJiB0aGlzLnZhbHVlID09PSBuYW1lICYmICF0aGlzLmNvbnRhaW5zRXNjXG4gIH07XG5cbiAgLy8gQ29uc3VtZXMgY29udGV4dHVhbCBrZXl3b3JkIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDkuZWF0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKG5hbWUpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICAvLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxuICBwcCQ5LmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwobmFtZSkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfTtcblxuICAvLyBUZXN0IHdoZXRoZXIgYSBzZW1pY29sb24gY2FuIGJlIGluc2VydGVkIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXG4gIHBwJDkuY2FuSW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lb2YgfHxcbiAgICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5icmFjZVIgfHxcbiAgICAgIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgfTtcblxuICBwcCQ5Lmluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pXG4gICAgICAgIHsgdGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24odGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcblxuICAvLyBDb25zdW1lIGEgc2VtaWNvbG9uLCBvciwgZmFpbGluZyB0aGF0LCBzZWUgaWYgd2UgYXJlIGFsbG93ZWQgdG9cbiAgLy8gcHJldGVuZCB0aGF0IHRoZXJlIGlzIGEgc2VtaWNvbG9uIGF0IHRoaXMgcG9zaXRpb24uXG5cbiAgcHAkOS5zZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEuc2VtaSkgJiYgIXRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfTtcblxuICBwcCQ5LmFmdGVyVHJhaWxpbmdDb21tYSA9IGZ1bmN0aW9uKHRva1R5cGUsIG5vdE5leHQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0b2tUeXBlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSlcbiAgICAgICAgeyB0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7IH1cbiAgICAgIGlmICghbm90TmV4dClcbiAgICAgICAgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cbiAgLy8gRXhwZWN0IGEgdG9rZW4gb2YgYSBnaXZlbiB0eXBlLiBJZiBmb3VuZCwgY29uc3VtZSBpdCwgb3RoZXJ3aXNlLFxuICAvLyByYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG4gIHBwJDkuZXhwZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHRoaXMuZWF0KHR5cGUpIHx8IHRoaXMudW5leHBlY3RlZCgpO1xuICB9O1xuXG4gIC8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbiAgcHAkOS51bmV4cGVjdGVkID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgdGhpcy5yYWlzZShwb3MgIT0gbnVsbCA/IHBvcyA6IHRoaXMuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgfTtcblxuICB2YXIgRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZ1bmN0aW9uIERlc3RydWN0dXJpbmdFcnJvcnMoKSB7XG4gICAgdGhpcy5zaG9ydGhhbmRBc3NpZ24gPVxuICAgIHRoaXMudHJhaWxpbmdDb21tYSA9XG4gICAgdGhpcy5wYXJlbnRoZXNpemVkQXNzaWduID1cbiAgICB0aGlzLnBhcmVudGhlc2l6ZWRCaW5kID1cbiAgICB0aGlzLmRvdWJsZVByb3RvID1cbiAgICAgIC0xO1xuICB9O1xuXG4gIHBwJDkuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgaXNBc3NpZ24pIHtcbiAgICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIH1cbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID4gLTEpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgdmFyIHBhcmVucyA9IGlzQXNzaWduID8gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDogcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZDtcbiAgICBpZiAocGFyZW5zID4gLTEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBhcmVucywgaXNBc3NpZ24gPyBcIkFzc2lnbmluZyB0byBydmFsdWVcIiA6IFwiUGFyZW50aGVzaXplZCBwYXR0ZXJuXCIpOyB9XG4gIH07XG5cbiAgcHAkOS5jaGVja0V4cHJlc3Npb25FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhbmRUaHJvdykge1xuICAgIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBzaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgICB2YXIgZG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICAgIGlmICghYW5kVGhyb3cpIHsgcmV0dXJuIHNob3J0aGFuZEFzc2lnbiA+PSAwIHx8IGRvdWJsZVByb3RvID49IDAgfVxuICAgIGlmIChzaG9ydGhhbmRBc3NpZ24gPj0gMClcbiAgICAgIHsgdGhpcy5yYWlzZShzaG9ydGhhbmRBc3NpZ24sIFwiU2hvcnRoYW5kIHByb3BlcnR5IGFzc2lnbm1lbnRzIGFyZSB2YWxpZCBvbmx5IGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnNcIik7IH1cbiAgICBpZiAoZG91YmxlUHJvdG8gPj0gMClcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGRvdWJsZVByb3RvLCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbiAgfTtcblxuICBwcCQ5LmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnlpZWxkUG9zICYmICghdGhpcy5hd2FpdFBvcyB8fCB0aGlzLnlpZWxkUG9zIDwgdGhpcy5hd2FpdFBvcykpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy55aWVsZFBvcywgXCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICBpZiAodGhpcy5hd2FpdFBvcylcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0UG9zLCBcIkF3YWl0IGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICB9O1xuXG4gIHBwJDkuaXNTaW1wbGVBc3NpZ25UYXJnZXQgPSBmdW5jdGlvbihleHByKSB7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgICAgeyByZXR1cm4gdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByLmV4cHJlc3Npb24pIH1cbiAgICByZXR1cm4gZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fCBleHByLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiXG4gIH07XG5cbiAgdmFyIHBwJDggPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIC8vICMjIyBTdGF0ZW1lbnQgcGFyc2luZ1xuXG4gIC8vIFBhcnNlIGEgcHJvZ3JhbS4gSW5pdGlhbGl6ZXMgdGhlIHBhcnNlciwgcmVhZHMgYW55IG51bWJlciBvZlxuICAvLyBzdGF0ZW1lbnRzLCBhbmQgd3JhcHMgdGhlbSBpbiBhIFByb2dyYW0gbm9kZS4gIE9wdGlvbmFsbHkgdGFrZXMgYVxuICAvLyBgcHJvZ3JhbWAgYXJndW1lbnQuICBJZiBwcmVzZW50LCB0aGUgc3RhdGVtZW50cyB3aWxsIGJlIGFwcGVuZGVkXG4gIC8vIHRvIGl0cyBib2R5IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgbm9kZS5cblxuICBwcCQ4LnBhcnNlVG9wTGV2ZWwgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmICghbm9kZS5ib2R5KSB7IG5vZGUuYm9keSA9IFtdOyB9XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5lb2YpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsLCB0cnVlLCBleHBvcnRzKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbk1vZHVsZSlcbiAgICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh0aGlzLnVuZGVmaW5lZEV4cG9ydHMpOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuYW1lID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV0uc3RhcnQsIChcIkV4cG9ydCAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgICAgfSB9XG4gICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keSk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5zb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb2dyYW1cIilcbiAgfTtcblxuICB2YXIgbG9vcExhYmVsID0ge2tpbmQ6IFwibG9vcFwifSwgc3dpdGNoTGFiZWwgPSB7a2luZDogXCJzd2l0Y2hcIn07XG5cbiAgcHAkOC5pc0xldCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gICAgLy8gRm9yIGFtYmlndW91cyBjYXNlcywgZGV0ZXJtaW5lIGlmIGEgTGV4aWNhbERlY2xhcmF0aW9uIChvciBvbmx5IGFcbiAgICAvLyBTdGF0ZW1lbnQpIGlzIGFsbG93ZWQgaGVyZS4gSWYgY29udGV4dCBpcyBub3QgZW1wdHkgdGhlbiBvbmx5IGEgU3RhdGVtZW50XG4gICAgLy8gaXMgYWxsb3dlZC4gSG93ZXZlciwgYGxldCBbYCBpcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSBsb29rYWhlYWQgZm9yXG4gICAgLy8gRXhwcmVzc2lvblN0YXRlbWVudCwgc28gc3BlY2lhbC1jYXNlIGl0IGZpcnN0LlxuICAgIGlmIChuZXh0Q2ggPT09IDkxIHx8IG5leHRDaCA9PT0gOTIpIHsgcmV0dXJuIHRydWUgfSAvLyAnWycsICdcXCdcbiAgICBpZiAoY29udGV4dCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKG5leHRDaCA9PT0gMTIzIHx8IG5leHRDaCA+IDB4ZDdmZiAmJiBuZXh0Q2ggPCAweGRjMDApIHsgcmV0dXJuIHRydWUgfSAvLyAneycsIGFzdHJhbFxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgICB2YXIgcG9zID0gbmV4dCArIDE7XG4gICAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcihuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICAgIGlmIChuZXh0Q2ggPT09IDkyIHx8IG5leHRDaCA+IDB4ZDdmZiAmJiBuZXh0Q2ggPCAweGRjMDApIHsgcmV0dXJuIHRydWUgfVxuICAgICAgdmFyIGlkZW50ID0gdGhpcy5pbnB1dC5zbGljZShuZXh0LCBwb3MpO1xuICAgICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gY2hlY2sgJ2FzeW5jIFtubyBMaW5lVGVybWluYXRvciBoZXJlXSBmdW5jdGlvbidcbiAgLy8gLSAnYXN5bmMgLypmb28qLyBmdW5jdGlvbicgaXMgT0suXG4gIC8vIC0gJ2FzeW5jIC8qXFxuKi8gZnVuY3Rpb24nIGlzIGludmFsaWQuXG4gIHBwJDguaXNBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwiYXN5bmNcIikpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBhZnRlcjtcbiAgICByZXR1cm4gIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIG5leHQpKSAmJlxuICAgICAgdGhpcy5pbnB1dC5zbGljZShuZXh0LCBuZXh0ICsgOCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fFxuICAgICAgICEoaXNJZGVudGlmaWVyQ2hhcihhZnRlciA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0ICsgOCkpIHx8IGFmdGVyID4gMHhkN2ZmICYmIGFmdGVyIDwgMHhkYzAwKSlcbiAgfTtcblxuICBwcCQ4LmlzVXNpbmdLZXl3b3JkID0gZnVuY3Rpb24oaXNBd2FpdFVzaW5nLCBpc0Zvcikge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxNyB8fCAhdGhpcy5pc0NvbnRleHR1YWwoaXNBd2FpdFVzaW5nID8gXCJhd2FpdFwiIDogXCJ1c2luZ1wiKSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGg7XG5cbiAgICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgbmV4dCkpKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZiAoaXNBd2FpdFVzaW5nKSB7XG4gICAgICB2YXIgYXdhaXRFbmRQb3MgPSBuZXh0ICsgNSAvKiBhd2FpdCAqLywgYWZ0ZXI7XG4gICAgICBpZiAodGhpcy5pbnB1dC5zbGljZShuZXh0LCBhd2FpdEVuZFBvcykgIT09IFwidXNpbmdcIiB8fFxuICAgICAgICBhd2FpdEVuZFBvcyA9PT0gdGhpcy5pbnB1dC5sZW5ndGggfHxcbiAgICAgICAgaXNJZGVudGlmaWVyQ2hhcihhZnRlciA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChhd2FpdEVuZFBvcykpIHx8XG4gICAgICAgIChhZnRlciA+IDB4ZDdmZiAmJiBhZnRlciA8IDB4ZGMwMClcbiAgICAgICkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBhd2FpdEVuZFBvcztcbiAgICAgIHZhciBza2lwQWZ0ZXJVc2luZyA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICBpZiAoc2tpcEFmdGVyVXNpbmcgJiYgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZShhd2FpdEVuZFBvcywgYXdhaXRFbmRQb3MgKyBza2lwQWZ0ZXJVc2luZ1swXS5sZW5ndGgpKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cblxuICAgIGlmIChpc0Zvcikge1xuICAgICAgdmFyIG9mRW5kUG9zID0gbmV4dCArIDIgLyogb2YgKi8sIGFmdGVyJDE7XG4gICAgICBpZiAodGhpcy5pbnB1dC5zbGljZShuZXh0LCBvZkVuZFBvcykgPT09IFwib2ZcIikge1xuICAgICAgICBpZiAob2ZFbmRQb3MgPT09IHRoaXMuaW5wdXQubGVuZ3RoIHx8XG4gICAgICAgICAgKCFpc0lkZW50aWZpZXJDaGFyKGFmdGVyJDEgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQob2ZFbmRQb3MpKSAmJiAhKGFmdGVyJDEgPiAweGQ3ZmYgJiYgYWZ0ZXIkMSA8IDB4ZGMwMCkpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJTdGFydChjaCwgdHJ1ZSkgfHwgY2ggPT09IDkyIC8vICdcXCdcbiAgfTtcblxuICBwcCQ4LmlzQXdhaXRVc2luZyA9IGZ1bmN0aW9uKGlzRm9yKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNVc2luZ0tleXdvcmQodHJ1ZSwgaXNGb3IpXG4gIH07XG5cbiAgcHAkOC5pc1VzaW5nID0gZnVuY3Rpb24oaXNGb3IpIHtcbiAgICByZXR1cm4gdGhpcy5pc1VzaW5nS2V5d29yZChmYWxzZSwgaXNGb3IpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuICAvL1xuICAvLyBJZiBleHBlY3RpbmcgYSBzdGF0ZW1lbnQgYW5kIGZpbmRpbmcgYSBzbGFzaCBvcGVyYXRvciwgcGFyc2UgYVxuICAvLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuICAvLyBgaWYgKGZvbykgL2JsYWgvLmV4ZWMoZm9vKWAsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4gIC8vIGRvZXMgbm90IGhlbHAuXG5cbiAgcHAkOC5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGNvbnRleHQsIHRvcExldmVsLCBleHBvcnRzKSB7XG4gICAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgICAgc3RhcnR0eXBlID0gdHlwZXMkMS5fdmFyO1xuICAgICAga2luZCA9IFwibGV0XCI7XG4gICAgfVxuXG4gICAgLy8gTW9zdCB0eXBlcyBvZiBzdGF0ZW1lbnRzIGFyZSByZWNvZ25pemVkIGJ5IHRoZSBrZXl3b3JkIHRoZXlcbiAgICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgICAvLyBjb21wbGV4aXR5LlxuXG4gICAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICBjYXNlIHR5cGVzJDEuX2JyZWFrOiBjYXNlIHR5cGVzJDEuX2NvbnRpbnVlOiByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpXG4gICAgY2FzZSB0eXBlcyQxLl9kZWJ1Z2dlcjogcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX2ZvcjogcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX2Z1bmN0aW9uOlxuICAgICAgLy8gRnVuY3Rpb24gYXMgc29sZSBib2R5IG9mIGVpdGhlciBhbiBpZiBzdGF0ZW1lbnQgb3IgYSBsYWJlbGVkIHN0YXRlbWVudFxuICAgICAgLy8gd29ya3MsIGJ1dCBub3Qgd2hlbiBpdCBpcyBwYXJ0IG9mIGEgbGFiZWxlZCBzdGF0ZW1lbnQgdGhhdCBpcyB0aGUgc29sZVxuICAgICAgLy8gYm9keSBvZiBhbiBpZiBzdGF0ZW1lbnQuXG4gICAgICBpZiAoKGNvbnRleHQgJiYgKHRoaXMuc3RyaWN0IHx8IGNvbnRleHQgIT09IFwiaWZcIiAmJiBjb250ZXh0ICE9PSBcImxhYmVsXCIpKSAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gICAgY2FzZSB0eXBlcyQxLl9jbGFzczpcbiAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gICAgY2FzZSB0eXBlcyQxLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fcmV0dXJuOiByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX3RyeTogcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX2NvbnN0OiBjYXNlIHR5cGVzJDEuX3ZhcjpcbiAgICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgICBpZiAoY29udGV4dCAmJiBraW5kICE9PSBcInZhclwiKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICAgIGNhc2UgdHlwZXMkMS5fd2hpbGU6IHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX3dpdGg6IHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgbm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuc2VtaTogcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fZXhwb3J0OlxuICAgIGNhc2UgdHlwZXMkMS5faW1wb3J0OlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5faW1wb3J0KSB7XG4gICAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgICAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICBpZiAobmV4dENoID09PSA0MCB8fCBuZXh0Q2ggPT09IDQ2KSAvLyAnKCcgb3IgJy4nXG4gICAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpIHtcbiAgICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZXhwb3J0cylcblxuICAgICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgICAgLy8gYnJhY2UsIGl0J3MgYW4gRXhwcmVzc2lvblN0YXRlbWVudCBvciBMYWJlbGVkU3RhdGVtZW50LiBXZVxuICAgICAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAgICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAgIC8vIElkZW50aWZpZXIgbm9kZSwgd2Ugc3dpdGNoIHRvIGludGVycHJldGluZyBpdCBhcyBhIGxhYmVsLlxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICAgIH1cblxuICAgICAgdmFyIHVzaW5nS2luZCA9IHRoaXMuaXNBd2FpdFVzaW5nKGZhbHNlKSA/IFwiYXdhaXQgdXNpbmdcIiA6IHRoaXMuaXNVc2luZyhmYWxzZSkgPyBcInVzaW5nXCIgOiBudWxsO1xuICAgICAgaWYgKHVzaW5nS2luZCkge1xuICAgICAgICBpZiAodG9wTGV2ZWwgJiYgdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVXNpbmcgZGVjbGFyYXRpb24gY2Fubm90IGFwcGVhciBpbiB0aGUgdG9wIGxldmVsIHdoZW4gc291cmNlIHR5cGUgaXMgYHNjcmlwdGBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzaW5nS2luZCA9PT0gXCJhd2FpdCB1c2luZ1wiKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmNhbkF3YWl0KSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQXdhaXQgdXNpbmcgY2Fubm90IGFwcGVhciBvdXRzaWRlIG9mIGFzeW5jIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwgdXNpbmdLaW5kKTtcbiAgICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgIH1cblxuICAgICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMkMS5jb2xvbikpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkgfVxuICAgICAgZWxzZSB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2V5d29yZCkge1xuICAgIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIGVsc2Uge1xuICAgICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgICAvLyBjb250aW51ZSB0by5cbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxhYiA9IHRoaXMubGFiZWxzW2ldO1xuICAgICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIHsgYnJlYWsgfVxuICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRG9TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJkb1wiKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLl93aGlsZSk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgdGhpcy5lYXQodHlwZXMkMS5zZW1pKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuICAvLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbiAgLy8gc3RhdGVtZW50IG9yIGV4cHJlc3Npb24sIGRpc2FsbG93aW5nIHRoZSBgaW5gIG9wZXJhdG9yIChzZWVcbiAgLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuICAvLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4gIC8vIHBhcnQgKHNlbWljb2xvbiBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyksIGl0XG4gIC8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG4gIHBwJDgucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5jYW5Bd2FpdCAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkgPyB0aGlzLmxhc3RUb2tTdGFydCA6IC0xO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc2VtaSkge1xuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gICAgfVxuICAgIHZhciBpc0xldCA9IHRoaXMuaXNMZXQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl92YXIgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLl9jb25zdCB8fCBpc0xldCkge1xuICAgICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckFmdGVySW5pdChub2RlLCBpbml0JDEsIGF3YWl0QXQpXG4gICAgfVxuICAgIHZhciBzdGFydHNXaXRoTGV0ID0gdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIiksIGlzRm9yT2YgPSBmYWxzZTtcblxuICAgIHZhciB1c2luZ0tpbmQgPSB0aGlzLmlzVXNpbmcodHJ1ZSkgPyBcInVzaW5nXCIgOiB0aGlzLmlzQXdhaXRVc2luZyh0cnVlKSA/IFwiYXdhaXQgdXNpbmdcIiA6IG51bGw7XG4gICAgaWYgKHVzaW5nS2luZCkge1xuICAgICAgdmFyIGluaXQkMiA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh1c2luZ0tpbmQgPT09IFwiYXdhaXQgdXNpbmdcIikgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgdGhpcy5wYXJzZVZhcihpbml0JDIsIHRydWUsIHVzaW5nS2luZCk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQyLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckFmdGVySW5pdChub2RlLCBpbml0JDIsIGF3YWl0QXQpXG4gICAgfVxuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICB2YXIgaW5pdFBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgdmFyIGluaXQgPSBhd2FpdEF0ID4gLTFcbiAgICAgID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIFwiYXdhaXRcIilcbiAgICAgIDogdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4gfHwgKGlzRm9yT2YgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkge1xuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyAvLyBpbXBsaWVzIGBlY21hVmVyc2lvbiA+PSA5YCAoc2VlIGRlY2xhcmF0aW9uIG9mIGF3YWl0QXQpXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICBub2RlLmF3YWl0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGb3JPZiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkge1xuICAgICAgICBpZiAoaW5pdC5zdGFydCA9PT0gaW5pdFBvcyAmJiAhY29udGFpbnNFc2MgJiYgaW5pdC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBpbml0Lm5hbWUgPT09IFwiYXN5bmNcIikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkgeyBub2RlLmF3YWl0ID0gZmFsc2U7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydHNXaXRoTGV0ICYmIGlzRm9yT2YpIHsgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBcIlRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhIGZvci1vZiBsb29wIG1heSBub3Qgc3RhcnQgd2l0aCAnbGV0Jy5cIik7IH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihpbml0KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbiAgfTtcblxuICAvLyBIZWxwZXIgbWV0aG9kIHRvIHBhcnNlIGZvciBsb29wIGFmdGVyIHZhcmlhYmxlIGluaXRpYWxpemF0aW9uXG4gIHBwJDgucGFyc2VGb3JBZnRlckluaXQgPSBmdW5jdGlvbihub2RlLCBpbml0LCBhd2FpdEF0KSB7XG4gICAgaWYgKCh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkgJiYgaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4pIHtcbiAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQpXG4gICAgfVxuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbiAgfTtcblxuICBwcCQ4LnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBpc0FzeW5jLCBkZWNsYXJhdGlvblBvc2l0aW9uKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBGVU5DX1NUQVRFTUVOVCB8IChkZWNsYXJhdGlvblBvc2l0aW9uID8gMCA6IEZVTkNfSEFOR0lOR19TVEFURU1FTlQpLCBmYWxzZSwgaXNBc3luYylcbiAgfTtcblxuICBwcCQ4LnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIC8vIGFsbG93IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBpbiBicmFuY2hlcywgYnV0IG9ubHkgaW4gbm9uLXN0cmljdCBtb2RlXG4gICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQodHlwZXMkMS5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIikgOiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCF0aGlzLmluRnVuY3Rpb24gJiYgIXRoaXMub3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7IH1cbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIEluIGByZXR1cm5gIChhbmQgYGJyZWFrYC9gY29udGludWVgKSwgdGhlIGtleXdvcmRzIHdpdGhcbiAgICAvLyBvcHRpb25hbCBhcmd1bWVudHMsIHdlIGVhZ2VybHkgbG9vayBmb3IgYSBzZW1pY29sb24gb3IgdGhlXG4gICAgLy8gcG9zc2liaWxpdHkgdG8gaW5zZXJ0IG9uZS5cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmNhc2VzID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICAgIHRoaXMubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcblxuICAgIC8vIFN0YXRlbWVudHMgdW5kZXIgbXVzdCBiZSBncm91cGVkIChieSBsYWJlbCkgaW4gU3dpdGNoQ2FzZVxuICAgIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gICAgLy8gYWRkaW5nIHN0YXRlbWVudHMgdG8uXG5cbiAgICB2YXIgY3VyO1xuICAgIGZvciAodmFyIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlUjspIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2Nhc2UgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLl9kZWZhdWx0KSB7XG4gICAgICAgIHZhciBpc0Nhc2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2Nhc2U7XG4gICAgICAgIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gICAgICAgIG5vZGUuY2FzZXMucHVzaChjdXIgPSB0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChpc0Nhc2UpIHtcbiAgICAgICAgICBjdXIudGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNhd0RlZmF1bHQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgfVxuICAgICAgICAgIHNhd0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbG9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VyKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICB0aGlzLm5leHQoKTsgLy8gQ2xvc2luZyBicmFjZVxuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTsgfVxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbiAgdmFyIGVtcHR5JDEgPSBbXTtcblxuICBwcCQ4LnBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHZhciBzaW1wbGUgPSBwYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIjtcbiAgICB0aGlzLmVudGVyU2NvcGUoc2ltcGxlID8gU0NPUEVfU0lNUExFX0NBVENIIDogMCk7XG4gICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKHBhcmFtLCBzaW1wbGUgPyBCSU5EX1NJTVBMRV9DQVRDSCA6IEJJTkRfTEVYSUNBTCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuXG4gICAgcmV0dXJuIHBhcmFtXG4gIH07XG5cbiAgcHAkOC5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9jYXRjaCkge1xuICAgICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnBhcmVuTCkpIHtcbiAgICAgICAgY2xhdXNlLnBhcmFtID0gdGhpcy5wYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgICB9XG4gICAgICBjbGF1c2UuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgICB9XG4gICAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCh0eXBlcyQxLl9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplcikge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndoaWxlXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndpdGhcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gdGhpcy5sYWJlbHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBsYWJlbCA9IGxpc3RbaSQxXTtcblxuICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gICAgfSB9XG4gICAgdmFyIGtpbmQgPSB0aGlzLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGxhYmVsJDEgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgIC8vIFVwZGF0ZSBpbmZvcm1hdGlvbiBhYm91dCBwcmV2aW91cyBsYWJlbHMgb24gdGhpcyBub2RlXG4gICAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgICAgfSBlbHNlIHsgYnJlYWsgfVxuICAgIH1cbiAgICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChjb250ZXh0ID8gY29udGV4dC5pbmRleE9mKFwibGFiZWxcIikgPT09IC0xID8gY29udGV4dCArIFwibGFiZWxcIiA6IGNvbnRleHQgOiBcImxhYmVsXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBzZW1pY29sb24tZW5jbG9zZWQgYmxvY2sgb2Ygc3RhdGVtZW50cywgaGFuZGxpbmcgYFwidXNlXG4gIC8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4gIC8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbiAgcHAkOC5wYXJzZUJsb2NrID0gZnVuY3Rpb24oY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBub2RlLCBleGl0U3RyaWN0KSB7XG4gICAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG4gICAgaWYgKCBub2RlID09PSB2b2lkIDAgKSBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIG5vZGUuYm9keSA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZW50ZXJTY29wZSgwKTsgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSKSB7XG4gICAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICB9XG4gICAgaWYgKGV4aXRTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSBmYWxzZTsgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHsgdGhpcy5leGl0U2NvcGUoKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGEgcmVndWxhciBgZm9yYCBsb29wLiBUaGUgZGlzYW1iaWd1YXRpb24gY29kZSBpblxuICAvLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3JcbiAgLy8gZXhwcmVzc2lvbi5cblxuICBwcCQ4LnBhcnNlRm9yID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICAgIG5vZGUuaW5pdCA9IGluaXQ7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5zZW1pKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc2VtaSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuc2VtaSk7XG4gICAgbm9kZS51cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5SID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3RcbiAgLy8gc2FtZSBmcm9tIHBhcnNlcidzIHBlcnNwZWN0aXZlLlxuXG4gIHBwJDgucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICB2YXIgaXNGb3JJbiA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW47XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAoXG4gICAgICBpbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmXG4gICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0ICE9IG51bGwgJiZcbiAgICAgIChcbiAgICAgICAgIWlzRm9ySW4gfHxcbiAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fFxuICAgICAgICB0aGlzLnN0cmljdCB8fFxuICAgICAgICBpbml0LmtpbmQgIT09IFwidmFyXCIgfHxcbiAgICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCJcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRoaXMucmFpc2UoXG4gICAgICAgIGluaXQuc3RhcnQsXG4gICAgICAgICgoaXNGb3JJbiA/IFwiZm9yLWluXCIgOiBcImZvci1vZlwiKSArIFwiIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyXCIpXG4gICAgICApO1xuICAgIH1cbiAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbiAgcHAkOC5wYXJzZVZhciA9IGZ1bmN0aW9uKG5vZGUsIGlzRm9yLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplcikge1xuICAgIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgbm9kZS5raW5kID0ga2luZDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZGVjbCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMkMS5lcSkpIHtcbiAgICAgICAgZGVjbC5pbml0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoIWFsbG93TWlzc2luZ0luaXRpYWxpemVyICYmIGtpbmQgPT09IFwiY29uc3RcIiAmJiAhKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWFsbG93TWlzc2luZ0luaXRpYWxpemVyICYmIChraW5kID09PSBcInVzaW5nXCIgfHwga2luZCA9PT0gXCJhd2FpdCB1c2luZ1wiKSAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTcgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLl9pbiAmJiAhdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgKFwiTWlzc2luZyBpbml0aWFsaXplciBpbiBcIiArIGtpbmQgKyBcIiBkZWNsYXJhdGlvblwiKSk7XG4gICAgICB9IGVsc2UgaWYgKCFhbGxvd01pc3NpbmdJbml0aWFsaXplciAmJiBkZWNsLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4gfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIkNvbXBsZXggYmluZGluZyBwYXR0ZXJucyByZXF1aXJlIGFuIGluaXRpYWxpemF0aW9uIHZhbHVlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjbC5pbml0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5jb21tYSkpIHsgYnJlYWsgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIHBwJDgucGFyc2VWYXJJZCA9IGZ1bmN0aW9uKGRlY2wsIGtpbmQpIHtcbiAgICBkZWNsLmlkID0ga2luZCA9PT0gXCJ1c2luZ1wiIHx8IGtpbmQgPT09IFwiYXdhaXQgdXNpbmdcIlxuICAgICAgPyB0aGlzLnBhcnNlSWRlbnQoKVxuICAgICAgOiB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cbiAgLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4gIC8vIGBzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVGApLlxuXG4gIC8vIFJlbW92ZSBgYWxsb3dFeHByZXNzaW9uQm9keWAgZm9yIDcuMC4wLCBhcyBpdCBpcyBvbmx5IGNhbGxlZCB3aXRoIGZhbHNlXG4gIHBwJDgucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYywgZm9ySW5pdCkge1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyICYmIChzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIGlmIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkge1xuICAgICAgbm9kZS5pZCA9IChzdGF0ZW1lbnQgJiBGVU5DX05VTExBQkxFX0lEKSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcmVndWxhciBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpbiBzbG9wcHkgbW9kZSwgdGhlbiBpdCBpc1xuICAgICAgICAvLyBzdWJqZWN0IHRvIEFubmV4IEIgc2VtYW50aWNzIChCSU5EX0ZVTkNUSU9OKS4gT3RoZXJ3aXNlLCB0aGUgYmluZGluZ1xuICAgICAgICAvLyBtb2RlIGRlcGVuZHMgb24gcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBzY29wZSAoc2VlXG4gICAgICAgIC8vIHRyZWF0RnVuY3Rpb25zQXNWYXIpLlxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuaWQsICh0aGlzLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jKSA/IHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhciA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMIDogQklORF9GVU5DVElPTik7IH1cbiAgICB9XG5cbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhub2RlLmFzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuXG4gICAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7IH1cblxuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGZhbHNlLCBmb3JJbml0KTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcyQxLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB9O1xuXG4gIC8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAvLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbiAgcHAkOC5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIGVjbWEtMjYyIDE0LjYgQ2xhc3MgRGVmaW5pdGlvbnNcbiAgICAvLyBBIGNsYXNzIGRlZmluaXRpb24gaXMgYWx3YXlzIHN0cmljdCBtb2RlIGNvZGUuXG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0O1xuICAgIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICB2YXIgcHJpdmF0ZU5hbWVNYXAgPSB0aGlzLmVudGVyQ2xhc3NCb2R5KCk7XG4gICAgdmFyIGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudChub2RlLnN1cGVyQ2xhc3MgIT09IG51bGwpO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY2xhc3NCb2R5LmJvZHkucHVzaChlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgZWxlbWVudC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVsZW1lbnQuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpOyB9XG4gICAgICAgICAgaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ICYmIGVsZW1lbnQua2V5LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIiAmJiBpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZChwcml2YXRlTmFtZU1hcCwgZWxlbWVudCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZWxlbWVudC5rZXkuc3RhcnQsIChcIklkZW50aWZpZXIgJyNcIiArIChlbGVtZW50LmtleS5uYW1lKSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoY2xhc3NCb2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgICB0aGlzLmV4aXRDbGFzc0JvZHkoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VDbGFzc0VsZW1lbnQgPSBmdW5jdGlvbihjb25zdHJ1Y3RvckFsbG93c1N1cGVyKSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgdmFyIGVjbWFWZXJzaW9uID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uO1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIga2V5TmFtZSA9IFwiXCI7XG4gICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XG4gICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcbiAgICB2YXIga2luZCA9IFwibWV0aG9kXCI7XG4gICAgdmFyIGlzU3RhdGljID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwic3RhdGljXCIpKSB7XG4gICAgICAvLyBQYXJzZSBzdGF0aWMgaW5pdCBibG9ja1xuICAgICAgaWYgKGVjbWFWZXJzaW9uID49IDEzICYmIHRoaXMuZWF0KHR5cGVzJDEuYnJhY2VMKSkge1xuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NTdGF0aWNCbG9jayhub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0KCkgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0YXIpIHtcbiAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5TmFtZSA9IFwic3RhdGljXCI7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgaWYgKCFrZXlOYW1lICYmIGVjbWFWZXJzaW9uID49IDggJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXN5bmNcIikpIHtcbiAgICAgIGlmICgodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleU5hbWUgPSBcImFzeW5jXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgha2V5TmFtZSAmJiAoZWNtYVZlcnNpb24gPj0gOSB8fCAhaXNBc3luYykgJiYgdGhpcy5lYXQodHlwZXMkMS5zdGFyKSkge1xuICAgICAgaXNHZW5lcmF0b3IgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWtleU5hbWUgJiYgIWlzQXN5bmMgJiYgIWlzR2VuZXJhdG9yKSB7XG4gICAgICB2YXIgbGFzdFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJnZXRcIikgfHwgdGhpcy5lYXRDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0KCkpIHtcbiAgICAgICAgICBraW5kID0gbGFzdFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleU5hbWUgPSBsYXN0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXJzZSBlbGVtZW50IG5hbWVcbiAgICBpZiAoa2V5TmFtZSkge1xuICAgICAgLy8gJ2FzeW5jJywgJ2dldCcsICdzZXQnLCBvciAnc3RhdGljJyB3ZXJlIG5vdCBhIGtleXdvcmQgY29udGV4dHVhbGx5LlxuICAgICAgLy8gVGhlIGxhc3QgdG9rZW4gaXMgYW55IG9mIHRob3NlLiBNYWtlIGl0IHRoZSBlbGVtZW50IG5hbWUuXG4gICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBub2RlLmtleSA9IHRoaXMuc3RhcnROb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgIG5vZGUua2V5Lm5hbWUgPSBrZXlOYW1lO1xuICAgICAgdGhpcy5maW5pc2hOb2RlKG5vZGUua2V5LCBcIklkZW50aWZpZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGVsZW1lbnQgdmFsdWVcbiAgICBpZiAoZWNtYVZlcnNpb24gPCAxMyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MIHx8IGtpbmQgIT09IFwibWV0aG9kXCIgfHwgaXNHZW5lcmF0b3IgfHwgaXNBc3luYykge1xuICAgICAgdmFyIGlzQ29uc3RydWN0b3IgPSAhbm9kZS5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKG5vZGUsIFwiY29uc3RydWN0b3JcIik7XG4gICAgICB2YXIgYWxsb3dzRGlyZWN0U3VwZXIgPSBpc0NvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yQWxsb3dzU3VwZXI7XG4gICAgICAvLyBDb3VsZG4ndCBtb3ZlIHRoaXMgY2hlY2sgaW50byB0aGUgJ3BhcnNlQ2xhc3NNZXRob2QnIG1ldGhvZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgIGlmIChpc0NvbnN0cnVjdG9yICYmIGtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICAgIG5vZGUua2luZCA9IGlzQ29uc3RydWN0b3IgPyBcImNvbnN0cnVjdG9yXCIgOiBraW5kO1xuICAgICAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKG5vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0ZpZWxkKG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkOC5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLmJyYWNrZXRMIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZFxuICAgIClcbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NFbGVtZW50TmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGFuIGVsZW1lbnQgbmFtZWQgJyNjb25zdHJ1Y3RvcidcIik7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50LmtleSA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShlbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOC5wYXJzZUNsYXNzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgICAvLyBDaGVjayBrZXkgYW5kIGZsYWdzXG4gICAgdmFyIGtleSA9IG1ldGhvZC5rZXk7XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgfSBlbHNlIGlmIChtZXRob2Quc3RhdGljICYmIGNoZWNrS2V5TmFtZShtZXRob2QsIFwicHJvdG90eXBlXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdmFsdWVcbiAgICB2YXIgdmFsdWUgPSBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG5cbiAgICAvLyBDaGVjayB2YWx1ZVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIiAmJiB2YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUuc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiB2YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUuc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIHZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh2YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NGaWVsZCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgaWYgKGNoZWNrS2V5TmFtZShmaWVsZCwgXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgdGhpcy5yYWlzZShmaWVsZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJ1wiKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkLnN0YXRpYyAmJiBjaGVja0tleU5hbWUoZmllbGQsIFwicHJvdG90eXBlXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKGZpZWxkLmtleS5zdGFydCwgXCJDbGFzc2VzIGNhbid0IGhhdmUgYSBzdGF0aWMgZmllbGQgbmFtZWQgJ3Byb3RvdHlwZSdcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuZXEpKSB7XG4gICAgICAvLyBUbyByYWlzZSBTeW50YXhFcnJvciBpZiAnYXJndW1lbnRzJyBleGlzdHMgaW4gdGhlIGluaXRpYWxpemVyLlxuICAgICAgdGhpcy5lbnRlclNjb3BlKFNDT1BFX0NMQVNTX0ZJRUxEX0lOSVQgfCBTQ09QRV9TVVBFUik7XG4gICAgICBmaWVsZC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGQudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShmaWVsZCwgXCJQcm9wZXJ0eURlZmluaXRpb25cIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NTdGF0aWNCbG9jayA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmJvZHkgPSBbXTtcblxuICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMuZW50ZXJTY29wZShTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgfCBTQ09QRV9TVVBFUik7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIHRoaXMubGFiZWxzID0gb2xkTGFiZWxzO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN0YXRpY0Jsb2NrXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUNsYXNzSWQgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgaWYgKGlzU3RhdGVtZW50KVxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuaWQsIEJJTkRfTEVYSUNBTCwgZmFsc2UpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1N0YXRlbWVudCA9PT0gdHJ1ZSlcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHR5cGVzJDEuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKG51bGwsIGZhbHNlKSA6IG51bGw7XG4gIH07XG5cbiAgcHAkOC5lbnRlckNsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbGVtZW50ID0ge2RlY2xhcmVkOiBPYmplY3QuY3JlYXRlKG51bGwpLCB1c2VkOiBbXX07XG4gICAgdGhpcy5wcml2YXRlTmFtZVN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGVjbGFyZWRcbiAgfTtcblxuICBwcCQ4LmV4aXRDbGFzc0JvZHkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLnBvcCgpO1xuICAgIHZhciBkZWNsYXJlZCA9IHJlZi5kZWNsYXJlZDtcbiAgICB2YXIgdXNlZCA9IHJlZi51c2VkO1xuICAgIGlmICghdGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcykgeyByZXR1cm4gfVxuICAgIHZhciBsZW4gPSB0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoO1xuICAgIHZhciBwYXJlbnQgPSBsZW4gPT09IDAgPyBudWxsIDogdGhpcy5wcml2YXRlTmFtZVN0YWNrW2xlbiAtIDFdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGlkID0gdXNlZFtpXTtcbiAgICAgIGlmICghaGFzT3duKGRlY2xhcmVkLCBpZC5uYW1lKSkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50LnVzZWQucHVzaChpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGlkLnN0YXJ0LCAoXCJQcml2YXRlIGZpZWxkICcjXCIgKyAoaWQubmFtZSkgKyBcIicgbXVzdCBiZSBkZWNsYXJlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3NcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzUHJpdmF0ZU5hbWVDb25mbGljdGVkKHByaXZhdGVOYW1lTWFwLCBlbGVtZW50KSB7XG4gICAgdmFyIG5hbWUgPSBlbGVtZW50LmtleS5uYW1lO1xuICAgIHZhciBjdXJyID0gcHJpdmF0ZU5hbWVNYXBbbmFtZV07XG5cbiAgICB2YXIgbmV4dCA9IFwidHJ1ZVwiO1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIChlbGVtZW50LmtpbmQgPT09IFwiZ2V0XCIgfHwgZWxlbWVudC5raW5kID09PSBcInNldFwiKSkge1xuICAgICAgbmV4dCA9IChlbGVtZW50LnN0YXRpYyA/IFwic1wiIDogXCJpXCIpICsgZWxlbWVudC5raW5kO1xuICAgIH1cblxuICAgIC8vIGBjbGFzcyB7IGdldCAjYSgpe307IHN0YXRpYyBzZXQgI2EoXyl7fSB9YCBpcyBhbHNvIGNvbmZsaWN0LlxuICAgIGlmIChcbiAgICAgIGN1cnIgPT09IFwiaWdldFwiICYmIG5leHQgPT09IFwiaXNldFwiIHx8XG4gICAgICBjdXJyID09PSBcImlzZXRcIiAmJiBuZXh0ID09PSBcImlnZXRcIiB8fFxuICAgICAgY3VyciA9PT0gXCJzZ2V0XCIgJiYgbmV4dCA9PT0gXCJzc2V0XCIgfHxcbiAgICAgIGN1cnIgPT09IFwic3NldFwiICYmIG5leHQgPT09IFwic2dldFwiXG4gICAgKSB7XG4gICAgICBwcml2YXRlTmFtZU1hcFtuYW1lXSA9IFwidHJ1ZVwiO1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmICghY3Vycikge1xuICAgICAgcHJpdmF0ZU5hbWVNYXBbbmFtZV0gPSBuZXh0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXlOYW1lKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBub2RlLmNvbXB1dGVkO1xuICAgIHZhciBrZXkgPSBub2RlLmtleTtcbiAgICByZXR1cm4gIWNvbXB1dGVkICYmIChcbiAgICAgIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gbmFtZSB8fFxuICAgICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gbmFtZVxuICAgIClcbiAgfVxuXG4gIC8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG4gIHBwJDgucGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgICAgbm9kZS5leHBvcnRlZCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5leHBvcnRlZCwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5leHBvcnRlZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTYpXG4gICAgICB7IG5vZGUuYXR0cmlidXRlcyA9IHRoaXMucGFyc2VXaXRoQ2xhdXNlKCk7IH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJ1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnN0YXIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIGV4cG9ydHMpXG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLl9kZWZhdWx0KSkgeyAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gICAgfVxuICAgIC8vIGV4cG9ydCB2YXJ8Y29uc3R8bGV0fGZ1bmN0aW9ufGNsYXNzIC4uLlxuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLCBub2RlLmRlY2xhcmF0aW9uLmlkLnN0YXJ0KTsgfVxuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KVxuICAgICAgICB7IG5vZGUuYXR0cmlidXRlcyA9IFtdOyB9XG4gICAgfSBlbHNlIHsgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKGV4cG9ydHMpO1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNilcbiAgICAgICAgICB7IG5vZGUuYXR0cmlidXRlcyA9IHRoaXMucGFyc2VXaXRoQ2xhdXNlKCk7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIC8vIGNoZWNrIGZvciBrZXl3b3JkcyB1c2VkIGFzIGxvY2FsIG5hbWVzXG4gICAgICAgICAgdmFyIHNwZWMgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgZXhwb3J0IGlzIGRlZmluZWRcbiAgICAgICAgICB0aGlzLmNoZWNrTG9jYWxFeHBvcnQoc3BlYy5sb2NhbCk7XG5cbiAgICAgICAgICBpZiAoc3BlYy5sb2NhbC50eXBlID09PSBcIkxpdGVyYWxcIikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShzcGVjLmxvY2FsLnN0YXJ0LCBcIkEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gZXhwb3J0ZWQgYmluZGluZyB3aXRob3V0IGBmcm9tYC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KVxuICAgICAgICAgIHsgbm9kZS5hdHRyaWJ1dGVzID0gW107IH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUV4cG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc0FzeW5jO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2Z1bmN0aW9uIHx8IChpc0FzeW5jID0gdGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkpIHtcbiAgICAgIHZhciBmTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMubmV4dCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKGZOb2RlLCBGVU5DX1NUQVRFTUVOVCB8IEZVTkNfTlVMTEFCTEVfSUQsIGZhbHNlLCBpc0FzeW5jKVxuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9jbGFzcykge1xuICAgICAgdmFyIGNOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MoY05vZGUsIFwibnVsbGFibGVJRFwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gZGVjbGFyYXRpb25cbiAgICB9XG4gIH07XG5cbiAgcHAkOC5jaGVja0V4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIHBvcykge1xuICAgIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHsgbmFtZSA9IG5hbWUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBuYW1lLm5hbWUgOiBuYW1lLnZhbHVlOyB9XG4gICAgaWYgKGhhc093bihleHBvcnRzLCBuYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgXCJEdXBsaWNhdGUgZXhwb3J0ICdcIiArIG5hbWUgKyBcIidcIik7IH1cbiAgICBleHBvcnRzW25hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICBwcCQ4LmNoZWNrUGF0dGVybkV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIHBhdCkge1xuICAgIHZhciB0eXBlID0gcGF0LnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIHBhdCwgcGF0LnN0YXJ0KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHByb3ApO1xuICAgICAgICB9IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFycmF5UGF0dGVyblwiKVxuICAgICAgeyBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBwYXQuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICAgIGlmIChlbHQpIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZWx0KTsgfVxuICAgICAgfSB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJQcm9wZXJ0eVwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQudmFsdWUpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQubGVmdCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5hcmd1bWVudCk7IH1cbiAgfTtcblxuICBwcCQ4LmNoZWNrVmFyaWFibGVFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWNscykge1xuICAgIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZGVjbHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGRlY2wgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBkZWNsLmlkKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOC5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY29uc3RcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY2xhc3NcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgdGhpcy5pc0xldCgpIHx8XG4gICAgICB0aGlzLmlzQXN5bmNGdW5jdGlvbigpXG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGV4cG9ydHMuXG5cbiAgcHAkOC5wYXJzZUV4cG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG5cbiAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpIDogbm9kZS5sb2NhbDtcbiAgICB0aGlzLmNoZWNrRXhwb3J0KFxuICAgICAgZXhwb3J0cyxcbiAgICAgIG5vZGUuZXhwb3J0ZWQsXG4gICAgICBub2RlLmV4cG9ydGVkLnN0YXJ0XG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzJDEuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIG5vZGVzLnB1c2godGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcihleHBvcnRzKSk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1xuICB9O1xuXG4gIC8vIFBhcnNlcyBpbXBvcnQgZGVjbGFyYXRpb24uXG5cbiAgcHAkOC5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIGltcG9ydCAnLi4uJ1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eSQxO1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KVxuICAgICAgeyBub2RlLmF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlV2l0aENsYXVzZSgpOyB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgaW1wb3J0cy5cblxuICBwcCQ4LnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuXG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUuaW1wb3J0ZWQpO1xuICAgICAgbm9kZS5sb2NhbCA9IG5vZGUuaW1wb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0U3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBpbXBvcnQgZGVmYXVsdE9iaiwgeyB4LCB5IGFzIHogfSBmcm9tICcuLi4nXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllcigpKTtcbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5jb21tYSkpIHsgcmV0dXJuIG5vZGVzIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSB7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICBwcCQ4LnBhcnNlV2l0aENsYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5fd2l0aCkpIHtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gICAgdmFyIGF0dHJpYnV0ZUtleXMgPSB7fTtcbiAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIGF0dHIgPSB0aGlzLnBhcnNlSW1wb3J0QXR0cmlidXRlKCk7XG4gICAgICB2YXIga2V5TmFtZSA9IGF0dHIua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gYXR0ci5rZXkubmFtZSA6IGF0dHIua2V5LnZhbHVlO1xuICAgICAgaWYgKGhhc093bihhdHRyaWJ1dGVLZXlzLCBrZXlOYW1lKSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoYXR0ci5rZXkuc3RhcnQsIFwiRHVwbGljYXRlIGF0dHJpYnV0ZSBrZXkgJ1wiICsga2V5TmFtZSArIFwiJ1wiKTsgfVxuICAgICAgYXR0cmlidXRlS2V5c1trZXlOYW1lXSA9IHRydWU7XG4gICAgICBub2Rlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICBwcCQ4LnBhcnNlSW1wb3J0QXR0cmlidXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUua2V5ID0gdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29sb24pO1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuc3RyaW5nKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRBdHRyaWJ1dGVcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlTW9kdWxlRXhwb3J0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgICAgdmFyIHN0cmluZ0xpdGVyYWwgPSB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKTtcbiAgICAgIGlmIChsb25lU3Vycm9nYXRlLnRlc3Qoc3RyaW5nTGl0ZXJhbC52YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdHJpbmdMaXRlcmFsLnN0YXJ0LCBcIkFuIGV4cG9ydCBuYW1lIGNhbm5vdCBpbmNsdWRlIGEgbG9uZSBzdXJyb2dhdGUuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudCh0cnVlKVxuICB9O1xuXG4gIC8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxuICBwcCQ4LmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUgPSBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aCAmJiB0aGlzLmlzRGlyZWN0aXZlQ2FuZGlkYXRlKHN0YXRlbWVudHNbaV0pOyArK2kpIHtcbiAgICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gICAgfVxuICB9O1xuICBwcCQ4LmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmXG4gICAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICAgIHN0YXRlbWVudC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmXG4gICAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgIC8vIFJlamVjdCBwYXJlbnRoZXNpemVkIHN0cmluZ3MuXG4gICAgICAodGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIlxcXCJcIiB8fCB0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiJ1wiKVxuICAgIClcbiAgfTtcblxuICB2YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4gIC8vIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDcudG9Bc3NpZ25hYmxlID0gZnVuY3Rpb24obm9kZSwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAgIC8vIEVhcmx5IGVycm9yOlxuICAgICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgICAvLyAgICAgYC4uLmAgRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRbWWllbGQsIEF3YWl0XVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJlxuICAgICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShwcm9wLmFyZ3VtZW50LnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgICBpZiAobm9kZS5raW5kICE9PSBcImluaXRcIikgeyB0aGlzLnJhaXNlKG5vZGUua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTsgfVxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGlzQmluZGluZyk7XG4gICAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5hcmd1bWVudC5zdGFydCwgXCJSZXN0IGVsZW1lbnRzIGNhbm5vdCBoYXZlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7IHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTsgfVxuICAgICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmxlZnQsIGlzQmluZGluZyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZVwiKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFpc0JpbmRpbmcpIHsgYnJlYWsgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIC8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxuICBwcCQ3LnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gICAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZWx0KSB7IHRoaXMudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2VuZCAtIDFdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3RcbiAgfTtcblxuICAvLyBQYXJzZXMgc3ByZWFkIGVsZW1lbnQuXG5cbiAgcHAkNy5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQ3LnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICAvLyBSZXN0RWxlbWVudCBpbnNpZGUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpZGVudGlmaWVyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbiAgcHAkNy5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcyQxLmJyYWNrZXRMOlxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzJDEuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpXG5cbiAgICAgIGNhc2UgdHlwZXMkMS5icmFjZUw6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxuICB9O1xuXG4gIHBwJDcucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93TW9kaWZpZXJzKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpOyB9XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtKGFsbG93TW9kaWZpZXJzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkNy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbSA9IGZ1bmN0aW9uKGFsbG93TW9kaWZpZXJzKSB7XG4gICAgdmFyIGVsZW0gPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgcmV0dXJuIGVsZW1cbiAgfTtcblxuICBwcCQ3LnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW1cbiAgfTtcblxuICAvLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDcucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMkMS5lcSkpIHsgcmV0dXJuIGxlZnQgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICB9O1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgdGhyZWUgZnVuY3Rpb25zIGFsbCB2ZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbHVlIOKAlFxuICAvLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYm91bmQsIG9yIGFzc2lnbmVkIHRvLiBJbiBvcmRlciB0byBkbyBzbywgdGhleSBwZXJmb3JtXG4gIC8vIGEgdmFyaWV0eSBvZiBjaGVja3M6XG4gIC8vXG4gIC8vIC0gQ2hlY2sgdGhhdCBub25lIG9mIHRoZSBib3VuZC9hc3NpZ25lZC10byBpZGVudGlmaWVycyBhcmUgcmVzZXJ2ZWQgd29yZHMuXG4gIC8vIC0gUmVjb3JkIG5hbWUgZGVjbGFyYXRpb25zIGZvciBiaW5kaW5ncyBpbiB0aGUgYXBwcm9wcmlhdGUgc2NvcGUuXG4gIC8vIC0gQ2hlY2sgZHVwbGljYXRlIGFyZ3VtZW50IG5hbWVzLCBpZiBjaGVja0NsYXNoZXMgaXMgc2V0LlxuICAvL1xuICAvLyBJZiBhIGNvbXBsZXggYmluZGluZyBwYXR0ZXJuIGlzIGVuY291bnRlcmVkIChlLmcuLCBvYmplY3QgYW5kIGFycmF5XG4gIC8vIGRlc3RydWN0dXJpbmcpLCB0aGUgZW50aXJlIHBhdHRlcm4gaXMgcmVjdXJzaXZlbHkgY2hlY2tlZC5cbiAgLy9cbiAgLy8gVGhlcmUgYXJlIHRocmVlIHZlcnNpb25zIG9mIGNoZWNrTFZhbCooKSBhcHByb3ByaWF0ZSBmb3IgZGlmZmVyZW50XG4gIC8vIGNpcmN1bXN0YW5jZXM6XG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsU2ltcGxlKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuICAvLyAgIG5vdGhpbmcgb3RoZXIgdGhhbiBpZGVudGlmaWVycyBhbmQgbWVtYmVyIGV4cHJlc3Npb25zLiBQYXJlbnRoZXNpemVkXG4gIC8vICAgZXhwcmVzc2lvbnMgYXJlIGFsc28gY29ycmVjdGx5IGhhbmRsZWQuIFRoaXMgaXMgZ2VuZXJhbGx5IGFwcHJvcHJpYXRlIGZvclxuICAvLyAgIGNvbnN0cnVjdHMgZm9yIHdoaWNoIHRoZSBzcGVjIHNheXNcbiAgLy9cbiAgLy8gICA+IEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4gIC8vICAgPiBzaW1wbGUuXG4gIC8vXG4gIC8vICAgSXQgaXMgYWxzbyBhcHByb3ByaWF0ZSBmb3IgY2hlY2tpbmcgaWYgYW4gaWRlbnRpZmllciBpcyB2YWxpZCBhbmQgbm90XG4gIC8vICAgZGVmaW5lZCBlbHNld2hlcmUsIGxpa2UgaW1wb3J0IGRlY2xhcmF0aW9ucyBvciBmdW5jdGlvbi9jbGFzcyBpZGVudGlmaWVycy5cbiAgLy9cbiAgLy8gICBFeGFtcGxlcyB3aGVyZSB0aGlzIGlzIHVzZWQgaW5jbHVkZTpcbiAgLy8gICAgIGEgKz0g4oCmO1xuICAvLyAgICAgaW1wb3J0IGEgZnJvbSAn4oCmJztcbiAgLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsUGF0dGVybigpIHNoYWxsIGJlIHVzZWQgaWYgdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3Qgc3VwcG9ydHNcbiAgLy8gICBhbnl0aGluZyBjaGVja0xWYWxTaW1wbGUoKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBvYmplY3QgYW5kIGFycmF5XG4gIC8vICAgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJucy4gVGhpcyBpcyBnZW5lcmFsbHkgYXBwcm9wcmlhdGUgZm9yIGNvbnN0cnVjdHMgZm9yXG4gIC8vICAgd2hpY2ggdGhlIHNwZWMgc2F5c1xuICAvL1xuICAvLyAgID4gSXQgaXMgYSBTeW50YXggRXJyb3IgaWYgW3RoZSBwcm9kdWN0aW9uXSBpcyBuZWl0aGVyIGFuIE9iamVjdExpdGVyYWwgbm9yXG4gIC8vICAgPiBhbiBBcnJheUxpdGVyYWwgYW5kIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4gIC8vICAgPiBzaW1wbGUuXG4gIC8vXG4gIC8vICAgRXhhbXBsZXMgd2hlcmUgdGhpcyBpcyB1c2VkIGluY2x1ZGU6XG4gIC8vICAgICAoYSA9IOKApik7XG4gIC8vICAgICBjb25zdCBhID0g4oCmO1xuICAvLyAgICAgdHJ5IHsg4oCmIH0gY2F0Y2ggKGEpIHsg4oCmIH1cbiAgLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuICAvLyAgIGFueXRoaW5nIGNoZWNrTFZhbFBhdHRlcm4oKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBkZWZhdWx0IGFzc2lnbm1lbnRcbiAgLy8gICBwYXR0ZXJucywgcmVzdCBlbGVtZW50cywgYW5kIG90aGVyIGNvbnN0cnVjdHMgdGhhdCBtYXkgYXBwZWFyIHdpdGhpbiBhblxuICAvLyAgIG9iamVjdCBvciBhcnJheSBkZXN0cnVjdHVyaW5nIHBhdHRlcm4uXG4gIC8vXG4gIC8vICAgQXMgYSBzcGVjaWFsIGNhc2UsIGZ1bmN0aW9uIHBhcmFtZXRlcnMgYWxzbyB1c2UgY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKCksXG4gIC8vICAgYXMgdGhleSBhbHNvIHN1cHBvcnQgZGVmYXVsdHMgYW5kIHJlc3QgY29uc3RydWN0cy5cbiAgLy9cbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRlbGliZXJhdGVseSBzdXBwb3J0IGJvdGggYXNzaWdubWVudCBhbmQgYmluZGluZyBjb25zdHJ1Y3RzLFxuICAvLyBhcyB0aGUgbG9naWMgZm9yIGJvdGggaXMgZXhjZWVkaW5nbHkgc2ltaWxhci4gSWYgdGhlIG5vZGUgaXMgdGhlIHRhcmdldCBvZlxuICAvLyBhbiBhc3NpZ25tZW50LCB0aGVuIGJpbmRpbmdUeXBlIHNob3VsZCBiZSBzZXQgdG8gQklORF9OT05FLiBPdGhlcndpc2UsIGl0XG4gIC8vIHNob3VsZCBiZSBzZXQgdG8gdGhlIGFwcHJvcHJpYXRlIEJJTkRfKiBjb25zdGFudCwgbGlrZSBCSU5EX1ZBUiBvclxuICAvLyBCSU5EX0xFWElDQUwuXG4gIC8vXG4gIC8vIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhIG5vbi1CSU5EX05PTkUgYmluZGluZ1R5cGUsIHRoZW5cbiAgLy8gYWRkaXRpb25hbGx5IGEgY2hlY2tDbGFzaGVzIG9iamVjdCBtYXkgYmUgc3BlY2lmaWVkIHRvIGFsbG93IGNoZWNraW5nIGZvclxuICAvLyBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMuIGNoZWNrQ2xhc2hlcyBpcyBpZ25vcmVkIGlmIHRoZSBwcm92aWRlZCBjb25zdHJ1Y3RcbiAgLy8gaXMgYW4gYXNzaWdubWVudCAoaS5lLiwgYmluZGluZ1R5cGUgaXMgQklORF9OT05FKS5cblxuICBwcCQ3LmNoZWNrTFZhbFNpbXBsZSA9IGZ1bmN0aW9uKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpIHtcbiAgICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICAgIHZhciBpc0JpbmQgPSBiaW5kaW5nVHlwZSAhPT0gQklORF9OT05FO1xuXG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoaXNCaW5kID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGlmIChpc0JpbmQpIHtcbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwgJiYgZXhwci5uYW1lID09PSBcImxldFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgICAgaWYgKGhhc093bihjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpXG4gICAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX09VVFNJREUpIHsgdGhpcy5kZWNsYXJlTmFtZShleHByLm5hbWUsIGJpbmRpbmdUeXBlLCBleHByLnN0YXJ0KTsgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gbGVmdC1oYW5kIHNpZGVcIik7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChpc0JpbmQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKGlzQmluZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tMVmFsU2ltcGxlKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcylcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChpc0JpbmQgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ3LmNoZWNrTFZhbFBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHIucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBleHByLmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZWxlbSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkNy5jaGVja0xWYWxJbm5lclBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICAgIHRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuICAvLyBnaXZlbiBwb2ludCBpbiB0aGUgcHJvZ3JhbSBpcyBsb29zZWx5IGJhc2VkIG9uIHN3ZWV0LmpzJyBhcHByb2FjaC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG5cblxuICB2YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSAhIWdlbmVyYXRvcjtcbiAgfTtcblxuICB2YXIgdHlwZXMgPSB7XG4gICAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICAgIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICAgIGJfdG1wbDogbmV3IFRva0NvbnRleHQoXCIke1wiLCBmYWxzZSksXG4gICAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICAgIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICAgIHFfdG1wbDogbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuKCk7IH0pLFxuICAgIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gICAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICAgIGZfZXhwcl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSwgZmFsc2UsIG51bGwsIHRydWUpLFxuICAgIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbiAgfTtcblxuICB2YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgcHAkNi5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbdHlwZXMuYl9zdGF0XVxuICB9O1xuXG4gIHBwJDYuY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG4gIH07XG5cbiAgcHAkNi5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAocGFyZW50ID09PSB0eXBlcy5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcy5mX3N0YXQpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMuYl9leHByKSlcbiAgICAgIHsgcmV0dXJuICFwYXJlbnQuaXNFeHByIH1cblxuICAgIC8vIFRoZSBjaGVjayBmb3IgYHR0Lm5hbWUgJiYgZXhwckFsbG93ZWRgIGRldGVjdHMgd2hldGhlciB3ZSBhcmVcbiAgICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAgIC8vIGB0dC5uYW1lYC5cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuc2VtaSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEucGFyZW5SIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLmFycm93KVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLmJyYWNlTClcbiAgICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEubmFtZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gIXRoaXMuZXhwckFsbG93ZWRcbiAgfTtcblxuICBwcCQ2LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTsgaSA+PSAxOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0W2ldO1xuICAgICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgeyByZXR1cm4gY29udGV4dC5nZW5lcmF0b3IgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ2LnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PT0gdHlwZXMkMS5kb3QpXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICAgIHsgdXBkYXRlLmNhbGwodGhpcywgcHJldlR5cGUpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byBoYW5kbGUgZWRnZSBjYXNlcyB3aGVuIHRva2VuIGNvbnRleHQgY291bGQgbm90IGJlIGluZmVycmVkIGNvcnJlY3RseSBkdXJpbmcgdG9rZW5pemF0aW9uIHBoYXNlXG5cbiAgcHAkNi5vdmVycmlkZUNvbnRleHQgPSBmdW5jdGlvbih0b2tlbkN0eCkge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdG9rZW5DdHgpIHtcbiAgICAgIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV0gPSB0b2tlbkN0eDtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG4gIHR5cGVzJDEucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcyQxLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgaWYgKG91dCA9PT0gdHlwZXMuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xuICB9O1xuXG4gIHR5cGVzJDEuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzLmJfc3RhdCA6IHR5cGVzLmJfZXhwcik7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzLmJfdG1wbCk7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcyQxLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aGlsZTtcbiAgICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcy5wX3N0YXQgOiB0eXBlcy5wX2V4cHIpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzJDEuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbiAgfTtcblxuICB0eXBlcyQxLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMkMS5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgaWYgKHByZXZUeXBlLmJlZm9yZUV4cHIgJiYgcHJldlR5cGUgIT09IHR5cGVzJDEuX2Vsc2UgJiZcbiAgICAgICAgIShwcmV2VHlwZSA9PT0gdHlwZXMkMS5zZW1pICYmIHRoaXMuY3VyQ29udGV4dCgpICE9PSB0eXBlcy5wX3N0YXQpICYmXG4gICAgICAgICEocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKSAmJlxuICAgICAgICAhKChwcmV2VHlwZSA9PT0gdHlwZXMkMS5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5iX3N0YXQpKVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX2V4cHIpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX3N0YXQpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzJDEuY29sb24udXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKS50b2tlbiA9PT0gXCJmdW5jdGlvblwiKSB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzJDEuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbClcbiAgICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5xX3RtcGwpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzJDEuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX2Z1bmN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcy5mX2V4cHIpXG4gICAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzLmZfZXhwcl9nZW47IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMuZl9nZW47IH1cbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5uYW1lLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcyQxLmRvdCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICAgIHRoaXMudmFsdWUgPT09IFwieWllbGRcIiAmJiB0aGlzLmluR2VuZXJhdG9yQ29udGV4dCgpKVxuICAgICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBhbGxvd2VkO1xuICB9O1xuXG4gIC8vIEEgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyIG9wZXJhdGVzIGJ5IGRlZmluaW5nIGZ1bmN0aW9ucyBmb3IgYWxsXG4gIC8vIHN5bnRhY3RpYyBlbGVtZW50cywgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhvc2UsIGVhY2ggZnVuY3Rpb25cbiAgLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuICAvLyBvZiBjb25zdHJ1Y3RzIChmb3IgZXhhbXBsZSwgdGhlIGZhY3QgdGhhdCBgIXhbMV1gIG1lYW5zIGAhKHhbMV0pYFxuICAvLyBpbnN0ZWFkIG9mIGAoIXgpWzFdYCBpcyBoYW5kbGVkIGJ5IHRoZSBmYWN0IHRoYXQgdGhlIHBhcnNlclxuICAvLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4gIC8vIGluIHR1cm4gY2FsbHMgdGhlIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGBbXWAgc3Vic2NyaXB0cyDigJQgdGhhdFxuICAvLyB3YXksIGl0J2xsIHJlY2VpdmUgdGhlIG5vZGUgZm9yIGB4WzFdYCBhbHJlYWR5IHBhcnNlZCwgYW5kIHdyYXBzXG4gIC8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbiAgLy9cbiAgLy8gQWNvcm4gdXNlcyBhbiBbb3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzZXJdW29wcF0gdG8gaGFuZGxlIGJpbmFyeVxuICAvLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbiAgLy8gdGhlIHRlY2huaXF1ZSBvdXRsaW5lZCBhYm92ZSwgd2hpY2ggdXNlcyBkaWZmZXJlbnQsIG5lc3RpbmdcbiAgLy8gZnVuY3Rpb25zIHRvIHNwZWNpZnkgcHJlY2VkZW5jZSwgZm9yIGFsbCBvZiB0aGUgdGVuIGJpbmFyeVxuICAvLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbiAgLy9cbiAgLy8gW29wcF06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0b3ItcHJlY2VkZW5jZV9wYXJzZXJcblxuXG4gIHZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBDaGVjayBpZiBwcm9wZXJ0eSBuYW1lIGNsYXNoZXMgd2l0aCBhbHJlYWR5IGFkZGVkLlxuICAvLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4gIC8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbiAgLy8gc3RyaWN0IG1vZGUsIGluaXQgcHJvcGVydGllcyBhcmUgYWxzbyBub3QgYWxsb3dlZCB0byBiZSByZXBlYXRlZC5cblxuICBwcCQ1LmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICAgIHsgcmV0dXJuIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgICAgeyByZXR1cm4gfVxuICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICB2YXIgbmFtZTtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjogbmFtZSA9IGtleS5uYW1lOyBicmVha1xuICAgIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgICBkZWZhdWx0OiByZXR1cm5cbiAgICB9XG4gICAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiAmJiBraW5kID09PSBcImluaXRcIikge1xuICAgICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPCAwKSB7XG4gICAgICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBrZXkuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gICAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gICAgaWYgKG90aGVyKSB7XG4gICAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgICAgaWYgKGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IHRoaXMuc3RyaWN0ICYmIG90aGVyLmluaXQgfHwgb3RoZXIuZ2V0IHx8IG90aGVyLnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IG90aGVyLmluaXQgfHwgb3RoZXJba2luZF07XG4gICAgICB9XG4gICAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZhbHNlLFxuICAgICAgICBzZXQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBvdGhlcltraW5kXSA9IHRydWU7XG4gIH07XG5cbiAgLy8gIyMjIEV4cHJlc3Npb24gcGFyc2luZ1xuXG4gIC8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuICAvLyAnYXRvbWljJywgbm9uZGl2aXNpYmxlIGV4cHJlc3Npb24gdHlwZXMgYXQgdGhlIGJvdHRvbS4gTW9zdCBvZlxuICAvLyB0aGUgZnVuY3Rpb25zIHdpbGwgc2ltcGx5IGxldCB0aGUgZnVuY3Rpb24ocykgYmVsb3cgdGhlbSBwYXJzZSxcbiAgLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbiAgLy8gdGhlIEFTVCBub2RlIHRoYXQgdGhlIGlubmVyIHBhcnNlciBnYXZlIHRoZW0gaW4gYW5vdGhlciBub2RlLlxuXG4gIC8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4gIC8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4gIC8vIGFuZCBwcm92aWRlIHJlZmVyZW5jZSBmb3Igc3RvcmluZyAnPScgb3BlcmF0b3IgaW5zaWRlIHNob3J0aGFuZFxuICAvLyBwcm9wZXJ0eSBhc3NpZ25tZW50IGluIGNvbnRleHRzIHdoZXJlIGJvdGggb2JqZWN0IGV4cHJlc3Npb25cbiAgLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuICAvLyBkZWxheWVkIHN5bnRheCBlcnJvciBhdCBjb3JyZWN0IHBvc2l0aW9uKS5cblxuICBwcCQ1LnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzJDEuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cbiAgLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuICAvLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG4gIHBwJDUucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICAgIGlmICh0aGlzLmluR2VuZXJhdG9yKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQoZm9ySW5pdCkgfVxuICAgICAgLy8gVGhlIHRva2VuaXplciB3aWxsIGFzc3VtZSBhbiBleHByZXNzaW9uIGlzIGFsbG93ZWQgYWZ0ZXJcbiAgICAgIC8vIGB5aWVsZGAsIGJ1dCB0aGlzIGlzbid0IHRoYXQga2luZCBvZiB5aWVsZFxuICAgICAgZWxzZSB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIH1cblxuICAgIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMSwgb2xkRG91YmxlUHJvdG8gPSAtMTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgICBvbGRUcmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgICAgb2xkRG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDtcbiAgICAgIHRoaXMucG90ZW50aWFsQXJyb3dJbkZvckF3YWl0ID0gZm9ySW5pdCA9PT0gXCJhd2FpdFwiO1xuICAgIH1cbiAgICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChhZnRlckxlZnRQYXJzZSkgeyBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpOyB9XG4gICAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICAgIHsgbGVmdCA9IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA+PSBsZWZ0LnN0YXJ0KVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IH0gLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGxlZnQpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobGVmdCk7IH1cbiAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCk7XG4gICAgICBpZiAob2xkRG91YmxlUHJvdG8gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0gb2xkRG91YmxlUHJvdG87IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIH1cbiAgICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICAgIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxuICBwcCQ1LnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uKSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLnRlc3QgPSBleHByO1xuICAgICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbG9uKTtcbiAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9O1xuXG4gIC8vIFN0YXJ0IHRoZSBwcmVjZWRlbmNlIHBhcnNlci5cblxuICBwcCQ1LnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSwgZmFsc2UsIGZvckluaXQpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgcmV0dXJuIGV4cHIuc3RhcnQgPT09IHN0YXJ0UG9zICYmIGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID8gZXhwciA6IHRoaXMucGFyc2VFeHByT3AoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCAtMSwgZm9ySW5pdClcbiAgfTtcblxuICAvLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuICAvLyBhbGdvcml0aG0uIGBsZWZ0YCBpcyB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIG9wZXJhdG9yLlxuICAvLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbiAgLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuICAvLyBvcGVyYXRvciB0aGF0IGhhcyBhIGxvd2VyIHByZWNlZGVuY2UgdGhhbiB0aGUgc2V0IGl0IGlzIHBhcnNpbmcuXG5cbiAgcHAkNS5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBmb3JJbml0KSB7XG4gICAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIWZvckluaXQgfHwgdGhpcy50eXBlICE9PSB0eXBlcyQxLl9pbikpIHtcbiAgICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgICB2YXIgbG9naWNhbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQ7XG4gICAgICAgIHZhciBjb2FsZXNjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb2FsZXNjZTtcbiAgICAgICAgaWYgKGNvYWxlc2NlKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIHRoZSBwcmVjZWRlbmNlIG9mIGB0dC5jb2FsZXNjZWAgYXMgZXF1YWwgdG8gdGhlIHJhbmdlIG9mIGxvZ2ljYWwgZXhwcmVzc2lvbnMuXG4gICAgICAgICAgLy8gSW4gb3RoZXIgd29yZHMsIGBub2RlLnJpZ2h0YCBzaG91bGRuJ3QgY29udGFpbiBsb2dpY2FsIGV4cHJlc3Npb25zIGluIG9yZGVyIHRvIGNoZWNrIHRoZSBtaXhlZCBlcnJvci5cbiAgICAgICAgICBwcmVjID0gdHlwZXMkMS5sb2dpY2FsQU5ELmJpbm9wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UsIGZhbHNlLCBmb3JJbml0KSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBmb3JJbml0KTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwgfHwgY29hbGVzY2UpO1xuICAgICAgICBpZiAoKGxvZ2ljYWwgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvYWxlc2NlKSB8fCAoY29hbGVzY2UgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQpKSkge1xuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkxvZ2ljYWwgZXhwcmVzc2lvbnMgYW5kIGNvYWxlc2NlIGV4cHJlc3Npb25zIGNhbm5vdCBiZSBtaXhlZC4gV3JhcCBlaXRoZXIgYnkgcGFyZW50aGVzZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIGZvckluaXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgcHAkNS5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIikgeyB0aGlzLnJhaXNlKHJpZ2h0LnN0YXJ0LCBcIlByaXZhdGUgaWRlbnRpZmllciBjYW4gb25seSBiZSBsZWZ0IHNpZGUgb2YgYmluYXJ5IGV4cHJlc3Npb25cIik7IH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxuICBwcCQ1LnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5LCBpbmNEZWMsIGZvckluaXQpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikgJiYgdGhpcy5jYW5Bd2FpdCkge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdChmb3JJbml0KTtcbiAgICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5wcmVmaXgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgdXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLmluY0RlYztcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSwgdXBkYXRlLCBmb3JJbml0KTtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgaWYgKHVwZGF0ZSkgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmFyZ3VtZW50KTsgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJiBpc0xvY2FsVmFyaWFibGVBY2Nlc3Mobm9kZS5hcmd1bWVudCkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGVsc2UgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiYgaXNQcml2YXRlRmllbGRBY2Nlc3Mobm9kZS5hcmd1bWVudCkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiUHJpdmF0ZSBmaWVsZHMgY2FuIG5vdCBiZSBkZWxldGVkXCIpOyB9XG4gICAgICBlbHNlIHsgc2F3VW5hcnkgPSB0cnVlOyB9XG4gICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICghc2F3VW5hcnkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgICAgaWYgKChmb3JJbml0IHx8IHRoaXMucHJpdmF0ZU5hbWVTdGFjay5sZW5ndGggPT09IDApICYmIHRoaXMub3B0aW9ucy5jaGVja1ByaXZhdGVGaWVsZHMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGV4cHIgPSB0aGlzLnBhcnNlUHJpdmF0ZUlkZW50KCk7XG4gICAgICAvLyBvbmx5IGNvdWxkIGJlIHByaXZhdGUgZmllbGRzIGluICdpbicsIHN1Y2ggYXMgI3ggaW4gb2JqXG4gICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcyQxLl9pbikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZvckluaXQpO1xuICAgICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICAgIHdoaWxlICh0aGlzLnR5cGUucG9zdGZpeCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICBub2RlJDEub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgICBub2RlJDEucHJlZml4ID0gZmFsc2U7XG4gICAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICAgIHRoaXMuY2hlY2tMVmFsU2ltcGxlKGV4cHIpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWluY0RlYyAmJiB0aGlzLmVhdCh0eXBlcyQxLnN0YXJzdGFyKSkge1xuICAgICAgaWYgKHNhd1VuYXJ5KVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCh0aGlzLmxhc3RUb2tTdGFydCk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZXR1cm4gdGhpcy5idWlsZEJpbmFyeShzdGFydFBvcywgc3RhcnRMb2MsIGV4cHIsIHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlLCBmYWxzZSwgZm9ySW5pdCksIFwiKipcIiwgZmFsc2UpIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV4cHJcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNMb2NhbFZhcmlhYmxlQWNjZXNzKG5vZGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgbm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fFxuICAgICAgbm9kZS50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIgJiYgaXNMb2NhbFZhcmlhYmxlQWNjZXNzKG5vZGUuZXhwcmVzc2lvbilcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgbm9kZS5wcm9wZXJ0eS50eXBlID09PSBcIlByaXZhdGVJZGVudGlmaWVyXCIgfHxcbiAgICAgIG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmV4cHJlc3Npb24pIHx8XG4gICAgICBub2RlLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmV4cHJlc3Npb24pXG4gICAgKVxuICB9XG5cbiAgLy8gUGFyc2UgY2FsbCwgZG90LCBhbmQgYFtdYC1zdWJzY3JpcHQgZXhwcmVzc2lvbnMuXG5cbiAgcHAkNS5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCkge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0KTtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCIpXG4gICAgICB7IHJldHVybiBleHByIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBmYWxzZSwgZm9ySW5pdCk7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVzdWx0LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSAtMTsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIHBwJDUucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBmb3JJbml0KSB7XG4gICAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgICAgdGhpcy5sYXN0VG9rRW5kID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiBiYXNlLmVuZCAtIGJhc2Uuc3RhcnQgPT09IDUgJiZcbiAgICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0O1xuICAgIHZhciBvcHRpb25hbENoYWluZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCk7XG5cbiAgICAgIGlmIChlbGVtZW50Lm9wdGlvbmFsKSB7IG9wdGlvbmFsQ2hhaW5lZCA9IHRydWU7IH1cbiAgICAgIGlmIChlbGVtZW50ID09PSBiYXNlIHx8IGVsZW1lbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgICB2YXIgY2hhaW5Ob2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgIGNoYWluTm9kZS5leHByZXNzaW9uID0gZWxlbWVudDtcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5maW5pc2hOb2RlKGNoYWluTm9kZSwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICAgIH1cblxuICAgICAgYmFzZSA9IGVsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDUuc2hvdWxkUGFyc2VBc3luY0Fycm93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzJDEuYXJyb3cpXG4gIH07XG5cbiAgcHAkNS5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3cgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgdHJ1ZSwgZm9ySW5pdClcbiAgfTtcblxuICBwcCQ1LnBhcnNlU3Vic2NyaXB0ID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCkge1xuICAgIHZhciBvcHRpb25hbFN1cHBvcnRlZCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgICB2YXIgb3B0aW9uYWwgPSBvcHRpb25hbFN1cHBvcnRlZCAmJiB0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uRG90KTtcbiAgICBpZiAobm9DYWxscyAmJiBvcHRpb25hbCkgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIGNhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbnNcIik7IH1cblxuICAgIHZhciBjb21wdXRlZCA9IHRoaXMuZWF0KHR5cGVzJDEuYnJhY2tldEwpO1xuICAgIGlmIChjb21wdXRlZCB8fCAob3B0aW9uYWwgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuTCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYmFja1F1b3RlKSB8fCB0aGlzLmVhdCh0eXBlcyQxLmRvdCkpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNrZXRSKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCAmJiBiYXNlLnR5cGUgIT09IFwiU3VwZXJcIikge1xuICAgICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVJZGVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICAgICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIH1cbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMkMS5wYXJlbkwpKSB7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzJDEucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhb3B0aW9uYWwgJiYgdGhpcy5zaG91bGRQYXJzZUFzeW5jQXJyb3coKSkge1xuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIGlmICh0aGlzLmF3YWl0SWRlbnRQb3MgPiAwKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0SWRlbnRQb3MsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3coc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdClcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3MgfHwgdGhpcy5hd2FpdElkZW50UG9zO1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMS5jYWxsZWUgPSBiYXNlO1xuICAgICAgbm9kZSQxLmFyZ3VtZW50cyA9IGV4cHJMaXN0O1xuICAgICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICAgIG5vZGUkMS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgfVxuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuYmFja1F1b3RlKSB7XG4gICAgICBpZiAob3B0aW9uYWwgfHwgb3B0aW9uYWxDaGFpbmVkKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSB0YWcgb2YgdGFnZ2VkIHRlbXBsYXRlIGV4cHJlc3Npb25zXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgICAgbm9kZSQyLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVxuICB9O1xuXG4gIC8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuICAvLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuICAvLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbiAgLy8gb3IgYHt9YC5cblxuICBwcCQ1LnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0LCBmb3JOZXcpIHtcbiAgICAvLyBJZiBhIGRpdmlzaW9uIG9wZXJhdG9yIGFwcGVhcnMgaW4gYW4gZXhwcmVzc2lvbiBwb3NpdGlvbiwgdGhlXG4gICAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNsYXNoKSB7IHRoaXMucmVhZFJlZ2V4cCgpOyB9XG5cbiAgICB2YXIgbm9kZSwgY2FuQmVBcnJvdyA9IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGFydDtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMkMS5fc3VwZXI6XG4gICAgICBpZiAoIXRoaXMuYWxsb3dTdXBlcilcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJzdXBlcigpIGNhbGwgb3V0c2lkZSBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzXCIpOyB9XG4gICAgICAvLyBUaGUgYHN1cGVyYCBrZXl3b3JkIGNhbiBhcHBlYXIgYXQgYmVsb3c6XG4gICAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgICAgLy8gICAgIHN1cGVyIFsgRXhwcmVzc2lvbiBdXG4gICAgICAvLyAgICAgc3VwZXIgLiBJZGVudGlmaWVyTmFtZVxuICAgICAgLy8gU3VwZXJDYWxsOlxuICAgICAgLy8gICAgIHN1cGVyICggQXJndW1lbnRzIClcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuZG90ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFja2V0TCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEucGFyZW5MKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICAgIGNhc2UgdHlwZXMkMS5fdGhpczpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHlwZXMkMS5uYW1lOlxuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5fZnVuY3Rpb24pKSB7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVDb250ZXh0KHR5cGVzLmZfZXhwcik7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCAwLCBmYWxzZSwgdHJ1ZSwgZm9ySW5pdClcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmFycm93KSlcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UsIGZvckluaXQpIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICghdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgfHwgdGhpcy52YWx1ZSAhPT0gXCJvZlwiIHx8IHRoaXMuY29udGFpbnNFc2MpKSB7XG4gICAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLmVhdCh0eXBlcyQxLmFycm93KSlcbiAgICAgICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUsIGZvckluaXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZFxuXG4gICAgY2FzZSB0eXBlcyQxLnJlZ2V4cDpcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWx1ZS5wYXR0ZXJuLCBmbGFnczogdmFsdWUuZmxhZ3N9O1xuICAgICAgcmV0dXJuIG5vZGVcblxuICAgIGNhc2UgdHlwZXMkMS5udW06IGNhc2UgdHlwZXMkMS5zdHJpbmc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSlcblxuICAgIGNhc2UgdHlwZXMkMS5fbnVsbDogY2FzZSB0eXBlcyQxLl90cnVlOiBjYXNlIHR5cGVzJDEuX2ZhbHNlOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9udWxsID8gbnVsbCA6IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fdHJ1ZTtcbiAgICAgIG5vZGUucmF3ID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgICBjYXNlIHR5cGVzJDEucGFyZW5MOlxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93LCBmb3JJbml0KTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwICYmICF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIpKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHN0YXJ0OyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwclxuXG4gICAgY2FzZSB0eXBlcyQxLmJyYWNrZXRMOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMkMS5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgICBjYXNlIHR5cGVzJDEuYnJhY2VMOlxuICAgICAgdGhpcy5vdmVycmlkZUNvbnRleHQodHlwZXMuYl9leHByKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gICAgY2FzZSB0eXBlcyQxLl9mdW5jdGlvbjpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDApXG5cbiAgICBjYXNlIHR5cGVzJDEuX2NsYXNzOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICAgIGNhc2UgdHlwZXMkMS5fbmV3OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gICAgY2FzZSB0eXBlcyQxLmJhY2tRdW90ZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gICAgY2FzZSB0eXBlcyQxLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckltcG9ydChmb3JOZXcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tRGVmYXVsdCgpXG4gICAgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VFeHByQXRvbURlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfTtcblxuICBwcCQ1LnBhcnNlRXhwckltcG9ydCA9IGZ1bmN0aW9uKGZvck5ldykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIC8vIENvbnN1bWUgYGltcG9ydGAgYXMgYW4gaWRlbnRpZmllciBmb3IgYGltcG9ydC5tZXRhYC5cbiAgICAvLyBCZWNhdXNlIGB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlgIGRvZXNuJ3QgY2hlY2sgZXNjYXBlIHNlcXVlbmNlcywgaXQgbmVlZHMgdGhlIGNoZWNrIG9mIGB0aGlzLmNvbnRhaW5zRXNjYC5cbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBpbXBvcnRcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MICYmICFmb3JOZXcpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydChub2RlKVxuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmRvdCkge1xuICAgICAgdmFyIG1ldGEgPSB0aGlzLnN0YXJ0Tm9kZUF0KG5vZGUuc3RhcnQsIG5vZGUubG9jICYmIG5vZGUubG9jLnN0YXJ0KTtcbiAgICAgIG1ldGEubmFtZSA9IFwiaW1wb3J0XCI7XG4gICAgICBub2RlLm1ldGEgPSB0aGlzLmZpbmlzaE5vZGUobWV0YSwgXCJJZGVudGlmaWVyXCIpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRNZXRhKG5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ1LnBhcnNlRHluYW1pY0ltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTsgLy8gc2tpcCBgKGBcblxuICAgIC8vIFBhcnNlIG5vZGUuc291cmNlLlxuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KSB7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEucGFyZW5SKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgICAgaWYgKCF0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLnBhcmVuUikpIHtcbiAgICAgICAgICBub2RlLm9wdGlvbnMgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEucGFyZW5SKSkge1xuICAgICAgICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEucGFyZW5SKSkge1xuICAgICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5vcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5vcHRpb25zID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVmVyaWZ5IGVuZGluZy5cbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5wYXJlblIpKSB7XG4gICAgICAgIHZhciBlcnJvclBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSAmJiB0aGlzLmVhdCh0eXBlcyQxLnBhcmVuUikpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXJyb3JQb3MsIFwiVHJhaWxpbmcgY29tbWEgaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KClcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKGVycm9yUG9zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkNS5wYXJzZUltcG9ydE1ldGEgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7IC8vIHNraXAgYC5gXG5cbiAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG5cbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcIm1ldGFcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgaW1wb3J0IGlzICdpbXBvcnQubWV0YSdcIik7IH1cbiAgICBpZiAoY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIidpbXBvcnQubWV0YScgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnNcIik7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgIT09IFwibW9kdWxlXCIgJiYgIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2ltcG9ydC5tZXRhJyBvdXRzaWRlIGEgbW9kdWxlXCIpOyB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gIH07XG5cbiAgcHAkNS5wYXJzZUxpdGVyYWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICBpZiAobm9kZS5yYXcuY2hhckNvZGVBdChub2RlLnJhdy5sZW5ndGggLSAxKSA9PT0gMTEwKVxuICAgICAgeyBub2RlLmJpZ2ludCA9IG5vZGUudmFsdWUgIT0gbnVsbCA/IG5vZGUudmFsdWUudG9TdHJpbmcoKSA6IG5vZGUucmF3LnNsaWNlKDAsIC0xKS5yZXBsYWNlKC9fL2csIFwiXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbiAgfTtcblxuICBwcCQ1LnBhcnNlUGFyZW5FeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICAgIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcbiAgICByZXR1cm4gdmFsXG4gIH07XG5cbiAgcHAkNS5zaG91bGRQYXJzZUFycm93ID0gZnVuY3Rpb24oZXhwckxpc3QpIHtcbiAgICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKClcbiAgfTtcblxuICBwcCQ1LnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24gPSBmdW5jdGlvbihjYW5CZUFycm93LCBmb3JJbml0KSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycywgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIHNwcmVhZFN0YXJ0O1xuICAgICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAgIC8vIERvIG5vdCBzYXZlIGF3YWl0SWRlbnRQb3MgdG8gYWxsb3cgY2hlY2tpbmcgYXdhaXRzIG5lc3RlZCBpbiBwYXJhbWV0ZXJzXG4gICAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuUikge1xuICAgICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLnBhcmVuUiwgdHJ1ZSkpIHtcbiAgICAgICAgICBsYXN0SXNDb21tYSA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZWxsaXBzaXMpIHtcbiAgICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKFxuICAgICAgICAgICAgICB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgICBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0aGlzLnBhcnNlUGFyZW5JdGVtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpbm5lckVuZFBvcyA9IHRoaXMubGFzdFRva0VuZCwgaW5uZXJFbmRMb2MgPSB0aGlzLmxhc3RUb2tFbmRMb2M7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG5cbiAgICAgIGlmIChjYW5CZUFycm93ICYmIHRoaXMuc2hvdWxkUGFyc2VBcnJvdyhleHByTGlzdCkgJiYgdGhpcy5lYXQodHlwZXMkMS5hcnJvdykpIHtcbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgICBpZiAoc3ByZWFkU3RhcnQpIHsgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTsgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuXG4gICAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgICB2YXIgcGFyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1cbiAgfTtcblxuICBwcCQ1LnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgZmFsc2UsIGZvckluaXQpXG4gIH07XG5cbiAgLy8gTmV3J3MgcHJlY2VkZW5jZSBpcyBzbGlnaHRseSB0cmlja3kuIEl0IG11c3QgYWxsb3cgaXRzIGFyZ3VtZW50IHRvXG4gIC8vIGJlIGEgYFtdYCBvciBkb3Qgc3Vic2NyaXB0IGV4cHJlc3Npb24sIGJ1dCBub3QgYSBjYWxsIOKAlCBhdCBsZWFzdCxcbiAgLy8gbm90IHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gcGFyZW50aGVzZXMuIFRodXMsIGl0IHVzZXMgdGhlIG5vQ2FsbHNcbiAgLy8gYXJndW1lbnQgdG8gcGFyc2VTdWJzY3JpcHRzIHRvIHByZXZlbnQgaXQgZnJvbSBjb25zdW1pbmcgdGhlXG4gIC8vIGFyZ3VtZW50IGxpc3QuXG5cbiAgdmFyIGVtcHR5ID0gW107XG5cbiAgcHAkNS5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIG5ld1wiKTsgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmRvdCkge1xuICAgICAgdmFyIG1ldGEgPSB0aGlzLnN0YXJ0Tm9kZUF0KG5vZGUuc3RhcnQsIG5vZGUubG9jICYmIG5vZGUubG9jLnN0YXJ0KTtcbiAgICAgIG1ldGEubmFtZSA9IFwibmV3XCI7XG4gICAgICBub2RlLm1ldGEgPSB0aGlzLmZpbmlzaE5vZGUobWV0YSwgXCJJZGVudGlmaWVyXCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzICduZXcudGFyZ2V0J1wiKTsgfVxuICAgICAgaWYgKGNvbnRhaW5zRXNjKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIiduZXcudGFyZ2V0JyBtdXN0IG5vdCBjb250YWluIGVzY2FwZWQgY2hhcmFjdGVyc1wiKTsgfVxuICAgICAgaWYgKCF0aGlzLmFsbG93TmV3RG90VGFyZ2V0KVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIiduZXcudGFyZ2V0JyBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9ucyBhbmQgY2xhc3Mgc3RhdGljIGJsb2NrXCIpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gICAgfVxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbShudWxsLCBmYWxzZSwgdHJ1ZSksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSwgZmFsc2UpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnBhcmVuTCkpIHsgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMkMS5wYXJlblIsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4LCBmYWxzZSk7IH1cbiAgICBlbHNlIHsgbm9kZS5hcmd1bWVudHMgPSBlbXB0eTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgdGVtcGxhdGUgZXhwcmVzc2lvbi5cblxuICBwcCQ1LnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkO1xuXG4gICAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuaW52YWxpZFRlbXBsYXRlKSB7XG4gICAgICBpZiAoIWlzVGFnZ2VkKSB7XG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkJhZCBlc2NhcGUgc2VxdWVuY2UgaW4gdW50YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICAgIH1cbiAgICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICAgIHJhdzogdGhpcy52YWx1ZS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgICBjb29rZWQ6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICAgIHJhdzogdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBlbGVtLnRhaWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYmFja1F1b3RlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQ1LnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gICAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkOyBpZiAoIGlzVGFnZ2VkID09PSB2b2lkIDAgKSBpc1RhZ2dlZCA9IGZhbHNlO1xuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSk7XG4gICAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVvZikgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpOyB9XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmRvbGxhckJyYWNlTCk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlUik7XG4gICAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKVxuICB9O1xuXG4gIHBwJDUuaXNBc3luY1Byb3AgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICAgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2tldEwgfHwgdGhpcy50eXBlLmtleXdvcmQgfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSkgJiZcbiAgICAgICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cbiAgLy8gUGFyc2UgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYmluZGluZyBwYXR0ZXJuLlxuXG4gIHBwJDUucGFyc2VPYmogPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgcHJvcEhhc2ggPSB7fTtcbiAgICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzJDEuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBwcm9wID0gdGhpcy5wYXJzZVByb3BlcnR5KGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAoIWlzUGF0dGVybikgeyB0aGlzLmNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQ1LnBhcnNlUHJvcGVydHkgPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzJDEuZWxsaXBzaXMpKSB7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJSZXN0RWxlbWVudFwiKVxuICAgICAgfVxuICAgICAgLy8gUGFyc2UgYXJndW1lbnQuXG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIC8vIFRvIGRpc2FsbG93IHRyYWlsaW5nIGNvbW1hIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMCkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgICAgLy8gRmluaXNoXG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiU3ByZWFkRWxlbWVudFwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgICAgaWYgKGlzUGF0dGVybiB8fCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtcbiAgICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BhdHRlcm4pXG4gICAgICAgIHsgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpOyB9XG4gICAgfVxuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIilcbiAgfTtcblxuICBwcCQ1LnBhcnNlR2V0dGVyU2V0dGVyID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHZhciBraW5kID0gcHJvcC5rZXkubmFtZTtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGZhbHNlKTtcbiAgICBwcm9wLmtpbmQgPSBraW5kO1xuICAgIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwcm9wLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgIH1cbiAgfTtcblxuICBwcCQ1LnBhcnNlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpIHtcbiAgICBpZiAoKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb2xvbilcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmNvbG9uKSkge1xuICAgICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MKSB7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBwcm9wLm1ldGhvZCA9IHRydWU7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICB9IGVsc2UgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAgICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuY29tbWEgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlUiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuZXEpKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgdGhpcy5wYXJzZUdldHRlclNldHRlcihwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQocHJvcC5rZXkpO1xuICAgICAgaWYgKHByb3Aua2V5Lm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IHN0YXJ0UG9zOyB9XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgdGhpcy5jb3B5Tm9kZShwcm9wLmtleSkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSB0aGlzLnN0YXJ0OyB9XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgdGhpcy5jb3B5Tm9kZShwcm9wLmtleSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMuY29weU5vZGUocHJvcC5rZXkpO1xuICAgICAgfVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gICAgfSBlbHNlIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfTtcblxuICBwcCQ1LnBhcnNlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuYnJhY2tldEwpKSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNrZXRSKTtcbiAgICAgICAgcmV0dXJuIHByb3Aua2V5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpXG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG4gIHBwJDUuaW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyBub2RlLmdlbmVyYXRvciA9IG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxuICB9O1xuXG4gIC8vIFBhcnNlIG9iamVjdCBvciBjbGFzcyBtZXRob2QuXG5cbiAgcHAkNS5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd0RpcmVjdFN1cGVyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikgfCBTQ09QRV9TVVBFUiB8IChhbGxvd0RpcmVjdFN1cGVyID8gU0NPUEVfRElSRUNUX1NVUEVSIDogMCkpO1xuXG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzJDEucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgfTtcblxuICAvLyBQYXJzZSBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy5cblxuICBwcCQ1LnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jLCBmb3JJbml0KSB7XG4gICAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gICAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgZmFsc2UpIHwgU0NPUEVfQVJST1cpO1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuXG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cnVlKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUsIGZhbHNlLCBmb3JJbml0KTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgfTtcblxuICAvLyBQYXJzZSBmdW5jdGlvbiBib2R5IGFuZCBjaGVjayBwYXJhbWV0ZXJzLlxuXG4gIHBwJDUucGFyc2VGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbihub2RlLCBpc0Fycm93RnVuY3Rpb24sIGlzTWV0aG9kLCBmb3JJbml0KSB7XG4gICAgdmFyIGlzRXhwcmVzc2lvbiA9IGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VMO1xuICAgIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdCwgdXNlU3RyaWN0ID0gZmFsc2U7XG5cbiAgICBpZiAoaXNFeHByZXNzaW9uKSB7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub25TaW1wbGUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiAhdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcyk7XG4gICAgICBpZiAoIW9sZFN0cmljdCB8fCBub25TaW1wbGUpIHtcbiAgICAgICAgdXNlU3RyaWN0ID0gdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5lbmQpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3RyaWN0IG1vZGUgZnVuY3Rpb24sIHZlcmlmeSB0aGF0IGFyZ3VtZW50IG5hbWVzXG4gICAgICAgIC8vIGFyZSBub3QgcmVwZWF0ZWQsIGFuZCBpdCBkb2VzIG5vdCB0cnkgdG8gYmluZCB0aGUgd29yZHMgYGV2YWxgXG4gICAgICAgIC8vIG9yIGBhcmd1bWVudHNgLlxuICAgICAgICBpZiAodXNlU3RyaWN0ICYmIG5vblNpbXBsZSlcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIklsbGVnYWwgJ3VzZSBzdHJpY3QnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3RcIik7IH1cbiAgICAgIH1cbiAgICAgIC8vIFN0YXJ0IGEgbmV3IHNjb3BlIHdpdGggcmVnYXJkIHRvIGxhYmVscyBhbmQgdGhlIGBpbkZ1bmN0aW9uYFxuICAgICAgLy8gZmxhZyAocmVzdG9yZSB0aGVtIHRvIHRoZWlyIG9sZCB2YWx1ZSBhZnRlcndhcmRzKS5cbiAgICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgICBpZiAodXNlU3RyaWN0KSB7IHRoaXMuc3RyaWN0ID0gdHJ1ZTsgfVxuXG4gICAgICAvLyBBZGQgdGhlIHBhcmFtcyB0byB2YXJEZWNsYXJlZE5hbWVzIHRvIGVuc3VyZSB0aGF0IGFuIGVycm9yIGlzIHRocm93blxuICAgICAgLy8gaWYgYSBsZXQvY29uc3QgZGVjbGFyYXRpb24gaW4gdGhlIGZ1bmN0aW9uIGNsYXNoZXMgd2l0aCBvbmUgb2YgdGhlIHBhcmFtcy5cbiAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgIW9sZFN0cmljdCAmJiAhdXNlU3RyaWN0ICYmICFpc0Fycm93RnVuY3Rpb24gJiYgIWlzTWV0aG9kICYmIHRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpKTtcbiAgICAgIC8vIEVuc3VyZSB0aGUgZnVuY3Rpb24gbmFtZSBpc24ndCBhIGZvcmJpZGRlbiBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLCBlLmcuICdldmFsJ1xuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUuaWQpIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5pZCwgQklORF9PVVRTSURFKTsgfVxuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlLCB1bmRlZmluZWQsIHVzZVN0cmljdCAmJiAhb2xkU3RyaWN0KTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keS5ib2R5KTtcbiAgICAgIHRoaXMubGFiZWxzID0gb2xkTGFiZWxzO1xuICAgIH1cbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICB9O1xuXG4gIHBwJDUuaXNTaW1wbGVQYXJhbUxpc3QgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHsgcmV0dXJuIGZhbHNlXG4gICAgfSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICAvLyBDaGVja3MgZnVuY3Rpb24gcGFyYW1zIGZvciB2YXJpb3VzIGRpc2FsbG93ZWQgcGF0dGVybnMgc3VjaCBhcyB1c2luZyBcImV2YWxcIlxuICAvLyBvciBcImFyZ3VtZW50c1wiIGFuZCBkdXBsaWNhdGUgcGFyYW1ldGVycy5cblxuICBwcCQ1LmNoZWNrUGFyYW1zID0gZnVuY3Rpb24obm9kZSwgYWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIG5hbWVIYXNoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKHBhcmFtLCBCSU5EX1ZBUiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhwcmVzc2lvbnMsIGFuZCByZXR1cm5zIHRoZW0gYXNcbiAgLy8gYW4gYXJyYXkuIGBjbG9zZWAgaXMgdGhlIHRva2VuIHR5cGUgdGhhdCBlbmRzIHRoZSBsaXN0LCBhbmRcbiAgLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuICAvLyBub3RoaW5nIGluIGJldHdlZW4gdGhlbSB0byBiZSBwYXJzZWQgYXMgYG51bGxgICh3aGljaCBpcyBuZWVkZWRcbiAgLy8gZm9yIGFycmF5IGxpdGVyYWxzKS5cblxuICBwcCQ1LnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSlcbiAgICAgICAgeyBlbHQgPSBudWxsOyB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZWxsaXBzaXMpIHtcbiAgICAgICAgZWx0ID0gdGhpcy5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0OyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgfVxuICAgICAgZWx0cy5wdXNoKGVsdCk7XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkNS5jaGVja1VucmVzZXJ2ZWQgPSBmdW5jdGlvbihyZWYpIHtcbiAgICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gICAgdmFyIG5hbWUgPSByZWYubmFtZTtcblxuICAgIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ3lpZWxkJyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgaWYgKCEodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9WQVIpICYmIG5hbWUgPT09IFwiYXJndW1lbnRzXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICdhcmd1bWVudHMnIGluIGNsYXNzIGZpZWxkIGluaXRpYWxpemVyXCIpOyB9XG4gICAgaWYgKHRoaXMuaW5DbGFzc1N0YXRpY0Jsb2NrICYmIChuYW1lID09PSBcImFyZ3VtZW50c1wiIHx8IG5hbWUgPT09IFwiYXdhaXRcIikpXG4gICAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIkNhbm5vdCB1c2UgXCIgKyBuYW1lICsgXCIgaW4gY2xhc3Mgc3RhdGljIGluaXRpYWxpemF0aW9uIGJsb2NrXCIpKTsgfVxuICAgIGlmICh0aGlzLmtleXdvcmRzLnRlc3QobmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIlVuZXhwZWN0ZWQga2V5d29yZCAnXCIgKyBuYW1lICsgXCInXCIpKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgICB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkgeyByZXR1cm4gfVxuICAgIHZhciByZSA9IHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzO1xuICAgIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2Uga2V5d29yZCAnYXdhaXQnIG91dHNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4gIC8vIHdoZW4gcGFyc2luZyBwcm9wZXJ0aWVzKSwgaXQgd2lsbCBhbHNvIGNvbnZlcnQga2V5d29yZHMgaW50b1xuICAvLyBpZGVudGlmaWVycy5cblxuICBwcCQ1LnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlSWRlbnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCEhbGliZXJhbCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgICBpZiAoIWxpYmVyYWwpIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUpO1xuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gbm9kZS5zdGFydDsgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIHBwJDUucGFyc2VJZGVudE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtleXdvcmQpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRoaXMudHlwZS5rZXl3b3JkO1xuXG4gICAgICAvLyBUbyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzLzU3NVxuICAgICAgLy8gYGNsYXNzYCBhbmQgYGZ1bmN0aW9uYCBrZXl3b3JkcyBwdXNoIG5ldyBjb250ZXh0IGludG8gdGhpcy5jb250ZXh0LlxuICAgICAgLy8gQnV0IHRoZXJlIGlzIG5vIGNoYW5jZSB0byBwb3AgdGhlIGNvbnRleHQgaWYgdGhlIGtleXdvcmQgaXMgY29uc3VtZWQgYXMgYW4gaWRlbnRpZmllciBzdWNoIGFzIGEgcHJvcGVydHkgbmFtZS5cbiAgICAgIC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBhIGRvdCwgdGhpcyBkb2VzIG5vdCBhcHBseSBiZWNhdXNlIHRoZSBjb250ZXh0LW1hbmFnaW5nIGNvZGUgYWxyZWFkeSBpZ25vcmVkIHRoZSBrZXl3b3JkXG4gICAgICBpZiAoKG5vZGUubmFtZSA9PT0gXCJjbGFzc1wiIHx8IG5vZGUubmFtZSA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAodGhpcy5sYXN0VG9rRW5kICE9PSB0aGlzLmxhc3RUb2tTdGFydCArIDEgfHwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubGFzdFRva1N0YXJ0KSAhPT0gNDYpKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHlwZSA9IHR5cGVzJDEubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkNS5wYXJzZVByaXZhdGVJZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByaXZhdGVJZGVudGlmaWVyXCIpO1xuXG4gICAgLy8gRm9yIHZhbGlkYXRpbmcgZXhpc3RlbmNlXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jaGVja1ByaXZhdGVGaWVsZHMpIHtcbiAgICAgIGlmICh0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgKFwiUHJpdmF0ZSBmaWVsZCAnI1wiICsgKG5vZGUubmFtZSkgKyBcIicgbXVzdCBiZSBkZWNsYXJlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3NcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcml2YXRlTmFtZVN0YWNrW3RoaXMucHJpdmF0ZU5hbWVTdGFjay5sZW5ndGggLSAxXS51c2VkLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICAvLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG4gIHBwJDUucGFyc2VZaWVsZCA9IGZ1bmN0aW9uKGZvckluaXQpIHtcbiAgICBpZiAoIXRoaXMueWllbGRQb3MpIHsgdGhpcy55aWVsZFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNlbWkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAodGhpcy50eXBlICE9PSB0eXBlcyQxLnN0YXIgJiYgIXRoaXMudHlwZS5zdGFydHNFeHByKSkge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VBd2FpdCA9IGZ1bmN0aW9uKGZvckluaXQpIHtcbiAgICBpZiAoIXRoaXMuYXdhaXRQb3MpIHsgdGhpcy5hd2FpdFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSwgZmFsc2UsIGZvckluaXQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIilcbiAgfTtcblxuICB2YXIgcHAkNCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMgb24gcGFyc2UgZXJyb3JzLiBJdFxuICAvLyB0YWtlcyBhbiBvZmZzZXQgaW50ZWdlciAoaW50byB0aGUgY3VycmVudCBgaW5wdXRgKSB0byBpbmRpY2F0ZVxuICAvLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuICAvLyBvZiB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIHRoZW4gcmFpc2VzIGEgYFN5bnRheEVycm9yYCB3aXRoIHRoYXRcbiAgLy8gbWVzc2FnZS5cblxuICBwcCQ0LnJhaXNlID0gZnVuY3Rpb24ocG9zLCBtZXNzYWdlKSB7XG4gICAgdmFyIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gICAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICAgIGlmICh0aGlzLnNvdXJjZUZpbGUpIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCIgaW4gXCIgKyB0aGlzLnNvdXJjZUZpbGU7XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gICAgZXJyLnBvcyA9IHBvczsgZXJyLmxvYyA9IGxvYzsgZXJyLnJhaXNlZEF0ID0gdGhpcy5wb3M7XG4gICAgdGhyb3cgZXJyXG4gIH07XG5cbiAgcHAkNC5yYWlzZVJlY292ZXJhYmxlID0gcHAkNC5yYWlzZTtcblxuICBwcCQ0LmN1clBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0KVxuICAgIH1cbiAgfTtcblxuICB2YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgdmFyIFNjb3BlID0gZnVuY3Rpb24gU2NvcGUoZmxhZ3MpIHtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgLy8gQSBsaXN0IG9mIHZhci1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gICAgdGhpcy52YXIgPSBbXTtcbiAgICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgICB0aGlzLmxleGljYWwgPSBbXTtcbiAgICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIEZ1bmN0aW9uRGVjbGFyYXRpb24gbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICAgIHRoaXMuZnVuY3Rpb25zID0gW107XG4gIH07XG5cbiAgLy8gVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBrZWVwIHRyYWNrIG9mIGRlY2xhcmVkIHZhcmlhYmxlcyBpbiB0aGUgY3VycmVudCBzY29wZSBpbiBvcmRlciB0byBkZXRlY3QgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWVzLlxuXG4gIHBwJDMuZW50ZXJTY29wZSA9IGZ1bmN0aW9uKGZsYWdzKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnB1c2gobmV3IFNjb3BlKGZsYWdzKSk7XG4gIH07XG5cbiAgcHAkMy5leGl0U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG4gIH07XG5cbiAgLy8gVGhlIHNwZWMgc2F5czpcbiAgLy8gPiBBdCB0aGUgdG9wIGxldmVsIG9mIGEgZnVuY3Rpb24sIG9yIHNjcmlwdCwgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGFyZVxuICAvLyA+IHRyZWF0ZWQgbGlrZSB2YXIgZGVjbGFyYXRpb25zIHJhdGhlciB0aGFuIGxpa2UgbGV4aWNhbCBkZWNsYXJhdGlvbnMuXG4gIHBwJDMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUgPSBmdW5jdGlvbihzY29wZSkge1xuICAgIHJldHVybiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgfHwgIXRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKVxuICB9O1xuXG4gIHBwJDMuZGVjbGFyZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKSB7XG4gICAgdmFyIHJlZGVjbGFyZWQgPSBmYWxzZTtcbiAgICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIHJlZGVjbGFyZWQgPSBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLnZhci5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgICBzY29wZS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX1NJTVBMRV9DQVRDSCkge1xuICAgICAgdmFyIHNjb3BlJDEgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgc2NvcGUkMS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9GVU5DVElPTikge1xuICAgICAgdmFyIHNjb3BlJDIgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgaWYgKHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhcilcbiAgICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlJDIudmFyLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgICAgc2NvcGUkMi5mdW5jdGlvbnMucHVzaChuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgc2NvcGUkMyA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgICAgaWYgKHNjb3BlJDMubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgJiYgISgoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1NJTVBMRV9DQVRDSCkgJiYgc2NvcGUkMy5sZXhpY2FsWzBdID09PSBuYW1lKSB8fFxuICAgICAgICAgICAgIXRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUoc2NvcGUkMykgJiYgc2NvcGUkMy5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgICAgcmVkZWNsYXJlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzY29wZSQzLnZhci5wdXNoKG5hbWUpO1xuICAgICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgICAgIGlmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVkFSKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZGVjbGFyZWQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgKFwiSWRlbnRpZmllciAnXCIgKyBuYW1lICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWRcIikpOyB9XG4gIH07XG5cbiAgcHAkMy5jaGVja0xvY2FsRXhwb3J0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAvLyBzY29wZS5mdW5jdGlvbnMgbXVzdCBiZSBlbXB0eSBhcyBNb2R1bGUgY29kZSBpcyBhbHdheXMgc3RyaWN0LlxuICAgIGlmICh0aGlzLnNjb3BlU3RhY2tbMF0ubGV4aWNhbC5pbmRleE9mKGlkLm5hbWUpID09PSAtMSAmJlxuICAgICAgICB0aGlzLnNjb3BlU3RhY2tbMF0udmFyLmluZGV4T2YoaWQubmFtZSkgPT09IC0xKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbaWQubmFtZV0gPSBpZDtcbiAgICB9XG4gIH07XG5cbiAgcHAkMy5jdXJyZW50U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXVxuICB9O1xuXG4gIHBwJDMuY3VycmVudFZhclNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUuZmxhZ3MgJiAoU0NPUEVfVkFSIHwgU0NPUEVfQ0xBU1NfRklFTERfSU5JVCB8IFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSykpIHsgcmV0dXJuIHNjb3BlIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ291bGQgYmUgdXNlZnVsIGZvciBgdGhpc2AsIGBuZXcudGFyZ2V0YCwgYHN1cGVyKClgLCBgc3VwZXIucHJvcGVydHlgLCBhbmQgYHN1cGVyW3Byb3BlcnR5XWAuXG4gIHBwJDMuY3VycmVudFRoaXNTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlLmZsYWdzICYgKFNDT1BFX1ZBUiB8IFNDT1BFX0NMQVNTX0ZJRUxEX0lOSVQgfCBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spICYmXG4gICAgICAgICAgIShzY29wZS5mbGFncyAmIFNDT1BFX0FSUk9XKSkgeyByZXR1cm4gc2NvcGUgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUocGFyc2VyLCBwb3MsIGxvYykge1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IHBvcztcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgaWYgKHBhcnNlci5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocGFyc2VyLCBsb2MpOyB9XG4gICAgaWYgKHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpXG4gICAgICB7IHRoaXMuc291cmNlRmlsZSA9IHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGU7IH1cbiAgICBpZiAocGFyc2VyLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyB0aGlzLnJhbmdlID0gW3BvcywgMF07IH1cbiAgfTtcblxuICAvLyBTdGFydCBhbiBBU1Qgbm9kZSwgYXR0YWNoaW5nIGEgc3RhcnQgb2Zmc2V0LlxuXG4gIHZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICBwcCQyLnN0YXJ0Tm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKVxuICB9O1xuXG4gIHBwJDIuc3RhcnROb2RlQXQgPSBmdW5jdGlvbihwb3MsIGxvYykge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbiAgfTtcblxuICAvLyBGaW5pc2ggYW4gQVNUIG5vZGUsIGFkZGluZyBgdHlwZWAgYW5kIGBlbmRgIHByb3BlcnRpZXMuXG5cbiAgZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICBub2RlLmVuZCA9IHBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgbm9kZS5sb2MuZW5kID0gbG9jOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgcHAkMi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCB0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYylcbiAgfTtcblxuICAvLyBGaW5pc2ggbm9kZSBhdCBnaXZlbiBwb3NpdGlvblxuXG4gIHBwJDIuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgcG9zLCBsb2MpXG4gIH07XG5cbiAgcHAkMi5jb3B5Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgbmV3Tm9kZSA9IG5ldyBOb2RlKHRoaXMsIG5vZGUuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgIGZvciAodmFyIHByb3AgaW4gbm9kZSkgeyBuZXdOb2RlW3Byb3BdID0gbm9kZVtwcm9wXTsgfVxuICAgIHJldHVybiBuZXdOb2RlXG4gIH07XG5cbiAgLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgXCJiaW4vZ2VuZXJhdGUtdW5pY29kZS1zY3JpcHQtdmFsdWVzLmpzXCIuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG4gIHZhciBzY3JpcHRWYWx1ZXNBZGRlZEluVW5pY29kZSA9IFwiR2FyYSBHYXJheSBHdWtoIEd1cnVuZ19LaGVtYSBIcmt0IEthdGFrYW5hX09yX0hpcmFnYW5hIEthd2kgS2lyYXRfUmFpIEtyYWkgTmFnX011bmRhcmkgTmFnbSBPbF9PbmFsIE9uYW8gU3VudSBTdW51d2FyIFRvZGhyaSBUb2RyIFR1bHVfVGlnYWxhcmkgVHV0ZyBVbmtub3duIFp6enpcIjtcblxuICAvLyBUaGlzIGZpbGUgY29udGFpbnMgVW5pY29kZSBwcm9wZXJ0aWVzIGV4dHJhY3RlZCBmcm9tIHRoZSBFQ01BU2NyaXB0IHNwZWNpZmljYXRpb24uXG4gIC8vIFRoZSBsaXN0cyBhcmUgZXh0cmFjdGVkIGxpa2Ugc286XG4gIC8vICQkKCcjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllcyA+IGZpZ3VyZSA+IHRhYmxlID4gdGJvZHkgPiB0ciA+IHRkOm50aC1jaGlsZCgxKSBjb2RlJykubWFwKGVsID0+IGVsLmlubmVyVGV4dClcblxuICAvLyAjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllc1xuICB2YXIgZWNtYTlCaW5hcnlQcm9wZXJ0aWVzID0gXCJBU0NJSSBBU0NJSV9IZXhfRGlnaXQgQUhleCBBbHBoYWJldGljIEFscGhhIEFueSBBc3NpZ25lZCBCaWRpX0NvbnRyb2wgQmlkaV9DIEJpZGlfTWlycm9yZWQgQmlkaV9NIENhc2VfSWdub3JhYmxlIENJIENhc2VkIENoYW5nZXNfV2hlbl9DYXNlZm9sZGVkIENXQ0YgQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQgQ1dDTSBDaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCBDV0wgQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZCBDV0tDRiBDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCBDV1QgQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQgQ1dVIERhc2ggRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBESSBEZXByZWNhdGVkIERlcCBEaWFjcml0aWMgRGlhIEVtb2ppIEVtb2ppX0NvbXBvbmVudCBFbW9qaV9Nb2RpZmllciBFbW9qaV9Nb2RpZmllcl9CYXNlIEVtb2ppX1ByZXNlbnRhdGlvbiBFeHRlbmRlciBFeHQgR3JhcGhlbWVfQmFzZSBHcl9CYXNlIEdyYXBoZW1lX0V4dGVuZCBHcl9FeHQgSGV4X0RpZ2l0IEhleCBJRFNfQmluYXJ5X09wZXJhdG9yIElEU0IgSURTX1RyaW5hcnlfT3BlcmF0b3IgSURTVCBJRF9Db250aW51ZSBJREMgSURfU3RhcnQgSURTIElkZW9ncmFwaGljIElkZW8gSm9pbl9Db250cm9sIEpvaW5fQyBMb2dpY2FsX09yZGVyX0V4Y2VwdGlvbiBMT0UgTG93ZXJjYXNlIExvd2VyIE1hdGggTm9uY2hhcmFjdGVyX0NvZGVfUG9pbnQgTkNoYXIgUGF0dGVybl9TeW50YXggUGF0X1N5biBQYXR0ZXJuX1doaXRlX1NwYWNlIFBhdF9XUyBRdW90YXRpb25fTWFyayBRTWFyayBSYWRpY2FsIFJlZ2lvbmFsX0luZGljYXRvciBSSSBTZW50ZW5jZV9UZXJtaW5hbCBTVGVybSBTb2Z0X0RvdHRlZCBTRCBUZXJtaW5hbF9QdW5jdHVhdGlvbiBUZXJtIFVuaWZpZWRfSWRlb2dyYXBoIFVJZGVvIFVwcGVyY2FzZSBVcHBlciBWYXJpYXRpb25fU2VsZWN0b3IgVlMgV2hpdGVfU3BhY2Ugc3BhY2UgWElEX0NvbnRpbnVlIFhJREMgWElEX1N0YXJ0IFhJRFNcIjtcbiAgdmFyIGVjbWExMEJpbmFyeVByb3BlcnRpZXMgPSBlY21hOUJpbmFyeVByb3BlcnRpZXMgKyBcIiBFeHRlbmRlZF9QaWN0b2dyYXBoaWNcIjtcbiAgdmFyIGVjbWExMUJpbmFyeVByb3BlcnRpZXMgPSBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzO1xuICB2YXIgZWNtYTEyQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMUJpbmFyeVByb3BlcnRpZXMgKyBcIiBFQmFzZSBFQ29tcCBFTW9kIEVQcmVzIEV4dFBpY3RcIjtcbiAgdmFyIGVjbWExM0JpbmFyeVByb3BlcnRpZXMgPSBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzO1xuICB2YXIgZWNtYTE0QmluYXJ5UHJvcGVydGllcyA9IGVjbWExM0JpbmFyeVByb3BlcnRpZXM7XG5cbiAgdmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzID0ge1xuICAgIDk6IGVjbWE5QmluYXJ5UHJvcGVydGllcyxcbiAgICAxMDogZWNtYTEwQmluYXJ5UHJvcGVydGllcyxcbiAgICAxMTogZWNtYTExQmluYXJ5UHJvcGVydGllcyxcbiAgICAxMjogZWNtYTEyQmluYXJ5UHJvcGVydGllcyxcbiAgICAxMzogZWNtYTEzQmluYXJ5UHJvcGVydGllcyxcbiAgICAxNDogZWNtYTE0QmluYXJ5UHJvcGVydGllc1xuICB9O1xuXG4gIC8vICN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzLW9mLXN0cmluZ3NcbiAgdmFyIGVjbWExNEJpbmFyeVByb3BlcnRpZXNPZlN0cmluZ3MgPSBcIkJhc2ljX0Vtb2ppIEVtb2ppX0tleWNhcF9TZXF1ZW5jZSBSR0lfRW1vamlfTW9kaWZpZXJfU2VxdWVuY2UgUkdJX0Vtb2ppX0ZsYWdfU2VxdWVuY2UgUkdJX0Vtb2ppX1RhZ19TZXF1ZW5jZSBSR0lfRW1vamlfWldKX1NlcXVlbmNlIFJHSV9FbW9qaVwiO1xuXG4gIHZhciB1bmljb2RlQmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyA9IHtcbiAgICA5OiBcIlwiLFxuICAgIDEwOiBcIlwiLFxuICAgIDExOiBcIlwiLFxuICAgIDEyOiBcIlwiLFxuICAgIDEzOiBcIlwiLFxuICAgIDE0OiBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzXG4gIH07XG5cbiAgLy8gI3RhYmxlLXVuaWNvZGUtZ2VuZXJhbC1jYXRlZ29yeS12YWx1ZXNcbiAgdmFyIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMgPSBcIkNhc2VkX0xldHRlciBMQyBDbG9zZV9QdW5jdHVhdGlvbiBQZSBDb25uZWN0b3JfUHVuY3R1YXRpb24gUGMgQ29udHJvbCBDYyBjbnRybCBDdXJyZW5jeV9TeW1ib2wgU2MgRGFzaF9QdW5jdHVhdGlvbiBQZCBEZWNpbWFsX051bWJlciBOZCBkaWdpdCBFbmNsb3NpbmdfTWFyayBNZSBGaW5hbF9QdW5jdHVhdGlvbiBQZiBGb3JtYXQgQ2YgSW5pdGlhbF9QdW5jdHVhdGlvbiBQaSBMZXR0ZXIgTCBMZXR0ZXJfTnVtYmVyIE5sIExpbmVfU2VwYXJhdG9yIFpsIExvd2VyY2FzZV9MZXR0ZXIgTGwgTWFyayBNIENvbWJpbmluZ19NYXJrIE1hdGhfU3ltYm9sIFNtIE1vZGlmaWVyX0xldHRlciBMbSBNb2RpZmllcl9TeW1ib2wgU2sgTm9uc3BhY2luZ19NYXJrIE1uIE51bWJlciBOIE9wZW5fUHVuY3R1YXRpb24gUHMgT3RoZXIgQyBPdGhlcl9MZXR0ZXIgTG8gT3RoZXJfTnVtYmVyIE5vIE90aGVyX1B1bmN0dWF0aW9uIFBvIE90aGVyX1N5bWJvbCBTbyBQYXJhZ3JhcGhfU2VwYXJhdG9yIFpwIFByaXZhdGVfVXNlIENvIFB1bmN0dWF0aW9uIFAgcHVuY3QgU2VwYXJhdG9yIFogU3BhY2VfU2VwYXJhdG9yIFpzIFNwYWNpbmdfTWFyayBNYyBTdXJyb2dhdGUgQ3MgU3ltYm9sIFMgVGl0bGVjYXNlX0xldHRlciBMdCBVbmFzc2lnbmVkIENuIFVwcGVyY2FzZV9MZXR0ZXIgTHVcIjtcblxuICAvLyAjdGFibGUtdW5pY29kZS1zY3JpcHQtdmFsdWVzXG4gIHZhciBlY21hOVNjcmlwdFZhbHVlcyA9IFwiQWRsYW0gQWRsbSBBaG9tIEFuYXRvbGlhbl9IaWVyb2dseXBocyBIbHV3IEFyYWJpYyBBcmFiIEFybWVuaWFuIEFybW4gQXZlc3RhbiBBdnN0IEJhbGluZXNlIEJhbGkgQmFtdW0gQmFtdSBCYXNzYV9WYWggQmFzcyBCYXRhayBCYXRrIEJlbmdhbGkgQmVuZyBCaGFpa3N1a2kgQmhrcyBCb3BvbW9mbyBCb3BvIEJyYWhtaSBCcmFoIEJyYWlsbGUgQnJhaSBCdWdpbmVzZSBCdWdpIEJ1aGlkIEJ1aGQgQ2FuYWRpYW5fQWJvcmlnaW5hbCBDYW5zIENhcmlhbiBDYXJpIENhdWNhc2lhbl9BbGJhbmlhbiBBZ2hiIENoYWttYSBDYWttIENoYW0gQ2hhbSBDaGVyb2tlZSBDaGVyIENvbW1vbiBaeXl5IENvcHRpYyBDb3B0IFFhYWMgQ3VuZWlmb3JtIFhzdXggQ3lwcmlvdCBDcHJ0IEN5cmlsbGljIEN5cmwgRGVzZXJldCBEc3J0IERldmFuYWdhcmkgRGV2YSBEdXBsb3lhbiBEdXBsIEVneXB0aWFuX0hpZXJvZ2x5cGhzIEVneXAgRWxiYXNhbiBFbGJhIEV0aGlvcGljIEV0aGkgR2VvcmdpYW4gR2VvciBHbGFnb2xpdGljIEdsYWcgR290aGljIEdvdGggR3JhbnRoYSBHcmFuIEdyZWVrIEdyZWsgR3VqYXJhdGkgR3VqciBHdXJtdWtoaSBHdXJ1IEhhbiBIYW5pIEhhbmd1bCBIYW5nIEhhbnVub28gSGFubyBIYXRyYW4gSGF0ciBIZWJyZXcgSGViciBIaXJhZ2FuYSBIaXJhIEltcGVyaWFsX0FyYW1haWMgQXJtaSBJbmhlcml0ZWQgWmluaCBRYWFpIEluc2NyaXB0aW9uYWxfUGFobGF2aSBQaGxpIEluc2NyaXB0aW9uYWxfUGFydGhpYW4gUHJ0aSBKYXZhbmVzZSBKYXZhIEthaXRoaSBLdGhpIEthbm5hZGEgS25kYSBLYXRha2FuYSBLYW5hIEtheWFoX0xpIEthbGkgS2hhcm9zaHRoaSBLaGFyIEtobWVyIEtobXIgS2hvamtpIEtob2ogS2h1ZGF3YWRpIFNpbmQgTGFvIExhb28gTGF0aW4gTGF0biBMZXBjaGEgTGVwYyBMaW1idSBMaW1iIExpbmVhcl9BIExpbmEgTGluZWFyX0IgTGluYiBMaXN1IExpc3UgTHljaWFuIEx5Y2kgTHlkaWFuIEx5ZGkgTWFoYWphbmkgTWFoaiBNYWxheWFsYW0gTWx5bSBNYW5kYWljIE1hbmQgTWFuaWNoYWVhbiBNYW5pIE1hcmNoZW4gTWFyYyBNYXNhcmFtX0dvbmRpIEdvbm0gTWVldGVpX01heWVrIE10ZWkgTWVuZGVfS2lrYWt1aSBNZW5kIE1lcm9pdGljX0N1cnNpdmUgTWVyYyBNZXJvaXRpY19IaWVyb2dseXBocyBNZXJvIE1pYW8gUGxyZCBNb2RpIE1vbmdvbGlhbiBNb25nIE1ybyBNcm9vIE11bHRhbmkgTXVsdCBNeWFubWFyIE15bXIgTmFiYXRhZWFuIE5iYXQgTmV3X1RhaV9MdWUgVGFsdSBOZXdhIE5ld2EgTmtvIE5rb28gTnVzaHUgTnNodSBPZ2hhbSBPZ2FtIE9sX0NoaWtpIE9sY2sgT2xkX0h1bmdhcmlhbiBIdW5nIE9sZF9JdGFsaWMgSXRhbCBPbGRfTm9ydGhfQXJhYmlhbiBOYXJiIE9sZF9QZXJtaWMgUGVybSBPbGRfUGVyc2lhbiBYcGVvIE9sZF9Tb3V0aF9BcmFiaWFuIFNhcmIgT2xkX1R1cmtpYyBPcmtoIE9yaXlhIE9yeWEgT3NhZ2UgT3NnZSBPc21hbnlhIE9zbWEgUGFoYXdoX0htb25nIEhtbmcgUGFsbXlyZW5lIFBhbG0gUGF1X0Npbl9IYXUgUGF1YyBQaGFnc19QYSBQaGFnIFBob2VuaWNpYW4gUGhueCBQc2FsdGVyX1BhaGxhdmkgUGhscCBSZWphbmcgUmpuZyBSdW5pYyBSdW5yIFNhbWFyaXRhbiBTYW1yIFNhdXJhc2h0cmEgU2F1ciBTaGFyYWRhIFNocmQgU2hhdmlhbiBTaGF3IFNpZGRoYW0gU2lkZCBTaWduV3JpdGluZyBTZ253IFNpbmhhbGEgU2luaCBTb3JhX1NvbXBlbmcgU29yYSBTb3lvbWJvIFNveW8gU3VuZGFuZXNlIFN1bmQgU3lsb3RpX05hZ3JpIFN5bG8gU3lyaWFjIFN5cmMgVGFnYWxvZyBUZ2xnIFRhZ2JhbndhIFRhZ2IgVGFpX0xlIFRhbGUgVGFpX1RoYW0gTGFuYSBUYWlfVmlldCBUYXZ0IFRha3JpIFRha3IgVGFtaWwgVGFtbCBUYW5ndXQgVGFuZyBUZWx1Z3UgVGVsdSBUaGFhbmEgVGhhYSBUaGFpIFRoYWkgVGliZXRhbiBUaWJ0IFRpZmluYWdoIFRmbmcgVGlyaHV0YSBUaXJoIFVnYXJpdGljIFVnYXIgVmFpIFZhaWkgV2FyYW5nX0NpdGkgV2FyYSBZaSBZaWlpIFphbmFiYXphcl9TcXVhcmUgWmFuYlwiO1xuICB2YXIgZWNtYTEwU2NyaXB0VmFsdWVzID0gZWNtYTlTY3JpcHRWYWx1ZXMgKyBcIiBEb2dyYSBEb2dyIEd1bmphbGFfR29uZGkgR29uZyBIYW5pZmlfUm9oaW5neWEgUm9oZyBNYWthc2FyIE1ha2EgTWVkZWZhaWRyaW4gTWVkZiBPbGRfU29nZGlhbiBTb2dvIFNvZ2RpYW4gU29nZFwiO1xuICB2YXIgZWNtYTExU2NyaXB0VmFsdWVzID0gZWNtYTEwU2NyaXB0VmFsdWVzICsgXCIgRWx5bWFpYyBFbHltIE5hbmRpbmFnYXJpIE5hbmQgTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyBIbW5wIFdhbmNobyBXY2hvXCI7XG4gIHZhciBlY21hMTJTY3JpcHRWYWx1ZXMgPSBlY21hMTFTY3JpcHRWYWx1ZXMgKyBcIiBDaG9yYXNtaWFuIENocnMgRGlhayBEaXZlc19Ba3VydSBLaGl0YW5fU21hbGxfU2NyaXB0IEtpdHMgWWV6aSBZZXppZGlcIjtcbiAgdmFyIGVjbWExM1NjcmlwdFZhbHVlcyA9IGVjbWExMlNjcmlwdFZhbHVlcyArIFwiIEN5cHJvX01pbm9hbiBDcG1uIE9sZF9VeWdodXIgT3VnciBUYW5nc2EgVG5zYSBUb3RvIFZpdGhrdXFpIFZpdGhcIjtcbiAgdmFyIGVjbWExNFNjcmlwdFZhbHVlcyA9IGVjbWExM1NjcmlwdFZhbHVlcyArIFwiIFwiICsgc2NyaXB0VmFsdWVzQWRkZWRJblVuaWNvZGU7XG5cbiAgdmFyIHVuaWNvZGVTY3JpcHRWYWx1ZXMgPSB7XG4gICAgOTogZWNtYTlTY3JpcHRWYWx1ZXMsXG4gICAgMTA6IGVjbWExMFNjcmlwdFZhbHVlcyxcbiAgICAxMTogZWNtYTExU2NyaXB0VmFsdWVzLFxuICAgIDEyOiBlY21hMTJTY3JpcHRWYWx1ZXMsXG4gICAgMTM6IGVjbWExM1NjcmlwdFZhbHVlcyxcbiAgICAxNDogZWNtYTE0U2NyaXB0VmFsdWVzXG4gIH07XG5cbiAgdmFyIGRhdGEgPSB7fTtcbiAgZnVuY3Rpb24gYnVpbGRVbmljb2RlRGF0YShlY21hVmVyc2lvbikge1xuICAgIHZhciBkID0gZGF0YVtlY21hVmVyc2lvbl0gPSB7XG4gICAgICBiaW5hcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzW2VjbWFWZXJzaW9uXSArIFwiIFwiICsgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICBiaW5hcnlPZlN0cmluZ3M6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzW2VjbWFWZXJzaW9uXSksXG4gICAgICBub25CaW5hcnk6IHtcbiAgICAgICAgR2VuZXJhbF9DYXRlZ29yeTogd29yZHNSZWdleHAodW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICAgIFNjcmlwdDogd29yZHNSZWdleHAodW5pY29kZVNjcmlwdFZhbHVlc1tlY21hVmVyc2lvbl0pXG4gICAgICB9XG4gICAgfTtcbiAgICBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcblxuICAgIGQubm9uQmluYXJ5LmdjID0gZC5ub25CaW5hcnkuR2VuZXJhbF9DYXRlZ29yeTtcbiAgICBkLm5vbkJpbmFyeS5zYyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcbiAgICBkLm5vbkJpbmFyeS5zY3ggPSBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gWzksIDEwLCAxMSwgMTIsIDEzLCAxNF07IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGVjbWFWZXJzaW9uID0gbGlzdFtpXTtcblxuICAgIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pO1xuICB9XG5cbiAgdmFyIHBwJDEgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIC8vIFRyYWNrIGRpc2p1bmN0aW9uIHN0cnVjdHVyZSB0byBkZXRlcm1pbmUgd2hldGhlciBhIGR1cGxpY2F0ZVxuICAvLyBjYXB0dXJlIGdyb3VwIG5hbWUgaXMgYWxsb3dlZCBiZWNhdXNlIGl0IGlzIGluIGEgc2VwYXJhdGUgYnJhbmNoLlxuICB2YXIgQnJhbmNoSUQgPSBmdW5jdGlvbiBCcmFuY2hJRChwYXJlbnQsIGJhc2UpIHtcbiAgICAvLyBQYXJlbnQgZGlzanVuY3Rpb24gYnJhbmNoXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgLy8gSWRlbnRpZmllcyB0aGlzIHNldCBvZiBzaWJsaW5nIGJyYW5jaGVzXG4gICAgdGhpcy5iYXNlID0gYmFzZSB8fCB0aGlzO1xuICB9O1xuXG4gIEJyYW5jaElELnByb3RvdHlwZS5zZXBhcmF0ZWRGcm9tID0gZnVuY3Rpb24gc2VwYXJhdGVkRnJvbSAoYWx0KSB7XG4gICAgLy8gQSBicmFuY2ggaXMgc2VwYXJhdGUgZnJvbSBhbm90aGVyIGJyYW5jaCBpZiB0aGV5IG9yIGFueSBvZlxuICAgIC8vIHRoZWlyIHBhcmVudHMgYXJlIHNpYmxpbmdzIGluIGEgZ2l2ZW4gZGlzanVuY3Rpb25cbiAgICBmb3IgKHZhciBzZWxmID0gdGhpczsgc2VsZjsgc2VsZiA9IHNlbGYucGFyZW50KSB7XG4gICAgICBmb3IgKHZhciBvdGhlciA9IGFsdDsgb3RoZXI7IG90aGVyID0gb3RoZXIucGFyZW50KSB7XG4gICAgICAgIGlmIChzZWxmLmJhc2UgPT09IG90aGVyLmJhc2UgJiYgc2VsZiAhPT0gb3RoZXIpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBCcmFuY2hJRC5wcm90b3R5cGUuc2libGluZyA9IGZ1bmN0aW9uIHNpYmxpbmcgKCkge1xuICAgIHJldHVybiBuZXcgQnJhbmNoSUQodGhpcy5wYXJlbnQsIHRoaXMuYmFzZSlcbiAgfTtcblxuICB2YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMudmFsaWRGbGFncyA9IFwiZ2ltXCIgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IFwidXlcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgPyBcInNcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEzID8gXCJkXCIgOiBcIlwiKSArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNSA/IFwidlwiIDogXCJcIik7XG4gICAgdGhpcy51bmljb2RlUHJvcGVydGllcyA9IGRhdGFbcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTQgPyAxNCA6IHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uXTtcbiAgICB0aGlzLnNvdXJjZSA9IFwiXCI7XG4gICAgdGhpcy5mbGFncyA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zd2l0Y2hVID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hWID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMubGFzdEludFZhbHVlID0gMDtcbiAgICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgdGhpcy5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gICAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICB0aGlzLmdyb3VwTmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzID0gW107XG4gICAgdGhpcy5icmFuY2hJRCA9IG51bGw7XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0IChzdGFydCwgcGF0dGVybiwgZmxhZ3MpIHtcbiAgICB2YXIgdW5pY29kZVNldHMgPSBmbGFncy5pbmRleE9mKFwidlwiKSAhPT0gLTE7XG4gICAgdmFyIHVuaWNvZGUgPSBmbGFncy5pbmRleE9mKFwidVwiKSAhPT0gLTE7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0IHwgMDtcbiAgICB0aGlzLnNvdXJjZSA9IHBhdHRlcm4gKyBcIlwiO1xuICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICBpZiAodW5pY29kZVNldHMgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNSkge1xuICAgICAgdGhpcy5zd2l0Y2hVID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3dpdGNoViA9IHRydWU7XG4gICAgICB0aGlzLnN3aXRjaE4gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgICAgIHRoaXMuc3dpdGNoViA9IGZhbHNlO1xuICAgICAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG4gICAgfVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmFpc2UgPSBmdW5jdGlvbiByYWlzZSAobWVzc2FnZSkge1xuICAgIHRoaXMucGFyc2VyLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgKFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC9cIiArICh0aGlzLnNvdXJjZSkgKyBcIi86IFwiICsgbWVzc2FnZSkpO1xuICB9O1xuXG4gIC8vIElmIHUgZmxhZyBpcyBnaXZlbiwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBpbmRleCAoaXQgY29tYmluZXMgYSBzdXJyb2dhdGUgcGFpcikuXG4gIC8vIE90aGVyd2lzZSwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgdGhlIGluZGV4IChjYW4gYmUgYSBwYXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIpLlxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQgKGksIGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIGlmIChpID49IGwpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoIShmb3JjZVUgfHwgdGhpcy5zd2l0Y2hVKSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsKSB7XG4gICAgICByZXR1cm4gY1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSk7XG4gICAgcmV0dXJuIG5leHQgPj0gMHhEQzAwICYmIG5leHQgPD0gMHhERkZGID8gKGMgPDwgMTApICsgbmV4dCAtIDB4MzVGREMwMCA6IGNcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLm5leHRJbmRleCA9IGZ1bmN0aW9uIG5leHRJbmRleCAoaSwgZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgaWYgKGkgPj0gbCkge1xuICAgICAgcmV0dXJuIGxcbiAgICB9XG4gICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSksIG5leHQ7XG4gICAgaWYgKCEoZm9yY2VVIHx8IHRoaXMuc3dpdGNoVSkgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCB8fFxuICAgICAgICAobmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhEQzAwIHx8IG5leHQgPiAweERGRkYpIHtcbiAgICAgIHJldHVybiBpICsgMVxuICAgIH1cbiAgICByZXR1cm4gaSArIDJcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50IChmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzLmF0KHRoaXMucG9zLCBmb3JjZVUpXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5sb29rYWhlYWQgPSBmdW5jdGlvbiBsb29rYWhlYWQgKGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXMuYXQodGhpcy5uZXh0SW5kZXgodGhpcy5wb3MsIGZvcmNlVSksIGZvcmNlVSlcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiBhZHZhbmNlIChmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHRoaXMucG9zID0gdGhpcy5uZXh0SW5kZXgodGhpcy5wb3MsIGZvcmNlVSk7XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKGNoLCBmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnQoZm9yY2VVKSA9PT0gY2gpIHtcbiAgICAgIHRoaXMuYWR2YW5jZShmb3JjZVUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXRDaGFycyA9IGZ1bmN0aW9uIGVhdENoYXJzIChjaHMsIGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gY2hzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGNoID0gbGlzdFtpXTtcblxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYXQocG9zLCBmb3JjZVUpO1xuICAgICAgaWYgKGN1cnJlbnQgPT09IC0xIHx8IGN1cnJlbnQgIT09IGNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcG9zID0gdGhpcy5uZXh0SW5kZXgocG9zLCBmb3JjZVUpO1xuICAgIH1cbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgZmxhZ3MgcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHBwJDEudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHZhbGlkRmxhZ3MgPSBzdGF0ZS52YWxpZEZsYWdzO1xuICAgIHZhciBmbGFncyA9IHN0YXRlLmZsYWdzO1xuXG4gICAgdmFyIHUgPSBmYWxzZTtcbiAgICB2YXIgdiA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZsYWcgPSBmbGFncy5jaGFyQXQoaSk7XG4gICAgICBpZiAodmFsaWRGbGFncy5pbmRleE9mKGZsYWcpID09PSAtMSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZihmbGFnLCBpICsgMSkgPiAtMSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFnID09PSBcInVcIikgeyB1ID0gdHJ1ZTsgfVxuICAgICAgaWYgKGZsYWcgPT09IFwidlwiKSB7IHYgPSB0cnVlOyB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTUgJiYgdSAmJiB2KSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGhhc1Byb3Aob2JqKSB7XG4gICAgZm9yICh2YXIgXyBpbiBvYmopIHsgcmV0dXJuIHRydWUgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBwYXR0ZXJuIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwcCQxLnZhbGlkYXRlUmVnRXhwUGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG5cbiAgICAvLyBUaGUgZ29hbCBzeW1ib2wgZm9yIHRoZSBwYXJzZSBpcyB8UGF0dGVyblt+VSwgfk5dfC4gSWYgdGhlIHJlc3VsdCBvZlxuICAgIC8vIHBhcnNpbmcgY29udGFpbnMgYSB8R3JvdXBOYW1lfCwgcmVwYXJzZSB3aXRoIHRoZSBnb2FsIHN5bWJvbFxuICAgIC8vIHxQYXR0ZXJuW35VLCArTl18IGFuZCB1c2UgdGhpcyByZXN1bHQgaW5zdGVhZC4gVGhyb3cgYSAqU3ludGF4RXJyb3IqXG4gICAgLy8gZXhjZXB0aW9uIGlmIF9QXyBkaWQgbm90IGNvbmZvcm0gdG8gdGhlIGdyYW1tYXIsIGlmIGFueSBlbGVtZW50cyBvZiBfUF9cbiAgICAvLyB3ZXJlIG5vdCBtYXRjaGVkIGJ5IHRoZSBwYXJzZSwgb3IgaWYgYW55IEVhcmx5IEVycm9yIGNvbmRpdGlvbnMgZXhpc3QuXG4gICAgaWYgKCFzdGF0ZS5zd2l0Y2hOICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIGhhc1Byb3Aoc3RhdGUuZ3JvdXBOYW1lcykpIHtcbiAgICAgIHN0YXRlLnN3aXRjaE4gPSB0cnVlO1xuICAgICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5cbiAgcHAkMS5yZWdleHBfcGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUucG9zID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICBzdGF0ZS5ncm91cE5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMubGVuZ3RoID0gMDtcbiAgICBzdGF0ZS5icmFuY2hJRCA9IG51bGw7XG5cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucG9zICE9PSBzdGF0ZS5zb3VyY2UubGVuZ3RoKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2VzIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW5tYXRjaGVkICcpJ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBdICovKSB8fCBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPiBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICBpZiAoIXN0YXRlLmdyb3VwTmFtZXNbbmFtZV0pIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIGNhcHR1cmUgcmVmZXJlbmNlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGlzanVuY3Rpb25cbiAgcHAkMS5yZWdleHBfZGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciB0cmFja0Rpc2p1bmN0aW9uID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2O1xuICAgIGlmICh0cmFja0Rpc2p1bmN0aW9uKSB7IHN0YXRlLmJyYW5jaElEID0gbmV3IEJyYW5jaElEKHN0YXRlLmJyYW5jaElELCBudWxsKTsgfVxuICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgICB3aGlsZSAoc3RhdGUuZWF0KDB4N0MgLyogfCAqLykpIHtcbiAgICAgIGlmICh0cmFja0Rpc2p1bmN0aW9uKSB7IHN0YXRlLmJyYW5jaElEID0gc3RhdGUuYnJhbmNoSUQuc2libGluZygpOyB9XG4gICAgICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gICAgfVxuICAgIGlmICh0cmFja0Rpc2p1bmN0aW9uKSB7IHN0YXRlLmJyYW5jaElEID0gc3RhdGUuYnJhbmNoSUQucGFyZW50OyB9XG5cbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BbHRlcm5hdGl2ZVxuICBwcCQxLnJlZ2V4cF9hbHRlcm5hdGl2ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXRlLnNvdXJjZS5sZW5ndGggJiYgdGhpcy5yZWdleHBfZWF0VGVybShzdGF0ZSkpIHt9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLVRlcm1cbiAgcHAkMS5yZWdleHBfZWF0VGVybSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEFzc2VydGlvbihzdGF0ZSkpIHtcbiAgICAgIC8vIEhhbmRsZSBgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uIFF1YW50aWZpZXJgIGFsdGVybmF0aXZlLlxuICAgICAgLy8gYHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZWAgaXMgdHJ1ZSBpZiB0aGUgbGFzdCBlYXRlbiBBc3NlcnRpb25cbiAgICAgIC8vIGlzIGEgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uLlxuICAgICAgaWYgKHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSAmJiB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKSkge1xuICAgICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHF1YW50aWZpZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgPyB0aGlzLnJlZ2V4cF9lYXRBdG9tKHN0YXRlKSA6IHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkQXRvbShzdGF0ZSkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXNzZXJ0aW9uXG4gIHBwJDEucmVnZXhwX2VhdEFzc2VydGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuXG4gICAgLy8gXiwgJFxuICAgIGlmIChzdGF0ZS5lYXQoMHg1RSAvKiBeICovKSB8fCBzdGF0ZS5lYXQoMHgyNCAvKiAkICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBcXGIgXFxCXG4gICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDQyIC8qIEIgKi8pIHx8IHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICAvLyBMb29rYWhlYWQgLyBMb29rYmVoaW5kXG4gICAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pICYmIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgICB2YXIgbG9va2JlaGluZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIGxvb2tiZWhpbmQgPSBzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSB8fCBzdGF0ZS5lYXQoMHgyMSAvKiAhICovKSkge1xuICAgICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICAgIGlmICghc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSAhbG9va2JlaGluZDtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyXG4gIHBwJDEucmVnZXhwX2VhdFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIGlmICggbm9FcnJvciA9PT0gdm9pZCAwICkgbm9FcnJvciA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgoc3RhdGUsIG5vRXJyb3IpKSB7XG4gICAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJQcmVmaXhcbiAgcHAkMS5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeCA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXRlLmVhdCgweDJBIC8qICogKi8pIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgyQiAvKiArICovKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIG5vRXJyb3IpXG4gICAgKVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgICB2YXIgbWluID0gMCwgbWF4ID0gLTE7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgbWluID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4MkMgLyogLCAqLykgJiYgdGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgICBtYXggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgICAgLy8gU3ludGF4RXJyb3IgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3NlYy10ZXJtXG4gICAgICAgICAgaWYgKG1heCAhPT0gLTEgJiYgbWF4IDwgbWluICYmICFub0Vycm9yKSB7XG4gICAgICAgICAgICBzdGF0ZS5yYWlzZShcIm51bWJlcnMgb3V0IG9mIG9yZGVyIGluIHt9IHF1YW50aWZpZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmICFub0Vycm9yKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW5jb21wbGV0ZSBxdWFudGlmaWVyXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUF0b21cbiAgcHAkMS5yZWdleHBfZWF0QXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzKHN0YXRlKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4MkUgLyogLiAqLykgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKVxuICAgIClcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEF0b21Fc2NhcGUoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDEucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KSB7XG4gICAgICAgICAgdmFyIGFkZE1vZGlmaWVycyA9IHRoaXMucmVnZXhwX2VhdE1vZGlmaWVycyhzdGF0ZSk7XG4gICAgICAgICAgdmFyIGhhc0h5cGhlbiA9IHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pO1xuICAgICAgICAgIGlmIChhZGRNb2RpZmllcnMgfHwgaGFzSHlwaGVuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZE1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgbW9kaWZpZXIgPSBhZGRNb2RpZmllcnMuY2hhckF0KGkpO1xuICAgICAgICAgICAgICBpZiAoYWRkTW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIsIGkgKyAxKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIG1vZGlmaWVyc1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0h5cGhlbikge1xuICAgICAgICAgICAgICB2YXIgcmVtb3ZlTW9kaWZpZXJzID0gdGhpcy5yZWdleHBfZWF0TW9kaWZpZXJzKHN0YXRlKTtcbiAgICAgICAgICAgICAgaWYgKCFhZGRNb2RpZmllcnMgJiYgIXJlbW92ZU1vZGlmaWVycyAmJiBzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0EgLyogOiAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gbW9kaWZpZXJzXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHJlbW92ZU1vZGlmaWVycy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVyJDEgPSByZW1vdmVNb2RpZmllcnMuY2hhckF0KGkkMSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgcmVtb3ZlTW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIkMSwgaSQxICsgMSkgPiAtMSB8fFxuICAgICAgICAgICAgICAgICAgYWRkTW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIkMSkgPiAtMVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIG1vZGlmaWVyc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDNBIC8qIDogKi8pKSB7XG4gICAgICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2dyb3VwU3BlY2lmaWVyKHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDNGIC8qID8gKi8pIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyArPSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICAvLyBSZWd1bGFyRXhwcmVzc2lvbk1vZGlmaWVycyA6OlxuICAvLyAgIFtlbXB0eV1cbiAgLy8gICBSZWd1bGFyRXhwcmVzc2lvbk1vZGlmaWVycyBSZWd1bGFyRXhwcmVzc2lvbk1vZGlmaWVyXG4gIHBwJDEucmVnZXhwX2VhdE1vZGlmaWVycyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIG1vZGlmaWVycyA9IFwiXCI7XG4gICAgdmFyIGNoID0gMDtcbiAgICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgaXNSZWd1bGFyRXhwcmVzc2lvbk1vZGlmaWVyKGNoKSkge1xuICAgICAgbW9kaWZpZXJzICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGlmaWVyc1xuICB9O1xuICAvLyBSZWd1bGFyRXhwcmVzc2lvbk1vZGlmaWVyIDo6IG9uZSBvZlxuICAvLyAgIGBpYCBgbWAgYHNgXG4gIGZ1bmN0aW9uIGlzUmVndWxhckV4cHJlc3Npb25Nb2RpZmllcihjaCkge1xuICAgIHJldHVybiBjaCA9PT0gMHg2OSAvKiBpICovIHx8IGNoID09PSAweDZkIC8qIG0gKi8gfHwgY2ggPT09IDB4NzMgLyogcyAqL1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkQXRvbVxuICBwcCQxLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUludmFsaWRCcmFjZWRRdWFudGlmaWVyXG4gIHBwJDEucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVN5bnRheENoYXJhY3RlclxuICBwcCQxLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1N5bnRheENoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyNCAvKiAkICovIHx8XG4gICAgICBjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovIHx8XG4gICAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgICBjaCA9PT0gMHgzRiAvKiA/ICovIHx8XG4gICAgICBjaCA+PSAweDVCIC8qIFsgKi8gJiYgY2ggPD0gMHg1RSAvKiBeICovIHx8XG4gICAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVybkNoYXJhY3RlclxuICAvLyBCdXQgZWF0IGVhZ2VyLlxuICBwcCQxLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgIT09IC0xICYmICFpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyXG4gIHBwJDEucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChcbiAgICAgIGNoICE9PSAtMSAmJlxuICAgICAgY2ggIT09IDB4MjQgLyogJCAqLyAmJlxuICAgICAgIShjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovKSAmJlxuICAgICAgY2ggIT09IDB4MkUgLyogLiAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YgLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4NUIgLyogWyAqLyAmJlxuICAgICAgY2ggIT09IDB4NUUgLyogXiAqLyAmJlxuICAgICAgY2ggIT09IDB4N0MgLyogfCAqL1xuICAgICkge1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gR3JvdXBTcGVjaWZpZXIgOjpcbiAgLy8gICBbZW1wdHldXG4gIC8vICAgYD9gIEdyb3VwTmFtZVxuICBwcCQxLnJlZ2V4cF9ncm91cFNwZWNpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgICBpZiAoIXRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpOyB9XG4gICAgICB2YXIgdHJhY2tEaXNqdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNjtcbiAgICAgIHZhciBrbm93biA9IHN0YXRlLmdyb3VwTmFtZXNbc3RhdGUubGFzdFN0cmluZ1ZhbHVlXTtcbiAgICAgIGlmIChrbm93bikge1xuICAgICAgICBpZiAodHJhY2tEaXNqdW5jdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0ga25vd247IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgYWx0SUQgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgICBpZiAoIWFsdElELnNlcGFyYXRlZEZyb20oc3RhdGUuYnJhbmNoSUQpKVxuICAgICAgICAgICAgICB7IHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0cmFja0Rpc2p1bmN0aW9uKSB7XG4gICAgICAgIChrbm93biB8fCAoc3RhdGUuZ3JvdXBOYW1lc1tzdGF0ZS5sYXN0U3RyaW5nVmFsdWVdID0gW10pKS5wdXNoKHN0YXRlLmJyYW5jaElEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmdyb3VwTmFtZXNbc3RhdGUubGFzdFN0cmluZ1ZhbHVlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEdyb3VwTmFtZSA6OlxuICAvLyAgIGA8YCBSZWdFeHBJZGVudGlmaWVyTmFtZSBgPmBcbiAgLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG4gIHBwJDEucmVnZXhwX2VhdEdyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0MgLyogPCAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0UgLyogPiAqLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIFJlZ0V4cElkZW50aWZpZXJOYW1lIDo6XG4gIC8vICAgUmVnRXhwSWRlbnRpZmllclN0YXJ0XG4gIC8vICAgUmVnRXhwSWRlbnRpZmllck5hbWUgUmVnRXhwSWRlbnRpZmllclBhcnRcbiAgLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG4gIHBwJDEucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQoc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydChzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBSZWdFeHBJZGVudGlmaWVyU3RhcnQgOjpcbiAgLy8gICBVbmljb2RlSURTdGFydFxuICAvLyAgIGAkYFxuICAvLyAgIGBfYFxuICAvLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWytVXVxuICBwcCQxLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgZm9yY2VVID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoZm9yY2VVKTtcbiAgICBzdGF0ZS5hZHZhbmNlKGZvcmNlVSk7XG5cbiAgICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmb3JjZVUpKSB7XG4gICAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJTdGFydChjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG4gIH1cblxuICAvLyBSZWdFeHBJZGVudGlmaWVyUGFydCA6OlxuICAvLyAgIFVuaWNvZGVJRENvbnRpbnVlXG4gIC8vICAgYCRgXG4gIC8vICAgYF9gXG4gIC8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbK1VdXG4gIC8vICAgPFpXTko+XG4gIC8vICAgPFpXSj5cbiAgcHAkMS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgZm9yY2VVID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoZm9yY2VVKTtcbiAgICBzdGF0ZS5hZHZhbmNlKGZvcmNlVSk7XG5cbiAgICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmb3JjZVUpKSB7XG4gICAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICByZXR1cm4gaXNJZGVudGlmaWVyQ2hhcihjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovIHx8IGNoID09PSAweDIwMEMgLyogPFpXTko+ICovIHx8IGNoID09PSAweDIwMEQgLyogPFpXSj4gKi9cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1BdG9tRXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdEF0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2Uoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIChzdGF0ZS5zd2l0Y2hOICYmIHRoaXMucmVnZXhwX2VhdEtHcm91cE5hbWUoc3RhdGUpKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4NjMgLyogYyAqLykge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0QmFja1JlZmVyZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlKHN0YXRlKSkge1xuICAgICAgdmFyIG4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICAvLyBGb3IgU3ludGF4RXJyb3IgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3NlYy1hdG9tZXNjYXBlXG4gICAgICAgIGlmIChuID4gc3RhdGUubWF4QmFja1JlZmVyZW5jZSkge1xuICAgICAgICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAobiA8PSBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0S0dyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDZCIC8qIGsgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIHJlZmVyZW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNoYXJhY3RlckVzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRaZXJvKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZhbHNlKSB8fFxuICAgICAgKCFzdGF0ZS5zd2l0Y2hVICYmIHRoaXMucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUoc3RhdGUpXG4gICAgKVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDEucmVnZXhwX2VhdFplcm8gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4MzAgLyogMCAqLyAmJiAhaXNEZWNpbWFsRGlnaXQoc3RhdGUubG9va2FoZWFkKCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbEVzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoID09PSAweDc0IC8qIHQgKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDk7IC8qIFxcdCAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDZFIC8qIG4gKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEE7IC8qIFxcbiAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDc2IC8qIHYgKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEI7IC8qIFxcdiAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDY2IC8qIGYgKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEM7IC8qIFxcZiAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDcyIC8qIHIgKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEQ7IC8qIFxcciAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbExldHRlclxuICBwcCQxLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzQ29udHJvbExldHRlcihjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDVBIC8qIFogKi8pIHx8XG4gICAgICAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4N0EgLyogeiAqLylcbiAgICApXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1SZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VcbiAgcHAkMS5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUsIGZvcmNlVSkge1xuICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgc3dpdGNoVSA9IGZvcmNlVSB8fCBzdGF0ZS5zd2l0Y2hVO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgIHZhciBsZWFkID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3dpdGNoVSAmJiBsZWFkID49IDB4RDgwMCAmJiBsZWFkIDw9IDB4REJGRikge1xuICAgICAgICAgIHZhciBsZWFkU3Vycm9nYXRlRW5kID0gc3RhdGUucG9zO1xuICAgICAgICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykgJiYgc3RhdGUuZWF0KDB4NzUgLyogdSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgICAgICB2YXIgdHJhaWwgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgICAgICBpZiAodHJhaWwgPj0gMHhEQzAwICYmIHRyYWlsIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5wb3MgPSBsZWFkU3Vycm9nYXRlRW5kO1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGxlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgc3dpdGNoVSAmJlxuICAgICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhEaWdpdHMoc3RhdGUpICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pICYmXG4gICAgICAgIGlzVmFsaWRVbmljb2RlKHN0YXRlLmxhc3RJbnRWYWx1ZSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzVmFsaWRVbmljb2RlKGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDAgJiYgY2ggPD0gMHgxMEZGRkZcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JZGVudGl0eUVzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkYgLyogLyAqLykpIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRjsgLyogLyAqL1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCAhPT0gMHg2MyAvKiBjICovICYmICghc3RhdGUuc3dpdGNoTiB8fCBjaCAhPT0gMHg2QiAvKiBrICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxFc2NhcGVcbiAgcHAkMS5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoID49IDB4MzEgLyogMSAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICAgIGRvIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICB9IHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBSZXR1cm4gdmFsdWVzIHVzZWQgYnkgY2hhcmFjdGVyIHNldCBwYXJzaW5nIG1ldGhvZHMsIG5lZWRlZCB0b1xuICAvLyBmb3JiaWQgbmVnYXRpb24gb2Ygc2V0cyB0aGF0IGNhbiBtYXRjaCBzdHJpbmdzLlxuICB2YXIgQ2hhclNldE5vbmUgPSAwOyAvLyBOb3RoaW5nIHBhcnNlZFxuICB2YXIgQ2hhclNldE9rID0gMTsgLy8gQ29uc3RydWN0IHBhcnNlZCwgY2Fubm90IGNvbnRhaW4gc3RyaW5nc1xuICB2YXIgQ2hhclNldFN0cmluZyA9IDI7IC8vIENvbnN0cnVjdCBwYXJzZWQsIGNhbiBjb250YWluIHN0cmluZ3NcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc0VzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuXG4gICAgaWYgKGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiBDaGFyU2V0T2tcbiAgICB9XG5cbiAgICB2YXIgbmVnYXRlID0gZmFsc2U7XG4gICAgaWYgKFxuICAgICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiZcbiAgICAgICgobmVnYXRlID0gY2ggPT09IDB4NTAgLyogUCAqLykgfHwgY2ggPT09IDB4NzAgLyogcCAqLylcbiAgICApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgICAgKHJlc3VsdCA9IHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihzdGF0ZSkpICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pXG4gICAgICApIHtcbiAgICAgICAgaWYgKG5lZ2F0ZSAmJiByZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIENoYXJTZXROb25lXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHg2NCAvKiBkICovIHx8XG4gICAgICBjaCA9PT0gMHg0NCAvKiBEICovIHx8XG4gICAgICBjaCA9PT0gMHg3MyAvKiBzICovIHx8XG4gICAgICBjaCA9PT0gMHg1MyAvKiBTICovIHx8XG4gICAgICBjaCA9PT0gMHg3NyAvKiB3ICovIHx8XG4gICAgICBjaCA9PT0gMHg1NyAvKiBXICovXG4gICAgKVxuICB9XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uIDo6XG4gIC8vICAgVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbiAgLy8gICBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbiAgcHAkMS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICAvLyBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSkge1xuICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoc3RhdGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIENoYXJTZXRPa1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcblxuICAgIC8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUpKSB7XG4gICAgICB2YXIgbmFtZU9yVmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSwgbmFtZU9yVmFsdWUpXG4gICAgfVxuICAgIHJldHVybiBDaGFyU2V0Tm9uZVxuICB9O1xuXG4gIHBwJDEucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFoYXNPd24oc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5LCBuYW1lKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeVtuYW1lXS50ZXN0KHZhbHVlKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IHZhbHVlXCIpOyB9XG4gIH07XG5cbiAgcHAkMS5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lT3JWYWx1ZSkge1xuICAgIGlmIChzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnkudGVzdChuYW1lT3JWYWx1ZSkpIHsgcmV0dXJuIENoYXJTZXRPayB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFYgJiYgc3RhdGUudW5pY29kZVByb3BlcnRpZXMuYmluYXJ5T2ZTdHJpbmdzLnRlc3QobmFtZU9yVmFsdWUpKSB7IHJldHVybiBDaGFyU2V0U3RyaW5nIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgfTtcblxuICAvLyBVbmljb2RlUHJvcGVydHlOYW1lIDo6XG4gIC8vICAgVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcnNcbiAgcHAkMS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIGlzQ29udHJvbExldHRlcihjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqL1xuICB9XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5VmFsdWUgOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbiAgcHAkMS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbiAgfTtcbiAgZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKVxuICB9XG5cbiAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIDo6XG4gIC8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG4gIHBwJDEucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzXG4gIHBwJDEucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUIgLyogWyAqLykpIHtcbiAgICAgIHZhciBuZWdhdGUgPSBzdGF0ZS5lYXQoMHg1RSAvKiBeICovKTtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc0NvbnRlbnRzKHN0YXRlKTtcbiAgICAgIGlmICghc3RhdGUuZWF0KDB4NUQgLyogXSAqLykpXG4gICAgICAgIHsgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzXCIpOyB9XG4gICAgICBpZiAobmVnYXRlICYmIHJlc3VsdCA9PT0gQ2hhclNldFN0cmluZylcbiAgICAgICAgeyBzdGF0ZS5yYWlzZShcIk5lZ2F0ZWQgY2hhcmFjdGVyIGNsYXNzIG1heSBjb250YWluIHN0cmluZ3NcIik7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzQ29udGVudHNcbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NSYW5nZXNcbiAgcHAkMS5yZWdleHBfY2xhc3NDb250ZW50cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg1RCAvKiBdICovKSB7IHJldHVybiBDaGFyU2V0T2sgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hWKSB7IHJldHVybiB0aGlzLnJlZ2V4cF9jbGFzc1NldEV4cHJlc3Npb24oc3RhdGUpIH1cbiAgICB0aGlzLnJlZ2V4cF9ub25FbXB0eUNsYXNzUmFuZ2VzKHN0YXRlKTtcbiAgICByZXR1cm4gQ2hhclNldE9rXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc1xuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXG4gIHBwJDEucmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICAgIHZhciByaWdodCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgKGxlZnQgPT09IC0xIHx8IHJpZ2h0ID09PSAtMSkpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0ICE9PSAtMSAmJiByaWdodCAhPT0gLTEgJiYgbGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbVxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21Ob0Rhc2hcbiAgcHAkMS5yZWdleHBfZWF0Q2xhc3NBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NFc2NhcGUoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICAgIHZhciBjaCQxID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgICBpZiAoY2gkMSA9PT0gMHg2MyAvKiBjICovIHx8IGlzT2N0YWxEaWdpdChjaCQxKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjbGFzcyBlc2NhcGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggIT09IDB4NUQgLyogXSAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0VzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyAvKiA8QlM+ICovXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJEOyAvKiAtICovXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICghc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRFeHByZXNzaW9uXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzVW5pb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NJbnRlcnNlY3Rpb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdWJ0cmFjdGlvblxuICBwcCQxLnJlZ2V4cF9jbGFzc1NldEV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBDaGFyU2V0T2ssIHN1YlJlc3VsdDtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRSYW5nZShzdGF0ZSkpIDsgZWxzZSBpZiAoc3ViUmVzdWx0ID0gdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKHN0YXRlKSkge1xuICAgICAgaWYgKHN1YlJlc3VsdCA9PT0gQ2hhclNldFN0cmluZykgeyByZXN1bHQgPSBDaGFyU2V0U3RyaW5nOyB9XG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc0ludGVyc2VjdGlvblxuICAgICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgICAgd2hpbGUgKHN0YXRlLmVhdENoYXJzKFsweDI2LCAweDI2XSAvKiAmJiAqLykpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0YXRlLmN1cnJlbnQoKSAhPT0gMHgyNiAvKiAmICovICYmXG4gICAgICAgICAgKHN1YlJlc3VsdCA9IHRoaXMucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZChzdGF0ZSkpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChzdWJSZXN1bHQgIT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldE9rOyB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gc3RhdGUucG9zKSB7IHJldHVybiByZXN1bHQgfVxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdWJ0cmFjdGlvblxuICAgICAgd2hpbGUgKHN0YXRlLmVhdENoYXJzKFsweDJELCAweDJEXSAvKiAtLSAqLykpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZChzdGF0ZSkpIHsgY29udGludWUgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gc3RhdGUucG9zKSB7IHJldHVybiByZXN1bHQgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NVbmlvblxuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlKHN0YXRlKSkgeyBjb250aW51ZSB9XG4gICAgICBzdWJSZXN1bHQgPSB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoc3RhdGUpO1xuICAgICAgaWYgKCFzdWJSZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgICBpZiAoc3ViUmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKSB7IHJlc3VsdCA9IENoYXJTZXRTdHJpbmc7IH1cbiAgICB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRSYW5nZVxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyKHN0YXRlKSkge1xuICAgICAgdmFyIGxlZnQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkQgLyogLSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHZhciByaWdodCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldE9wZXJhbmRcbiAgcHAkMS5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIoc3RhdGUpKSB7IHJldHVybiBDaGFyU2V0T2sgfVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRDbGFzc1N0cmluZ0Rpc2p1bmN0aW9uKHN0YXRlKSB8fCB0aGlzLnJlZ2V4cF9lYXROZXN0ZWRDbGFzcyhzdGF0ZSlcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1OZXN0ZWRDbGFzc1xuICBwcCQxLnJlZ2V4cF9lYXROZXN0ZWRDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QiAvKiBbICovKSkge1xuICAgICAgdmFyIG5lZ2F0ZSA9IHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVnZXhwX2NsYXNzQ29udGVudHMoc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDVEIC8qIF0gKi8pKSB7XG4gICAgICAgIGlmIChuZWdhdGUgJiYgcmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJOZWdhdGVkIGNoYXJhY3RlciBjbGFzcyBtYXkgY29udGFpbiBzdHJpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgICB2YXIgcmVzdWx0JDEgPSB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0JDEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCQxXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N0cmluZ0Rpc2p1bmN0aW9uXG4gIHBwJDEucmVnZXhwX2VhdENsYXNzU3RyaW5nRGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0Q2hhcnMoWzB4NUMsIDB4NzFdIC8qIFxccSAqLykpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWdleHBfY2xhc3NTdHJpbmdEaXNqdW5jdGlvbkNvbnRlbnRzKHN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHNcbiAgcHAkMS5yZWdleHBfY2xhc3NTdHJpbmdEaXNqdW5jdGlvbkNvbnRlbnRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWdleHBfY2xhc3NTdHJpbmcoc3RhdGUpO1xuICAgIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2NsYXNzU3RyaW5nKHN0YXRlKSA9PT0gQ2hhclNldFN0cmluZykgeyByZXN1bHQgPSBDaGFyU2V0U3RyaW5nOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N0cmluZ1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1Ob25FbXB0eUNsYXNzU3RyaW5nXG4gIHBwJDEucmVnZXhwX2NsYXNzU3RyaW5nID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHsgY291bnQrKzsgfVxuICAgIHJldHVybiBjb3VudCA9PT0gMSA/IENoYXJTZXRPayA6IENoYXJTZXRTdHJpbmdcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldENoYXJhY3RlclxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihzdGF0ZSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IC8qIDxCUz4gKi9cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPCAwIHx8IGNoID09PSBzdGF0ZS5sb29rYWhlYWQoKSAmJiBpc0NsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yQ2hhcmFjdGVyKGNoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChpc0NsYXNzU2V0U3ludGF4Q2hhcmFjdGVyKGNoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yXG4gIGZ1bmN0aW9uIGlzQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4MjEgLyogISAqLyB8fFxuICAgICAgY2ggPj0gMHgyMyAvKiAjICovICYmIGNoIDw9IDB4MjYgLyogJiAqLyB8fFxuICAgICAgY2ggPj0gMHgyQSAvKiAqICovICYmIGNoIDw9IDB4MkMgLyogLCAqLyB8fFxuICAgICAgY2ggPT09IDB4MkUgLyogLiAqLyB8fFxuICAgICAgY2ggPj0gMHgzQSAvKiA6ICovICYmIGNoIDw9IDB4NDAgLyogQCAqLyB8fFxuICAgICAgY2ggPT09IDB4NUUgLyogXiAqLyB8fFxuICAgICAgY2ggPT09IDB4NjAgLyogYCAqLyB8fFxuICAgICAgY2ggPT09IDB4N0UgLyogfiAqL1xuICAgIClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0U3ludGF4Q2hhcmFjdGVyXG4gIGZ1bmN0aW9uIGlzQ2xhc3NTZXRTeW50YXhDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4MjggLyogKCAqLyB8fFxuICAgICAgY2ggPT09IDB4MjkgLyogKSAqLyB8fFxuICAgICAgY2ggPT09IDB4MkQgLyogLSAqLyB8fFxuICAgICAgY2ggPT09IDB4MkYgLyogLyAqLyB8fFxuICAgICAgY2ggPj0gMHg1QiAvKiBbICovICYmIGNoIDw9IDB4NUQgLyogXSAqLyB8fFxuICAgICAgY2ggPj0gMHg3QiAvKiB7ICovICYmIGNoIDw9IDB4N0QgLyogfSAqL1xuICAgIClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yXG4gIHBwJDEucmVnZXhwX2VhdENsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yXG4gIGZ1bmN0aW9uIGlzQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4MjEgLyogISAqLyB8fFxuICAgICAgY2ggPT09IDB4MjMgLyogIyAqLyB8fFxuICAgICAgY2ggPT09IDB4MjUgLyogJSAqLyB8fFxuICAgICAgY2ggPT09IDB4MjYgLyogJiAqLyB8fFxuICAgICAgY2ggPT09IDB4MkMgLyogLCAqLyB8fFxuICAgICAgY2ggPT09IDB4MkQgLyogLSAqLyB8fFxuICAgICAgY2ggPj0gMHgzQSAvKiA6ICovICYmIGNoIDw9IDB4M0UgLyogPiAqLyB8fFxuICAgICAgY2ggPT09IDB4NDAgLyogQCAqLyB8fFxuICAgICAgY2ggPT09IDB4NjAgLyogYCAqLyB8fFxuICAgICAgY2ggPT09IDB4N0UgLyogfiAqL1xuICAgIClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0NvbnRyb2xMZXR0ZXJcbiAgcHAkMS5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxuICBwcCQxLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg3OCAvKiB4ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRGlnaXRzXG4gIHBwJDEucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdHNcbiAgcHAkMS5yZWdleHBfZWF0SGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHdoaWxlIChpc0hleERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG4gIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHx8XG4gICAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykgfHxcbiAgICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKVxuICAgIClcbiAgfVxuICBmdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICAgIGlmIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB7XG4gICAgICByZXR1cm4gMTAgKyAoY2ggLSAweDQxIC8qIEEgKi8pXG4gICAgfVxuICAgIGlmIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKSB7XG4gICAgICByZXR1cm4gMTAgKyAoY2ggLSAweDYxIC8qIGEgKi8pXG4gICAgfVxuICAgIHJldHVybiBjaCAtIDB4MzAgLyogMCAqL1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUxlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2VcbiAgLy8gQWxsb3dzIG9ubHkgMC0zNzcob2N0YWwpIGkuZS4gMC0yNTUoZGVjaW1hbCkuXG4gIHBwJDEucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgdmFyIG4xID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgIHZhciBuMiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKG4xIDw9IDMgJiYgdGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDY0ICsgbjIgKiA4ICsgc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogOCArIG4yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU9jdGFsRGlnaXRcbiAgcHAkMS5yZWdleHBfZWF0T2N0YWxEaWdpdCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAtIDB4MzA7IC8qIDAgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzNyAvKiA3ICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXg0RGlnaXRzXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0XG4gIC8vIEFuZCBIZXhEaWdpdCBIZXhEaWdpdCBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxuICBwcCQxLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIE9iamVjdCB0eXBlIHVzZWQgdG8gcmVwcmVzZW50IHRva2Vucy4gTm90ZSB0aGF0IG5vcm1hbGx5LCB0b2tlbnNcbiAgLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuICAvLyB1c2VkIGZvciB0aGUgb25Ub2tlbiBjYWxsYmFjayBhbmQgdGhlIGV4dGVybmFsIHRva2VuaXplci5cblxuICB2YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihwKSB7XG4gICAgdGhpcy50eXBlID0gcC50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBwLnZhbHVlO1xuICAgIHRoaXMuc3RhcnQgPSBwLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gcC5lbmQ7XG4gICAgaWYgKHAub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHAsIHAuc3RhcnRMb2MsIHAuZW5kTG9jKTsgfVxuICAgIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyB0aGlzLnJhbmdlID0gW3Auc3RhcnQsIHAuZW5kXTsgfVxuICB9O1xuXG4gIC8vICMjIFRva2VuaXplclxuXG4gIHZhciBwcCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gTW92ZSB0byB0aGUgbmV4dCB0b2tlblxuXG4gIHBwLm5leHQgPSBmdW5jdGlvbihpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCkge1xuICAgIGlmICghaWdub3JlRXNjYXBlU2VxdWVuY2VJbktleXdvcmQgJiYgdGhpcy50eXBlLmtleXdvcmQgJiYgdGhpcy5jb250YWluc0VzYylcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgXCIgKyB0aGlzLnR5cGUua2V5d29yZCk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vblRva2VuKG5ldyBUb2tlbih0aGlzKSk7IH1cblxuICAgIHRoaXMubGFzdFRva0VuZCA9IHRoaXMuZW5kO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgfTtcblxuICBwcC5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiBuZXcgVG9rZW4odGhpcylcbiAgfTtcblxuICAvLyBJZiB3ZSdyZSBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIG1ha2UgcGFyc2VycyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICB7IHBwW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzJDEkMS5nZXRUb2tlbigpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0b2tlbi50eXBlID09PSB0eXBlcyQxLmVvZixcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IH1cblxuICAvLyBUb2dnbGUgc3RyaWN0IG1vZGUuIFJlLXJlYWRzIHRoZSBuZXh0IG51bWJlciBvciBzdHJpbmcgdG8gcGxlYXNlXG4gIC8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxuICAvLyBSZWFkIGEgc2luZ2xlIHRva2VuLCB1cGRhdGluZyB0aGUgcGFyc2VyIG9iamVjdCdzIHRva2VuLXJlbGF0ZWRcbiAgLy8gcHJvcGVydGllcy5cblxuICBwcC5uZXh0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgIGlmICghY3VyQ29udGV4dCB8fCAhY3VyQ29udGV4dC5wcmVzZXJ2ZVNwYWNlKSB7IHRoaXMuc2tpcFNwYWNlKCk7IH1cblxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLnN0YXJ0TG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuZW9mKSB9XG5cbiAgICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gICAgZWxzZSB7IHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7IH1cbiAgfTtcblxuICBwcC5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgLy8gSWRlbnRpZmllciBvciBrZXl3b3JkLiAnXFx1WFhYWCcgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIGluXG4gICAgLy8gaWRlbnRpZmllcnMsIHNvICdcXCcgYWxzbyBkaXNwYXRjaGVzIHRvIHRoYXQuXG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKVxuICAgICAgeyByZXR1cm4gdGhpcy5yZWFkV29yZCgpIH1cblxuICAgIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSlcbiAgfTtcblxuICBwcC5mdWxsQ2hhckNvZGVBdFBvcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGRjMDApIHsgcmV0dXJuIGNvZGUgfVxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgcmV0dXJuIG5leHQgPD0gMHhkYmZmIHx8IG5leHQgPj0gMHhlMDAwID8gY29kZSA6IChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDBcbiAgfTtcblxuICBwcC5za2lwQmxvY2tDb21tZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICAgIGlmIChlbmQgPT09IC0xKSB7IHRoaXMucmFpc2UodGhpcy5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpOyB9XG4gICAgdGhpcy5wb3MgPSBlbmQgKyAyO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBuZXh0QnJlYWsgPSAodm9pZCAwKSwgcG9zID0gc3RhcnQ7IChuZXh0QnJlYWsgPSBuZXh0TGluZUJyZWFrKHRoaXMuaW5wdXQsIHBvcywgdGhpcy5wb3MpKSA+IC0xOykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgcG9zID0gdGhpcy5saW5lU3RhcnQgPSBuZXh0QnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG4gIH07XG5cbiAgcHAuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24oc3RhcnRTa2lwKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICs9IHN0YXJ0U2tpcCk7XG4gICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgIWlzTmV3TGluZShjaCkpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuICAvLyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYW5kLlxuXG4gIHBwLnNraXBTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICAgIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAzMjogY2FzZSAxNjA6IC8vICcgJ1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTA6IGNhc2UgODIzMjogY2FzZSA4MjMzOlxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDc6IC8vICcvJ1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpKSB7XG4gICAgICAgIGNhc2UgNDI6IC8vICcqJ1xuICAgICAgICAgIHRoaXMuc2tpcEJsb2NrQ29tbWVudCgpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIENhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHRva2VuLiBTZXRzIGBlbmRgLCBgdmFsYCwgYW5kXG4gIC8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbiAgLy8gdGhlIHRva2VuLCBzbyB0aGF0IHRoZSBuZXh0IG9uZSdzIGBzdGFydGAgd2lsbCBwb2ludCBhdCB0aGVcbiAgLy8gcmlnaHQgcG9zaXRpb24uXG5cbiAgcHAuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIHtcbiAgICB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gICAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICAgIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG4gIH07XG5cbiAgLy8gIyMjIFRva2VuIHJlYWRpbmdcblxuICAvLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbiAgLy8gaXMgc29tZXdoYXQgb2JzY3VyZSwgYmVjYXVzZSBpdCB3b3JrcyBpbiBjaGFyYWN0ZXIgY29kZXMgcmF0aGVyXG4gIC8vIHRoYW4gY2hhcmFjdGVycywgYW5kIGJlY2F1c2Ugb3BlcmF0b3IgcGFyc2luZyBoYXMgYmVlbiBpbmxpbmVkXG4gIC8vIGludG8gaXQuXG4gIC8vXG4gIC8vIEFsbCBpbiB0aGUgbmFtZSBvZiBzcGVlZC5cbiAgLy9cbiAgcHAucmVhZFRva2VuX2RvdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbmV4dCA9PT0gNDYgJiYgbmV4dDIgPT09IDQ2KSB7IC8vIDQ2ID0gZG90ICcuJ1xuICAgICAgdGhpcy5wb3MgKz0gMztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuZWxsaXBzaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmRvdClcbiAgICB9XG4gIH07XG5cbiAgcHAucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24oKSB7IC8vICcvJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnNsYXNoLCAxKVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICclKidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHZhciBzaXplID0gMTtcbiAgICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0eXBlcyQxLnN0YXIgOiB0eXBlcyQxLm1vZHVsbztcblxuICAgIC8vIGV4cG9uZW50aWF0aW9uIG9wZXJhdG9yICoqIGFuZCAqKj1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICAgICsrc2l6ZTtcbiAgICAgIHRva2VudHlwZSA9IHR5cGVzJDEuc3RhcnN0YXI7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCBzaXplICsgMSkgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbiAgfTtcblxuICBwcC5yZWFkVG9rZW5fcGlwZV9hbXAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICd8JidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEyKSB7XG4gICAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgICBpZiAobmV4dDIgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAzKSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcyQxLmxvZ2ljYWxPUiA6IHR5cGVzJDEubG9naWNhbEFORCwgMilcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMkMS5iaXR3aXNlT1IgOiB0eXBlcyQxLmJpdHdpc2VBTkQsIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX2NhcmV0ID0gZnVuY3Rpb24oKSB7IC8vICdeJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5iaXR3aXNlWE9SLCAxKVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbl9wbHVzX21pbiA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJystJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmIChuZXh0ID09PSA0NSAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgJiZcbiAgICAgICAgICAodGhpcy5sYXN0VG9rRW5kID09PSAwIHx8IGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnBvcykpKSkge1xuICAgICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuaW5jRGVjLCAyKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnBsdXNNaW4sIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPD4nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIHNpemUgPSBjb2RlID09PSA2MiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmJpdFNoaWZ0LCBzaXplKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09PSA0NSkge1xuICAgICAgLy8gYDwhLS1gLCBhbiBYTUwtc3R5bGUgY29tbWVudCB0aGF0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHNpemUgPSAyOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5yZWxhdGlvbmFsLCBzaXplKVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbl9lcV9leGNsID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPSEnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgICBpZiAoY29kZSA9PT0gNjEgJiYgbmV4dCA9PT0gNjIgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgLy8gJz0+J1xuICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYXJyb3cpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gdHlwZXMkMS5lcSA6IHR5cGVzJDEucHJlZml4LCAxKVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbl9xdWVzdGlvbiA9IGZ1bmN0aW9uKCkgeyAvLyAnPydcbiAgICB2YXIgZWNtYVZlcnNpb24gPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb247XG4gICAgaWYgKGVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgaWYgKG5leHQgPT09IDQ2KSB7XG4gICAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgICBpZiAobmV4dDIgPCA0OCB8fCBuZXh0MiA+IDU3KSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucXVlc3Rpb25Eb3QsIDIpIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXh0ID09PSA2Mykge1xuICAgICAgICBpZiAoZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgICAgICB2YXIgbmV4dDIkMSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgICAgIGlmIChuZXh0MiQxID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMykgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuY29hbGVzY2UsIDIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucXVlc3Rpb24sIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX251bWJlclNpZ24gPSBmdW5jdGlvbigpIHsgLy8gJyMnXG4gICAgdmFyIGVjbWFWZXJzaW9uID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uO1xuICAgIHZhciBjb2RlID0gMzU7IC8vICcjJ1xuICAgIGlmIChlY21hVmVyc2lvbiA+PSAxMykge1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGNvZGUgPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdHJ1ZSkgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLykge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnByaXZhdGVJZCwgdGhpcy5yZWFkV29yZDEoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xuICB9O1xuXG4gIHBwLmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAgIC8vIGJ5IGEgZGlnaXQgb3IgYW5vdGhlciB0d28gZG90cy5cbiAgICBjYXNlIDQ2OiAvLyAnLidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKVxuXG4gICAgLy8gUHVuY3R1YXRpb24gdG9rZW5zLlxuICAgIGNhc2UgNDA6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucGFyZW5MKVxuICAgIGNhc2UgNDE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucGFyZW5SKVxuICAgIGNhc2UgNTk6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuc2VtaSlcbiAgICBjYXNlIDQ0OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmNvbW1hKVxuICAgIGNhc2UgOTE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2tldEwpXG4gICAgY2FzZSA5MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFja2V0UilcbiAgICBjYXNlIDEyMzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFjZUwpXG4gICAgY2FzZSAxMjU6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2VSKVxuICAgIGNhc2UgNTg6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuY29sb24pXG5cbiAgICBjYXNlIDk2OiAvLyAnYCdcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJhY2tRdW90ZSlcblxuICAgIGNhc2UgNDg6IC8vICcwJ1xuICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICAgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KSB9IC8vICcweCcsICcwWCcgLSBoZXggbnVtYmVyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoOCkgfSAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMikgfSAvLyAnMGInLCAnMEInIC0gYmluYXJ5IG51bWJlclxuICAgICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZSBiZWdpbm5pbmcgd2l0aCBhIGRpZ2l0IGlzIGFuIGludGVnZXIsIG9jdGFsXG4gICAgLy8gbnVtYmVyLCBvciBmbG9hdC5cbiAgICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiAvLyAxLTlcbiAgICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIoZmFsc2UpXG5cbiAgICAvLyBRdW90ZXMgcHJvZHVjZSBzdHJpbmdzLlxuICAgIGNhc2UgMzQ6IGNhc2UgMzk6IC8vICdcIicsIFwiJ1wiXG4gICAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKGNvZGUpXG5cbiAgICAvLyBPcGVyYXRvcnMgYXJlIHBhcnNlZCBpbmxpbmUgaW4gdGlueSBzdGF0ZSBtYWNoaW5lcy4gJz0nICg2MSkgaXNcbiAgICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAgIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gICAgLy8gb2YgdGhlIHR5cGUgZ2l2ZW4gYnkgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICAgIGNhc2UgNDc6IC8vICcvJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3NsYXNoKClcblxuICAgIGNhc2UgMzc6IGNhc2UgNDI6IC8vICclKidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSlcblxuICAgIGNhc2UgMTI0OiBjYXNlIDM4OiAvLyAnfCYnXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSlcblxuICAgIGNhc2UgOTQ6IC8vICdeJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KClcblxuICAgIGNhc2UgNDM6IGNhc2UgNDU6IC8vICcrLSdcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gICAgY2FzZSA2MDogY2FzZSA2MjogLy8gJzw+J1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2x0X2d0KGNvZGUpXG5cbiAgICBjYXNlIDYxOiBjYXNlIDMzOiAvLyAnPSEnXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKVxuXG4gICAgY2FzZSA2MzogLy8gJz8nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcXVlc3Rpb24oKVxuXG4gICAgY2FzZSAxMjY6IC8vICd+J1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5wcmVmaXgsIDEpXG5cbiAgICBjYXNlIDM1OiAvLyAnIydcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9udW1iZXJTaWduKClcbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xuICB9O1xuXG4gIHBwLmZpbmlzaE9wID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpO1xuICAgIHRoaXMucG9zICs9IHNpemU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKVxuICB9O1xuXG4gIHBwLnJlYWRSZWdleHAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgIGlmIChjaCA9PT0gXCJbXCIpIHsgaW5DbGFzcyA9IHRydWU7IH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykgeyBicmVhayB9XG4gICAgICAgIGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCI7XG4gICAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgdmFyIGZsYWdzU3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgZmxhZ3MgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMudW5leHBlY3RlZChmbGFnc1N0YXJ0KTsgfVxuXG4gICAgLy8gVmFsaWRhdGUgcGF0dGVyblxuICAgIHZhciBzdGF0ZSA9IHRoaXMucmVnZXhwU3RhdGUgfHwgKHRoaXMucmVnZXhwU3RhdGUgPSBuZXcgUmVnRXhwVmFsaWRhdGlvblN0YXRlKHRoaXMpKTtcbiAgICBzdGF0ZS5yZXNldChzdGFydCwgcGF0dGVybiwgZmxhZ3MpO1xuICAgIHRoaXMudmFsaWRhdGVSZWdFeHBGbGFncyhzdGF0ZSk7XG4gICAgdGhpcy52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4oc3RhdGUpO1xuXG4gICAgLy8gQ3JlYXRlIExpdGVyYWwjdmFsdWUgcHJvcGVydHkgdmFsdWUuXG4gICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBFU1RyZWUgcmVxdWlyZXMgbnVsbCBpZiBpdCBmYWlsZWQgdG8gaW5zdGFudGlhdGUgUmVnRXhwIG9iamVjdC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVlL2Jsb2IvYTI3MDAzYWRmNGZkN2JmYWQ0NGRlOWNlZjM3MmEyZWFjZDUyN2IxYy9lczUubWQjcmVnZXhwbGl0ZXJhbFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucmVnZXhwLCB7cGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzLCB2YWx1ZTogdmFsdWV9KVxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaW50ZWdlciBpbiB0aGUgZ2l2ZW4gcmFkaXguIFJldHVybiBudWxsIGlmIHplcm8gZGlnaXRzXG4gIC8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYCB1bmxlc3MgdGhlIGludGVnZXIgaGFzIGV4YWN0bHkgYGxlbmAgZGlnaXRzLlxuXG4gIHBwLnJlYWRJbnQgPSBmdW5jdGlvbihyYWRpeCwgbGVuLCBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAvLyBgbGVuYCBpcyB1c2VkIGZvciBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcy4gSW4gdGhhdCBjYXNlLCBkaXNhbGxvdyBzZXBhcmF0b3JzLlxuICAgIHZhciBhbGxvd1NlcGFyYXRvcnMgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIgJiYgbGVuID09PSB1bmRlZmluZWQ7XG5cbiAgICAvLyBgbWF5YmVMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsYCBpcyB0cnVlIGlmIGl0IGRvZXNuJ3QgaGF2ZSBwcmVmaXggKDB4LDBvLDBiKVxuICAgIC8vIGFuZCBpc24ndCBmcmFjdGlvbiBwYXJ0IG5vciBleHBvbmVudCBwYXJ0LiBJbiB0aGF0IGNhc2UsIGlmIHRoZSBmaXJzdCBkaWdpdFxuICAgIC8vIGlzIHplcm8gdGhlbiBkaXNhbGxvdyBzZXBhcmF0b3JzLlxuICAgIHZhciBpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwgPSBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gNDg7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwLCBsYXN0Q29kZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpLCArK3RoaXMucG9zKSB7XG4gICAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIHZhbCA9ICh2b2lkIDApO1xuXG4gICAgICBpZiAoYWxsb3dTZXBhcmF0b3JzICYmIGNvZGUgPT09IDk1KSB7XG4gICAgICAgIGlmIChpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zLCBcIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGluIGxlZ2FjeSBvY3RhbCBudW1lcmljIGxpdGVyYWxzXCIpOyB9XG4gICAgICAgIGlmIChsYXN0Q29kZSA9PT0gOTUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zLCBcIk51bWVyaWMgc2VwYXJhdG9yIG11c3QgYmUgZXhhY3RseSBvbmUgdW5kZXJzY29yZVwiKTsgfVxuICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgYXQgdGhlIGZpcnN0IG9mIGRpZ2l0c1wiKTsgfVxuICAgICAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlID49IDk3KSB7IHZhbCA9IGNvZGUgLSA5NyArIDEwOyB9IC8vIGFcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHsgdmFsID0gY29kZSAtIDY1ICsgMTA7IH0gLy8gQVxuICAgICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICAgIGVsc2UgeyB2YWwgPSBJbmZpbml0eTsgfVxuICAgICAgaWYgKHZhbCA+PSByYWRpeCkgeyBicmVhayB9XG4gICAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93U2VwYXJhdG9ycyAmJiBsYXN0Q29kZSA9PT0gOTUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zIC0gMSwgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgbGFzdCBvZiBkaWdpdHNcIik7IH1cbiAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgeyByZXR1cm4gbnVsbCB9XG5cbiAgICByZXR1cm4gdG90YWxcbiAgfTtcblxuICBmdW5jdGlvbiBzdHJpbmdUb051bWJlcihzdHIsIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgIGlmIChpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChzdHIsIDgpXG4gICAgfVxuXG4gICAgLy8gYHBhcnNlRmxvYXQodmFsdWUpYCBzdG9wcyBwYXJzaW5nIGF0IHRoZSBmaXJzdCBudW1lcmljIHNlcGFyYXRvciB0aGVuIHJldHVybnMgYSB3cm9uZyB2YWx1ZS5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQmlnSW50KHN0cikge1xuICAgIGlmICh0eXBlb2YgQmlnSW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gYEJpZ0ludCh2YWx1ZSlgIHRocm93cyBzeW50YXggZXJyb3IgaWYgdGhlIHN0cmluZyBjb250YWlucyBudW1lcmljIHNlcGFyYXRvcnMuXG4gICAgcmV0dXJuIEJpZ0ludChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbiAgfVxuXG4gIHBwLnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gMjsgLy8gMHhcbiAgICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgICBpZiAodmFsID09IG51bGwpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDExMCkge1xuICAgICAgdmFsID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLm51bSwgdmFsKVxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaW50ZWdlciwgb2N0YWwgaW50ZWdlciwgb3IgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXG4gIHBwLnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCwgdW5kZWZpbmVkLCB0cnVlKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICAgIGlmIChvY3RhbCAmJiB0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmICghb2N0YWwgJiYgIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIG5leHQgPT09IDExMCkge1xuICAgICAgdmFyIHZhbCQxID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLm51bSwgdmFsJDEpXG4gICAgfVxuICAgIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgIW9jdGFsKSB7IC8vICcuJ1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICB9XG4gICAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSB7ICsrdGhpcy5wb3M7IH0gLy8gJystJ1xuICAgICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG5cbiAgICB2YXIgdmFsID0gc3RyaW5nVG9OdW1iZXIodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpLCBvY3RhbCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5udW0sIHZhbClcbiAgfTtcblxuICAvLyBSZWFkIGEgc3RyaW5nIHZhbHVlLCBpbnRlcnByZXRpbmcgYmFja3NsYXNoLWVzY2FwZXMuXG5cbiAgcHAucmVhZENvZGVQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIGNvZGU7XG5cbiAgICBpZiAoY2ggPT09IDEyMykgeyAvLyAneydcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB2YXIgY29kZVBvcyA9ICsrdGhpcy5wb3M7XG4gICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9O1xuXG4gIHBwLnJlYWRTdHJpbmcgPSBmdW5jdGlvbihxdW90ZSkge1xuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IHF1b3RlKSB7IGJyZWFrIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MjAyOCB8fCBjaCA9PT0gMHgyMDI5KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgIHRoaXMuY3VyTGluZSsrO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9XG4gICAgfVxuICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuc3RyaW5nLCBvdXQpXG4gIH07XG5cbiAgLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxuICB2YXIgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IgPSB7fTtcblxuICBwcC50cnlSZWFkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlYWRUbXBsVG9rZW4oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgPT09IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SKSB7XG4gICAgICAgIHRoaXMucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gZmFsc2U7XG4gIH07XG5cbiAgcHAuaW52YWxpZFN0cmluZ1Rva2VuID0gZnVuY3Rpb24ocG9zaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5pblRlbXBsYXRlRWxlbWVudCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgdGhyb3cgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1JcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYWlzZShwb3NpdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICB9O1xuXG4gIHBwLnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEyMykgeyAvLyAnYCcsICckeydcbiAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLnN0YXJ0ICYmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEudGVtcGxhdGUgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDM2KSB7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5kb2xsYXJCcmFjZUwpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJhY2tRdW90ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnRlbXBsYXRlLCBvdXQpXG4gICAgICB9XG4gICAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIodHJ1ZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfVxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlYWRzIGEgdGVtcGxhdGUgdG9rZW4gdG8gc2VhcmNoIGZvciB0aGUgZW5kLCB3aXRob3V0IHZhbGlkYXRpbmcgYW55IGVzY2FwZSBzZXF1ZW5jZXNcbiAgcHAucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICg7IHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHRoaXMucG9zKyspIHtcbiAgICAgIHN3aXRjaCAodGhpcy5pbnB1dFt0aGlzLnBvc10pIHtcbiAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgIGlmICh0aGlzLmlucHV0W3RoaXMucG9zICsgMV0gIT09IFwie1wiKSB7IGJyZWFrIH1cbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlIFwiYFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSwgdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcykpXG5cbiAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRbdGhpcy5wb3MgKyAxXSA9PT0gXCJcXG5cIikgeyArK3RoaXMucG9zOyB9XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgY2FzZSBcIlxcblwiOiBjYXNlIFwiXFx1MjAyOFwiOiBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZWFkIGVzY2FwZWQgY2hhcmFjdGVyc1xuXG4gIHBwLnJlYWRFc2NhcGVkQ2hhciA9IGZ1bmN0aW9uKGluVGVtcGxhdGUpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAxMTA6IHJldHVybiBcIlxcblwiIC8vICduJyAtPiAnXFxuJ1xuICAgIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIiAvLyAncicgLT4gJ1xccidcbiAgICBjYXNlIDEyMDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSGV4Q2hhcigyKSkgLy8gJ3gnXG4gICAgY2FzZSAxMTc6IHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyh0aGlzLnJlYWRDb2RlUG9pbnQoKSkgLy8gJ3UnXG4gICAgY2FzZSAxMTY6IHJldHVybiBcIlxcdFwiIC8vICd0JyAtPiAnXFx0J1xuICAgIGNhc2UgOTg6IHJldHVybiBcIlxcYlwiIC8vICdiJyAtPiAnXFxiJ1xuICAgIGNhc2UgMTE4OiByZXR1cm4gXCJcXHUwMDBiXCIgLy8gJ3YnIC0+ICdcXHUwMDBiJ1xuICAgIGNhc2UgMTAyOiByZXR1cm4gXCJcXGZcIiAvLyAnZicgLT4gJ1xcZidcbiAgICBjYXNlIDEzOiBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfSAvLyAnXFxyXFxuJ1xuICAgIGNhc2UgMTA6IC8vICcgXFxuJ1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmU7IH1cbiAgICAgIHJldHVybiBcIlwiXG4gICAgY2FzZSA1NjpcbiAgICBjYXNlIDU3OlxuICAgICAgaWYgKHRoaXMuc3RyaWN0KSB7XG4gICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgIHRoaXMucG9zIC0gMSxcbiAgICAgICAgICBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBjb2RlUG9zID0gdGhpcy5wb3MgLSAxO1xuXG4gICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgIGNvZGVQb3MsXG4gICAgICAgICAgXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgICAgdmFyIG9jdGFsU3RyID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MgLSAxLCAzKS5tYXRjaCgvXlswLTddKy8pWzBdO1xuICAgICAgICB2YXIgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKChvY3RhbFN0ciAhPT0gXCIwXCIgfHwgY2ggPT09IDU2IHx8IGNoID09PSA1NykgJiYgKHRoaXMuc3RyaWN0IHx8IGluVGVtcGxhdGUpKSB7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgICB0aGlzLnBvcyAtIDEgLSBvY3RhbFN0ci5sZW5ndGgsXG4gICAgICAgICAgICBpblRlbXBsYXRlXG4gICAgICAgICAgICAgID8gXCJPY3RhbCBsaXRlcmFsIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICAgICAgIDogXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdGFsKVxuICAgICAgfVxuICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgLy8gVW5pY29kZSBuZXcgbGluZSBjaGFyYWN0ZXJzIGFmdGVyIFxcIGdldCByZW1vdmVkIGZyb20gb3V0cHV0IGluIGJvdGhcbiAgICAgICAgLy8gdGVtcGxhdGUgbGl0ZXJhbHMgYW5kIHN0cmluZ3NcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmU7IH1cbiAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKVxuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JywgJ1xcVScpLlxuXG4gIHBwLnJlYWRIZXhDaGFyID0gZnVuY3Rpb24obGVuKSB7XG4gICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgICB2YXIgbiA9IHRoaXMucmVhZEludCgxNiwgbGVuKTtcbiAgICBpZiAobiA9PT0gbnVsbCkgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpOyB9XG4gICAgcmV0dXJuIG5cbiAgfTtcblxuICAvLyBSZWFkIGFuIGlkZW50aWZpZXIsIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcuIFNldHMgYHRoaXMuY29udGFpbnNFc2NgXG4gIC8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuICAvL1xuICAvLyBJbmNyZW1lbnRhbGx5IGFkZHMgb25seSBlc2NhcGVkIGNoYXJzLCBhZGRpbmcgb3RoZXIgY2h1bmtzIGFzLWlzXG4gIC8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG4gIHBwLnJlYWRXb3JkMSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgICB2YXIgd29yZCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZSwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBhc3RyYWwgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpO1xuICAgICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gsIGFzdHJhbCkpIHtcbiAgICAgICAgdGhpcy5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5MikgeyAvLyBcIlxcXCJcbiAgICAgICAgdGhpcy5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICAgIHdvcmQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIHZhciBlc2NTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpICE9PSAxMTcpIC8vIFwidVwiXG4gICAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbih0aGlzLnBvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpOyB9XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHZhciBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQoKTtcbiAgICAgICAgaWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydCA6IGlzSWRlbnRpZmllckNoYXIpKGVzYywgYXN0cmFsKSlcbiAgICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGVzY1N0YXJ0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7IH1cbiAgICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyhlc2MpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmQgKyB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKVxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaWRlbnRpZmllciBvciBrZXl3b3JkIHRva2VuLiBXaWxsIGNoZWNrIGZvciByZXNlcnZlZFxuICAvLyB3b3JkcyB3aGVuIG5lY2Vzc2FyeS5cblxuICBwcC5yZWFkV29yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgICB2YXIgdHlwZSA9IHR5cGVzJDEubmFtZTtcbiAgICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgICB0eXBlID0ga2V5d29yZHNbd29yZF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpXG4gIH07XG5cbiAgLy8gQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cbiAgLy9cbiAgLy8gQWNvcm4gd2FzIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZSwgSW5ndmFyIFN0ZXBhbnlhbiwgYW5kXG4gIC8vIHZhcmlvdXMgY29udHJpYnV0b3JzIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS5cbiAgLy9cbiAgLy8gR2l0IHJlcG9zaXRvcmllcyBmb3IgQWNvcm4gYXJlIGF2YWlsYWJsZSBhdFxuICAvL1xuICAvLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbiAgLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hY29ybmpzL2Fjb3JuLmdpdFxuICAvL1xuICAvLyBQbGVhc2UgdXNlIHRoZSBbZ2l0aHViIGJ1ZyB0cmFja2VyXVtnaGJ0XSB0byByZXBvcnQgaXNzdWVzLlxuICAvL1xuICAvLyBbZ2hidF06IGh0dHBzOi8vZ2l0aHViLmNvbS9hY29ybmpzL2Fjb3JuL2lzc3Vlc1xuXG5cbiAgdmFyIHZlcnNpb24gPSBcIjguMTUuMFwiO1xuXG4gIFBhcnNlci5hY29ybiA9IHtcbiAgICBQYXJzZXI6IFBhcnNlcixcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcbiAgICBQb3NpdGlvbjogUG9zaXRpb24sXG4gICAgU291cmNlTG9jYXRpb246IFNvdXJjZUxvY2F0aW9uLFxuICAgIGdldExpbmVJbmZvOiBnZXRMaW5lSW5mbyxcbiAgICBOb2RlOiBOb2RlLFxuICAgIFRva2VuVHlwZTogVG9rZW5UeXBlLFxuICAgIHRva1R5cGVzOiB0eXBlcyQxLFxuICAgIGtleXdvcmRUeXBlczoga2V5d29yZHMsXG4gICAgVG9rQ29udGV4dDogVG9rQ29udGV4dCxcbiAgICB0b2tDb250ZXh0czogdHlwZXMsXG4gICAgaXNJZGVudGlmaWVyQ2hhcjogaXNJZGVudGlmaWVyQ2hhcixcbiAgICBpc0lkZW50aWZpZXJTdGFydDogaXNJZGVudGlmaWVyU3RhcnQsXG4gICAgVG9rZW46IFRva2VuLFxuICAgIGlzTmV3TGluZTogaXNOZXdMaW5lLFxuICAgIGxpbmVCcmVhazogbGluZUJyZWFrLFxuICAgIGxpbmVCcmVha0c6IGxpbmVCcmVha0csXG4gICAgbm9uQVNDSUl3aGl0ZXNwYWNlOiBub25BU0NJSXdoaXRlc3BhY2VcbiAgfTtcblxuICAvLyBUaGUgbWFpbiBleHBvcnRlZCBpbnRlcmZhY2UgKHVuZGVyIGBzZWxmLmFjb3JuYCB3aGVuIGluIHRoZVxuICAvLyBicm93c2VyKSBpcyBhIGBwYXJzZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGNvZGUgc3RyaW5nIGFuZCByZXR1cm5zXG4gIC8vIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlIGFzIHNwZWNpZmllZCBieSB0aGUgW0VTVHJlZSBzcGVjXVtlc3RyZWVdLlxuICAvL1xuICAvLyBbZXN0cmVlXTogaHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWVcblxuICBmdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpXG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGEgc2luZ2xlIGV4cHJlc3Npb24gYXQgYSBnaXZlblxuICAvLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4gIC8vIHRoYXQgZW1iZWQgSmF2YVNjcmlwdCBleHByZXNzaW9ucy5cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKVxuICB9XG5cbiAgLy8gQWNvcm4gaXMgb3JnYW5pemVkIGFzIGEgdG9rZW5pemVyIGFuZCBhIHJlY3Vyc2l2ZS1kZXNjZW50IHBhcnNlci5cbiAgLy8gVGhlIGB0b2tlbml6ZXJgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cblxuICBmdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnRva2VuaXplcihpbnB1dCwgb3B0aW9ucylcbiAgfVxuXG4gIGV4cG9ydHMuTm9kZSA9IE5vZGU7XG4gIGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuICBleHBvcnRzLlBvc2l0aW9uID0gUG9zaXRpb247XG4gIGV4cG9ydHMuU291cmNlTG9jYXRpb24gPSBTb3VyY2VMb2NhdGlvbjtcbiAgZXhwb3J0cy5Ub2tDb250ZXh0ID0gVG9rQ29udGV4dDtcbiAgZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuICBleHBvcnRzLlRva2VuVHlwZSA9IFRva2VuVHlwZTtcbiAgZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICBleHBvcnRzLmdldExpbmVJbmZvID0gZ2V0TGluZUluZm87XG4gIGV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGlzSWRlbnRpZmllckNoYXI7XG4gIGV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBpc0lkZW50aWZpZXJTdGFydDtcbiAgZXhwb3J0cy5pc05ld0xpbmUgPSBpc05ld0xpbmU7XG4gIGV4cG9ydHMua2V5d29yZFR5cGVzID0ga2V5d29yZHM7XG4gIGV4cG9ydHMubGluZUJyZWFrID0gbGluZUJyZWFrO1xuICBleHBvcnRzLmxpbmVCcmVha0cgPSBsaW5lQnJlYWtHO1xuICBleHBvcnRzLm5vbkFTQ0lJd2hpdGVzcGFjZSA9IG5vbkFTQ0lJd2hpdGVzcGFjZTtcbiAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuICBleHBvcnRzLnBhcnNlRXhwcmVzc2lvbkF0ID0gcGFyc2VFeHByZXNzaW9uQXQ7XG4gIGV4cG9ydHMudG9rQ29udGV4dHMgPSB0eXBlcztcbiAgZXhwb3J0cy50b2tUeXBlcyA9IHR5cGVzJDE7XG4gIGV4cG9ydHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICBleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/acorn/dist/acorn.js\n\n}");

/***/ },

/***/ "./node_modules/terser/dist/bundle.min.js"
/*!************************************************!*\
  !*** ./node_modules/terser/dist/bundle.min.js ***!
  \************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

eval("{(function (global, factory) {\n true ? factory(exports, __webpack_require__(/*! @jridgewell/source-map */ \"./node_modules/@jridgewell/source-map/dist/source-map.umd.js\")) :\n0;\n})(this, (function (exports, sourceMap) { 'use strict';\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nfunction characters(str) {\n    return str.split(\"\");\n}\n\nfunction member(name, array) {\n    return array.includes(name);\n}\n\nclass DefaultsError extends Error {\n    constructor(msg, defs) {\n        super();\n\n        this.name = \"DefaultsError\";\n        this.message = msg;\n        this.defs = defs;\n    }\n}\n\nfunction defaults(args, defs, croak) {\n    if (args === true) {\n        args = {};\n    } else if (args != null && typeof args === \"object\") {\n        args = {...args};\n    }\n\n    const ret = args || {};\n\n    if (croak) for (const i in ret) if (HOP(ret, i) && !HOP(defs, i)) {\n        throw new DefaultsError(\"`\" + i + \"` is not a supported option\", defs);\n    }\n\n    for (const i in defs) if (HOP(defs, i)) {\n        if (!args || !HOP(args, i)) {\n            ret[i] = defs[i];\n        } else if (i === \"ecma\") {\n            let ecma = args[i] | 0;\n            if (ecma > 5 && ecma < 2015) ecma += 2009;\n            ret[i] = ecma;\n        } else {\n            ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];\n        }\n    }\n\n    return ret;\n}\n\nfunction noop() {}\nfunction return_false() { return false; }\nfunction return_true() { return true; }\nfunction return_this() { return this; }\nfunction return_null() { return null; }\n\nvar MAP = (function() {\n    function MAP(a, tw, allow_splicing = true) {\n        const new_a = [];\n\n        for (let i = 0; i < a.length; ++i) {\n            let item = a[i];\n            let ret = item.transform(tw, allow_splicing);\n\n            if (ret instanceof AST_Node) {\n                new_a.push(ret);\n            } else if (ret instanceof Splice) {\n                new_a.push(...ret.v);\n            }\n        }\n\n        return new_a;\n    }\n\n    MAP.splice = function(val) { return new Splice(val); };\n    MAP.skip = {};\n    function Splice(val) { this.v = val; }\n    return MAP;\n})();\n\nfunction make_node(ctor, orig, props) {\n    if (!props) props = {};\n    if (orig) {\n        if (!props.start) props.start = orig.start;\n        if (!props.end) props.end = orig.end;\n    }\n    return new ctor(props);\n}\n\nfunction push_uniq(array, el) {\n    if (!array.includes(el))\n        array.push(el);\n}\n\nfunction string_template(text, props) {\n    return text.replace(/{(.+?)}/g, function(str, p) {\n        return props && props[p];\n    });\n}\n\nfunction remove(array, el) {\n    for (var i = array.length; --i >= 0;) {\n        if (array[i] === el) array.splice(i, 1);\n    }\n}\n\nfunction mergeSort(array, cmp) {\n    if (array.length < 2) return array.slice();\n    function merge(a, b) {\n        var r = [], ai = 0, bi = 0, i = 0;\n        while (ai < a.length && bi < b.length) {\n            cmp(a[ai], b[bi]) <= 0\n                ? r[i++] = a[ai++]\n                : r[i++] = b[bi++];\n        }\n        if (ai < a.length) r.push.apply(r, a.slice(ai));\n        if (bi < b.length) r.push.apply(r, b.slice(bi));\n        return r;\n    }\n    function _ms(a) {\n        if (a.length <= 1)\n            return a;\n        var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);\n        left = _ms(left);\n        right = _ms(right);\n        return merge(left, right);\n    }\n    return _ms(array);\n}\n\nfunction makePredicate(words) {\n    if (!Array.isArray(words)) words = words.split(\" \");\n\n    return new Set(words.sort());\n}\n\nfunction map_add(map, key, value) {\n    if (map.has(key)) {\n        map.get(key).push(value);\n    } else {\n        map.set(key, [ value ]);\n    }\n}\n\nfunction map_from_object(obj) {\n    var map = new Map();\n    for (var key in obj) {\n        if (HOP(obj, key) && key.charAt(0) === \"$\") {\n            map.set(key.substr(1), obj[key]);\n        }\n    }\n    return map;\n}\n\nfunction map_to_object(map) {\n    var obj = Object.create(null);\n    map.forEach(function (value, key) {\n        obj[\"$\" + key] = value;\n    });\n    return obj;\n}\n\nfunction HOP(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction keep_name(keep_setting, name) {\n    return keep_setting === true\n        || (keep_setting instanceof RegExp && keep_setting.test(name));\n}\n\nvar lineTerminatorEscape = {\n    \"\\0\": \"0\",\n    \"\\n\": \"n\",\n    \"\\r\": \"r\",\n    \"\\u2028\": \"u2028\",\n    \"\\u2029\": \"u2029\",\n};\nfunction regexp_source_fix(source) {\n    // V8 does not escape line terminators in regexp patterns in node 12\n    // We'll also remove literal \\0\n    return source.replace(/[\\0\\n\\r\\u2028\\u2029]/g, function (match, offset) {\n        var escaped = source[offset - 1] == \"\\\\\"\n            && (source[offset - 2] != \"\\\\\"\n            || /(?:^|[^\\\\])(?:\\\\{2})*$/.test(source.slice(0, offset - 1)));\n        return (escaped ? \"\" : \"\\\\\") + lineTerminatorEscape[match];\n    });\n}\n\n// Subset of regexps that is not going to cause regexp based DDOS\n// https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\nconst re_safe_regexp = /^[\\\\/|\\0\\s\\w^$.[\\]()]*$/;\n\n/** Check if the regexp is safe for Terser to create without risking a RegExp DOS */\nconst regexp_is_safe = (source) => re_safe_regexp.test(source);\n\nconst all_flags = \"dgimsuyv\";\nfunction sort_regexp_flags(flags) {\n    const existing_flags = new Set(flags.split(\"\"));\n    let out = \"\";\n    for (const flag of all_flags) {\n        if (existing_flags.has(flag)) {\n            out += flag;\n            existing_flags.delete(flag);\n        }\n    }\n    if (existing_flags.size) {\n        // Flags Terser doesn't know about\n        existing_flags.forEach(flag => { out += flag; });\n    }\n    return out;\n}\n\nfunction has_annotation(node, annotation) {\n    return node._annotations & annotation;\n}\n\nfunction set_annotation(node, annotation) {\n    node._annotations |= annotation;\n}\n\nfunction clear_annotation(node, annotation) {\n    node._annotations &= ~annotation;\n}\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nvar LATEST_RAW = \"\";  // Only used for numbers and template strings\nvar TEMPLATE_RAWS = new Map();  // Raw template strings\n\nvar KEYWORDS = \"break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with\";\nvar KEYWORDS_ATOM = \"false null true\";\nvar RESERVED_WORDS = \"enum import super this \" + KEYWORDS_ATOM + \" \" + KEYWORDS;\nvar ALL_RESERVED_WORDS = \"implements interface package private protected public static \" + RESERVED_WORDS;\nvar KEYWORDS_BEFORE_EXPRESSION = \"return new delete throw else case yield await\";\n\nKEYWORDS = makePredicate(KEYWORDS);\nRESERVED_WORDS = makePredicate(RESERVED_WORDS);\nKEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);\nKEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);\nALL_RESERVED_WORDS = makePredicate(ALL_RESERVED_WORDS);\n\nvar OPERATOR_CHARS = makePredicate(characters(\"+-*&%=<>!?|~^\"));\n\nvar RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\nvar RE_OCT_NUMBER = /^0[0-7]+$/;\nvar RE_ES6_OCT_NUMBER = /^0o[0-7]+$/i;\nvar RE_BIN_NUMBER = /^0b[01]+$/i;\nvar RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\nvar RE_BIG_INT = /^(0[xob])?[0-9a-f]+n$/i;\n\nvar RE_KEYWORD_RELATIONAL_OPERATORS = /in(?:stanceof)?/y;\n\nvar OPERATORS = makePredicate([\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"new\",\n    \"void\",\n    \"delete\",\n    \"++\",\n    \"--\",\n    \"+\",\n    \"-\",\n    \"!\",\n    \"~\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \"*\",\n    \"**\",\n    \"/\",\n    \"%\",\n    \">>\",\n    \"<<\",\n    \">>>\",\n    \"<\",\n    \">\",\n    \"<=\",\n    \">=\",\n    \"==\",\n    \"===\",\n    \"!=\",\n    \"!==\",\n    \"?\",\n    \"=\",\n    \"+=\",\n    \"-=\",\n    \"||=\",\n    \"&&=\",\n    \"??=\",\n    \"/=\",\n    \"*=\",\n    \"**=\",\n    \"%=\",\n    \">>=\",\n    \"<<=\",\n    \">>>=\",\n    \"|=\",\n    \"^=\",\n    \"&=\",\n    \"&&\",\n    \"??\",\n    \"||\",\n]);\n\nvar WHITESPACE_CHARS = makePredicate(characters(\" \\u00a0\\n\\r\\t\\f\\u000b\\u200b\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\uFEFF\"));\n\nvar NEWLINE_CHARS = makePredicate(characters(\"\\n\\r\\u2028\\u2029\"));\n\nvar PUNC_AFTER_EXPRESSION = makePredicate(characters(\";]),:\"));\n\nvar PUNC_BEFORE_EXPRESSION = makePredicate(characters(\"[{(,;:\"));\n\nvar PUNC_CHARS = makePredicate(characters(\"[]{}(),;:\"));\n\n/* -----[ Tokenizer ]----- */\n\n// surrogate safe regexps adapted from https://github.com/mathiasbynens/unicode-8.0.0/tree/89b412d8a71ecca9ed593d9e9fa073ab64acfebe/Binary_Property\nvar UNICODE = {\n    ID_Start: /[$A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n    ID_Continue: /(?:[$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF])+/,\n};\n\nfunction get_full_char(str, pos) {\n    if (is_surrogate_pair_head(str.charCodeAt(pos))) {\n        if (is_surrogate_pair_tail(str.charCodeAt(pos + 1))) {\n            return str.charAt(pos) + str.charAt(pos + 1);\n        }\n    } else if (is_surrogate_pair_tail(str.charCodeAt(pos))) {\n        if (is_surrogate_pair_head(str.charCodeAt(pos - 1))) {\n            return str.charAt(pos - 1) + str.charAt(pos);\n        }\n    }\n    return str.charAt(pos);\n}\n\nfunction get_full_char_code(str, pos) {\n    // https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n    if (is_surrogate_pair_head(str.charCodeAt(pos))) {\n        return 0x10000 + (str.charCodeAt(pos) - 0xd800 << 10) + str.charCodeAt(pos + 1) - 0xdc00;\n    }\n    return str.charCodeAt(pos);\n}\n\nfunction get_full_char_length(str) {\n    var surrogates = 0;\n\n    for (var i = 0; i < str.length; i++) {\n        if (is_surrogate_pair_head(str.charCodeAt(i)) && is_surrogate_pair_tail(str.charCodeAt(i + 1))) {\n            surrogates++;\n            i++;\n        }\n    }\n\n    return str.length - surrogates;\n}\n\nfunction from_char_code(code) {\n    // Based on https://github.com/mathiasbynens/String.fromCodePoint/blob/master/fromcodepoint.js\n    if (code > 0xFFFF) {\n        code -= 0x10000;\n        return (String.fromCharCode((code >> 10) + 0xD800) +\n            String.fromCharCode((code % 0x400) + 0xDC00));\n    }\n    return String.fromCharCode(code);\n}\n\nfunction is_surrogate_pair_head(code) {\n    return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction is_surrogate_pair_tail(code) {\n    return code >= 0xdc00 && code <= 0xdfff;\n}\n\nfunction is_digit(code) {\n    return code >= 48 && code <= 57;\n}\n\nfunction is_identifier_start(ch) {\n    return UNICODE.ID_Start.test(ch);\n}\n\nfunction is_identifier_char(ch) {\n    return UNICODE.ID_Continue.test(ch);\n}\n\nconst BASIC_IDENT = /^[a-z_$][a-z0-9_$]*$/i;\n\nfunction is_basic_identifier_string(str) {\n    return BASIC_IDENT.test(str);\n}\n\nfunction is_identifier_string(str, allow_surrogates) {\n    if (BASIC_IDENT.test(str)) {\n        return true;\n    }\n    if (!allow_surrogates && /[\\ud800-\\udfff]/.test(str)) {\n        return false;\n    }\n    var match = UNICODE.ID_Start.exec(str);\n    if (!match || match.index !== 0) {\n        return false;\n    }\n\n    str = str.slice(match[0].length);\n    if (!str) {\n        return true;\n    }\n\n    match = UNICODE.ID_Continue.exec(str);\n    return !!match && match[0].length === str.length;\n}\n\nfunction parse_js_number(num, allow_e = true) {\n    if (!allow_e && num.includes(\"e\")) {\n        return NaN;\n    }\n    if (RE_HEX_NUMBER.test(num)) {\n        return parseInt(num.substr(2), 16);\n    } else if (RE_OCT_NUMBER.test(num)) {\n        return parseInt(num.substr(1), 8);\n    } else if (RE_ES6_OCT_NUMBER.test(num)) {\n        return parseInt(num.substr(2), 8);\n    } else if (RE_BIN_NUMBER.test(num)) {\n        return parseInt(num.substr(2), 2);\n    } else if (RE_DEC_NUMBER.test(num)) {\n        return parseFloat(num);\n    } else {\n        var val = parseFloat(num);\n        if (val == num) return val;\n    }\n}\n\nclass JS_Parse_Error extends Error {\n    constructor(message, filename, line, col, pos) {\n        super();\n\n        this.name = \"SyntaxError\";\n        this.message = message;\n        this.filename = filename;\n        this.line = line;\n        this.col = col;\n        this.pos = pos;\n    }\n}\n\nfunction js_error(message, filename, line, col, pos) {\n    throw new JS_Parse_Error(message, filename, line, col, pos);\n}\n\nfunction is_token(token, type, val) {\n    return token.type == type && (val == null || token.value == val);\n}\n\nvar EX_EOF = {};\n\nfunction tokenizer($TEXT, filename, html5_comments, shebang) {\n    var S = {\n        text            : $TEXT,\n        filename        : filename,\n        pos             : 0,\n        tokpos          : 0,\n        line            : 1,\n        tokline         : 0,\n        col             : 0,\n        tokcol          : 0,\n        newline_before  : false,\n        regex_allowed   : false,\n        brace_counter   : 0,\n        template_braces : [],\n        comments_before : [],\n        directives      : {},\n        directive_stack : []\n    };\n\n    function peek() { return get_full_char(S.text, S.pos); }\n\n    // Used because parsing ?. involves a lookahead for a digit\n    function is_option_chain_op() {\n        const must_be_dot = S.text.charCodeAt(S.pos + 1) === 46;\n        if (!must_be_dot) return false;\n\n        const cannot_be_digit = S.text.charCodeAt(S.pos + 2);\n        return cannot_be_digit < 48 || cannot_be_digit > 57;\n    }\n\n    function next(signal_eof, in_string) {\n        var ch = get_full_char(S.text, S.pos++);\n        if (signal_eof && !ch)\n            throw EX_EOF;\n        if (NEWLINE_CHARS.has(ch)) {\n            S.newline_before = S.newline_before || !in_string;\n            ++S.line;\n            S.col = 0;\n            if (ch == \"\\r\" && peek() == \"\\n\") {\n                // treat a \\r\\n sequence as a single \\n\n                ++S.pos;\n                ch = \"\\n\";\n            }\n        } else {\n            if (ch.length > 1) {\n                ++S.pos;\n                ++S.col;\n            }\n            ++S.col;\n        }\n        return ch;\n    }\n\n    function forward(i) {\n        while (i--) next();\n    }\n\n    function looking_at(str) {\n        return S.text.substr(S.pos, str.length) == str;\n    }\n\n    function find_eol() {\n        var text = S.text;\n        for (var i = S.pos, n = S.text.length; i < n; ++i) {\n            var ch = text[i];\n            if (NEWLINE_CHARS.has(ch))\n                return i;\n        }\n        return -1;\n    }\n\n    function find(what, signal_eof) {\n        var pos = S.text.indexOf(what, S.pos);\n        if (signal_eof && pos == -1) throw EX_EOF;\n        return pos;\n    }\n\n    function start_token() {\n        S.tokline = S.line;\n        S.tokcol = S.col;\n        S.tokpos = S.pos;\n    }\n\n    var prev_was_dot = false;\n    var previous_token = null;\n    function token(type, value, is_comment) {\n        S.regex_allowed = ((type == \"operator\" && !UNARY_POSTFIX.has(value)) ||\n                           (type == \"keyword\" && KEYWORDS_BEFORE_EXPRESSION.has(value)) ||\n                           (type == \"punc\" && PUNC_BEFORE_EXPRESSION.has(value))) ||\n                           (type == \"arrow\");\n        if (type == \"punc\" && (value == \".\" || value == \"?.\")) {\n            prev_was_dot = true;\n        } else if (!is_comment) {\n            prev_was_dot = false;\n        }\n        const line     = S.tokline;\n        const col      = S.tokcol;\n        const pos      = S.tokpos;\n        const nlb      = S.newline_before;\n        const file     = filename;\n        let comments_before = [];\n        let comments_after  = [];\n\n        if (!is_comment) {\n            comments_before = S.comments_before;\n            comments_after = S.comments_before = [];\n        }\n        S.newline_before = false;\n        const tok = new AST_Token(type, value, line, col, pos, nlb, comments_before, comments_after, file);\n\n        if (!is_comment) previous_token = tok;\n        return tok;\n    }\n\n    function skip_whitespace() {\n        while (WHITESPACE_CHARS.has(peek()))\n            next();\n    }\n\n    function peek_next_token_start_or_newline() {\n        var pos = S.pos;\n        for (var in_multiline_comment = false; pos < S.text.length; ) {\n            var ch = get_full_char(S.text, pos);\n            if (NEWLINE_CHARS.has(ch)) {\n                return { char: ch, pos: pos };\n            } else if (in_multiline_comment) {\n                if (ch == \"*\" && get_full_char(S.text, pos + 1) == \"/\") {\n                    pos += 2;\n                    in_multiline_comment = false;\n                } else {\n                    pos++;\n                }\n            } else if (!WHITESPACE_CHARS.has(ch)) {\n                if (ch == \"/\") {\n                    var next_ch = get_full_char(S.text, pos + 1);\n                    if (next_ch == \"/\") {\n                        pos = find_eol();\n                        return { char: get_full_char(S.text, pos), pos: pos };\n                    } else if (next_ch == \"*\") {\n                        in_multiline_comment = true;\n                        pos += 2;\n                        continue;\n                    }\n                }\n                return { char: ch, pos: pos };\n            } else {\n                pos++;\n            }\n        }\n        return { char: null, pos: pos };\n    }\n\n    function ch_starts_binding_identifier(ch, pos) {\n        if (ch == \"\\\\\") {\n            return true;\n        } else if (is_identifier_start(ch)) {\n            RE_KEYWORD_RELATIONAL_OPERATORS.lastIndex = pos;\n            if (RE_KEYWORD_RELATIONAL_OPERATORS.test(S.text)) {\n                var after = get_full_char(S.text, RE_KEYWORD_RELATIONAL_OPERATORS.lastIndex);\n                if (!is_identifier_char(after) && after != \"\\\\\") {\n                    // \"in\" or \"instanceof\" are keywords, not binding identifiers\n                    return false; \n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    function read_while(pred) {\n        var ret = \"\", ch, i = 0;\n        while ((ch = peek()) && pred(ch, i++))\n            ret += next();\n        return ret;\n    }\n\n    function parse_error(err) {\n        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);\n    }\n\n    function read_num(prefix) {\n        var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\", is_big_int = false, numeric_separator = false;\n        var num = read_while(function(ch, i) {\n            if (is_big_int) return false;\n\n            var code = ch.charCodeAt(0);\n            switch (code) {\n              case 95: // _\n                return (numeric_separator = true);\n              case 98: case 66: // bB\n                return (has_x = true); // Can occur in hex sequence, don't return false yet\n              case 111: case 79: // oO\n              case 120: case 88: // xX\n                return has_x ? false : (has_x = true);\n              case 101: case 69: // eE\n                return has_x ? true : has_e ? false : (has_e = after_e = true);\n              case 45: // -\n                return after_e || (i == 0 && !prefix);\n              case 43: // +\n                return after_e;\n              case (after_e = false, 46): // .\n                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;\n              case 110: // n\n                is_big_int = true;\n                return true;\n            }\n\n            return (\n                code >= 48 && code <= 57 // 0-9\n                || code >= 97 && code <= 102 // a-f\n                || code >= 65 && code <= 70 // A-F\n            );\n        });\n        if (prefix) num = prefix + num;\n\n        LATEST_RAW = num;\n\n        if (RE_OCT_NUMBER.test(num) && next_token.has_directive(\"use strict\")) {\n            parse_error(\"Legacy octal literals are not allowed in strict mode\");\n        }\n        if (numeric_separator) {\n            if (num.endsWith(\"_\")) {\n                parse_error(\"Numeric separators are not allowed at the end of numeric literals\");\n            } else if (num.includes(\"__\")) {\n                parse_error(\"Only one underscore is allowed as numeric separator\");\n            }\n            num = num.replace(/_/g, \"\");\n        }\n        if (is_big_int) {\n            const without_n = num.slice(0, -1);\n            const allow_e = RE_HEX_NUMBER.test(without_n);\n            const valid = parse_js_number(without_n, allow_e);\n            if (!has_dot && RE_BIG_INT.test(num) && !isNaN(valid))\n                return token(\"big_int\", without_n);\n            parse_error(\"Invalid or unexpected token\");\n        }\n        var valid = parse_js_number(num);\n        if (!isNaN(valid)) {\n            return token(\"num\", valid);\n        } else {\n            parse_error(\"Invalid syntax: \" + num);\n        }\n    }\n\n    function is_octal(ch) {\n        return ch >= \"0\" && ch <= \"7\";\n    }\n\n    function read_escaped_char(in_string, strict_hex, template_string) {\n        var ch = next(true, in_string);\n        switch (ch.charCodeAt(0)) {\n          case 110 : return \"\\n\";\n          case 114 : return \"\\r\";\n          case 116 : return \"\\t\";\n          case 98  : return \"\\b\";\n          case 118 : return \"\\u000b\"; // \\v\n          case 102 : return \"\\f\";\n          case 120 : return String.fromCharCode(hex_bytes(2, strict_hex)); // \\x\n          case 117 : // \\u\n            if (peek() == \"{\") {\n                next(true);\n                if (peek() === \"}\")\n                    parse_error(\"Expecting hex-character between {}\");\n                while (peek() == \"0\") next(true); // No significance\n                var result, length = find(\"}\", true) - S.pos;\n                // Avoid 32 bit integer overflow (1 << 32 === 1)\n                // We know first character isn't 0 and thus out of range anyway\n                if (length > 6 || (result = hex_bytes(length, strict_hex)) > 0x10FFFF) {\n                    parse_error(\"Unicode reference out of bounds\");\n                }\n                next(true);\n                return from_char_code(result);\n            }\n            return String.fromCharCode(hex_bytes(4, strict_hex));\n          case 10  : return \"\"; // newline\n          case 13  :            // \\r\n            if (peek() == \"\\n\") { // DOS newline\n                next(true, in_string);\n                return \"\";\n            }\n        }\n        if (is_octal(ch)) {\n            if (template_string && strict_hex) {\n                const represents_null_character = ch === \"0\" && !is_octal(peek());\n                if (!represents_null_character) {\n                    parse_error(\"Octal escape sequences are not allowed in template strings\");\n                }\n            }\n            return read_octal_escape_sequence(ch, strict_hex);\n        }\n        return ch;\n    }\n\n    function read_octal_escape_sequence(ch, strict_octal) {\n        // Read\n        var p = peek();\n        if (p >= \"0\" && p <= \"7\") {\n            ch += next(true);\n            if (ch[0] <= \"3\" && (p = peek()) >= \"0\" && p <= \"7\")\n                ch += next(true);\n        }\n\n        // Parse\n        if (ch === \"0\") return \"\\0\";\n        if (ch.length > 0 && next_token.has_directive(\"use strict\") && strict_octal)\n            parse_error(\"Legacy octal escape sequences are not allowed in strict mode\");\n        return String.fromCharCode(parseInt(ch, 8));\n    }\n\n    function hex_bytes(n, strict_hex) {\n        var num = 0;\n        for (; n > 0; --n) {\n            if (!strict_hex && isNaN(parseInt(peek(), 16))) {\n                return parseInt(num, 16) || \"\";\n            }\n            var digit = next(true);\n            if (isNaN(parseInt(digit, 16)))\n                parse_error(\"Invalid hex-character pattern in string\");\n            num += digit;\n        }\n        return parseInt(num, 16);\n    }\n\n    var read_string = with_eof_error(\"Unterminated string constant\", function() {\n        const start_pos = S.pos;\n        var quote = next(), ret = [];\n        for (;;) {\n            var ch = next(true, true);\n            if (ch == \"\\\\\") ch = read_escaped_char(true, true);\n            else if (ch == \"\\r\" || ch == \"\\n\") parse_error(\"Unterminated string constant\");\n            else if (ch == quote) break;\n            ret.push(ch);\n        }\n        var tok = token(\"string\", ret.join(\"\"));\n        LATEST_RAW = S.text.slice(start_pos, S.pos);\n        tok.quote = quote;\n        return tok;\n    });\n\n    var read_template_characters = with_eof_error(\"Unterminated template\", function(begin) {\n        if (begin) {\n            S.template_braces.push(S.brace_counter);\n        }\n        var content = \"\", raw = \"\", ch, tok;\n        next(true, true);\n        while ((ch = next(true, true)) != \"`\") {\n            if (ch == \"\\r\") {\n                if (peek() == \"\\n\") ++S.pos;\n                ch = \"\\n\";\n            } else if (ch == \"$\" && peek() == \"{\") {\n                next(true, true);\n                S.brace_counter++;\n                tok = token(begin ? \"template_head\" : \"template_cont\", content);\n                TEMPLATE_RAWS.set(tok, raw);\n                tok.template_end = false;\n                return tok;\n            }\n\n            raw += ch;\n            if (ch == \"\\\\\") {\n                var tmp = S.pos;\n                var prev_is_tag = previous_token && (previous_token.type === \"name\" || previous_token.type === \"punc\" && (previous_token.value === \")\" || previous_token.value === \"]\"));\n                ch = read_escaped_char(true, !prev_is_tag, true);\n                raw += S.text.substr(tmp, S.pos - tmp);\n            }\n\n            content += ch;\n        }\n        S.template_braces.pop();\n        tok = token(begin ? \"template_head\" : \"template_cont\", content);\n        TEMPLATE_RAWS.set(tok, raw);\n        tok.template_end = true;\n        return tok;\n    });\n\n    function skip_line_comment(type) {\n        var regex_allowed = S.regex_allowed;\n        var i = find_eol(), ret;\n        if (i == -1) {\n            ret = S.text.substr(S.pos);\n            S.pos = S.text.length;\n        } else {\n            ret = S.text.substring(S.pos, i);\n            S.pos = i;\n        }\n        S.col = S.tokcol + (S.pos - S.tokpos);\n        S.comments_before.push(token(type, ret, true));\n        S.regex_allowed = regex_allowed;\n        return next_token;\n    }\n\n    var skip_multiline_comment = with_eof_error(\"Unterminated multiline comment\", function() {\n        var regex_allowed = S.regex_allowed;\n        var i = find(\"*/\", true);\n        var text = S.text.substring(S.pos, i).replace(/\\r\\n|\\r|\\u2028|\\u2029/g, \"\\n\");\n        // update stream position\n        forward(get_full_char_length(text) /* text length doesn't count \\r\\n as 2 char while S.pos - i does */ + 2);\n        S.comments_before.push(token(\"comment2\", text, true));\n        S.newline_before = S.newline_before || text.includes(\"\\n\");\n        S.regex_allowed = regex_allowed;\n        return next_token;\n    });\n\n    var read_name = function () {\n        let start = S.pos, end = start - 1, ch = \"c\";\n\n        while (\n            (ch = S.text.charAt(++end))\n            && (ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\")\n        );\n\n        // 0x7F is very rare in actual code, so we compare it to \"~\" (0x7E)\n        if (end > start + 1 && ch && ch !== \"\\\\\" && !is_identifier_char(ch) && ch <= \"~\") {\n            S.pos += end - start;\n            S.col += end - start;\n            return S.text.slice(start, S.pos);\n        }\n\n        return read_name_hard();\n    };\n\n    var read_name_hard = with_eof_error(\"Unterminated identifier name\", function() {\n        var name = [], ch, escaped = false;\n        var read_escaped_identifier_char = function() {\n            escaped = true;\n            next();\n            if (peek() !== \"u\") {\n                parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}\");\n            }\n            return read_escaped_char(false, true);\n        };\n\n        // Read first character (ID_Start)\n        if ((ch = peek()) === \"\\\\\") {\n            ch = read_escaped_identifier_char();\n            if (!is_identifier_start(ch)) {\n                parse_error(\"First identifier char is an invalid identifier char\");\n            }\n        } else if (is_identifier_start(ch)) {\n            next();\n        } else {\n            return \"\";\n        }\n\n        name.push(ch);\n\n        // Read ID_Continue\n        while ((ch = peek()) != null) {\n            if ((ch = peek()) === \"\\\\\") {\n                ch = read_escaped_identifier_char();\n                if (!is_identifier_char(ch)) {\n                    parse_error(\"Invalid escaped identifier char\");\n                }\n            } else {\n                if (!is_identifier_char(ch)) {\n                    break;\n                }\n                next();\n            }\n            name.push(ch);\n        }\n        const name_str = name.join(\"\");\n        if (RESERVED_WORDS.has(name_str) && escaped) {\n            parse_error(\"Escaped characters are not allowed in keywords\");\n        }\n        return name_str;\n    });\n\n    var read_regexp = with_eof_error(\"Unterminated regular expression\", function(source) {\n        var prev_backslash = false, ch, in_class = false;\n        while ((ch = next(true))) if (NEWLINE_CHARS.has(ch)) {\n            parse_error(\"Unexpected line terminator\");\n        } else if (prev_backslash) {\n            if (/^[\\u0000-\\u007F]$/.test(ch)) {\n                source += \"\\\\\" + ch;\n            } else {\n                // Remove the useless slash before the escape, but only for characters that won't be added to regexp syntax\n                source += ch;\n            }\n            prev_backslash = false;\n        } else if (ch == \"[\") {\n            in_class = true;\n            source += ch;\n        } else if (ch == \"]\" && in_class) {\n            in_class = false;\n            source += ch;\n        } else if (ch == \"/\" && !in_class) {\n            break;\n        } else if (ch == \"\\\\\") {\n            prev_backslash = true;\n        } else {\n            source += ch;\n        }\n        const flags = read_name();\n        return token(\"regexp\", \"/\" + source + \"/\" + flags);\n    });\n\n    function read_operator(prefix) {\n        function grow(op) {\n            if (!peek()) return op;\n            var bigger = op + peek();\n            if (OPERATORS.has(bigger)) {\n                next();\n                return grow(bigger);\n            } else {\n                return op;\n            }\n        }\n        return token(\"operator\", grow(prefix || next()));\n    }\n\n    function handle_slash() {\n        next();\n        switch (peek()) {\n          case \"/\":\n            next();\n            return skip_line_comment(\"comment1\");\n          case \"*\":\n            next();\n            return skip_multiline_comment();\n        }\n        return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n    }\n\n    function handle_eq_sign() {\n        next();\n        if (peek() === \">\") {\n            next();\n            return token(\"arrow\", \"=>\");\n        } else {\n            return read_operator(\"=\");\n        }\n    }\n\n    function handle_dot() {\n        next();\n        if (is_digit(peek().charCodeAt(0))) {\n            return read_num(\".\");\n        }\n        if (peek() === \".\") {\n            next();  // Consume second dot\n            next();  // Consume third dot\n            return token(\"expand\", \"...\");\n        }\n\n        return token(\"punc\", \".\");\n    }\n\n    function read_word() {\n        var word = read_name();\n        if (prev_was_dot) return token(\"name\", word);\n        return KEYWORDS_ATOM.has(word) ? token(\"atom\", word)\n            : !KEYWORDS.has(word) ? token(\"name\", word)\n            : OPERATORS.has(word) ? token(\"operator\", word)\n            : token(\"keyword\", word);\n    }\n\n    function read_private_word() {\n        next();\n        return token(\"privatename\", read_name());\n    }\n\n    function with_eof_error(eof_error, cont) {\n        return function(x) {\n            try {\n                return cont(x);\n            } catch(ex) {\n                if (ex === EX_EOF) parse_error(eof_error);\n                else throw ex;\n            }\n        };\n    }\n\n    function next_token(force_regexp) {\n        if (force_regexp != null)\n            return read_regexp(force_regexp);\n        if (shebang && S.pos == 0 && looking_at(\"#!\")) {\n            start_token();\n            forward(2);\n            skip_line_comment(\"comment5\");\n        }\n        for (;;) {\n            skip_whitespace();\n            start_token();\n            if (html5_comments) {\n                if (looking_at(\"<!--\")) {\n                    forward(4);\n                    skip_line_comment(\"comment3\");\n                    continue;\n                }\n                if (looking_at(\"-->\") && S.newline_before) {\n                    forward(3);\n                    skip_line_comment(\"comment4\");\n                    continue;\n                }\n            }\n            var ch = peek();\n            if (!ch) return token(\"eof\");\n            var code = ch.charCodeAt(0);\n            switch (code) {\n              case 34: case 39: return read_string();\n              case 46: return handle_dot();\n              case 47: {\n                  var tok = handle_slash();\n                  if (tok === next_token) continue;\n                  return tok;\n              }\n              case 61: return handle_eq_sign();\n              case 63: {\n                  if (!is_option_chain_op()) break;  // Handled below\n\n                  next(); // ?\n                  next(); // .\n\n                  return token(\"punc\", \"?.\");\n              }\n              case 96: return read_template_characters(true);\n              case 123:\n                S.brace_counter++;\n                break;\n              case 125:\n                S.brace_counter--;\n                if (S.template_braces.length > 0\n                    && S.template_braces[S.template_braces.length - 1] === S.brace_counter)\n                    return read_template_characters(false);\n                break;\n            }\n            if (is_digit(code)) return read_num();\n            if (PUNC_CHARS.has(ch)) return token(\"punc\", next());\n            if (OPERATOR_CHARS.has(ch)) return read_operator();\n            if (code == 92 || is_identifier_start(ch)) return read_word();\n            if (code == 35) return read_private_word();\n            break;\n        }\n        parse_error(\"Unexpected character '\" + ch + \"'\");\n    }\n\n    next_token.next = next;\n    next_token.peek = peek;\n\n    next_token.context = function(nc) {\n        if (nc) S = nc;\n        return S;\n    };\n\n    next_token.add_directive = function(directive) {\n        S.directive_stack[S.directive_stack.length - 1].push(directive);\n\n        if (S.directives[directive] === undefined) {\n            S.directives[directive] = 1;\n        } else {\n            S.directives[directive]++;\n        }\n    };\n\n    next_token.push_directives_stack = function() {\n        S.directive_stack.push([]);\n    };\n\n    next_token.pop_directives_stack = function() {\n        var directives = S.directive_stack[S.directive_stack.length - 1];\n\n        for (var i = 0; i < directives.length; i++) {\n            S.directives[directives[i]]--;\n        }\n\n        S.directive_stack.pop();\n    };\n\n    next_token.has_directive = function(directive) {\n        return S.directives[directive] > 0;\n    };\n\n    next_token.peek_next_token_start_or_newline = peek_next_token_start_or_newline;\n    next_token.ch_starts_binding_identifier = ch_starts_binding_identifier;\n\n    return next_token;\n\n}\n\n/* -----[ Parser (constants) ]----- */\n\nvar UNARY_PREFIX = makePredicate([\n    \"typeof\",\n    \"void\",\n    \"delete\",\n    \"--\",\n    \"++\",\n    \"!\",\n    \"~\",\n    \"-\",\n    \"+\"\n]);\n\nvar UNARY_POSTFIX = makePredicate([ \"--\", \"++\" ]);\n\nvar ASSIGNMENT = makePredicate([ \"=\", \"+=\", \"-=\", \"??=\", \"&&=\", \"||=\", \"/=\", \"*=\", \"**=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\" ]);\n\nvar LOGICAL_ASSIGNMENT = makePredicate([ \"??=\", \"&&=\", \"||=\" ]);\n\nvar PRECEDENCE = (function(a, ret) {\n    for (var i = 0; i < a.length; ++i) {\n        for (const op of a[i]) {\n            ret[op] = i + 1;\n        }\n    }\n    return ret;\n})(\n    [\n        [\"||\"],\n        [\"??\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"],\n        [\"**\"]\n    ],\n    {}\n);\n\nvar ATOMIC_START_TOKEN = makePredicate([ \"atom\", \"num\", \"big_int\", \"string\", \"regexp\", \"name\"]);\n\n/* -----[ Parser ]----- */\n\nfunction parse($TEXT, options) {\n    // maps start tokens to count of comments found outside of their parens\n    // Example: /* I count */ ( /* I don't */ foo() )\n    // Useful because comments_before property of call with parens outside\n    // contains both comments inside and outside these parens. Used to find the\n    \n    const outer_comments_before_counts = new WeakMap();\n\n    options = defaults(options, {\n        bare_returns   : false,\n        ecma           : null,  // Legacy\n        expression     : false,\n        filename       : null,\n        html5_comments : true,\n        module         : false,\n        shebang        : true,\n        strict         : false,\n        toplevel       : null,\n    }, true);\n\n    var S = {\n        input         : (typeof $TEXT == \"string\"\n                         ? tokenizer($TEXT, options.filename,\n                                     options.html5_comments, options.shebang)\n                         : $TEXT),\n        token         : null,\n        prev          : null,\n        peeked        : null,\n        in_function   : 0,\n        in_async      : -1,\n        in_generator  : -1,\n        in_directives : true,\n        in_loop       : 0,\n        labels        : []\n    };\n\n    S.token = next();\n\n    function is(type, value) {\n        return is_token(S.token, type, value);\n    }\n\n    function peek() { return S.peeked || (S.peeked = S.input()); }\n\n    function next() {\n        S.prev = S.token;\n\n        if (!S.peeked) peek();\n        S.token = S.peeked;\n        S.peeked = null;\n        S.in_directives = S.in_directives && (\n            S.token.type == \"string\" || is(\"punc\", \";\")\n        );\n        return S.token;\n    }\n\n    function prev() {\n        return S.prev;\n    }\n\n    function croak(msg, line, col, pos) {\n        var ctx = S.input.context();\n        js_error(msg,\n                 ctx.filename,\n                 line != null ? line : ctx.tokline,\n                 col != null ? col : ctx.tokcol,\n                 pos != null ? pos : ctx.tokpos);\n    }\n\n    function token_error(token, msg) {\n        croak(msg, token.line, token.col);\n    }\n\n    function unexpected(token) {\n        if (token == null)\n            token = S.token;\n        token_error(token, \"Unexpected token: \" + token.type + \" (\" + token.value + \")\");\n    }\n\n    function expect_token(type, val) {\n        if (is(type, val)) {\n            return next();\n        }\n        token_error(S.token, \"Unexpected token \" + S.token.type + \" \" + S.token.value + \"\" + \", expected \" + type + \" \" + val + \"\");\n    }\n\n    function expect(punc) { return expect_token(\"punc\", punc); }\n\n    function has_newline_before(token) {\n        return token.nlb || !token.comments_before.every((comment) => !comment.nlb);\n    }\n\n    function can_insert_semicolon() {\n        return !options.strict\n            && (is(\"eof\") || is(\"punc\", \"}\") || has_newline_before(S.token));\n    }\n\n    function is_in_generator() {\n        return S.in_generator === S.in_function;\n    }\n\n    function is_in_async() {\n        return S.in_async === S.in_function;\n    }\n\n    function can_await() {\n        return (\n            S.in_async === S.in_function\n            || S.in_function === 0 && S.input.has_directive(\"use strict\")\n        );\n    }\n\n    function semicolon(optional) {\n        if (is(\"punc\", \";\")) next();\n        else if (!optional && !can_insert_semicolon()) unexpected();\n    }\n\n    function parenthesised() {\n        expect(\"(\");\n        var exp = expression(true);\n        expect(\")\");\n        return exp;\n    }\n\n    function embed_tokens(parser) {\n        return function _embed_tokens_wrapper(...args) {\n            const start = S.token;\n            const expr = parser(...args);\n            expr.start = start;\n            expr.end = prev();\n            return expr;\n        };\n    }\n\n    function handle_regexp() {\n        if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n            S.peeked = null;\n            S.token = S.input(S.token.value.substr(1)); // force regexp\n        }\n    }\n\n    var statement = embed_tokens(function statement(is_export_default, is_for_body, is_if_body) {\n        handle_regexp();\n        switch (S.token.type) {\n          case \"string\":\n            if (S.in_directives) {\n                var token = peek();\n                if (!LATEST_RAW.includes(\"\\\\\")\n                    && (is_token(token, \"punc\", \";\")\n                        || is_token(token, \"punc\", \"}\")\n                        || has_newline_before(token)\n                        || is_token(token, \"eof\"))) {\n                    S.input.add_directive(S.token.value);\n                } else {\n                    S.in_directives = false;\n                }\n            }\n            var dir = S.in_directives, stat = simple_statement();\n            return dir && stat.body instanceof AST_String ? new AST_Directive(stat.body) : stat;\n          case \"template_head\":\n          case \"num\":\n          case \"big_int\":\n          case \"regexp\":\n          case \"operator\":\n          case \"atom\":\n            return simple_statement();\n\n          case \"name\":\n            if (S.token.value == \"async\" && is_token(peek(), \"keyword\", \"function\")) {\n                next();\n                next();\n                if (is_for_body) {\n                    croak(\"functions are not allowed as the body of a loop\");\n                }\n                return function_(AST_Defun, false, true, is_export_default);\n            }\n            if (S.token.value == \"import\" && !is_token(peek(), \"punc\", \"(\") && !is_token(peek(), \"punc\", \".\")) {\n                next();\n                var node = import_statement();\n                semicolon();\n                return node;\n            }\n            if (S.token.value == \"using\" && is_token(peek(), \"name\") && !has_newline_before(peek())) {\n                next();\n                var node = using_();\n                semicolon();\n                return node;\n            }\n            if (S.token.value == \"await\" && can_await() && is_token(peek(), \"name\", \"using\") && !has_newline_before(peek())) {\n                var next_next = S.input.peek_next_token_start_or_newline();\n                if (S.input.ch_starts_binding_identifier(next_next.char, next_next.pos)) {\n                    next();\n                    // The \"using\" token will be consumed by the await_using_ function.\n                    var node = await_using_();\n                    semicolon();\n                    return node;\n                }\n            }\n            return is_token(peek(), \"punc\", \":\")\n                ? labeled_statement()\n                : simple_statement();\n\n          case \"privatename\":\n            if(!S.in_class)\n              croak(\"Private field must be used in an enclosing class\");\n            return simple_statement();\n\n          case \"punc\":\n            switch (S.token.value) {\n              case \"{\":\n                return new AST_BlockStatement({\n                    start : S.token,\n                    body  : block_(),\n                    end   : prev()\n                });\n              case \"[\":\n              case \"(\":\n                return simple_statement();\n              case \";\":\n                S.in_directives = false;\n                next();\n                return new AST_EmptyStatement();\n              default:\n                unexpected();\n            }\n\n          case \"keyword\":\n            switch (S.token.value) {\n              case \"break\":\n                next();\n                return break_cont(AST_Break);\n\n              case \"continue\":\n                next();\n                return break_cont(AST_Continue);\n\n              case \"debugger\":\n                next();\n                semicolon();\n                return new AST_Debugger();\n\n              case \"do\":\n                next();\n                var body = in_loop(statement);\n                expect_token(\"keyword\", \"while\");\n                var condition = parenthesised();\n                semicolon(true);\n                return new AST_Do({\n                    body      : body,\n                    condition : condition\n                });\n\n              case \"while\":\n                next();\n                return new AST_While({\n                    condition : parenthesised(),\n                    body      : in_loop(function() { return statement(false, true); })\n                });\n\n              case \"for\":\n                next();\n                return for_();\n\n              case \"class\":\n                next();\n                if (is_for_body) {\n                    croak(\"classes are not allowed as the body of a loop\");\n                }\n                if (is_if_body) {\n                    croak(\"classes are not allowed as the body of an if\");\n                }\n                return class_(AST_DefClass, is_export_default);\n\n              case \"function\":\n                next();\n                if (is_for_body) {\n                    croak(\"functions are not allowed as the body of a loop\");\n                }\n                return function_(AST_Defun, false, false, is_export_default);\n\n              case \"if\":\n                next();\n                return if_();\n\n              case \"return\":\n                if (S.in_function == 0 && !options.bare_returns)\n                    croak(\"'return' outside of function\");\n                next();\n                var value = null;\n                if (is(\"punc\", \";\")) {\n                    next();\n                } else if (!can_insert_semicolon()) {\n                    value = expression(true);\n                    semicolon();\n                }\n                return new AST_Return({\n                    value: value\n                });\n\n              case \"switch\":\n                next();\n                return new AST_Switch({\n                    expression : parenthesised(),\n                    body       : in_loop(switch_body_)\n                });\n\n              case \"throw\":\n                next();\n                if (has_newline_before(S.token))\n                    croak(\"Illegal newline after 'throw'\");\n                var value = expression(true);\n                semicolon();\n                return new AST_Throw({\n                    value: value\n                });\n\n              case \"try\":\n                next();\n                return try_();\n\n              case \"var\":\n                next();\n                var node = var_();\n                semicolon();\n                return node;\n\n              case \"let\":\n                next();\n                var node = let_();\n                semicolon();\n                return node;\n\n              case \"const\":\n                next();\n                var node = const_();\n                semicolon();\n                return node;\n\n              case \"with\":\n                if (S.input.has_directive(\"use strict\")) {\n                    croak(\"Strict mode may not include a with statement\");\n                }\n                next();\n                return new AST_With({\n                    expression : parenthesised(),\n                    body       : statement()\n                });\n\n              case \"export\":\n                if (!is_token(peek(), \"punc\", \"(\")) {\n                    next();\n                    var node = export_statement();\n                    if (is(\"punc\", \";\")) semicolon();\n                    return node;\n                }\n            }\n        }\n        unexpected();\n    });\n\n    function labeled_statement() {\n        var label = as_symbol(AST_Label);\n        if (label.name === \"await\" && is_in_async()) {\n            token_error(S.prev, \"await cannot be used as label inside async function\");\n        }\n        if (S.labels.some((l) => l.name === label.name)) {\n            // ECMA-262, 12.12: An ECMAScript program is considered\n            // syntactically incorrect if it contains a\n            // LabelledStatement that is enclosed by a\n            // LabelledStatement with the same Identifier as label.\n            croak(\"Label \" + label.name + \" defined twice\");\n        }\n        expect(\":\");\n        S.labels.push(label);\n        var stat = statement();\n        S.labels.pop();\n        if (!(stat instanceof AST_IterationStatement)) {\n            // check for `continue` that refers to this label.\n            // those should be reported as syntax errors.\n            // https://github.com/mishoo/UglifyJS2/issues/287\n            label.references.forEach(function(ref) {\n                if (ref instanceof AST_Continue) {\n                    ref = ref.label.start;\n                    croak(\"Continue label `\" + label.name + \"` refers to non-IterationStatement.\",\n                          ref.line, ref.col, ref.pos);\n                }\n            });\n        }\n        return new AST_LabeledStatement({ body: stat, label: label });\n    }\n\n    function simple_statement(tmp) {\n        return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });\n    }\n\n    function break_cont(type) {\n        var label = null, ldef;\n        if (!can_insert_semicolon()) {\n            label = as_symbol(AST_LabelRef, true);\n        }\n        if (label != null) {\n            ldef = S.labels.find((l) => l.name === label.name);\n            if (!ldef)\n                croak(\"Undefined label \" + label.name);\n            label.thedef = ldef;\n        } else if (S.in_loop == 0)\n            croak(type.TYPE + \" not inside a loop or switch\");\n        semicolon();\n        var stat = new type({ label: label });\n        if (ldef) ldef.references.push(stat);\n        return stat;\n    }\n\n    function for_() {\n        var for_await_error = \"`for await` invalid in this context\";\n        var await_tok = S.token;\n        if (await_tok.type == \"name\" && await_tok.value == \"await\") {\n            if (!can_await()) {\n                token_error(await_tok, for_await_error);\n            }\n            next();\n        } else {\n            await_tok = false;\n        }\n        expect(\"(\");\n        var init = null;\n        if (!is(\"punc\", \";\")) {\n            init =\n                is(\"keyword\", \"var\") ? (next(), var_(true)) :\n                is(\"keyword\", \"let\") ? (next(), let_(true)) :\n                is(\"keyword\", \"const\") ? (next(), const_(true)) :\n                is(\"name\", \"using\") && is_token(peek(), \"name\") && (peek().value != \"of\" || S.input.peek_next_token_start_or_newline().char == \"=\") ? (next(), using_(true)) :\n                is(\"name\", \"await\") && can_await() && is_token(peek(), \"name\", \"using\") ? (next(), await_using_(true)) :\n                                       expression(true, true);\n            var is_in = is(\"operator\", \"in\");\n            var is_of = is(\"name\", \"of\");\n            if (await_tok && !is_of) {\n                token_error(await_tok, for_await_error);\n            }\n            if (is_in || is_of) {\n                if (init instanceof AST_DefinitionsLike) {\n                    if (init.definitions.length > 1)\n                        token_error(init.start, \"Only one variable declaration allowed in for..in loop\");\n                    if (is_in && init instanceof AST_Using) {\n                        token_error(init.start, \"Invalid using declaration in for..in loop\");\n                    }\n                } else if (!(is_assignable(init) || (init = to_destructuring(init)) instanceof AST_Destructuring)) {\n                    token_error(init.start, \"Invalid left-hand side in for..in loop\");\n                }\n                next();\n                if (is_in) {\n                    return for_in(init);\n                } else {\n                    return for_of(init, !!await_tok);\n                }\n            }\n        } else if (await_tok) {\n            token_error(await_tok, for_await_error);\n        }\n        return regular_for(init);\n    }\n\n    function regular_for(init) {\n        expect(\";\");\n        var test = is(\"punc\", \";\") ? null : expression(true);\n        expect(\";\");\n        var step = is(\"punc\", \")\") ? null : expression(true);\n        expect(\")\");\n        return new AST_For({\n            init      : init,\n            condition : test,\n            step      : step,\n            body      : in_loop(function() { return statement(false, true); })\n        });\n    }\n\n    function for_of(init, is_await) {\n        var lhs = init instanceof AST_DefinitionsLike ? init.definitions[0].name : null;\n        var obj = expression(true);\n        expect(\")\");\n        return new AST_ForOf({\n            await  : is_await,\n            init   : init,\n            name   : lhs,\n            object : obj,\n            body   : in_loop(function() { return statement(false, true); })\n        });\n    }\n\n    function for_in(init) {\n        var obj = expression(true);\n        expect(\")\");\n        return new AST_ForIn({\n            init   : init,\n            object : obj,\n            body   : in_loop(function() { return statement(false, true); })\n        });\n    }\n\n    var arrow_function = function(start, argnames, is_async) {\n        if (has_newline_before(S.token)) {\n            croak(\"Unexpected newline before arrow (=>)\");\n        }\n\n        expect_token(\"arrow\", \"=>\");\n\n        var body = _function_body(is(\"punc\", \"{\"), false, is_async);\n\n        return new AST_Arrow({\n            start    : start,\n            end      : body.end,\n            async    : is_async,\n            argnames : argnames,\n            body     : body\n        });\n    };\n\n    var function_ = function(ctor, is_generator, is_async, is_export_default) {\n        var in_statement = ctor === AST_Defun;\n        if (is(\"operator\", \"*\")) {\n            is_generator = true;\n            next();\n        }\n\n        var name = is(\"name\") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;\n        if (in_statement && !name) {\n            if (is_export_default) {\n                ctor = AST_Function;\n            } else {\n                unexpected();\n            }\n        }\n\n        if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))\n            unexpected(prev());\n\n        var args = [];\n        var body = _function_body(true, is_generator, is_async, name, args);\n        return new ctor({\n            start : args.start,\n            end   : body.end,\n            is_generator: is_generator,\n            async : is_async,\n            name  : name,\n            argnames: args,\n            body  : body\n        });\n    };\n\n    class UsedParametersTracker {\n        constructor(is_parameter, strict, duplicates_ok = false) {\n            this.is_parameter = is_parameter;\n            this.duplicates_ok = duplicates_ok;\n            this.parameters = new Set();\n            this.duplicate = null;\n            this.default_assignment = false;\n            this.spread = false;\n            this.strict_mode = !!strict;\n        }\n        add_parameter(token) {\n            if (this.parameters.has(token.value)) {\n                if (this.duplicate === null) {\n                    this.duplicate = token;\n                }\n                this.check_strict();\n            } else {\n                this.parameters.add(token.value);\n                if (this.is_parameter) {\n                    switch (token.value) {\n                      case \"arguments\":\n                      case \"eval\":\n                      case \"yield\":\n                        if (this.strict_mode) {\n                            token_error(token, \"Unexpected \" + token.value + \" identifier as parameter inside strict mode\");\n                        }\n                        break;\n                      default:\n                        if (RESERVED_WORDS.has(token.value)) {\n                            unexpected();\n                        }\n                    }\n                }\n            }\n        }\n        mark_default_assignment(token) {\n            if (this.default_assignment === false) {\n                this.default_assignment = token;\n            }\n        }\n        mark_spread(token) {\n            if (this.spread === false) {\n                this.spread = token;\n            }\n        }\n        mark_strict_mode() {\n            this.strict_mode = true;\n        }\n        is_strict() {\n            return this.default_assignment !== false || this.spread !== false || this.strict_mode;\n        }\n        check_strict() {\n            if (this.is_strict() && this.duplicate !== null && !this.duplicates_ok) {\n                token_error(this.duplicate, \"Parameter \" + this.duplicate.value + \" was used already\");\n            }\n        }\n    }\n\n    function parameters(params) {\n        var used_parameters = new UsedParametersTracker(true, S.input.has_directive(\"use strict\"));\n\n        expect(\"(\");\n\n        while (!is(\"punc\", \")\")) {\n            var param = parameter(used_parameters);\n            params.push(param);\n\n            if (!is(\"punc\", \")\")) {\n                expect(\",\");\n            }\n\n            if (param instanceof AST_Expansion) {\n                break;\n            }\n        }\n\n        next();\n    }\n\n    function parameter(used_parameters, symbol_type) {\n        var param;\n        var expand = false;\n        if (used_parameters === undefined) {\n            used_parameters = new UsedParametersTracker(true, S.input.has_directive(\"use strict\"));\n        }\n        if (is(\"expand\", \"...\")) {\n            expand = S.token;\n            used_parameters.mark_spread(S.token);\n            next();\n        }\n        param = binding_element(used_parameters, symbol_type);\n\n        if (is(\"operator\", \"=\") && expand === false) {\n            used_parameters.mark_default_assignment(S.token);\n            next();\n            param = new AST_DefaultAssign({\n                start: param.start,\n                left: param,\n                operator: \"=\",\n                right: expression(false),\n                end: S.token\n            });\n        }\n\n        if (expand !== false) {\n            if (!is(\"punc\", \")\")) {\n                unexpected();\n            }\n            param = new AST_Expansion({\n                start: expand,\n                expression: param,\n                end: expand\n            });\n        }\n        used_parameters.check_strict();\n\n        return param;\n    }\n\n    function binding_element(used_parameters, symbol_type) {\n        var elements = [];\n        var first = true;\n        var is_expand = false;\n        var expand_token;\n        var first_token = S.token;\n        if (used_parameters === undefined) {\n            const strict = S.input.has_directive(\"use strict\");\n            const duplicates_ok = symbol_type === AST_SymbolVar;\n            used_parameters = new UsedParametersTracker(false, strict, duplicates_ok);\n        }\n        symbol_type = symbol_type === undefined ? AST_SymbolFunarg : symbol_type;\n        if (is(\"punc\", \"[\")) {\n            next();\n            while (!is(\"punc\", \"]\")) {\n                if (first) {\n                    first = false;\n                } else {\n                    expect(\",\");\n                }\n\n                if (is(\"expand\", \"...\")) {\n                    is_expand = true;\n                    expand_token = S.token;\n                    used_parameters.mark_spread(S.token);\n                    next();\n                }\n                if (is(\"punc\")) {\n                    switch (S.token.value) {\n                      case \",\":\n                        elements.push(new AST_Hole({\n                            start: S.token,\n                            end: S.token\n                        }));\n                        continue;\n                      case \"]\": // Trailing comma after last element\n                        break;\n                      case \"[\":\n                      case \"{\":\n                        elements.push(binding_element(used_parameters, symbol_type));\n                        break;\n                      default:\n                        unexpected();\n                    }\n                } else if (is(\"name\")) {\n                    used_parameters.add_parameter(S.token);\n                    elements.push(as_symbol(symbol_type));\n                } else {\n                    croak(\"Invalid function parameter\");\n                }\n                if (is(\"operator\", \"=\") && is_expand === false) {\n                    used_parameters.mark_default_assignment(S.token);\n                    next();\n                    elements[elements.length - 1] = new AST_DefaultAssign({\n                        start: elements[elements.length - 1].start,\n                        left: elements[elements.length - 1],\n                        operator: \"=\",\n                        right: expression(false),\n                        end: S.token\n                    });\n                }\n                if (is_expand) {\n                    if (!is(\"punc\", \"]\")) {\n                        croak(\"Rest element must be last element\");\n                    }\n                    elements[elements.length - 1] = new AST_Expansion({\n                        start: expand_token,\n                        expression: elements[elements.length - 1],\n                        end: expand_token\n                    });\n                }\n            }\n            expect(\"]\");\n            used_parameters.check_strict();\n            return new AST_Destructuring({\n                start: first_token,\n                names: elements,\n                is_array: true,\n                end: prev()\n            });\n        } else if (is(\"punc\", \"{\")) {\n            next();\n            while (!is(\"punc\", \"}\")) {\n                if (first) {\n                    first = false;\n                } else {\n                    expect(\",\");\n                }\n                if (is(\"expand\", \"...\")) {\n                    is_expand = true;\n                    expand_token = S.token;\n                    used_parameters.mark_spread(S.token);\n                    next();\n                }\n                if (is(\"name\") && (is_token(peek(), \"punc\") || is_token(peek(), \"operator\")) && [\",\", \"}\", \"=\"].includes(peek().value)) {\n                    used_parameters.add_parameter(S.token);\n                    var start = prev();\n                    var value = as_symbol(symbol_type);\n                    if (is_expand) {\n                        elements.push(new AST_Expansion({\n                            start: expand_token,\n                            expression: value,\n                            end: value.end,\n                        }));\n                    } else {\n                        elements.push(new AST_ObjectKeyVal({\n                            start: start,\n                            key: value.name,\n                            value: value,\n                            end: value.end,\n                        }));\n                    }\n                } else if (is(\"punc\", \"}\")) {\n                    continue; // Allow trailing hole\n                } else {\n                    var property_token = S.token;\n                    var property = as_property_name();\n                    if (property === null) {\n                        unexpected(prev());\n                    } else if (prev().type === \"name\" && !is(\"punc\", \":\")) {\n                        elements.push(new AST_ObjectKeyVal({\n                            start: prev(),\n                            key: property,\n                            value: new symbol_type({\n                                start: prev(),\n                                name: property,\n                                end: prev()\n                            }),\n                            end: prev()\n                        }));\n                    } else {\n                        expect(\":\");\n                        elements.push(new AST_ObjectKeyVal({\n                            start: property_token,\n                            quote: property_token.quote,\n                            key: property,\n                            value: binding_element(used_parameters, symbol_type),\n                            end: prev()\n                        }));\n                    }\n                }\n                if (is_expand) {\n                    if (!is(\"punc\", \"}\")) {\n                        croak(\"Rest element must be last element\");\n                    }\n                } else if (is(\"operator\", \"=\")) {\n                    used_parameters.mark_default_assignment(S.token);\n                    next();\n                    elements[elements.length - 1].value = new AST_DefaultAssign({\n                        start: elements[elements.length - 1].value.start,\n                        left: elements[elements.length - 1].value,\n                        operator: \"=\",\n                        right: expression(false),\n                        end: S.token\n                    });\n                }\n            }\n            expect(\"}\");\n            used_parameters.check_strict();\n            return new AST_Destructuring({\n                start: first_token,\n                names: elements,\n                is_array: false,\n                end: prev()\n            });\n        } else if (is(\"name\")) {\n            used_parameters.add_parameter(S.token);\n            return as_symbol(symbol_type);\n        } else {\n            croak(\"Invalid function parameter\");\n        }\n    }\n\n    function params_or_seq_(allow_arrows, maybe_sequence) {\n        var spread_token;\n        var invalid_sequence;\n        var trailing_comma;\n        var a = [];\n        expect(\"(\");\n        while (!is(\"punc\", \")\")) {\n            if (spread_token) unexpected(spread_token);\n            if (is(\"expand\", \"...\")) {\n                spread_token = S.token;\n                if (maybe_sequence) invalid_sequence = S.token;\n                next();\n                a.push(new AST_Expansion({\n                    start: prev(),\n                    expression: expression(),\n                    end: S.token,\n                }));\n            } else {\n                a.push(expression());\n            }\n            if (!is(\"punc\", \")\")) {\n                expect(\",\");\n                if (is(\"punc\", \")\")) {\n                    trailing_comma = prev();\n                    if (maybe_sequence) invalid_sequence = trailing_comma;\n                }\n            }\n        }\n        expect(\")\");\n        if (allow_arrows && is(\"arrow\", \"=>\")) {\n            if (spread_token && trailing_comma) unexpected(trailing_comma);\n        } else if (invalid_sequence) {\n            unexpected(invalid_sequence);\n        }\n        return a;\n    }\n\n    function _function_body(block, generator, is_async, name, args) {\n        var loop = S.in_loop;\n        var labels = S.labels;\n        var current_generator = S.in_generator;\n        var current_async = S.in_async;\n        ++S.in_function;\n        if (generator)\n            S.in_generator = S.in_function;\n        if (is_async)\n            S.in_async = S.in_function;\n        if (args) parameters(args);\n        if (block)\n            S.in_directives = true;\n        S.in_loop = 0;\n        S.labels = [];\n        if (block) {\n            S.input.push_directives_stack();\n            var a = block_();\n            if (name) _verify_symbol(name);\n            if (args) args.forEach(_verify_symbol);\n            S.input.pop_directives_stack();\n        } else {\n            var a = [new AST_Return({\n                start: S.token,\n                value: expression(false),\n                end: S.token\n            })];\n        }\n        --S.in_function;\n        S.in_loop = loop;\n        S.labels = labels;\n        S.in_generator = current_generator;\n        S.in_async = current_async;\n        return a;\n    }\n\n    function _await_expression() {\n        // Previous token must be \"await\" and not be interpreted as an identifier\n        if (!can_await()) {\n            croak(\"Unexpected await expression outside async function\",\n                S.prev.line, S.prev.col, S.prev.pos);\n        }\n        // the await expression is parsed as a unary expression in Babel\n        return new AST_Await({\n            start: prev(),\n            end: S.token,\n            expression : maybe_unary(true),\n        });\n    }\n\n    function _yield_expression() {\n        var start = S.token;\n        var star = false;\n        var has_expression = true;\n\n        // Attempt to get expression or star (and then the mandatory expression)\n        // behind yield on the same line.\n        //\n        // If nothing follows on the same line of the yieldExpression,\n        // it should default to the value `undefined` for yield to return.\n        // In that case, the `undefined` stored as `null` in ast.\n        //\n        // Note 1: It isn't allowed for yield* to close without an expression\n        // Note 2: If there is a nlb between yield and star, it is interpret as\n        //         yield <explicit undefined> <inserted automatic semicolon> *\n        if (\n            can_insert_semicolon()\n            || is(\"punc\") && PUNC_AFTER_EXPRESSION.has(S.token.value)\n            || is(\"template_cont\")\n        ) {\n            has_expression = false;\n        } else if (is(\"operator\", \"*\")) {\n            star = true;\n            next();\n        }\n\n        return new AST_Yield({\n            start      : start,\n            is_star    : star,\n            expression : has_expression ? expression() : null,\n            end        : prev()\n        });\n    }\n\n    function if_() {\n        var cond = parenthesised(), body = statement(false, false, true), belse = null;\n        if (is(\"keyword\", \"else\")) {\n            next();\n            belse = statement(false, false, true);\n        }\n        return new AST_If({\n            condition   : cond,\n            body        : body,\n            alternative : belse\n        });\n    }\n\n    function block_() {\n        expect(\"{\");\n        var a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) unexpected();\n            a.push(statement());\n        }\n        next();\n        return a;\n    }\n\n    function switch_body_() {\n        expect(\"{\");\n        var a = [], cur = null, branch = null, tmp;\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) unexpected();\n            if (is(\"keyword\", \"case\")) {\n                if (branch) branch.end = prev();\n                cur = [];\n                branch = new AST_Case({\n                    start      : (tmp = S.token, next(), tmp),\n                    expression : expression(true),\n                    body       : cur\n                });\n                a.push(branch);\n                expect(\":\");\n            } else if (is(\"keyword\", \"default\")) {\n                if (branch) branch.end = prev();\n                cur = [];\n                branch = new AST_Default({\n                    start : (tmp = S.token, next(), expect(\":\"), tmp),\n                    body  : cur\n                });\n                a.push(branch);\n            } else {\n                if (!cur) unexpected();\n                cur.push(statement());\n            }\n        }\n        if (branch) branch.end = prev();\n        next();\n        return a;\n    }\n\n    function try_() {\n        var body, bcatch = null, bfinally = null;\n        body = new AST_TryBlock({\n            start : S.token,\n            body  : block_(),\n            end   : prev(),\n        });\n        if (is(\"keyword\", \"catch\")) {\n            var start = S.token;\n            next();\n            if (is(\"punc\", \"{\")) {\n                var name = null;\n            } else {\n                expect(\"(\");\n                var name = parameter(undefined, AST_SymbolCatch);\n                expect(\")\");\n            }\n            bcatch = new AST_Catch({\n                start   : start,\n                argname : name,\n                body    : block_(),\n                end     : prev()\n            });\n        }\n        if (is(\"keyword\", \"finally\")) {\n            var start = S.token;\n            next();\n            bfinally = new AST_Finally({\n                start : start,\n                body  : block_(),\n                end   : prev()\n            });\n        }\n        if (!bcatch && !bfinally)\n            croak(\"Missing catch/finally blocks\");\n        return new AST_Try({\n            body     : body,\n            bcatch   : bcatch,\n            bfinally : bfinally\n        });\n    }\n\n    /**\n     * var\n     *   vardef1 = 2,\n     *   vardef2 = 3;\n     */\n    function vardefs(no_in, kind) {\n        var var_defs = [];\n        var def;\n        for (;;) {\n            var sym_type =\n                kind === \"var\" ? AST_SymbolVar :\n                kind === \"const\" ? AST_SymbolConst :\n                kind === \"let\" ? AST_SymbolLet :\n                kind === \"using\" ? AST_SymbolUsing :\n                kind === \"await using\" ? AST_SymbolUsing : null;\n            var def_type = kind === \"using\" || kind === \"await using\" ? AST_UsingDef : AST_VarDef;\n            // var { a } = b\n            if (is(\"punc\", \"{\") || is(\"punc\", \"[\")) {\n                def = new def_type({\n                    start: S.token,\n                    name: binding_element(undefined, sym_type),\n                    value: is(\"operator\", \"=\") ? (expect_token(\"operator\", \"=\"), expression(false, no_in)) : null,\n                    end: prev()\n                });\n            } else {\n                def = new def_type({\n                    start : S.token,\n                    name  : as_symbol(sym_type),\n                    value : is(\"operator\", \"=\")\n                        ? (next(), expression(false, no_in))\n                        : !no_in && (kind === \"const\" || kind === \"using\" || kind === \"await using\")\n                            ? croak(\"Missing initializer in \" + kind + \" declaration\") : null,\n                    end   : prev()\n                });\n                if (def.name.name == \"import\") croak(\"Unexpected token: import\");\n            }\n            var_defs.push(def);\n            if (!is(\"punc\", \",\"))\n                break;\n            next();\n        }\n        return var_defs;\n    }\n\n    var var_ = function(no_in) {\n        return new AST_Var({\n            start       : prev(),\n            definitions : vardefs(no_in, \"var\"),\n            end         : prev()\n        });\n    };\n\n    var let_ = function(no_in) {\n        return new AST_Let({\n            start       : prev(),\n            definitions : vardefs(no_in, \"let\"),\n            end         : prev()\n        });\n    };\n\n    var const_ = function(no_in) {\n        return new AST_Const({\n            start       : prev(),\n            definitions : vardefs(no_in, \"const\"),\n            end         : prev()\n        });\n    };\n\n    var using_ = function(no_in) {\n        return new AST_Using({\n            start       : prev(),\n            await       : false,\n            definitions : vardefs(no_in, \"using\"),\n            end         : prev()\n        });\n    };\n\n    var await_using_ = function(no_in) {\n        // Assumption: When await_using_ is called, only the `await` token has been consumed.\n        return new AST_Using({\n            start       : prev(),\n            await       : true,\n            definitions : (next(), vardefs(no_in, \"await using\")),\n            end         : prev()\n        });\n    };\n\n    var new_ = function(allow_calls) {\n        var start = S.token;\n        expect_token(\"operator\", \"new\");\n        if (is(\"punc\", \".\")) {\n            next();\n            expect_token(\"name\", \"target\");\n            return subscripts(new AST_NewTarget({\n                start : start,\n                end   : prev()\n            }), allow_calls);\n        }\n        var newexp = expr_atom(false), args;\n        if (is(\"punc\", \"(\")) {\n            next();\n            args = expr_list(\")\", true);\n        } else {\n            args = [];\n        }\n        var call = new AST_New({\n            start      : start,\n            expression : newexp,\n            args       : args,\n            end        : prev()\n        });\n        annotate(call);\n        return subscripts(call, allow_calls);\n    };\n\n    function as_atom_node() {\n        var tok = S.token, ret;\n        switch (tok.type) {\n          case \"name\":\n            ret = _make_symbol(AST_SymbolRef);\n            break;\n          case \"num\":\n            ret = new AST_Number({\n                start: tok,\n                end: tok,\n                value: tok.value,\n                raw: LATEST_RAW\n            });\n            break;\n          case \"big_int\":\n            ret = new AST_BigInt({\n                start: tok,\n                end: tok,\n                value: tok.value,\n                raw: LATEST_RAW,\n            });\n            break;\n          case \"string\":\n            ret = new AST_String({\n                start : tok,\n                end   : tok,\n                value : tok.value,\n                quote : tok.quote\n            });\n            annotate(ret);\n            break;\n          case \"regexp\":\n            const [_, source, flags] = tok.value.match(/^\\/(.*)\\/(\\w*)$/);\n\n            ret = new AST_RegExp({ start: tok, end: tok, value: { source, flags } });\n            break;\n          case \"atom\":\n            switch (tok.value) {\n              case \"false\":\n                ret = new AST_False({ start: tok, end: tok });\n                break;\n              case \"true\":\n                ret = new AST_True({ start: tok, end: tok });\n                break;\n              case \"null\":\n                ret = new AST_Null({ start: tok, end: tok });\n                break;\n            }\n            break;\n        }\n        next();\n        return ret;\n    }\n\n    function to_fun_args(ex, default_seen_above) {\n        var insert_default = function(ex, default_value) {\n            if (default_value) {\n                return new AST_DefaultAssign({\n                    start: ex.start,\n                    left: ex,\n                    operator: \"=\",\n                    right: default_value,\n                    end: default_value.end\n                });\n            }\n            return ex;\n        };\n        if (ex instanceof AST_Object) {\n            return insert_default(new AST_Destructuring({\n                start: ex.start,\n                end: ex.end,\n                is_array: false,\n                names: ex.properties.map(prop => to_fun_args(prop))\n            }), default_seen_above);\n        } else if (ex instanceof AST_ObjectKeyVal) {\n            ex.value = to_fun_args(ex.value);\n            return insert_default(ex, default_seen_above);\n        } else if (ex instanceof AST_Hole) {\n            return ex;\n        } else if (ex instanceof AST_Destructuring) {\n            ex.names = ex.names.map(name => to_fun_args(name));\n            return insert_default(ex, default_seen_above);\n        } else if (ex instanceof AST_SymbolRef) {\n            return insert_default(new AST_SymbolFunarg({\n                name: ex.name,\n                start: ex.start,\n                end: ex.end\n            }), default_seen_above);\n        } else if (ex instanceof AST_Expansion) {\n            ex.expression = to_fun_args(ex.expression);\n            return insert_default(ex, default_seen_above);\n        } else if (ex instanceof AST_Array) {\n            return insert_default(new AST_Destructuring({\n                start: ex.start,\n                end: ex.end,\n                is_array: true,\n                names: ex.elements.map(elm => to_fun_args(elm))\n            }), default_seen_above);\n        } else if (ex instanceof AST_Assign) {\n            return insert_default(to_fun_args(ex.left, ex.right), default_seen_above);\n        } else if (ex instanceof AST_DefaultAssign) {\n            ex.left = to_fun_args(ex.left);\n            return ex;\n        } else {\n            croak(\"Invalid function parameter\", ex.start.line, ex.start.col);\n        }\n    }\n\n    var expr_atom = function(allow_calls, allow_arrows) {\n        if (is(\"operator\", \"new\")) {\n            return new_(allow_calls);\n        }\n        if (is(\"name\", \"import\") && is_token(peek(), \"punc\", \".\")) {\n            return import_meta(allow_calls);\n        }\n        var start = S.token;\n        var peeked;\n        var async = is(\"name\", \"async\")\n            && (peeked = peek()).value != \"[\"\n            && peeked.type != \"arrow\"\n            && as_atom_node();\n        if (is(\"punc\")) {\n            switch (S.token.value) {\n              case \"(\":\n                if (async && !allow_calls) break;\n                var exprs = params_or_seq_(allow_arrows, !async);\n                if (allow_arrows && is(\"arrow\", \"=>\")) {\n                    return arrow_function(start, exprs.map(e => to_fun_args(e)), !!async);\n                }\n                var ex = async ? new AST_Call({\n                    expression: async,\n                    args: exprs\n                }) : to_expr_or_sequence(start, exprs);\n                if (ex.start) {\n                    const outer_comments_before = start.comments_before.length;\n                    outer_comments_before_counts.set(start, outer_comments_before);\n                    ex.start.comments_before.unshift(...start.comments_before);\n                    start.comments_before = ex.start.comments_before;\n                    if (outer_comments_before == 0 && start.comments_before.length > 0) {\n                        var comment = start.comments_before[0];\n                        if (!comment.nlb) {\n                            comment.nlb = start.nlb;\n                            start.nlb = false;\n                        }\n                    }\n                    start.comments_after = ex.start.comments_after;\n                }\n                ex.start = start;\n                var end = prev();\n                if (ex.end) {\n                    end.comments_before = ex.end.comments_before;\n                    ex.end.comments_after.push(...end.comments_after);\n                    end.comments_after = ex.end.comments_after;\n                }\n                ex.end = end;\n                if (ex instanceof AST_Call) annotate(ex);\n                return subscripts(ex, allow_calls);\n              case \"[\":\n                return subscripts(array_(), allow_calls);\n              case \"{\":\n                return subscripts(object_or_destructuring_(), allow_calls);\n            }\n            if (!async) unexpected();\n        }\n        if (allow_arrows && is(\"name\") && is_token(peek(), \"arrow\")) {\n            var param = new AST_SymbolFunarg({\n                name: S.token.value,\n                start: start,\n                end: start,\n            });\n            next();\n            return arrow_function(start, [param], !!async);\n        }\n        if (is(\"keyword\", \"function\")) {\n            next();\n            var func = function_(AST_Function, false, !!async);\n            func.start = start;\n            func.end = prev();\n            return subscripts(func, allow_calls);\n        }\n        if (async) return subscripts(async, allow_calls);\n        if (is(\"keyword\", \"class\")) {\n            next();\n            var cls = class_(AST_ClassExpression);\n            cls.start = start;\n            cls.end = prev();\n            return subscripts(cls, allow_calls);\n        }\n        if (is(\"template_head\")) {\n            return subscripts(template_string(), allow_calls);\n        }\n        if (ATOMIC_START_TOKEN.has(S.token.type)) {\n            return subscripts(as_atom_node(), allow_calls);\n        }\n        unexpected();\n    };\n\n    function template_string() {\n        var segments = [], start = S.token;\n\n        segments.push(new AST_TemplateSegment({\n            start: S.token,\n            raw: TEMPLATE_RAWS.get(S.token),\n            value: S.token.value,\n            end: S.token\n        }));\n\n        while (!S.token.template_end) {\n            next();\n            handle_regexp();\n            segments.push(expression(true));\n\n            segments.push(new AST_TemplateSegment({\n                start: S.token,\n                raw: TEMPLATE_RAWS.get(S.token),\n                value: S.token.value,\n                end: S.token\n            }));\n        }\n        next();\n\n        return new AST_TemplateString({\n            start: start,\n            segments: segments,\n            end: S.token\n        });\n    }\n\n    function expr_list(closing, allow_trailing_comma, allow_empty) {\n        var first = true, a = [];\n        while (!is(\"punc\", closing)) {\n            if (first) first = false; else expect(\",\");\n            if (allow_trailing_comma && is(\"punc\", closing)) break;\n            if (is(\"punc\", \",\") && allow_empty) {\n                a.push(new AST_Hole({ start: S.token, end: S.token }));\n            } else if (is(\"expand\", \"...\")) {\n                next();\n                a.push(new AST_Expansion({start: prev(), expression: expression(),end: S.token}));\n            } else {\n                a.push(expression(false));\n            }\n        }\n        next();\n        return a;\n    }\n\n    var array_ = embed_tokens(function() {\n        expect(\"[\");\n        return new AST_Array({\n            elements: expr_list(\"]\", !options.strict, true)\n        });\n    });\n\n    var create_accessor = embed_tokens((is_generator, is_async) => {\n        return function_(AST_Accessor, is_generator, is_async);\n    });\n\n    var object_or_destructuring_ = embed_tokens(function object_or_destructuring_() {\n        var start = S.token, first = true, a = [];\n        expect(\"{\");\n        while (!is(\"punc\", \"}\")) {\n            if (first) first = false; else expect(\",\");\n            if (!options.strict && is(\"punc\", \"}\"))\n                // allow trailing comma\n                break;\n\n            start = S.token;\n            if (start.type == \"expand\") {\n                next();\n                a.push(new AST_Expansion({\n                    start: start,\n                    expression: expression(false),\n                    end: prev(),\n                }));\n                continue;\n            }\n            if(is(\"privatename\")) {\n                croak(\"private fields are not allowed in an object\");\n            }\n            var name = as_property_name();\n            var value;\n\n            // Check property and fetch value\n            if (!is(\"punc\", \":\")) {\n                var concise = object_or_class_property(name, start);\n                if (concise) {\n                    a.push(concise);\n                    continue;\n                }\n\n                value = new AST_SymbolRef({\n                    start: prev(),\n                    name: name,\n                    end: prev()\n                });\n            } else if (name === null) {\n                unexpected(prev());\n            } else {\n                next(); // `:` - see first condition\n                value = expression(false);\n            }\n\n            // Check for default value and alter value accordingly if necessary\n            if (is(\"operator\", \"=\")) {\n                next();\n                value = new AST_Assign({\n                    start: start,\n                    left: value,\n                    operator: \"=\",\n                    right: expression(false),\n                    logical: false,\n                    end: prev()\n                });\n            }\n\n            // Create property\n            const kv = new AST_ObjectKeyVal({\n                start: start,\n                quote: start.quote,\n                key: name,\n                value: value,\n                end: prev()\n            });\n            a.push(annotate(kv));\n        }\n        next();\n        return new AST_Object({ properties: a });\n    });\n\n    function class_(KindOfClass, is_export_default) {\n        var start, method, class_name, extends_, properties = [];\n\n        S.input.push_directives_stack(); // Push directive stack, but not scope stack\n        S.input.add_directive(\"use strict\");\n\n        if (S.token.type == \"name\" && S.token.value != \"extends\") {\n            class_name = as_symbol(KindOfClass === AST_DefClass ? AST_SymbolDefClass : AST_SymbolClass);\n        }\n\n        if (KindOfClass === AST_DefClass && !class_name) {\n            if (is_export_default) {\n                KindOfClass = AST_ClassExpression;\n            } else {\n                unexpected();\n            }\n        }\n\n        if (S.token.value == \"extends\") {\n            next();\n            extends_ = expression(true);\n        }\n\n        expect(\"{\");\n        // mark in class feild,\n        const save_in_class = S.in_class;\n        S.in_class = true;\n        while (is(\"punc\", \";\")) { next(); }  // Leading semicolons are okay in class bodies.\n        while (!is(\"punc\", \"}\")) {\n            start = S.token;\n            method = object_or_class_property(as_property_name(), start, true);\n            if (!method) { unexpected(); }\n            properties.push(method);\n            while (is(\"punc\", \";\")) { next(); }\n        }\n        // mark in class feild,\n        S.in_class = save_in_class;\n\n        S.input.pop_directives_stack();\n\n        next();\n\n        return new KindOfClass({\n            start: start,\n            name: class_name,\n            extends: extends_,\n            properties: properties,\n            end: prev(),\n        });\n    }\n\n    function object_or_class_property(name, start, is_class) {\n        const get_symbol_ast = (name, SymbolClass) => {\n            if (typeof name === \"string\") {\n                return new SymbolClass({ start, name, end: prev() });\n            } else if (name === null) {\n                unexpected();\n            }\n            return name;\n        };\n\n        var is_private = prev().type === \"privatename\";\n        const is_not_method_start = () =>\n            !is(\"punc\", \"(\") && !is(\"punc\", \",\") && !is(\"punc\", \"}\") && !is(\"punc\", \";\") && !is(\"operator\", \"=\") && !is_private;\n\n        var is_async = false;\n        var is_static = false;\n        var is_generator = false;\n        var accessor_type = null;\n\n        if (is_class && name === \"static\" && is_not_method_start()) {\n            const static_block = class_static_block();\n            if (static_block != null) {\n                return static_block;\n            }\n            is_static = true;\n            name = as_property_name();\n        }\n        if (name === \"async\" && is_not_method_start()) {\n            is_async = true;\n            name = as_property_name();\n        }\n        if (prev().type === \"operator\" && prev().value === \"*\") {\n            is_generator = true;\n            name = as_property_name();\n        }\n        if ((name === \"get\" || name === \"set\") && is_not_method_start()) {\n            accessor_type = name;\n            name = as_property_name();\n        }\n        if (!is_private && prev().type === \"privatename\") {\n            is_private = true;\n        }\n\n        const property_token = prev();\n\n        if (accessor_type != null) {\n            if (!is_private) {\n                const AccessorClass = accessor_type === \"get\"\n                    ? AST_ObjectGetter\n                    : AST_ObjectSetter;\n\n                name = get_symbol_ast(name, AST_SymbolMethod);\n                return annotate(new AccessorClass({\n                    start,\n                    static: is_static,\n                    key: name,\n                    quote: name instanceof AST_SymbolMethod ? property_token.quote : undefined,\n                    value: create_accessor(),\n                    end: prev()\n                }));\n            } else {\n                const AccessorClass = accessor_type === \"get\"\n                    ? AST_PrivateGetter\n                    : AST_PrivateSetter;\n\n                return annotate(new AccessorClass({\n                    start,\n                    static: is_static,\n                    key: get_symbol_ast(name, AST_SymbolMethod),\n                    value: create_accessor(),\n                    end: prev(),\n                }));\n            }\n        }\n\n        if (is(\"punc\", \"(\")) {\n            name = get_symbol_ast(name, AST_SymbolMethod);\n            const AST_MethodVariant = is_private\n                ? AST_PrivateMethod\n                : AST_ConciseMethod;\n            var node = new AST_MethodVariant({\n                start       : start,\n                static      : is_static,\n                key         : name,\n                quote       : name instanceof AST_SymbolMethod ?\n                              property_token.quote : undefined,\n                value       : create_accessor(is_generator, is_async),\n                end         : prev()\n            });\n            return annotate(node);\n        }\n\n        if (is_class) {\n            const AST_SymbolVariant = is_private\n                ? AST_SymbolPrivateProperty\n                : AST_SymbolClassProperty;\n            const AST_ClassPropertyVariant = is_private\n                ? AST_ClassPrivateProperty\n                : AST_ClassProperty;\n\n            const key = get_symbol_ast(name, AST_SymbolVariant);\n            const quote = key instanceof AST_SymbolClassProperty\n                ? property_token.quote\n                : undefined;\n            if (is(\"operator\", \"=\")) {\n                next();\n                return annotate(\n                    new AST_ClassPropertyVariant({\n                        start,\n                        static: is_static,\n                        quote,\n                        key,\n                        value: expression(false),\n                        end: prev()\n                    })\n                );\n            } else if (\n                is(\"name\")\n                || is(\"privatename\")\n                || is(\"punc\", \"[\")\n                || is(\"operator\", \"*\")\n                || is(\"punc\", \";\")\n                || is(\"punc\", \"}\")\n                || is(\"string\")\n                || is(\"num\")\n                || is(\"big_int\")\n            ) {\n                return annotate(\n                    new AST_ClassPropertyVariant({\n                        start,\n                        static: is_static,\n                        quote,\n                        key,\n                        end: prev()\n                    })\n                );\n            }\n        }\n    }\n\n    function class_static_block() {\n        if (!is(\"punc\", \"{\")) {\n            return null;\n        }\n\n        const start = S.token;\n        const body = [];\n\n        next();\n\n        while (!is(\"punc\", \"}\")) {\n            body.push(statement());\n        }\n\n        next();\n\n        return new AST_ClassStaticBlock({ start, body, end: prev() });\n    }\n\n    function maybe_import_attributes() {\n        if (\n            (is(\"keyword\", \"with\") || is(\"name\", \"assert\"))\n            && !has_newline_before(S.token)\n        ) {\n            next();\n            return object_or_destructuring_();\n        }\n        return null;\n    }\n\n    function import_statement() {\n        var start = prev();\n\n        var imported_name;\n        var imported_names;\n        if (is(\"name\")) {\n            imported_name = as_symbol(AST_SymbolImport);\n        }\n\n        if (is(\"punc\", \",\")) {\n            next();\n        }\n\n        imported_names = map_names(true);\n\n        if (imported_names || imported_name) {\n            expect_token(\"name\", \"from\");\n        }\n        var mod_str = S.token;\n        if (mod_str.type !== \"string\") {\n            unexpected();\n        }\n        next();\n\n        const attributes = maybe_import_attributes();\n\n        return new AST_Import({\n            start,\n            imported_name,\n            imported_names,\n            module_name: new AST_String({\n                start: mod_str,\n                value: mod_str.value,\n                quote: mod_str.quote,\n                end: mod_str,\n            }),\n            attributes,\n            end: S.token,\n        });\n    }\n\n    function import_meta(allow_calls) {\n        var start = S.token;\n        expect_token(\"name\", \"import\");\n        expect_token(\"punc\", \".\");\n        expect_token(\"name\", \"meta\");\n        return subscripts(new AST_ImportMeta({\n            start: start,\n            end: prev()\n        }), allow_calls);\n    }\n\n    function map_name(is_import) {\n        function make_symbol(type, quote) {\n            return new type({\n                name: as_property_name(),\n                quote: quote || undefined,\n                start: prev(),\n                end: prev()\n            });\n        }\n\n        var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;\n        var type = is_import ? AST_SymbolImport : AST_SymbolExport;\n        var start = S.token;\n        var foreign_name;\n        var name;\n\n        if (is_import) {\n            foreign_name = make_symbol(foreign_type, start.quote);\n        } else {\n            name = make_symbol(type, start.quote);\n        }\n        if (is(\"name\", \"as\")) {\n            next();  // The \"as\" word\n            if (is_import) {\n                name = make_symbol(type);\n            } else {\n                foreign_name = make_symbol(foreign_type, S.token.quote);\n            }\n        } else {\n            if (is_import) {\n                name = new type(foreign_name);\n            } else {\n                foreign_name = new foreign_type(name);\n            }\n        }\n\n        return new AST_NameMapping({\n            start: start,\n            foreign_name: foreign_name,\n            name: name,\n            end: prev(),\n        });\n    }\n\n    function map_nameAsterisk(is_import, import_or_export_foreign_name) {\n        var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;\n        var type = is_import ? AST_SymbolImport : AST_SymbolExport;\n        var start = S.token;\n        var name, foreign_name;\n        var end = prev();\n\n        if (is_import) {\n            name = import_or_export_foreign_name;\n        } else {\n            foreign_name = import_or_export_foreign_name;\n        }\n\n        name = name || new type({\n            start: start,\n            name: \"*\",\n            end: end,\n        });\n\n        foreign_name = foreign_name || new foreign_type({\n            start: start,\n            name: \"*\",\n            end: end,\n        });\n\n        return new AST_NameMapping({\n            start: start,\n            foreign_name: foreign_name,\n            name: name,\n            end: end,\n        });\n    }\n\n    function map_names(is_import) {\n        var names;\n        if (is(\"punc\", \"{\")) {\n            next();\n            names = [];\n            while (!is(\"punc\", \"}\")) {\n                names.push(map_name(is_import));\n                if (is(\"punc\", \",\")) {\n                    next();\n                }\n            }\n            next();\n        } else if (is(\"operator\", \"*\")) {\n            var name;\n            next();\n            if (is(\"name\", \"as\")) {\n                next();  // The \"as\" word\n                name = is_import ? as_symbol(AST_SymbolImport) : as_symbol_or_string(AST_SymbolExportForeign);\n            }\n            names = [map_nameAsterisk(is_import, name)];\n        }\n        return names;\n    }\n\n    function export_statement() {\n        var start = S.token;\n        var is_default;\n        var exported_names;\n\n        if (is(\"keyword\", \"default\")) {\n            is_default = true;\n            next();\n        } else if (exported_names = map_names(false)) {\n            if (is(\"name\", \"from\")) {\n                next();\n\n                var mod_str = S.token;\n                if (mod_str.type !== \"string\") {\n                    unexpected();\n                }\n                next();\n\n                const attributes = maybe_import_attributes();\n\n                return new AST_Export({\n                    start: start,\n                    is_default: is_default,\n                    exported_names: exported_names,\n                    module_name: new AST_String({\n                        start: mod_str,\n                        value: mod_str.value,\n                        quote: mod_str.quote,\n                        end: mod_str,\n                    }),\n                    end: prev(),\n                    attributes\n                });\n            } else {\n                return new AST_Export({\n                    start: start,\n                    is_default: is_default,\n                    exported_names: exported_names,\n                    end: prev(),\n                });\n            }\n        }\n\n        var node;\n        var exported_value;\n        var exported_definition;\n        if (is(\"punc\", \"{\")\n            || is_default\n                && (is(\"keyword\", \"class\") || is(\"keyword\", \"function\"))\n                && is_token(peek(), \"punc\")) {\n            exported_value = expression(false);\n            semicolon();\n        } else if ((node = statement(is_default)) instanceof AST_Definitions && is_default) {\n            unexpected(node.start);\n        } else if (\n            node instanceof AST_Definitions\n            || node instanceof AST_Defun\n            || node instanceof AST_DefClass\n        ) {\n            exported_definition = node;\n        } else if (\n            node instanceof AST_ClassExpression\n            || node instanceof AST_Function\n        ) {\n            exported_value = node;\n        } else if (node instanceof AST_SimpleStatement) {\n            exported_value = node.body;\n        } else {\n            unexpected(node.start);\n        }\n\n        return new AST_Export({\n            start: start,\n            is_default: is_default,\n            exported_value: exported_value,\n            exported_definition: exported_definition,\n            end: prev(),\n            attributes: null\n        });\n    }\n\n    function as_property_name() {\n        var tmp = S.token;\n        switch (tmp.type) {\n          case \"punc\":\n            if (tmp.value === \"[\") {\n                next();\n                var ex = expression(false);\n                expect(\"]\");\n                return ex;\n            } else unexpected(tmp);\n          case \"operator\":\n            if (tmp.value === \"*\") {\n                next();\n                return null;\n            }\n            if (![\"delete\", \"in\", \"instanceof\", \"new\", \"typeof\", \"void\"].includes(tmp.value)) {\n                unexpected(tmp);\n            }\n            /* falls through */\n          case \"name\":\n          case \"privatename\":\n          case \"string\":\n          case \"keyword\":\n          case \"atom\":\n            next();\n            return tmp.value;\n          case \"num\":\n          case \"big_int\":\n            next();\n            return \"\" + tmp.value;\n          default:\n            unexpected(tmp);\n        }\n    }\n\n    function as_name() {\n        var tmp = S.token;\n        if (tmp.type != \"name\" && tmp.type != \"privatename\") unexpected();\n        next();\n        return tmp.value;\n    }\n\n    function _make_symbol(type) {\n        var name = S.token.value;\n        return new (name == \"this\" ? AST_This :\n                    name == \"super\" ? AST_Super :\n                    type)({\n            name  : String(name),\n            start : S.token,\n            end   : S.token\n        });\n    }\n\n    function _verify_symbol(sym) {\n        var name = sym.name;\n        if (is_in_generator() && name == \"yield\") {\n            token_error(sym.start, \"Yield cannot be used as identifier inside generators\");\n        }\n        if (S.input.has_directive(\"use strict\")) {\n            if (name == \"yield\") {\n                token_error(sym.start, \"Unexpected yield identifier inside strict mode\");\n            }\n            if (sym instanceof AST_SymbolDeclaration && (name == \"arguments\" || name == \"eval\")) {\n                token_error(sym.start, \"Unexpected \" + name + \" in strict mode\");\n            }\n        }\n    }\n\n    function as_symbol(type, noerror) {\n        if (!is(\"name\")) {\n            if (!noerror) croak(\"Name expected\");\n            return null;\n        }\n        var sym = _make_symbol(type);\n        _verify_symbol(sym);\n        next();\n        return sym;\n    }\n\n    function as_symbol_or_string(type) {\n        if (!is(\"name\")) {\n            if (!is(\"string\")) {\n                croak(\"Name or string expected\");\n            }\n            var tok = S.token;\n            var ret = new type({\n                start : tok,\n                end   : tok,\n                name : tok.value,\n                quote : tok.quote\n            });\n            next();\n            return ret;\n        }\n        var sym = _make_symbol(type);\n        _verify_symbol(sym);\n        next();\n        return sym;\n    }\n\n    // Annotate AST_Call, AST_Lambda or AST_New with the special comments\n    function annotate(node, before_token = node.start) {\n        var comments = before_token.comments_before;\n        const comments_outside_parens = outer_comments_before_counts.get(before_token);\n        var i = comments_outside_parens != null ? comments_outside_parens : comments.length;\n        while (--i >= 0) {\n            var comment = comments[i];\n            if (/[@#]__/.test(comment.value)) {\n                if (/[@#]__PURE__/.test(comment.value)) {\n                    set_annotation(node, _PURE);\n                    break;\n                }\n                if (/[@#]__INLINE__/.test(comment.value)) {\n                    set_annotation(node, _INLINE);\n                    break;\n                }\n                if (/[@#]__NOINLINE__/.test(comment.value)) {\n                    set_annotation(node, _NOINLINE);\n                    break;\n                }\n                if (/[@#]__KEY__/.test(comment.value)) {\n                    set_annotation(node, _KEY);\n                    break;\n                }\n                if (/[@#]__MANGLE_PROP__/.test(comment.value)) {\n                    set_annotation(node, _MANGLEPROP);\n                    break;\n                }\n            }\n        }\n        return node;\n    }\n\n    var subscripts = function(expr, allow_calls, is_chain) {\n        var start = expr.start;\n        if (is(\"punc\", \".\")) {\n            next();\n            if(is(\"privatename\") && !S.in_class) \n                croak(\"Private field must be used in an enclosing class\");\n            const AST_DotVariant = is(\"privatename\") ? AST_DotHash : AST_Dot;\n            return annotate(subscripts(new AST_DotVariant({\n                start      : start,\n                expression : expr,\n                optional   : false,\n                property   : as_name(),\n                end        : prev()\n            }), allow_calls, is_chain));\n        }\n        if (is(\"punc\", \"[\")) {\n            next();\n            var prop = expression(true);\n            expect(\"]\");\n            return annotate(subscripts(new AST_Sub({\n                start      : start,\n                expression : expr,\n                optional   : false,\n                property   : prop,\n                end        : prev()\n            }), allow_calls, is_chain));\n        }\n        if (allow_calls && is(\"punc\", \"(\")) {\n            next();\n            var call = new AST_Call({\n                start      : start,\n                expression : expr,\n                optional   : false,\n                args       : call_args(),\n                end        : prev()\n            });\n            annotate(call);\n            return subscripts(call, true, is_chain);\n        }\n\n        // Optional chain\n        if (is(\"punc\", \"?.\")) {\n            next();\n\n            let chain_contents;\n\n            if (allow_calls && is(\"punc\", \"(\")) {\n                next();\n\n                const call = new AST_Call({\n                    start,\n                    optional: true,\n                    expression: expr,\n                    args: call_args(),\n                    end: prev()\n                });\n                annotate(call);\n\n                chain_contents = subscripts(call, true, true);\n            } else if (is(\"name\") || is(\"privatename\")) {\n                if(is(\"privatename\") && !S.in_class) \n                    croak(\"Private field must be used in an enclosing class\");\n                const AST_DotVariant = is(\"privatename\") ? AST_DotHash : AST_Dot;\n                chain_contents = annotate(subscripts(new AST_DotVariant({\n                    start,\n                    expression: expr,\n                    optional: true,\n                    property: as_name(),\n                    end: prev()\n                }), allow_calls, true));\n            } else if (is(\"punc\", \"[\")) {\n                next();\n                const property = expression(true);\n                expect(\"]\");\n                chain_contents = annotate(subscripts(new AST_Sub({\n                    start,\n                    expression: expr,\n                    optional: true,\n                    property,\n                    end: prev()\n                }), allow_calls, true));\n            }\n\n            if (!chain_contents) unexpected();\n\n            if (chain_contents instanceof AST_Chain) return chain_contents;\n\n            return new AST_Chain({\n                start,\n                expression: chain_contents,\n                end: prev()\n            });\n        }\n\n        if (is(\"template_head\")) {\n            if (is_chain) {\n                // a?.b`c` is a syntax error\n                unexpected();\n            }\n\n            return subscripts(new AST_PrefixedTemplateString({\n                start: start,\n                prefix: expr,\n                template_string: template_string(),\n                end: prev()\n            }), allow_calls);\n        }\n        return expr;\n    };\n\n    function call_args() {\n        var args = [];\n        while (!is(\"punc\", \")\")) {\n            if (is(\"expand\", \"...\")) {\n                next();\n                args.push(new AST_Expansion({\n                    start: prev(),\n                    expression: expression(false),\n                    end: prev()\n                }));\n            } else {\n                args.push(expression(false));\n            }\n            if (!is(\"punc\", \")\")) {\n                expect(\",\");\n            }\n        }\n        next();\n        return args;\n    }\n\n    var maybe_unary = function(allow_calls, allow_arrows) {\n        var start = S.token;\n        if (start.type == \"name\" && start.value == \"await\" && can_await()) {\n            next();\n            return _await_expression();\n        }\n        if (is(\"operator\") && UNARY_PREFIX.has(start.value)) {\n            next();\n            handle_regexp();\n            var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(allow_calls));\n            ex.start = start;\n            ex.end = prev();\n            return ex;\n        }\n        var val = expr_atom(allow_calls, allow_arrows);\n        while (is(\"operator\") && UNARY_POSTFIX.has(S.token.value) && !has_newline_before(S.token)) {\n            if (val instanceof AST_Arrow) unexpected();\n            val = make_unary(AST_UnaryPostfix, S.token, val);\n            val.start = start;\n            val.end = S.token;\n            next();\n        }\n        return val;\n    };\n\n    function make_unary(ctor, token, expr) {\n        var op = token.value;\n        switch (op) {\n          case \"++\":\n          case \"--\":\n            if (!is_assignable(expr))\n                croak(\"Invalid use of \" + op + \" operator\", token.line, token.col, token.pos);\n            break;\n          case \"delete\":\n            if (expr instanceof AST_SymbolRef && S.input.has_directive(\"use strict\"))\n                croak(\"Calling delete on expression not allowed in strict mode\", expr.start.line, expr.start.col, expr.start.pos);\n            break;\n        }\n        return new ctor({ operator: op, expression: expr });\n    }\n\n    var expr_op = function(left, min_prec, no_in) {\n        var op = is(\"operator\") ? S.token.value : null;\n        if (op == \"in\" && no_in) op = null;\n        if (op == \"**\" && left instanceof AST_UnaryPrefix\n            /* unary token in front not allowed - parenthesis required */\n            && !is_token(left.start, \"punc\", \"(\")\n            && left.operator !== \"--\" && left.operator !== \"++\")\n                unexpected(left.start);\n        var prec = op != null ? PRECEDENCE[op] : null;\n        if (prec != null && (prec > min_prec || (op === \"**\" && min_prec === prec))) {\n            next();\n            var right = expr_ops(no_in, prec, true);\n            return expr_op(new AST_Binary({\n                start    : left.start,\n                left     : left,\n                operator : op,\n                right    : right,\n                end      : right.end\n            }), min_prec, no_in);\n        }\n        return left;\n    };\n\n    function expr_ops(no_in, min_prec, allow_calls, allow_arrows) {\n        // maybe_unary won't return us a AST_SymbolPrivateProperty\n        if (!no_in && min_prec < PRECEDENCE[\"in\"] && is(\"privatename\")) {\n            if(!S.in_class) {\n                croak(\"Private field must be used in an enclosing class\");\n            }\n\n            const start = S.token;\n            const key = new AST_SymbolPrivateProperty({\n                start,\n                name: start.value,\n                end: start\n            });\n            next();\n            expect_token(\"operator\", \"in\");\n\n            const private_in = new AST_PrivateIn({\n                start,\n                key,\n                value: expr_ops(no_in, PRECEDENCE[\"in\"], true),\n                end: prev()\n            });\n\n            return expr_op(private_in, 0, no_in);\n        } else {\n            return expr_op(maybe_unary(allow_calls, allow_arrows), min_prec, no_in);\n        }\n    }\n\n    var maybe_conditional = function(no_in) {\n        var start = S.token;\n        var expr = expr_ops(no_in, 0, true, true);\n        if (is(\"operator\", \"?\")) {\n            next();\n            var yes = expression(false);\n            expect(\":\");\n            return new AST_Conditional({\n                start       : start,\n                condition   : expr,\n                consequent  : yes,\n                alternative : expression(false, no_in),\n                end         : prev()\n            });\n        }\n        return expr;\n    };\n\n    function is_assignable(expr) {\n        return expr instanceof AST_PropAccess || expr instanceof AST_SymbolRef;\n    }\n\n    function to_destructuring(node) {\n        if (node instanceof AST_Object) {\n            node = new AST_Destructuring({\n                start: node.start,\n                names: node.properties.map(to_destructuring),\n                is_array: false,\n                end: node.end\n            });\n        } else if (node instanceof AST_Array) {\n            var names = [];\n\n            for (var i = 0; i < node.elements.length; i++) {\n                // Only allow expansion as last element\n                if (node.elements[i] instanceof AST_Expansion) {\n                    if (i + 1 !== node.elements.length) {\n                        token_error(node.elements[i].start, \"Spread must the be last element in destructuring array\");\n                    }\n                    node.elements[i].expression = to_destructuring(node.elements[i].expression);\n                }\n\n                names.push(to_destructuring(node.elements[i]));\n            }\n\n            node = new AST_Destructuring({\n                start: node.start,\n                names: names,\n                is_array: true,\n                end: node.end\n            });\n        } else if (node instanceof AST_ObjectProperty) {\n            node.value = to_destructuring(node.value);\n        } else if (node instanceof AST_Assign) {\n            node = new AST_DefaultAssign({\n                start: node.start,\n                left: node.left,\n                operator: \"=\",\n                right: node.right,\n                end: node.end\n            });\n        }\n        return node;\n    }\n\n    // In ES6, AssignmentExpression can also be an ArrowFunction\n    var maybe_assign = function(no_in) {\n        handle_regexp();\n        var start = S.token;\n\n        if (start.type == \"name\" && start.value == \"yield\") {\n            if (is_in_generator()) {\n                next();\n                return _yield_expression();\n            } else if (S.input.has_directive(\"use strict\")) {\n                token_error(S.token, \"Unexpected yield identifier inside strict mode\");\n            }\n        }\n\n        var left = maybe_conditional(no_in);\n        var val = S.token.value;\n\n        if (is(\"operator\") && ASSIGNMENT.has(val)) {\n            if (is_assignable(left) || (left = to_destructuring(left)) instanceof AST_Destructuring) {\n                next();\n\n                return new AST_Assign({\n                    start    : start,\n                    left     : left,\n                    operator : val,\n                    right    : maybe_assign(no_in),\n                    logical  : LOGICAL_ASSIGNMENT.has(val),\n                    end      : prev()\n                });\n            }\n            croak(\"Invalid assignment\");\n        }\n        return left;\n    };\n\n    var to_expr_or_sequence = function(start, exprs) {\n        if (exprs.length === 1) {\n            return exprs[0];\n        } else if (exprs.length > 1) {\n            return new AST_Sequence({ start, expressions: exprs, end: peek() });\n        } else {\n            croak(\"Invalid parenthesized expression\");\n        }\n    };\n\n    var expression = function(commas, no_in) {\n        var start = S.token;\n        var exprs = [];\n        while (true) {\n            exprs.push(maybe_assign(no_in));\n            if (!commas || !is(\"punc\", \",\")) break;\n            next();\n            commas = true;\n        }\n        return to_expr_or_sequence(start, exprs);\n    };\n\n    function in_loop(cont) {\n        ++S.in_loop;\n        var ret = cont();\n        --S.in_loop;\n        return ret;\n    }\n\n    if (options.expression) {\n        return expression(true);\n    }\n\n    return (function parse_toplevel() {\n        var start = S.token;\n        var body = [];\n        S.input.push_directives_stack();\n        if (options.module) S.input.add_directive(\"use strict\");\n        while (!is(\"eof\")) {\n            body.push(statement());\n        }\n        S.input.pop_directives_stack();\n        var end = prev();\n        var toplevel = options.toplevel;\n        if (toplevel) {\n            toplevel.body = toplevel.body.concat(body);\n            toplevel.end = end;\n        } else {\n            toplevel = new AST_Toplevel({ start: start, body: body, end: end });\n        }\n        TEMPLATE_RAWS = new Map();\n        return toplevel;\n    })();\n\n}\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nfunction DEFNODE(type, props, ctor, methods, base = AST_Node) {\n    if (!props) props = [];\n    else props = props.split(/\\s+/);\n    var self_props = props;\n    if (base && base.PROPS)\n        props = props.concat(base.PROPS);\n    const proto = base && Object.create(base.prototype);\n    if (proto) {\n        ctor.prototype = proto;\n        ctor.BASE = base;\n    }\n    if (base) base.SUBCLASSES.push(ctor);\n    ctor.prototype.CTOR = ctor;\n    ctor.prototype.constructor = ctor;\n    ctor.PROPS = props || null;\n    ctor.SELF_PROPS = self_props;\n    ctor.SUBCLASSES = [];\n    if (type) {\n        ctor.prototype.TYPE = ctor.TYPE = type;\n    }\n    if (methods) for (let i in methods) if (HOP(methods, i)) {\n        if (i[0] === \"$\") {\n            ctor[i.substr(1)] = methods[i];\n        } else {\n            ctor.prototype[i] = methods[i];\n        }\n    }\n    ctor.DEFMETHOD = function(name, method) {\n        this.prototype[name] = method;\n    };\n    return ctor;\n}\n\nconst has_tok_flag = (tok, flag) => Boolean(tok.flags & flag);\nconst set_tok_flag = (tok, flag, truth) => {\n    if (truth) {\n        tok.flags |= flag;\n    } else {\n        tok.flags &= ~flag;\n    }\n};\n\nconst TOK_FLAG_NLB          = 0b0001;\nconst TOK_FLAG_QUOTE_SINGLE = 0b0010;\nconst TOK_FLAG_QUOTE_EXISTS = 0b0100;\nconst TOK_FLAG_TEMPLATE_END = 0b1000;\n\nclass AST_Token {\n    constructor(type, value, line, col, pos, nlb, comments_before, comments_after, file) {\n        this.flags = (nlb ? 1 : 0);\n\n        this.type = type;\n        this.value = value;\n        this.line = line;\n        this.col = col;\n        this.pos = pos;\n        this.comments_before = comments_before;\n        this.comments_after = comments_after;\n        this.file = file;\n\n        Object.seal(this);\n    }\n\n    // Return a string summary of the token for node.js console.log\n    [Symbol.for(\"nodejs.util.inspect.custom\")](_depth, options) {\n        const special = str => options.stylize(str, \"special\");\n        const quote = typeof this.value === \"string\" && this.value.includes(\"`\") ? \"'\" : \"`\";\n        const value = `${quote}${this.value}${quote}`;\n        return `${special(\"[AST_Token\")} ${value} at ${this.line}:${this.col}${special(\"]\")}`;\n    }\n\n    get nlb() {\n        return has_tok_flag(this, TOK_FLAG_NLB);\n    }\n\n    set nlb(new_nlb) {\n        set_tok_flag(this, TOK_FLAG_NLB, new_nlb);\n    }\n\n    get quote() {\n        return !has_tok_flag(this, TOK_FLAG_QUOTE_EXISTS)\n            ? \"\"\n            : (has_tok_flag(this, TOK_FLAG_QUOTE_SINGLE) ? \"'\" : '\"');\n    }\n\n    set quote(quote_type) {\n        set_tok_flag(this, TOK_FLAG_QUOTE_SINGLE, quote_type === \"'\");\n        set_tok_flag(this, TOK_FLAG_QUOTE_EXISTS, !!quote_type);\n    }\n\n    get template_end() {\n        return has_tok_flag(this, TOK_FLAG_TEMPLATE_END);\n    }\n\n    set template_end(new_template_end) {\n        set_tok_flag(this, TOK_FLAG_TEMPLATE_END, new_template_end);\n    }\n}\n\nvar AST_Node = DEFNODE(\"Node\", \"start end\", function AST_Node(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    _clone: function(deep) {\n        if (deep) {\n            var self = this.clone();\n            return self.transform(new TreeTransformer(function(node) {\n                if (node !== self) {\n                    return node.clone(true);\n                }\n            }));\n        }\n        return new this.CTOR(this);\n    },\n    clone: function(deep) {\n        return this._clone(deep);\n    },\n    $documentation: \"Base class of all AST nodes\",\n    $propdoc: {\n        start: \"[AST_Token] The first token of this node\",\n        end: \"[AST_Token] The last token of this node\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this);\n    },\n    walk: function(visitor) {\n        return this._walk(visitor); // not sure the indirection will be any help\n    },\n    _children_backwards: () => {}\n}, null);\n\n/* -----[ statements ]----- */\n\nvar AST_Statement = DEFNODE(\"Statement\", null, function AST_Statement(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class of all statements\",\n});\n\nvar AST_Debugger = DEFNODE(\"Debugger\", null, function AST_Debugger(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Represents a debugger statement\",\n}, AST_Statement);\n\nvar AST_Directive = DEFNODE(\"Directive\", \"value quote\", function AST_Directive(props) {\n    if (props) {\n        this.value = props.value;\n        this.quote = props.quote;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Represents a directive, like \\\"use strict\\\";\",\n    $propdoc: {\n        value: \"[string] The value of this directive as a plain string (it's not an AST_String!)\",\n        quote: \"[string] the original quote character\"\n    },\n}, AST_Statement);\n\nvar AST_SimpleStatement = DEFNODE(\"SimpleStatement\", \"body\", function AST_SimpleStatement(props) {\n    if (props) {\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A statement consisting of an expression, i.e. a = 1 + 2\",\n    $propdoc: {\n        body: \"[AST_Node] an expression node (should not be instanceof AST_Statement)\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n    }\n}, AST_Statement);\n\nfunction walk_body(node, visitor) {\n    const body = node.body;\n    for (var i = 0, len = body.length; i < len; i++) {\n        body[i]._walk(visitor);\n    }\n}\n\nfunction clone_block_scope(deep) {\n    var clone = this._clone(deep);\n    if (this.block_scope) {\n        clone.block_scope = this.block_scope.clone();\n    }\n    return clone;\n}\n\nvar AST_Block = DEFNODE(\"Block\", \"body block_scope\", function AST_Block(props) {\n    if (props) {\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A body of statements (usually braced)\",\n    $propdoc: {\n        body: \"[AST_Statement*] an array of statements\",\n        block_scope: \"[AST_Scope] the block scope\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            walk_body(this, visitor);\n        });\n    },\n    _children_backwards(push) {\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n    },\n    clone: clone_block_scope\n}, AST_Statement);\n\nvar AST_BlockStatement = DEFNODE(\"BlockStatement\", null, function AST_BlockStatement(props) {\n    if (props) {\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A block statement\",\n}, AST_Block);\n\nvar AST_EmptyStatement = DEFNODE(\"EmptyStatement\", null, function AST_EmptyStatement(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The empty statement (empty block or simply a semicolon)\"\n}, AST_Statement);\n\nvar AST_StatementWithBody = DEFNODE(\"StatementWithBody\", \"body\", function AST_StatementWithBody(props) {\n    if (props) {\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`\",\n    $propdoc: {\n        body: \"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\"\n    }\n}, AST_Statement);\n\nvar AST_LabeledStatement = DEFNODE(\"LabeledStatement\", \"label\", function AST_LabeledStatement(props) {\n    if (props) {\n        this.label = props.label;\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Statement with a label\",\n    $propdoc: {\n        label: \"[AST_Label] a label definition\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.label._walk(visitor);\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n        push(this.label);\n    },\n    clone: function(deep) {\n        var node = this._clone(deep);\n        if (deep) {\n            var label = node.label;\n            var def = this.label;\n            node.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_LoopControl\n                    && node.label && node.label.thedef === def) {\n                    node.label.thedef = label;\n                    label.references.push(node);\n                }\n            }));\n        }\n        return node;\n    }\n}, AST_StatementWithBody);\n\nvar AST_IterationStatement = DEFNODE(\n    \"IterationStatement\",\n    \"block_scope\",\n    function AST_IterationStatement(props) {\n        if (props) {\n            this.block_scope = props.block_scope;\n            this.body = props.body;\n            this.start = props.start;\n            this.end = props.end;\n        }\n\n        this.flags = 0;\n    },\n    {\n        $documentation: \"Internal class.  All loops inherit from it.\",\n        $propdoc: {\n            block_scope: \"[AST_Scope] the block scope for this iteration statement.\"\n        },\n        clone: clone_block_scope\n    },\n    AST_StatementWithBody\n);\n\nvar AST_DWLoop = DEFNODE(\"DWLoop\", \"condition\", function AST_DWLoop(props) {\n    if (props) {\n        this.condition = props.condition;\n        this.block_scope = props.block_scope;\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for do/while statements\",\n    $propdoc: {\n        condition: \"[AST_Node] the loop condition.  Should not be instanceof AST_Statement\"\n    }\n}, AST_IterationStatement);\n\nvar AST_Do = DEFNODE(\"Do\", null, function AST_Do(props) {\n    if (props) {\n        this.condition = props.condition;\n        this.block_scope = props.block_scope;\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `do` statement\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.body._walk(visitor);\n            this.condition._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.condition);\n        push(this.body);\n    }\n}, AST_DWLoop);\n\nvar AST_While = DEFNODE(\"While\", null, function AST_While(props) {\n    if (props) {\n        this.condition = props.condition;\n        this.block_scope = props.block_scope;\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `while` statement\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.condition._walk(visitor);\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n        push(this.condition);\n    },\n}, AST_DWLoop);\n\nvar AST_For = DEFNODE(\"For\", \"init condition step\", function AST_For(props) {\n    if (props) {\n        this.init = props.init;\n        this.condition = props.condition;\n        this.step = props.step;\n        this.block_scope = props.block_scope;\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `for` statement\",\n    $propdoc: {\n        init: \"[AST_Node?] the `for` initialization code, or null if empty\",\n        condition: \"[AST_Node?] the `for` termination clause, or null if empty\",\n        step: \"[AST_Node?] the `for` update clause, or null if empty\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.init) this.init._walk(visitor);\n            if (this.condition) this.condition._walk(visitor);\n            if (this.step) this.step._walk(visitor);\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n        if (this.step) push(this.step);\n        if (this.condition) push(this.condition);\n        if (this.init) push(this.init);\n    },\n}, AST_IterationStatement);\n\nvar AST_ForIn = DEFNODE(\"ForIn\", \"init object\", function AST_ForIn(props) {\n    if (props) {\n        this.init = props.init;\n        this.object = props.object;\n        this.block_scope = props.block_scope;\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `for ... in` statement\",\n    $propdoc: {\n        init: \"[AST_Node] the `for/in` initialization code\",\n        object: \"[AST_Node] the object that we're looping through\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.init._walk(visitor);\n            this.object._walk(visitor);\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n        if (this.object) push(this.object);\n        if (this.init) push(this.init);\n    },\n}, AST_IterationStatement);\n\nvar AST_ForOf = DEFNODE(\"ForOf\", \"await\", function AST_ForOf(props) {\n    if (props) {\n        this.await = props.await;\n        this.init = props.init;\n        this.object = props.object;\n        this.block_scope = props.block_scope;\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `for ... of` statement\",\n}, AST_ForIn);\n\nvar AST_With = DEFNODE(\"With\", \"expression\", function AST_With(props) {\n    if (props) {\n        this.expression = props.expression;\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `with` statement\",\n    $propdoc: {\n        expression: \"[AST_Node] the `with` expression\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n        push(this.expression);\n    },\n}, AST_StatementWithBody);\n\n/* -----[ scope and functions ]----- */\n\nvar AST_Scope = DEFNODE(\n    \"Scope\",\n    \"variables uses_with uses_eval parent_scope enclosed cname\",\n    function AST_Scope(props) {\n        if (props) {\n            this.variables = props.variables;\n            this.uses_with = props.uses_with;\n            this.uses_eval = props.uses_eval;\n            this.parent_scope = props.parent_scope;\n            this.enclosed = props.enclosed;\n            this.cname = props.cname;\n            this.body = props.body;\n            this.block_scope = props.block_scope;\n            this.start = props.start;\n            this.end = props.end;\n        }\n\n        this.flags = 0;\n    },\n    {\n        $documentation: \"Base class for all statements introducing a lexical scope\",\n        $propdoc: {\n            variables: \"[Map/S] a map of name -> SymbolDef for all variables/functions defined in this scope\",\n            uses_with: \"[boolean/S] tells whether this scope uses the `with` statement\",\n            uses_eval: \"[boolean/S] tells whether this scope contains a direct call to the global `eval`\",\n            parent_scope: \"[AST_Scope?/S] link to the parent scope\",\n            enclosed: \"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes\",\n            cname: \"[integer/S] current index for mangling variables (used internally by the mangler)\",\n        },\n        get_defun_scope: function() {\n            var self = this;\n            while (self.is_block_scope()) {\n                self = self.parent_scope;\n            }\n            return self;\n        },\n        clone: function(deep, toplevel) {\n            var node = this._clone(deep);\n            if (deep && this.variables && toplevel && !this._block_scope) {\n                node.figure_out_scope({}, {\n                    toplevel: toplevel,\n                    parent_scope: this.parent_scope\n                });\n            } else {\n                if (this.variables) node.variables = new Map(this.variables);\n                if (this.enclosed) node.enclosed = this.enclosed.slice();\n                if (this._block_scope) node._block_scope = this._block_scope;\n            }\n            return node;\n        },\n        pinned: function() {\n            return this.uses_eval || this.uses_with;\n        }\n    },\n    AST_Block\n);\n\nvar AST_Toplevel = DEFNODE(\"Toplevel\", \"globals\", function AST_Toplevel(props) {\n    if (props) {\n        this.globals = props.globals;\n        this.variables = props.variables;\n        this.uses_with = props.uses_with;\n        this.uses_eval = props.uses_eval;\n        this.parent_scope = props.parent_scope;\n        this.enclosed = props.enclosed;\n        this.cname = props.cname;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The toplevel scope\",\n    $propdoc: {\n        globals: \"[Map/S] a map of name -> SymbolDef for all undeclared names\",\n    },\n    wrap_commonjs: function(name) {\n        var body = this.body;\n        var wrapped_tl = \"(function(exports){'$ORIG';})(typeof \" + name + \"=='undefined'?(\" + name + \"={}):\" + name + \");\";\n        wrapped_tl = parse(wrapped_tl);\n        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function(node) {\n            if (node instanceof AST_Directive && node.value == \"$ORIG\") {\n                return MAP.splice(body);\n            }\n        }));\n        return wrapped_tl;\n    },\n    wrap_enclose: function(args_values) {\n        if (typeof args_values != \"string\") args_values = \"\";\n        var index = args_values.indexOf(\":\");\n        if (index < 0) index = args_values.length;\n        var body = this.body;\n        return parse([\n            \"(function(\",\n            args_values.slice(0, index),\n            '){\"$ORIG\"})(',\n            args_values.slice(index + 1),\n            \")\"\n        ].join(\"\")).transform(new TreeTransformer(function(node) {\n            if (node instanceof AST_Directive && node.value == \"$ORIG\") {\n                return MAP.splice(body);\n            }\n        }));\n    }\n}, AST_Scope);\n\nvar AST_Expansion = DEFNODE(\"Expansion\", \"expression\", function AST_Expansion(props) {\n    if (props) {\n        this.expression = props.expression;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list\",\n    $propdoc: {\n        expression: \"[AST_Node] the thing to be expanded\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression.walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n});\n\nvar AST_Lambda = DEFNODE(\n    \"Lambda\",\n    \"name argnames uses_arguments is_generator async\",\n    function AST_Lambda(props) {\n        if (props) {\n            this.name = props.name;\n            this.argnames = props.argnames;\n            this.uses_arguments = props.uses_arguments;\n            this.is_generator = props.is_generator;\n            this.async = props.async;\n            this.variables = props.variables;\n            this.uses_with = props.uses_with;\n            this.uses_eval = props.uses_eval;\n            this.parent_scope = props.parent_scope;\n            this.enclosed = props.enclosed;\n            this.cname = props.cname;\n            this.body = props.body;\n            this.block_scope = props.block_scope;\n            this.start = props.start;\n            this.end = props.end;\n        }\n\n        this.flags = 0;\n    },\n    {\n        $documentation: \"Base class for functions\",\n        $propdoc: {\n            name: \"[AST_SymbolDeclaration?] the name of this function\",\n            argnames: \"[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments\",\n            uses_arguments: \"[boolean/S] tells whether this function accesses the arguments array\",\n            is_generator: \"[boolean] is this a generator method\",\n            async: \"[boolean] is this method async\",\n        },\n        args_as_names: function () {\n            var out = [];\n            for (var i = 0; i < this.argnames.length; i++) {\n                if (this.argnames[i] instanceof AST_Destructuring) {\n                    out.push(...this.argnames[i].all_symbols());\n                } else {\n                    out.push(this.argnames[i]);\n                }\n            }\n            return out;\n        },\n        _walk: function(visitor) {\n            return visitor._visit(this, function() {\n                if (this.name) this.name._walk(visitor);\n                var argnames = this.argnames;\n                for (var i = 0, len = argnames.length; i < len; i++) {\n                    argnames[i]._walk(visitor);\n                }\n                walk_body(this, visitor);\n            });\n        },\n        _children_backwards(push) {\n            let i = this.body.length;\n            while (i--) push(this.body[i]);\n\n            i = this.argnames.length;\n            while (i--) push(this.argnames[i]);\n\n            if (this.name) push(this.name);\n        },\n        is_braceless() {\n            return this.body[0] instanceof AST_Return && this.body[0].value;\n        },\n        // Default args and expansion don't count, so .argnames.length doesn't cut it\n        length_property() {\n            let length = 0;\n\n            for (const arg of this.argnames) {\n                if (arg instanceof AST_SymbolFunarg || arg instanceof AST_Destructuring) {\n                    length++;\n                }\n            }\n\n            return length;\n        }\n    },\n    AST_Scope\n);\n\nvar AST_Accessor = DEFNODE(\"Accessor\", null, function AST_Accessor(props) {\n    if (props) {\n        this.name = props.name;\n        this.argnames = props.argnames;\n        this.uses_arguments = props.uses_arguments;\n        this.is_generator = props.is_generator;\n        this.async = props.async;\n        this.variables = props.variables;\n        this.uses_with = props.uses_with;\n        this.uses_eval = props.uses_eval;\n        this.parent_scope = props.parent_scope;\n        this.enclosed = props.enclosed;\n        this.cname = props.cname;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A setter/getter function.  The `name` property is always null.\"\n}, AST_Lambda);\n\nvar AST_Function = DEFNODE(\"Function\", null, function AST_Function(props) {\n    if (props) {\n        this.name = props.name;\n        this.argnames = props.argnames;\n        this.uses_arguments = props.uses_arguments;\n        this.is_generator = props.is_generator;\n        this.async = props.async;\n        this.variables = props.variables;\n        this.uses_with = props.uses_with;\n        this.uses_eval = props.uses_eval;\n        this.parent_scope = props.parent_scope;\n        this.enclosed = props.enclosed;\n        this.cname = props.cname;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A function expression\"\n}, AST_Lambda);\n\nvar AST_Arrow = DEFNODE(\"Arrow\", null, function AST_Arrow(props) {\n    if (props) {\n        this.name = props.name;\n        this.argnames = props.argnames;\n        this.uses_arguments = props.uses_arguments;\n        this.is_generator = props.is_generator;\n        this.async = props.async;\n        this.variables = props.variables;\n        this.uses_with = props.uses_with;\n        this.uses_eval = props.uses_eval;\n        this.parent_scope = props.parent_scope;\n        this.enclosed = props.enclosed;\n        this.cname = props.cname;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"An ES6 Arrow function ((a) => b)\"\n}, AST_Lambda);\n\nvar AST_Defun = DEFNODE(\"Defun\", null, function AST_Defun(props) {\n    if (props) {\n        this.name = props.name;\n        this.argnames = props.argnames;\n        this.uses_arguments = props.uses_arguments;\n        this.is_generator = props.is_generator;\n        this.async = props.async;\n        this.variables = props.variables;\n        this.uses_with = props.uses_with;\n        this.uses_eval = props.uses_eval;\n        this.parent_scope = props.parent_scope;\n        this.enclosed = props.enclosed;\n        this.cname = props.cname;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A function definition\"\n}, AST_Lambda);\n\n/* -----[ DESTRUCTURING ]----- */\nvar AST_Destructuring = DEFNODE(\"Destructuring\", \"names is_array\", function AST_Destructuring(props) {\n    if (props) {\n        this.names = props.names;\n        this.is_array = props.is_array;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A destructuring of several names. Used in destructuring assignment and with destructuring function argument names\",\n    $propdoc: {\n        \"names\": \"[AST_Node*] Array of properties or elements\",\n        \"is_array\": \"[Boolean] Whether the destructuring represents an object or array\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.names.forEach(function(name) {\n                name._walk(visitor);\n            });\n        });\n    },\n    _children_backwards(push) {\n        let i = this.names.length;\n        while (i--) push(this.names[i]);\n    },\n    all_symbols: function() {\n        var out = [];\n        walk(this, node => {\n            if (node instanceof AST_SymbolDeclaration) {\n                out.push(node);\n            }\n            if (node instanceof AST_Lambda) {\n                return true;\n            }\n        });\n        return out;\n    }\n});\n\nvar AST_PrefixedTemplateString = DEFNODE(\n    \"PrefixedTemplateString\",\n    \"template_string prefix\",\n    function AST_PrefixedTemplateString(props) {\n        if (props) {\n            this.template_string = props.template_string;\n            this.prefix = props.prefix;\n            this.start = props.start;\n            this.end = props.end;\n        }\n\n        this.flags = 0;\n    },\n    {\n        $documentation: \"A templatestring with a prefix, such as String.raw`foobarbaz`\",\n        $propdoc: {\n            template_string: \"[AST_TemplateString] The template string\",\n            prefix: \"[AST_Node] The prefix, which will get called.\"\n        },\n        _walk: function(visitor) {\n            return visitor._visit(this, function () {\n                this.prefix._walk(visitor);\n                this.template_string._walk(visitor);\n            });\n        },\n        _children_backwards(push) {\n            push(this.template_string);\n            push(this.prefix);\n        },\n    }\n);\n\nvar AST_TemplateString = DEFNODE(\"TemplateString\", \"segments\", function AST_TemplateString(props) {\n    if (props) {\n        this.segments = props.segments;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A template string literal\",\n    $propdoc: {\n        segments: \"[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment.\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.segments.forEach(function(seg) {\n                seg._walk(visitor);\n            });\n        });\n    },\n    _children_backwards(push) {\n        let i = this.segments.length;\n        while (i--) push(this.segments[i]);\n    }\n});\n\nvar AST_TemplateSegment = DEFNODE(\"TemplateSegment\", \"value raw\", function AST_TemplateSegment(props) {\n    if (props) {\n        this.value = props.value;\n        this.raw = props.raw;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A segment of a template string literal\",\n    $propdoc: {\n        value: \"Content of the segment\",\n        raw: \"Raw source of the segment\",\n    }\n});\n\n/* -----[ JUMPS ]----- */\n\nvar AST_Jump = DEFNODE(\"Jump\", null, function AST_Jump(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for jumps (for now that's `return`, `throw`, `break` and `continue`)\"\n}, AST_Statement);\n\n/** Base class for exits (`return` and `throw`) */\nvar AST_Exit = DEFNODE(\"Exit\", \"value\", function AST_Exit(props) {\n    if (props) {\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for exits (`return` and `throw`)\",\n    $propdoc: {\n        value: \"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, this.value && function() {\n            this.value._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.value) push(this.value);\n    },\n}, AST_Jump);\n\nvar AST_Return = DEFNODE(\"Return\", null, function AST_Return(props) {\n    if (props) {\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `return` statement\"\n}, AST_Exit);\n\nvar AST_Throw = DEFNODE(\"Throw\", null, function AST_Throw(props) {\n    if (props) {\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `throw` statement\"\n}, AST_Exit);\n\nvar AST_LoopControl = DEFNODE(\"LoopControl\", \"label\", function AST_LoopControl(props) {\n    if (props) {\n        this.label = props.label;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for loop control statements (`break` and `continue`)\",\n    $propdoc: {\n        label: \"[AST_LabelRef?] the label, or null if none\",\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, this.label && function() {\n            this.label._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.label) push(this.label);\n    },\n}, AST_Jump);\n\nvar AST_Break = DEFNODE(\"Break\", null, function AST_Break(props) {\n    if (props) {\n        this.label = props.label;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `break` statement\"\n}, AST_LoopControl);\n\nvar AST_Continue = DEFNODE(\"Continue\", null, function AST_Continue(props) {\n    if (props) {\n        this.label = props.label;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `continue` statement\"\n}, AST_LoopControl);\n\nvar AST_Await = DEFNODE(\"Await\", \"expression\", function AST_Await(props) {\n    if (props) {\n        this.expression = props.expression;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"An `await` statement\",\n    $propdoc: {\n        expression: \"[AST_Node] the mandatory expression being awaited\",\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n});\n\nvar AST_Yield = DEFNODE(\"Yield\", \"expression is_star\", function AST_Yield(props) {\n    if (props) {\n        this.expression = props.expression;\n        this.is_star = props.is_star;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `yield` statement\",\n    $propdoc: {\n        expression: \"[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false\",\n        is_star: \"[Boolean] Whether this is a yield or yield* statement\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, this.expression && function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.expression) push(this.expression);\n    }\n});\n\n/* -----[ IF ]----- */\n\nvar AST_If = DEFNODE(\"If\", \"condition alternative\", function AST_If(props) {\n    if (props) {\n        this.condition = props.condition;\n        this.alternative = props.alternative;\n        this.body = props.body;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `if` statement\",\n    $propdoc: {\n        condition: \"[AST_Node] the `if` condition\",\n        alternative: \"[AST_Statement?] the `else` part, or null if not present\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.condition._walk(visitor);\n            this.body._walk(visitor);\n            if (this.alternative) this.alternative._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.alternative) {\n            push(this.alternative);\n        }\n        push(this.body);\n        push(this.condition);\n    }\n}, AST_StatementWithBody);\n\n/* -----[ SWITCH ]----- */\n\nvar AST_Switch = DEFNODE(\"Switch\", \"expression\", function AST_Switch(props) {\n    if (props) {\n        this.expression = props.expression;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `switch` statement\",\n    $propdoc: {\n        expression: \"[AST_Node] the `switch` discriminant\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n            walk_body(this, visitor);\n        });\n    },\n    _children_backwards(push) {\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n        push(this.expression);\n    }\n}, AST_Block);\n\nvar AST_SwitchBranch = DEFNODE(\"SwitchBranch\", null, function AST_SwitchBranch(props) {\n    if (props) {\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for `switch` branches\",\n}, AST_Block);\n\nvar AST_Default = DEFNODE(\"Default\", null, function AST_Default(props) {\n    if (props) {\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `default` switch branch\",\n}, AST_SwitchBranch);\n\nvar AST_Case = DEFNODE(\"Case\", \"expression\", function AST_Case(props) {\n    if (props) {\n        this.expression = props.expression;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `case` switch branch\",\n    $propdoc: {\n        expression: \"[AST_Node] the `case` expression\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n            walk_body(this, visitor);\n        });\n    },\n    _children_backwards(push) {\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n        push(this.expression);\n    },\n}, AST_SwitchBranch);\n\n/* -----[ EXCEPTIONS ]----- */\n\nvar AST_Try = DEFNODE(\"Try\", \"body bcatch bfinally\", function AST_Try(props) {\n    if (props) {\n        this.body = props.body;\n        this.bcatch = props.bcatch;\n        this.bfinally = props.bfinally;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `try` statement\",\n    $propdoc: {\n        body: \"[AST_TryBlock] the try block\",\n        bcatch: \"[AST_Catch?] the catch block, or null if not present\",\n        bfinally: \"[AST_Finally?] the finally block, or null if not present\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.body._walk(visitor);\n            if (this.bcatch) this.bcatch._walk(visitor);\n            if (this.bfinally) this.bfinally._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.bfinally) push(this.bfinally);\n        if (this.bcatch) push(this.bcatch);\n        push(this.body);\n    },\n}, AST_Statement);\n\nvar AST_TryBlock = DEFNODE(\"TryBlock\", null, function AST_TryBlock(props) {\n    if (props) {\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The `try` block of a try statement\"\n}, AST_Block);\n\nvar AST_Catch = DEFNODE(\"Catch\", \"argname\", function AST_Catch(props) {\n    if (props) {\n        this.argname = props.argname;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `catch` node; only makes sense as part of a `try` statement\",\n    $propdoc: {\n        argname: \"[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.argname) this.argname._walk(visitor);\n            walk_body(this, visitor);\n        });\n    },\n    _children_backwards(push) {\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n        if (this.argname) push(this.argname);\n    },\n}, AST_Block);\n\nvar AST_Finally = DEFNODE(\"Finally\", null, function AST_Finally(props) {\n    if (props) {\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `finally` node; only makes sense as part of a `try` statement\"\n}, AST_Block);\n\n/* -----[ VAR/CONST ]----- */\n\nvar AST_DefinitionsLike = DEFNODE(\"DefinitionsLike\", \"definitions\", function AST_DefinitionsLike(props) {\n    if (props) {\n        this.definitions = props.definitions;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for variable definitions and `using`\",\n    $propdoc: {\n        definitions: \"[AST_VarDef*|AST_UsingDef*] array of variable definitions\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            var definitions = this.definitions;\n            for (var i = 0, len = definitions.length; i < len; i++) {\n                definitions[i]._walk(visitor);\n            }\n        });\n    },\n    _children_backwards(push) {\n        let i = this.definitions.length;\n        while (i--) push(this.definitions[i]);\n    },\n}, AST_Statement);\n\nvar AST_Definitions = DEFNODE(\"Definitions\", null, function AST_Definitions(props) {\n    if (props) {\n        this.definitions = props.definitions;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for `var` or `const` nodes (variable declarations/initializations)\",\n}, AST_DefinitionsLike);\n\nvar AST_Var = DEFNODE(\"Var\", null, function AST_Var(props) {\n    if (props) {\n        this.definitions = props.definitions;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `var` statement\"\n}, AST_Definitions);\n\nvar AST_Let = DEFNODE(\"Let\", null, function AST_Let(props) {\n    if (props) {\n        this.definitions = props.definitions;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `let` statement\"\n}, AST_Definitions);\n\nvar AST_Const = DEFNODE(\"Const\", null, function AST_Const(props) {\n    if (props) {\n        this.definitions = props.definitions;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `const` statement\"\n}, AST_Definitions);\n\nvar AST_Using = DEFNODE(\"Using\", \"await\", function AST_Using(props) {\n    if (props) {\n        this.await = props.await;\n        this.definitions = props.definitions;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `using` statement\",\n    $propdoc: {\n        await: \"[boolean] Whether it's `await using`\"\n    },\n}, AST_DefinitionsLike);\n\nvar AST_VarDefLike = DEFNODE(\"VarDefLike\", \"name value\", function AST_VarDefLike(props) {\n    if (props) {\n        this.name = props.name;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A name=value pair in a variable definition statement or `using`\",\n    $propdoc: {\n        name: \"[AST_Destructuring|AST_SymbolDeclaration] name of the variable\",\n        value: \"[AST_Node?] initializer, or null of there's no initializer\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.name._walk(visitor);\n            if (this.value) this.value._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.value) push(this.value);\n        push(this.name);\n    },\n    declarations_as_names() {\n        if (this.name instanceof AST_SymbolDeclaration) {\n            return [this.name];\n        } else {\n            return this.name.all_symbols();\n        }\n    }\n});\n\nvar AST_VarDef = DEFNODE(\"VarDef\", null, function AST_VarDef(props) {\n    if (props) {\n        this.name = props.name;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A variable declaration; only appears in a AST_Definitions node\",\n}, AST_VarDefLike);\n\nvar AST_UsingDef = DEFNODE(\"UsingDef\", null, function AST_UsingDef(props) {\n    if (props) {\n        this.name = props.name;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Like VarDef but specific to AST_Using\",\n}, AST_VarDefLike);\n\nvar AST_NameMapping = DEFNODE(\"NameMapping\", \"foreign_name name\", function AST_NameMapping(props) {\n    if (props) {\n        this.foreign_name = props.foreign_name;\n        this.name = props.name;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The part of the export/import statement that declare names from a module.\",\n    $propdoc: {\n        foreign_name: \"[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)\",\n        name: \"[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module.\"\n    },\n    _walk: function (visitor) {\n        return visitor._visit(this, function() {\n            this.foreign_name._walk(visitor);\n            this.name._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.name);\n        push(this.foreign_name);\n    },\n});\n\nvar AST_Import = DEFNODE(\n    \"Import\",\n    \"imported_name imported_names module_name attributes\",\n    function AST_Import(props) {\n        if (props) {\n            this.imported_name = props.imported_name;\n            this.imported_names = props.imported_names;\n            this.module_name = props.module_name;\n            this.attributes = props.attributes;\n            this.start = props.start;\n            this.end = props.end;\n        }\n\n        this.flags = 0;\n    },\n    {\n        $documentation: \"An `import` statement\",\n        $propdoc: {\n            imported_name: \"[AST_SymbolImport] The name of the variable holding the module's default export.\",\n            imported_names: \"[AST_NameMapping*] The names of non-default imported variables\",\n            module_name: \"[AST_String] String literal describing where this module came from\",\n            attributes: \"[AST_Object?] The import attributes (with {...})\"\n        },\n        _walk: function(visitor) {\n            return visitor._visit(this, function() {\n                if (this.imported_name) {\n                    this.imported_name._walk(visitor);\n                }\n                if (this.imported_names) {\n                    this.imported_names.forEach(function(name_import) {\n                        name_import._walk(visitor);\n                    });\n                }\n                this.module_name._walk(visitor);\n            });\n        },\n        _children_backwards(push) {\n            push(this.module_name);\n            if (this.imported_names) {\n                let i = this.imported_names.length;\n                while (i--) push(this.imported_names[i]);\n            }\n            if (this.imported_name) push(this.imported_name);\n        },\n    }\n);\n\nvar AST_ImportMeta = DEFNODE(\"ImportMeta\", null, function AST_ImportMeta(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A reference to import.meta\",\n});\n\nvar AST_Export = DEFNODE(\n    \"Export\",\n    \"exported_definition exported_value is_default exported_names module_name attributes\",\n    function AST_Export(props) {\n        if (props) {\n            this.exported_definition = props.exported_definition;\n            this.exported_value = props.exported_value;\n            this.is_default = props.is_default;\n            this.exported_names = props.exported_names;\n            this.module_name = props.module_name;\n            this.attributes = props.attributes;\n            this.start = props.start;\n            this.end = props.end;\n        }\n\n        this.flags = 0;\n    },\n    {\n        $documentation: \"An `export` statement\",\n        $propdoc: {\n            exported_definition: \"[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition\",\n            exported_value: \"[AST_Node?] An exported value\",\n            exported_names: \"[AST_NameMapping*?] List of exported names\",\n            module_name: \"[AST_String?] Name of the file to load exports from\",\n            is_default: \"[Boolean] Whether this is the default exported value of this module\",\n            attributes: \"[AST_Object?] The import attributes\"\n        },\n        _walk: function (visitor) {\n            return visitor._visit(this, function () {\n                if (this.exported_definition) {\n                    this.exported_definition._walk(visitor);\n                }\n                if (this.exported_value) {\n                    this.exported_value._walk(visitor);\n                }\n                if (this.exported_names) {\n                    this.exported_names.forEach(function(name_export) {\n                        name_export._walk(visitor);\n                    });\n                }\n                if (this.module_name) {\n                    this.module_name._walk(visitor);\n                }\n            });\n        },\n        _children_backwards(push) {\n            if (this.module_name) push(this.module_name);\n            if (this.exported_names) {\n                let i = this.exported_names.length;\n                while (i--) push(this.exported_names[i]);\n            }\n            if (this.exported_value) push(this.exported_value);\n            if (this.exported_definition) push(this.exported_definition);\n        }\n    },\n    AST_Statement\n);\n\n/* -----[ OTHER ]----- */\n\nvar AST_Call = DEFNODE(\n    \"Call\",\n    \"expression args optional _annotations\",\n    function AST_Call(props) {\n        if (props) {\n            this.expression = props.expression;\n            this.args = props.args;\n            this.optional = props.optional;\n            this._annotations = props._annotations;\n            this.start = props.start;\n            this.end = props.end;\n            this.initialize();\n        }\n\n        this.flags = 0;\n    },\n    {\n        $documentation: \"A function call expression\",\n        $propdoc: {\n            expression: \"[AST_Node] expression to invoke as function\",\n            args: \"[AST_Node*] array of arguments\",\n            optional: \"[boolean] whether this is an optional call (IE ?.() )\",\n            _annotations: \"[number] bitfield containing information about the call\"\n        },\n        initialize() {\n            if (this._annotations == null) this._annotations = 0;\n        },\n        _walk(visitor) {\n            return visitor._visit(this, function() {\n                var args = this.args;\n                for (var i = 0, len = args.length; i < len; i++) {\n                    args[i]._walk(visitor);\n                }\n                this.expression._walk(visitor);  // TODO why do we need to crawl this last?\n            });\n        },\n        _children_backwards(push) {\n            let i = this.args.length;\n            while (i--) push(this.args[i]);\n            push(this.expression);\n        },\n    }\n);\n\nvar AST_New = DEFNODE(\"New\", null, function AST_New(props) {\n    if (props) {\n        this.expression = props.expression;\n        this.args = props.args;\n        this.optional = props.optional;\n        this._annotations = props._annotations;\n        this.start = props.start;\n        this.end = props.end;\n        this.initialize();\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"An object instantiation.  Derives from a function call since it has exactly the same properties\"\n}, AST_Call);\n\nvar AST_Sequence = DEFNODE(\"Sequence\", \"expressions\", function AST_Sequence(props) {\n    if (props) {\n        this.expressions = props.expressions;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A sequence expression (comma-separated expressions)\",\n    $propdoc: {\n        expressions: \"[AST_Node*] array of expressions (at least two)\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expressions.forEach(function(node) {\n                node._walk(visitor);\n            });\n        });\n    },\n    _children_backwards(push) {\n        let i = this.expressions.length;\n        while (i--) push(this.expressions[i]);\n    },\n});\n\nvar AST_PropAccess = DEFNODE(\n    \"PropAccess\",\n    \"expression property optional\",\n    function AST_PropAccess(props) {\n        if (props) {\n            this.expression = props.expression;\n            this.property = props.property;\n            this.optional = props.optional;\n            this.start = props.start;\n            this.end = props.end;\n        }\n\n        this.flags = 0;\n    },\n    {\n        $documentation: \"Base class for property access expressions, i.e. `a.foo` or `a[\\\"foo\\\"]`\",\n        $propdoc: {\n            expression: \"[AST_Node] the container expression\",\n            property: \"[AST_Node|string] the property to access.  For AST_Dot & AST_DotHash this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\",\n\n            optional: \"[boolean] whether this is an optional property access (IE ?.)\"\n        }\n    }\n);\n\nvar AST_Dot = DEFNODE(\"Dot\", \"quote\", function AST_Dot(props) {\n    if (props) {\n        this.quote = props.quote;\n        this.expression = props.expression;\n        this.property = props.property;\n        this.optional = props.optional;\n        this._annotations = props._annotations;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A dotted property access expression\",\n    $propdoc: {\n        quote: \"[string] the original quote character when transformed from AST_Sub\",\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n}, AST_PropAccess);\n\nvar AST_DotHash = DEFNODE(\"DotHash\", \"\", function AST_DotHash(props) {\n    if (props) {\n        this.expression = props.expression;\n        this.property = props.property;\n        this.optional = props.optional;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A dotted property access to a private property\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n}, AST_PropAccess);\n\nvar AST_Sub = DEFNODE(\"Sub\", null, function AST_Sub(props) {\n    if (props) {\n        this.expression = props.expression;\n        this.property = props.property;\n        this.optional = props.optional;\n        this._annotations = props._annotations;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Index-style property access, i.e. `a[\\\"foo\\\"]`\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n            this.property._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.property);\n        push(this.expression);\n    },\n}, AST_PropAccess);\n\nvar AST_Chain = DEFNODE(\"Chain\", \"expression\", function AST_Chain(props) {\n    if (props) {\n        this.expression = props.expression;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A chain expression like a?.b?.(c)?.[d]\",\n    $propdoc: {\n        expression: \"[AST_Call|AST_Dot|AST_DotHash|AST_Sub] chain element.\"\n    },\n    _walk: function (visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n});\n\nvar AST_Unary = DEFNODE(\"Unary\", \"operator expression\", function AST_Unary(props) {\n    if (props) {\n        this.operator = props.operator;\n        this.expression = props.expression;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for unary expressions\",\n    $propdoc: {\n        operator: \"[string] the operator\",\n        expression: \"[AST_Node] expression that this unary operator applies to\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n});\n\nvar AST_UnaryPrefix = DEFNODE(\"UnaryPrefix\", null, function AST_UnaryPrefix(props) {\n    if (props) {\n        this.operator = props.operator;\n        this.expression = props.expression;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Unary prefix expression, i.e. `typeof i` or `++i`\"\n}, AST_Unary);\n\nvar AST_UnaryPostfix = DEFNODE(\"UnaryPostfix\", null, function AST_UnaryPostfix(props) {\n    if (props) {\n        this.operator = props.operator;\n        this.expression = props.expression;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Unary postfix expression, i.e. `i++`\"\n}, AST_Unary);\n\nvar AST_Binary = DEFNODE(\"Binary\", \"operator left right\", function AST_Binary(props) {\n    if (props) {\n        this.operator = props.operator;\n        this.left = props.left;\n        this.right = props.right;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Binary expression, i.e. `a + b`\",\n    $propdoc: {\n        left: \"[AST_Node] left-hand side expression\",\n        operator: \"[string] the operator\",\n        right: \"[AST_Node] right-hand side expression\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.left._walk(visitor);\n            this.right._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.right);\n        push(this.left);\n    },\n});\n\nvar AST_Conditional = DEFNODE(\n    \"Conditional\",\n    \"condition consequent alternative\",\n    function AST_Conditional(props) {\n        if (props) {\n            this.condition = props.condition;\n            this.consequent = props.consequent;\n            this.alternative = props.alternative;\n            this.start = props.start;\n            this.end = props.end;\n        }\n\n        this.flags = 0;\n    },\n    {\n        $documentation: \"Conditional expression using the ternary operator, i.e. `a ? b : c`\",\n        $propdoc: {\n            condition: \"[AST_Node]\",\n            consequent: \"[AST_Node]\",\n            alternative: \"[AST_Node]\"\n        },\n        _walk: function(visitor) {\n            return visitor._visit(this, function() {\n                this.condition._walk(visitor);\n                this.consequent._walk(visitor);\n                this.alternative._walk(visitor);\n            });\n        },\n        _children_backwards(push) {\n            push(this.alternative);\n            push(this.consequent);\n            push(this.condition);\n        },\n    }\n);\n\nvar AST_Assign = DEFNODE(\"Assign\", \"logical\", function AST_Assign(props) {\n    if (props) {\n        this.logical = props.logical;\n        this.operator = props.operator;\n        this.left = props.left;\n        this.right = props.right;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"An assignment expression  `a = b + 5`\",\n    $propdoc: {\n        logical: \"Whether it's a logical assignment\"\n    }\n}, AST_Binary);\n\nvar AST_DefaultAssign = DEFNODE(\"DefaultAssign\", null, function AST_DefaultAssign(props) {\n    if (props) {\n        this.operator = props.operator;\n        this.left = props.left;\n        this.right = props.right;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A default assignment expression like in `(a = 3) => a`\"\n}, AST_Binary);\n\n/* -----[ LITERALS ]----- */\n\nvar AST_Array = DEFNODE(\"Array\", \"elements\", function AST_Array(props) {\n    if (props) {\n        this.elements = props.elements;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"An array literal\",\n    $propdoc: {\n        elements: \"[AST_Node*] array of elements\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            var elements = this.elements;\n            for (var i = 0, len = elements.length; i < len; i++) {\n                elements[i]._walk(visitor);\n            }\n        });\n    },\n    _children_backwards(push) {\n        let i = this.elements.length;\n        while (i--) push(this.elements[i]);\n    },\n});\n\nvar AST_Object = DEFNODE(\"Object\", \"properties\", function AST_Object(props) {\n    if (props) {\n        this.properties = props.properties;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"An object literal\",\n    $propdoc: {\n        properties: \"[AST_ObjectProperty*] array of properties\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            var properties = this.properties;\n            for (var i = 0, len = properties.length; i < len; i++) {\n                properties[i]._walk(visitor);\n            }\n        });\n    },\n    _children_backwards(push) {\n        let i = this.properties.length;\n        while (i--) push(this.properties[i]);\n    },\n});\n\n/* -----[ OBJECT/CLASS PROPERTIES ]----- */\n\n/**\n * Everything inside the curly braces of an object/class is a subclass of AST_ObjectProperty, except for AST_ClassStaticBlock.\n **/\nvar AST_ObjectProperty = DEFNODE(\"ObjectProperty\", \"key value\", function AST_ObjectProperty(props) {\n    if (props) {\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n        this._annotations = props._annotations;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for literal object properties\",\n    $propdoc: {\n        key: \"[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.\",\n        value: \"[AST_Node] property value.  For getters, setters and methods this is an AST_Accessor.\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.key instanceof AST_Node)\n                this.key._walk(visitor);\n            this.value._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.value);\n        if (this.key instanceof AST_Node) push(this.key);\n    },\n});\n\nvar AST_ObjectKeyVal = DEFNODE(\"ObjectKeyVal\", \"quote\", function AST_ObjectKeyVal(props) {\n    if (props) {\n        this.quote = props.quote;\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n        this._annotations = props._annotations;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A key: value object property\",\n    $propdoc: {\n        quote: \"[string] the original quote character\"\n    },\n    computed_key() {\n        return this.key instanceof AST_Node;\n    }\n}, AST_ObjectProperty);\n\nvar AST_PrivateSetter = DEFNODE(\"PrivateSetter\", \"static\", function AST_PrivateSetter(props) {\n    if (props) {\n        this.static = props.static;\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $propdoc: {\n        static: \"[boolean] whether this is a static private setter\"\n    },\n    $documentation: \"A private setter property\",\n    computed_key() {\n        return false;\n    }\n}, AST_ObjectProperty);\n\nvar AST_PrivateGetter = DEFNODE(\"PrivateGetter\", \"static\", function AST_PrivateGetter(props) {\n    if (props) {\n        this.static = props.static;\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $propdoc: {\n        static: \"[boolean] whether this is a static private getter\"\n    },\n    $documentation: \"A private getter property\",\n    computed_key() {\n        return false;\n    }\n}, AST_ObjectProperty);\n\nvar AST_ObjectSetter = DEFNODE(\"ObjectSetter\", \"quote static\", function AST_ObjectSetter(props) {\n    if (props) {\n        this.quote = props.quote;\n        this.static = props.static;\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n        this._annotations = props._annotations;\n    }\n\n    this.flags = 0;\n}, {\n    $propdoc: {\n        quote: \"[string|undefined] the original quote character, if any\",\n        static: \"[boolean] whether this is a static setter (classes only)\"\n    },\n    $documentation: \"An object setter property\",\n    computed_key() {\n        return !(this.key instanceof AST_SymbolMethod);\n    }\n}, AST_ObjectProperty);\n\nvar AST_ObjectGetter = DEFNODE(\"ObjectGetter\", \"quote static\", function AST_ObjectGetter(props) {\n    if (props) {\n        this.quote = props.quote;\n        this.static = props.static;\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n        this._annotations = props._annotations;\n    }\n\n    this.flags = 0;\n}, {\n    $propdoc: {\n        quote: \"[string|undefined] the original quote character, if any\",\n        static: \"[boolean] whether this is a static getter (classes only)\"\n    },\n    $documentation: \"An object getter property\",\n    computed_key() {\n        return !(this.key instanceof AST_SymbolMethod);\n    }\n}, AST_ObjectProperty);\n\nvar AST_ConciseMethod = DEFNODE(\"ConciseMethod\", \"quote static\", function AST_ConciseMethod(props) {\n    if (props) {\n        this.quote = props.quote;\n        this.static = props.static;\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n        this._annotations = props._annotations;\n    }\n\n    this.flags = 0;\n}, {\n    $propdoc: {\n        quote: \"[string|undefined] the original quote character, if any\",\n        static: \"[boolean] is this method static (classes only)\",\n    },\n    $documentation: \"An ES6 concise method inside an object or class\",\n    computed_key() {\n        return !(this.key instanceof AST_SymbolMethod);\n    }\n}, AST_ObjectProperty);\n\nvar AST_PrivateMethod = DEFNODE(\"PrivateMethod\", \"static\", function AST_PrivateMethod(props) {\n    if (props) {\n        this.static = props.static;\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A private class method inside a class\",\n    $propdoc: {\n        static: \"[boolean] is this a static private method\",\n    },\n    computed_key() {\n        return false;\n    },\n}, AST_ObjectProperty);\n\nvar AST_Class = DEFNODE(\"Class\", \"name extends properties\", function AST_Class(props) {\n    if (props) {\n        this.name = props.name;\n        this.extends = props.extends;\n        this.properties = props.properties;\n        this.variables = props.variables;\n        this.uses_with = props.uses_with;\n        this.uses_eval = props.uses_eval;\n        this.parent_scope = props.parent_scope;\n        this.enclosed = props.enclosed;\n        this.cname = props.cname;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $propdoc: {\n        name: \"[AST_SymbolClass|AST_SymbolDefClass?] optional class name.\",\n        extends: \"[AST_Node]? optional parent class\",\n        properties: \"[AST_ObjectProperty|AST_ClassStaticBlock]* array of properties or static blocks\"\n    },\n    $documentation: \"An ES6 class\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.name) {\n                this.name._walk(visitor);\n            }\n            if (this.extends) {\n                this.extends._walk(visitor);\n            }\n            this.properties.forEach((prop) => prop._walk(visitor));\n        });\n    },\n    _children_backwards(push) {\n        let i = this.properties.length;\n        while (i--) push(this.properties[i]);\n        if (this.extends) push(this.extends);\n        if (this.name) push(this.name);\n    },\n    /** go through the bits that are executed instantly, not when the class is `new`'d. Doesn't walk the name. */\n    visit_nondeferred_class_parts(visitor) {\n        if (this.extends) {\n            this.extends._walk(visitor);\n        }\n        this.properties.forEach((prop) => {\n            if (prop instanceof AST_ClassStaticBlock) {\n                prop._walk(visitor);\n                return;\n            }\n            if (prop.computed_key()) {\n                visitor.push(prop);\n                prop.key._walk(visitor);\n                visitor.pop();\n            }\n            if (\n                prop instanceof AST_ClassPrivateProperty && prop.static && prop.value\n                || prop instanceof AST_ClassProperty && prop.static && prop.value\n            ) {\n                visitor.push(prop);\n                prop.value._walk(visitor);\n                visitor.pop();\n            }\n        });\n    },\n    /** go through the bits that are executed later, when the class is `new`'d or a static method is called */\n    visit_deferred_class_parts(visitor) {\n        this.properties.forEach((prop) => {\n            if (\n                prop instanceof AST_ConciseMethod\n                || prop instanceof AST_PrivateMethod\n            ) {\n                prop.walk(visitor);\n            } else if (\n                prop instanceof AST_ClassProperty && !prop.static && prop.value\n                || prop instanceof AST_ClassPrivateProperty && !prop.static && prop.value\n            ) {\n                visitor.push(prop);\n                prop.value._walk(visitor);\n                visitor.pop();\n            }\n        });\n    },\n    is_self_referential: function() {\n        const this_id = this.name && this.name.definition().id;\n        let found = false;\n        let class_this = true;\n        this.visit_nondeferred_class_parts(new TreeWalker((node, descend) => {\n            if (found) return true;\n            if (node instanceof AST_This) return (found = class_this);\n            if (node instanceof AST_SymbolRef) return (found = node.definition().id === this_id);\n            if (node instanceof AST_Lambda && !(node instanceof AST_Arrow)) {\n                const class_this_save = class_this;\n                class_this = false;\n                descend();\n                class_this = class_this_save;\n                return true;\n            }\n        }));\n        return found;\n    },\n}, AST_Scope /* TODO a class might have a scope but it's not a scope */);\n\nvar AST_ClassProperty = DEFNODE(\"ClassProperty\", \"static quote\", function AST_ClassProperty(props) {\n    if (props) {\n        this.static = props.static;\n        this.quote = props.quote;\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n        this._annotations = props._annotations;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A class property\",\n    $propdoc: {\n        static: \"[boolean] whether this is a static key\",\n        quote: \"[string] which quote is being used\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.key instanceof AST_Node)\n                this.key._walk(visitor);\n            if (this.value instanceof AST_Node)\n                this.value._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.value instanceof AST_Node) push(this.value);\n        if (this.key instanceof AST_Node) push(this.key);\n    },\n    computed_key() {\n        return !(this.key instanceof AST_SymbolClassProperty);\n    }\n}, AST_ObjectProperty);\n\nvar AST_ClassPrivateProperty = DEFNODE(\"ClassPrivateProperty\", \"\", function AST_ClassPrivateProperty(props) {\n    if (props) {\n        this.static = props.static;\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A class property for a private property\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.value instanceof AST_Node)\n                this.value._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.value instanceof AST_Node) push(this.value);\n    },\n    computed_key() {\n        return false;\n    },\n}, AST_ObjectProperty);\n\nvar AST_PrivateIn = DEFNODE(\"PrivateIn\", \"key value\", function AST_PrivateIn(props) {\n    if (props) {\n        this.key = props.key;\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"An `in` binop when the key is private, eg #x in this\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.key._walk(visitor);\n            this.value._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.value);\n        push(this.key);\n    },\n});\n\nvar AST_DefClass = DEFNODE(\"DefClass\", null, function AST_DefClass(props) {\n    if (props) {\n        this.name = props.name;\n        this.extends = props.extends;\n        this.properties = props.properties;\n        this.variables = props.variables;\n        this.uses_with = props.uses_with;\n        this.uses_eval = props.uses_eval;\n        this.parent_scope = props.parent_scope;\n        this.enclosed = props.enclosed;\n        this.cname = props.cname;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A class definition\",\n}, AST_Class);\n\nvar AST_ClassStaticBlock = DEFNODE(\"ClassStaticBlock\", \"body block_scope\", function AST_ClassStaticBlock (props) {\n    this.body = props.body;\n    this.block_scope = props.block_scope;\n    this.start = props.start;\n    this.end = props.end;\n}, {\n    $documentation: \"A block containing statements to be executed in the context of the class\",\n    $propdoc: {\n        body: \"[AST_Statement*] an array of statements\",\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            walk_body(this, visitor);\n        });\n    },\n    _children_backwards(push) {\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n    },\n    clone: clone_block_scope,\n    computed_key() {\n        return false;\n    },\n}, AST_Scope);\n\nvar AST_ClassExpression = DEFNODE(\"ClassExpression\", null, function AST_ClassExpression(props) {\n    if (props) {\n        this.name = props.name;\n        this.extends = props.extends;\n        this.properties = props.properties;\n        this.variables = props.variables;\n        this.uses_with = props.uses_with;\n        this.uses_eval = props.uses_eval;\n        this.parent_scope = props.parent_scope;\n        this.enclosed = props.enclosed;\n        this.cname = props.cname;\n        this.body = props.body;\n        this.block_scope = props.block_scope;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A class expression.\"\n}, AST_Class);\n\nvar AST_Symbol = DEFNODE(\"Symbol\", \"scope name thedef\", function AST_Symbol(props) {\n    if (props) {\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $propdoc: {\n        name: \"[string] name of this symbol\",\n        scope: \"[AST_Scope/S] the current scope (not necessarily the definition scope)\",\n        thedef: \"[SymbolDef/S] the definition of this symbol\"\n    },\n    $documentation: \"Base class for all symbols\"\n});\n\nvar AST_NewTarget = DEFNODE(\"NewTarget\", null, function AST_NewTarget(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A reference to new.target\"\n});\n\nvar AST_SymbolDeclaration = DEFNODE(\"SymbolDeclaration\", \"init\", function AST_SymbolDeclaration(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)\",\n}, AST_Symbol);\n\nvar AST_SymbolVar = DEFNODE(\"SymbolVar\", null, function AST_SymbolVar(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol defining a variable\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolBlockDeclaration = DEFNODE(\n    \"SymbolBlockDeclaration\",\n    null,\n    function AST_SymbolBlockDeclaration(props) {\n        if (props) {\n            this.init = props.init;\n            this.scope = props.scope;\n            this.name = props.name;\n            this.thedef = props.thedef;\n            this.start = props.start;\n            this.end = props.end;\n        }\n\n        this.flags = 0;\n    },\n    {\n        $documentation: \"Base class for block-scoped declaration symbols\"\n    },\n    AST_SymbolDeclaration\n);\n\nvar AST_SymbolConst = DEFNODE(\"SymbolConst\", null, function AST_SymbolConst(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A constant declaration\"\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolUsing = DEFNODE(\"SymbolUsing\", null, function AST_SymbolUsing(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A `using` declaration\"\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolLet = DEFNODE(\"SymbolLet\", null, function AST_SymbolLet(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A block-scoped `let` declaration\"\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolFunarg = DEFNODE(\"SymbolFunarg\", null, function AST_SymbolFunarg(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol naming a function argument\",\n}, AST_SymbolVar);\n\nvar AST_SymbolDefun = DEFNODE(\"SymbolDefun\", null, function AST_SymbolDefun(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol defining a function\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolMethod = DEFNODE(\"SymbolMethod\", null, function AST_SymbolMethod(props) {\n    if (props) {\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol in an object defining a method\",\n}, AST_Symbol);\n\nvar AST_SymbolClassProperty = DEFNODE(\"SymbolClassProperty\", null, function AST_SymbolClassProperty(props) {\n    if (props) {\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol for a class property\",\n}, AST_Symbol);\n\nvar AST_SymbolLambda = DEFNODE(\"SymbolLambda\", null, function AST_SymbolLambda(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol naming a function expression\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolDefClass = DEFNODE(\"SymbolDefClass\", null, function AST_SymbolDefClass(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class.\"\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolClass = DEFNODE(\"SymbolClass\", null, function AST_SymbolClass(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol naming a class's name. Lexically scoped to the class.\"\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolCatch = DEFNODE(\"SymbolCatch\", null, function AST_SymbolCatch(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol naming the exception in catch\",\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolImport = DEFNODE(\"SymbolImport\", null, function AST_SymbolImport(props) {\n    if (props) {\n        this.init = props.init;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol referring to an imported name\",\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolImportForeign = DEFNODE(\"SymbolImportForeign\", \"quote\", function AST_SymbolImportForeign(props) {\n    if (props) {\n        this.quote = props.quote;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes\",\n}, AST_Symbol);\n\nvar AST_Label = DEFNODE(\"Label\", \"references\", function AST_Label(props) {\n    if (props) {\n        this.references = props.references;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n        this.initialize();\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol naming a label (declaration)\",\n    $propdoc: {\n        references: \"[AST_LoopControl*] a list of nodes referring to this label\"\n    },\n    initialize: function() {\n        this.references = [];\n        this.thedef = this;\n    }\n}, AST_Symbol);\n\nvar AST_SymbolRef = DEFNODE(\"SymbolRef\", null, function AST_SymbolRef(props) {\n    if (props) {\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Reference to some symbol (not definition/declaration)\",\n}, AST_Symbol);\n\nvar AST_SymbolExport = DEFNODE(\"SymbolExport\", \"quote\", function AST_SymbolExport(props) {\n    if (props) {\n        this.quote = props.quote;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Symbol referring to a name to export\",\n}, AST_SymbolRef);\n\nvar AST_SymbolExportForeign = DEFNODE(\"SymbolExportForeign\", \"quote\", function AST_SymbolExportForeign(props) {\n    if (props) {\n        this.quote = props.quote;\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes\",\n}, AST_Symbol);\n\nvar AST_LabelRef = DEFNODE(\"LabelRef\", null, function AST_LabelRef(props) {\n    if (props) {\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Reference to a label symbol\",\n}, AST_Symbol);\n\nvar AST_SymbolPrivateProperty = DEFNODE(\"SymbolPrivateProperty\", null, function AST_SymbolPrivateProperty(props) {\n    if (props) {\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A symbol that refers to a private property\",\n}, AST_Symbol);\n\nvar AST_This = DEFNODE(\"This\", null, function AST_This(props) {\n    if (props) {\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The `this` symbol\",\n}, AST_Symbol);\n\nvar AST_Super = DEFNODE(\"Super\", null, function AST_Super(props) {\n    if (props) {\n        this.scope = props.scope;\n        this.name = props.name;\n        this.thedef = props.thedef;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The `super` symbol\",\n}, AST_This);\n\nvar AST_Constant = DEFNODE(\"Constant\", null, function AST_Constant(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for all constants\",\n    getValue: function() {\n        return this.value;\n    }\n});\n\nvar AST_String = DEFNODE(\"String\", \"value quote\", function AST_String(props) {\n    if (props) {\n        this.value = props.value;\n        this.quote = props.quote;\n        this.start = props.start;\n        this.end = props.end;\n        this._annotations = props._annotations;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A string literal\",\n    $propdoc: {\n        value: \"[string] the contents of this string\",\n        quote: \"[string] the original quote character\"\n    }\n}, AST_Constant);\n\nvar AST_Number = DEFNODE(\"Number\", \"value raw\", function AST_Number(props) {\n    if (props) {\n        this.value = props.value;\n        this.raw = props.raw;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A number literal\",\n    $propdoc: {\n        value: \"[number] the numeric value\",\n        raw: \"[string] numeric value as string\"\n    }\n}, AST_Constant);\n\nvar AST_BigInt = DEFNODE(\"BigInt\", \"value raw\", function AST_BigInt(props) {\n    if (props) {\n        this.value = props.value;\n        this.raw = props.raw;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A big int literal\",\n    $propdoc: {\n        value: \"[string] big int value, represented as a string\",\n        raw: \"[string] the original format preserved\"\n    }\n}, AST_Constant);\n\nvar AST_RegExp = DEFNODE(\"RegExp\", \"value\", function AST_RegExp(props) {\n    if (props) {\n        this.value = props.value;\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A regexp literal\",\n    $propdoc: {\n        value: \"[RegExp] the actual regexp\",\n    }\n}, AST_Constant);\n\nvar AST_Atom = DEFNODE(\"Atom\", null, function AST_Atom(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for atoms\",\n}, AST_Constant);\n\nvar AST_Null = DEFNODE(\"Null\", null, function AST_Null(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The `null` atom\",\n    value: null\n}, AST_Atom);\n\nvar AST_NaN = DEFNODE(\"NaN\", null, function AST_NaN(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The impossible value\",\n    value: 0/0\n}, AST_Atom);\n\nvar AST_Undefined = DEFNODE(\"Undefined\", null, function AST_Undefined(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The `undefined` value\",\n    value: (function() {}())\n}, AST_Atom);\n\nvar AST_Hole = DEFNODE(\"Hole\", null, function AST_Hole(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"A hole in an array\",\n    value: (function() {}())\n}, AST_Atom);\n\nvar AST_Infinity = DEFNODE(\"Infinity\", null, function AST_Infinity(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The `Infinity` value\",\n    value: 1/0\n}, AST_Atom);\n\nvar AST_Boolean = DEFNODE(\"Boolean\", null, function AST_Boolean(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"Base class for booleans\",\n}, AST_Atom);\n\nvar AST_False = DEFNODE(\"False\", null, function AST_False(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The `false` atom\",\n    value: false\n}, AST_Boolean);\n\nvar AST_True = DEFNODE(\"True\", null, function AST_True(props) {\n    if (props) {\n        this.start = props.start;\n        this.end = props.end;\n    }\n\n    this.flags = 0;\n}, {\n    $documentation: \"The `true` atom\",\n    value: true\n}, AST_Boolean);\n\n/* -----[ Walk function ]---- */\n\n/**\n * Walk nodes in depth-first search fashion.\n * Callback can return `walk_abort` symbol to stop iteration.\n * It can also return `true` to stop iteration just for child nodes.\n * Iteration can be stopped and continued by passing the `to_visit` argument,\n * which is given to the callback in the second argument.\n **/\nfunction walk(node, cb, to_visit = [node]) {\n    const push = to_visit.push.bind(to_visit);\n    while (to_visit.length) {\n        const node = to_visit.pop();\n        const ret = cb(node, to_visit);\n\n        if (ret) {\n            if (ret === walk_abort) return true;\n            continue;\n        }\n\n        node._children_backwards(push);\n    }\n    return false;\n}\n\n/**\n * Walks an AST node and its children.\n *\n * {cb} can return `walk_abort` to interrupt the walk.\n *\n * @param node\n * @param cb {(node, info: { parent: (nth) => any }) => (boolean | undefined)}\n *\n * @returns {boolean} whether the walk was aborted\n *\n * @example\n * const found_some_cond = walk_parent(my_ast_node, (node, { parent }) => {\n *   if (some_cond(node, parent())) return walk_abort\n * });\n */\nfunction walk_parent(node, cb, initial_stack) {\n    const to_visit = [node];\n    const push = to_visit.push.bind(to_visit);\n    const stack = initial_stack ? initial_stack.slice() : [];\n    const parent_pop_indices = [];\n\n    let current;\n\n    const info = {\n        parent: (n = 0) => {\n            if (n === -1) {\n                return current;\n            }\n\n            // [ p1 p0 ] [ 1 0 ]\n            if (initial_stack && n >= stack.length) {\n                n -= stack.length;\n                return initial_stack[\n                    initial_stack.length - (n + 1)\n                ];\n            }\n\n            return stack[stack.length - (1 + n)];\n        },\n    };\n\n    while (to_visit.length) {\n        current = to_visit.pop();\n\n        while (\n            parent_pop_indices.length &&\n            to_visit.length == parent_pop_indices[parent_pop_indices.length - 1]\n        ) {\n            stack.pop();\n            parent_pop_indices.pop();\n        }\n\n        const ret = cb(current, info);\n\n        if (ret) {\n            if (ret === walk_abort) return true;\n            continue;\n        }\n\n        const visit_length = to_visit.length;\n\n        current._children_backwards(push);\n\n        // Push only if we're going to traverse the children\n        if (to_visit.length > visit_length) {\n            stack.push(current);\n            parent_pop_indices.push(visit_length - 1);\n        }\n    }\n\n    return false;\n}\n\nconst walk_abort = Symbol(\"abort walk\");\n\n/* -----[ TreeWalker ]----- */\n\nclass TreeWalker {\n    constructor(callback) {\n        this.visit = callback;\n        this.stack = [];\n        this.directives = Object.create(null);\n    }\n\n    _visit(node, descend) {\n        this.push(node);\n        var ret = this.visit(node, descend ? function() {\n            descend.call(node);\n        } : noop);\n        if (!ret && descend) {\n            descend.call(node);\n        }\n        this.pop();\n        return ret;\n    }\n\n    parent(n) {\n        return this.stack[this.stack.length - 2 - (n || 0)];\n    }\n\n    push(node) {\n        if (node instanceof AST_Lambda) {\n            this.directives = Object.create(this.directives);\n        } else if (node instanceof AST_Directive && !this.directives[node.value]) {\n            this.directives[node.value] = node;\n        } else if (node instanceof AST_Class) {\n            this.directives = Object.create(this.directives);\n            if (!this.directives[\"use strict\"]) {\n                this.directives[\"use strict\"] = node;\n            }\n        }\n        this.stack.push(node);\n    }\n\n    pop() {\n        var node = this.stack.pop();\n        if (node instanceof AST_Lambda || node instanceof AST_Class) {\n            this.directives = Object.getPrototypeOf(this.directives);\n        }\n    }\n\n    self() {\n        return this.stack[this.stack.length - 1];\n    }\n\n    find_parent(type) {\n        var stack = this.stack;\n        for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof type) return x;\n        }\n    }\n\n    is_within_loop() {\n        let i = this.stack.length - 1;\n        let child = this.stack[i];\n        while (i--) {\n            const node = this.stack[i];\n\n            if (node instanceof AST_Lambda) return false;\n            if (\n                node instanceof AST_IterationStatement\n                // exclude for-loop bits that only run once\n                && !((node instanceof AST_For) && child === node.init)\n                && !((node instanceof AST_ForIn || node instanceof AST_ForOf) && child === node.object)\n            ) {\n                return true;\n            }\n\n            child = node;\n        }\n\n        return false;\n    }\n\n    find_scope() {\n        var stack = this.stack;\n        for (var i = stack.length; --i >= 0;) {\n            const p = stack[i];\n            if (p instanceof AST_Toplevel) return p;\n            if (p instanceof AST_Lambda) return p;\n            if (p.block_scope) return p.block_scope;\n        }\n    }\n\n    has_directive(type) {\n        var dir = this.directives[type];\n        if (dir) return dir;\n        var node = this.stack[this.stack.length - 1];\n        if (node instanceof AST_Scope && node.body) {\n            for (var i = 0; i < node.body.length; ++i) {\n                var st = node.body[i];\n                if (!(st instanceof AST_Directive)) break;\n                if (st.value == type) return st;\n            }\n        }\n    }\n\n    loopcontrol_target(node) {\n        var stack = this.stack;\n        if (node.label) for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof AST_LabeledStatement && x.label.name == node.label.name)\n                return x.body;\n        } else for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof AST_IterationStatement\n                || node instanceof AST_Break && x instanceof AST_Switch)\n                return x;\n        }\n    }\n}\n\n// Tree transformer helpers.\nclass TreeTransformer extends TreeWalker {\n    constructor(before, after) {\n        super();\n        this.before = before;\n        this.after = after;\n    }\n}\n\nconst _PURE       = 0b00000001;\nconst _INLINE     = 0b00000010;\nconst _NOINLINE   = 0b00000100;\nconst _KEY        = 0b00001000;\nconst _MANGLEPROP = 0b00010000;\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nfunction def_transform(node, descend) {\n    node.DEFMETHOD(\"transform\", function(tw, in_list) {\n        let transformed = undefined;\n        tw.push(this);\n        if (tw.before) transformed = tw.before(this, descend, in_list);\n        if (transformed === undefined) {\n            transformed = this;\n            descend(transformed, tw);\n            if (tw.after) {\n                const after_ret = tw.after(transformed, in_list);\n                if (after_ret !== undefined) transformed = after_ret;\n            }\n        }\n        tw.pop();\n        return transformed;\n    });\n}\n\ndef_transform(AST_Node, noop);\n\ndef_transform(AST_LabeledStatement, function(self, tw) {\n    self.label = self.label.transform(tw);\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_SimpleStatement, function(self, tw) {\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_Block, function(self, tw) {\n    self.body = MAP(self.body, tw);\n});\n\ndef_transform(AST_Do, function(self, tw) {\n    self.body = self.body.transform(tw);\n    self.condition = self.condition.transform(tw);\n});\n\ndef_transform(AST_While, function(self, tw) {\n    self.condition = self.condition.transform(tw);\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_For, function(self, tw) {\n    if (self.init) self.init = self.init.transform(tw);\n    if (self.condition) self.condition = self.condition.transform(tw);\n    if (self.step) self.step = self.step.transform(tw);\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_ForIn, function(self, tw) {\n    self.init = self.init.transform(tw);\n    self.object = self.object.transform(tw);\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_With, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_Exit, function(self, tw) {\n    if (self.value) self.value = self.value.transform(tw);\n});\n\ndef_transform(AST_LoopControl, function(self, tw) {\n    if (self.label) self.label = self.label.transform(tw);\n});\n\ndef_transform(AST_If, function(self, tw) {\n    self.condition = self.condition.transform(tw);\n    self.body = self.body.transform(tw);\n    if (self.alternative) self.alternative = self.alternative.transform(tw);\n});\n\ndef_transform(AST_Switch, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n    self.body = MAP(self.body, tw);\n});\n\ndef_transform(AST_Case, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n    self.body = MAP(self.body, tw);\n});\n\ndef_transform(AST_Try, function(self, tw) {\n    self.body = self.body.transform(tw);\n    if (self.bcatch) self.bcatch = self.bcatch.transform(tw);\n    if (self.bfinally) self.bfinally = self.bfinally.transform(tw);\n});\n\ndef_transform(AST_Catch, function(self, tw) {\n    if (self.argname) self.argname = self.argname.transform(tw);\n    self.body = MAP(self.body, tw);\n});\n\ndef_transform(AST_DefinitionsLike, function(self, tw) {\n    self.definitions = MAP(self.definitions, tw);\n});\n\ndef_transform(AST_VarDefLike, function(self, tw) {\n    self.name = self.name.transform(tw);\n    if (self.value) self.value = self.value.transform(tw);\n});\n\ndef_transform(AST_Destructuring, function(self, tw) {\n    self.names = MAP(self.names, tw);\n});\n\ndef_transform(AST_Lambda, function(self, tw) {\n    if (self.name) self.name = self.name.transform(tw);\n    self.argnames = MAP(self.argnames, tw, /* allow_splicing */ false);\n    if (self.body instanceof AST_Node) {\n        self.body = self.body.transform(tw);\n    } else {\n        self.body = MAP(self.body, tw);\n    }\n});\n\ndef_transform(AST_Call, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n    self.args = MAP(self.args, tw, /* allow_splicing */ false);\n});\n\ndef_transform(AST_Sequence, function(self, tw) {\n    const result = MAP(self.expressions, tw);\n    self.expressions = result.length\n        ? result\n        : [new AST_Number({ value: 0 })];\n});\n\ndef_transform(AST_PropAccess, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_Sub, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n    self.property = self.property.transform(tw);\n});\n\ndef_transform(AST_Chain, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_Yield, function(self, tw) {\n    if (self.expression) self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_Await, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_Unary, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_Binary, function(self, tw) {\n    self.left = self.left.transform(tw);\n    self.right = self.right.transform(tw);\n});\n\ndef_transform(AST_PrivateIn, function(self, tw) {\n    self.key = self.key.transform(tw);\n    self.value = self.value.transform(tw);\n});\n\ndef_transform(AST_Conditional, function(self, tw) {\n    self.condition = self.condition.transform(tw);\n    self.consequent = self.consequent.transform(tw);\n    self.alternative = self.alternative.transform(tw);\n});\n\ndef_transform(AST_Array, function(self, tw) {\n    self.elements = MAP(self.elements, tw);\n});\n\ndef_transform(AST_Object, function(self, tw) {\n    self.properties = MAP(self.properties, tw);\n});\n\ndef_transform(AST_ObjectProperty, function(self, tw) {\n    if (self.key instanceof AST_Node) {\n        self.key = self.key.transform(tw);\n    }\n    if (self.value) self.value = self.value.transform(tw);\n});\n\ndef_transform(AST_Class, function(self, tw) {\n    if (self.name) self.name = self.name.transform(tw);\n    if (self.extends) self.extends = self.extends.transform(tw);\n    self.properties = MAP(self.properties, tw);\n});\n\ndef_transform(AST_ClassStaticBlock, function(self, tw) {\n    self.body = MAP(self.body, tw);\n});\n\ndef_transform(AST_Expansion, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_NameMapping, function(self, tw) {\n    self.foreign_name = self.foreign_name.transform(tw);\n    self.name = self.name.transform(tw);\n});\n\ndef_transform(AST_Import, function(self, tw) {\n    if (self.imported_name) self.imported_name = self.imported_name.transform(tw);\n    if (self.imported_names) MAP(self.imported_names, tw);\n    self.module_name = self.module_name.transform(tw);\n});\n\ndef_transform(AST_Export, function(self, tw) {\n    if (self.exported_definition) self.exported_definition = self.exported_definition.transform(tw);\n    if (self.exported_value) self.exported_value = self.exported_value.transform(tw);\n    if (self.exported_names) MAP(self.exported_names, tw);\n    if (self.module_name) self.module_name = self.module_name.transform(tw);\n});\n\ndef_transform(AST_TemplateString, function(self, tw) {\n    self.segments = MAP(self.segments, tw);\n});\n\ndef_transform(AST_PrefixedTemplateString, function(self, tw) {\n    self.prefix = self.prefix.transform(tw);\n    self.template_string = self.template_string.transform(tw);\n});\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n(function() {\n\n    var normalize_directives = function(body) {\n        for (var i = 0; i < body.length; i++) {\n            if (body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n                body[i] = new AST_Directive({\n                    start: body[i].start,\n                    end: body[i].end,\n                    quote: '\"',\n                    value: body[i].body.value\n                });\n            } else {\n                return body;\n            }\n        }\n\n        return body;\n    };\n\n    function import_attributes_from_moz(attributes) {\n        if (attributes && attributes.length > 0) {\n            return new AST_Object({\n                start: my_start_token(attributes),\n                end: my_end_token(attributes),\n                properties: attributes.map((attr) =>\n                    new AST_ObjectKeyVal({\n                        start: my_start_token(attr),\n                        end: my_end_token(attr),\n                        key: attr.key.name || attr.key.value,\n                        value: from_moz(attr.value)\n                    })\n                )\n            });\n        }\n        return null;\n    }\n\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz))\n            });\n        },\n\n        ArrayPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.elements.map(function(elm) {\n                    if (elm === null) {\n                        return new AST_Hole();\n                    }\n                    return from_moz(elm);\n                }),\n                is_array: true\n            });\n        },\n\n        ObjectPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.properties.map(from_moz),\n                is_array: false\n            });\n        },\n\n        AssignmentPattern: function(M) {\n            return new AST_DefaultAssign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                left: from_moz(M.left),\n                operator: \"=\",\n                right: from_moz(M.right)\n            });\n        },\n\n        SpreadElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n\n        RestElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n\n        TemplateElement: function(M) {\n            return new AST_TemplateSegment({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: M.value.cooked,\n                raw: M.value.raw\n            });\n        },\n\n        TemplateLiteral: function(M) {\n            var segments = [];\n            for (var i = 0; i < M.quasis.length; i++) {\n                segments.push(from_moz(M.quasis[i]));\n                if (M.expressions[i]) {\n                    segments.push(from_moz(M.expressions[i]));\n                }\n            }\n            return new AST_TemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                segments: segments\n            });\n        },\n\n        TaggedTemplateExpression: function(M) {\n            return new AST_PrefixedTemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                template_string: from_moz(M.quasi),\n                prefix: from_moz(M.tag)\n            });\n        },\n\n        FunctionDeclaration: function(M) {\n            return new AST_Defun({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: M.id && from_moz_symbol(AST_SymbolDefun, M.id),\n                argnames: M.params.map(M => from_moz_pattern(M, AST_SymbolFunarg)),\n                is_generator: M.generator,\n                async: M.async,\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n\n        FunctionExpression: function(M) {\n            return from_moz_lambda(M, /*is_method=*/false);\n        },\n\n        ArrowFunctionExpression: function(M) {\n            const body = M.body.type === \"BlockStatement\"\n                ? from_moz(M.body).body\n                : [make_node(AST_Return, {}, { value: from_moz(M.body) })];\n            return new AST_Arrow({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: M.params.map(p => from_moz_pattern(p, AST_SymbolFunarg)),\n                body,\n                async: M.async,\n            });\n        },\n\n        ExpressionStatement: function(M) {\n            return new AST_SimpleStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.expression)\n            });\n        },\n\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : new AST_TryBlock(from_moz(M.block)),\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n            });\n        },\n\n        Property: function(M) {\n            if (M.kind == \"init\" && !M.method) {\n                var args = {\n                    start    : my_start_token(M.key || M.value),\n                    end      : my_end_token(M.value),\n                    key      : M.computed\n                                ? from_moz(M.key)\n                                : M.key.name || String(M.key.value),\n                    quote    : from_moz_quote(M.key, M.computed),\n                    static   : false, // always an object\n                    value    : from_moz(M.value)\n                };\n\n                return new AST_ObjectKeyVal(args);\n            } else {\n                var value = from_moz_lambda(M.value, /*is_method=*/true);\n                var args = {\n                    start    : my_start_token(M.key || M.value),\n                    end      : my_end_token(M.value),\n                    key      : M.computed\n                                ? from_moz(M.key)\n                                : from_moz_symbol(AST_SymbolMethod, M.key),\n                    quote    : from_moz_quote(M.key, M.computed),\n                    static   : false, // always an object\n                    value,\n                };\n\n                if (M.kind == \"get\") return new AST_ObjectGetter(args);\n                if (M.kind == \"set\") return new AST_ObjectSetter(args);\n                if (M.method) return new AST_ConciseMethod(args);\n            }\n        },\n\n        MethodDefinition: function(M) {\n            const is_private = M.key.type === \"PrivateIdentifier\";\n            const key = M.computed ? from_moz(M.key) : new AST_SymbolMethod({ name: M.key.name || String(M.key.value) });\n\n            var args = {\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key,\n                quote    : from_moz_quote(M.key, M.computed),\n                value    : from_moz_lambda(M.value, /*is_method=*/true),\n                static   : M.static,\n            };\n            if (M.kind == \"get\") {\n                return new (is_private ? AST_PrivateGetter : AST_ObjectGetter)(args);\n            }\n            if (M.kind == \"set\") {\n                return new (is_private ? AST_PrivateSetter : AST_ObjectSetter)(args);\n            }\n            return new (is_private ? AST_PrivateMethod : AST_ConciseMethod)(args);\n        },\n\n        FieldDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else {\n                if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in FieldDefinition\");\n                key = from_moz(M.key);\n            }\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                quote    : from_moz_quote(M.key, M.computed),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n\n        PropertyDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else if (M.key.type === \"PrivateIdentifier\") {\n                return new AST_ClassPrivateProperty({\n                    start    : my_start_token(M),\n                    end      : my_end_token(M),\n                    key      : from_moz(M.key),\n                    value    : from_moz(M.value),\n                    static   : M.static,\n                });\n            } else {\n                key = from_moz_symbol(AST_SymbolClassProperty, M.key);\n            }\n\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                quote    : from_moz_quote(M.key, M.computed),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n\n        PrivateIdentifier: function (M) {\n            return new AST_SymbolPrivateProperty({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: M.name\n            });\n        },\n\n        StaticBlock: function(M) {\n            return new AST_ClassStaticBlock({\n                start : my_start_token(M),\n                end   : my_end_token(M),\n                body  : M.body.map(from_moz),\n            });\n        },\n\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                elements : M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                })\n            });\n        },\n\n        ObjectExpression: function(M) {\n            return new AST_Object({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                properties : M.properties.map(function(prop) {\n                    if (prop.type === \"SpreadElement\") {\n                        return from_moz(prop);\n                    }\n                    prop.type = \"Property\";\n                    return from_moz(prop);\n                })\n            });\n        },\n\n        SequenceExpression: function(M) {\n            return new AST_Sequence({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expressions: M.expressions.map(from_moz)\n            });\n        },\n\n        MemberExpression: function(M) {\n            if (M.property.type === \"PrivateIdentifier\") {\n                return new AST_DotHash({\n                    start      : my_start_token(M),\n                    end        : my_end_token(M),\n                    property   : M.property.name,\n                    expression : from_moz(M.object),\n                    optional   : M.optional || false\n                });\n            }\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                property   : M.computed ? from_moz(M.property) : M.property.name,\n                expression : from_moz(M.object),\n                optional   : M.optional || false\n            });\n        },\n\n        ChainExpression: function(M) {\n            return new AST_Chain({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.expression)\n            });\n        },\n\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz)\n            });\n        },\n\n        VariableDeclaration: function(M) {\n            let decl_type;\n            let defs_type = AST_VarDef;\n            let sym_type;\n            let await_using = false;\n            if (M.kind === \"const\") {\n                decl_type = AST_Const;\n                sym_type = AST_SymbolConst;\n            } else if (M.kind === \"let\") {\n                decl_type = AST_Let;\n                sym_type = AST_SymbolLet;\n            } else if (M.kind === \"using\") {\n                decl_type = AST_Using;\n                defs_type = AST_UsingDef;\n                sym_type = AST_SymbolUsing;\n            } else if (M.kind === \"await using\") {\n                decl_type = AST_Using;\n                defs_type = AST_UsingDef;\n                sym_type = AST_SymbolUsing;\n                await_using = true;\n            } else {\n                decl_type = AST_Var;\n                sym_type = AST_SymbolVar;\n            }\n            const definitions = M.declarations.map(M => {\n                return new defs_type({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    name: from_moz_pattern(M.id, sym_type),\n                    value: from_moz(M.init),\n                });\n            });\n            return new decl_type({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                definitions : definitions,\n                await       : await_using,\n            });\n        },\n\n        ImportDeclaration: function(M) {\n            var imported_name = null;\n            var imported_names = null;\n            M.specifiers.forEach(function (specifier) {\n                if (specifier.type === \"ImportSpecifier\" || specifier.type === \"ImportNamespaceSpecifier\") {\n                    if (!imported_names) { imported_names = []; }\n                    imported_names.push(from_moz(specifier));\n                } else if (specifier.type === \"ImportDefaultSpecifier\") {\n                    imported_name = from_moz(specifier);\n                }\n            });\n            return new AST_Import({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                imported_name: imported_name,\n                imported_names : imported_names,\n                module_name : from_moz(M.source),\n                attributes: import_attributes_from_moz(M.attributes || M.assertions)\n            });\n        },\n\n        ImportSpecifier: function(M) {\n            return new AST_NameMapping({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                foreign_name: from_moz_symbol(AST_SymbolImportForeign, M.imported, M.imported.type === \"Literal\"),\n                name: from_moz_symbol(AST_SymbolImport, M.local)\n            });\n        },\n\n        ImportDefaultSpecifier: function(M) {\n            return from_moz_symbol(AST_SymbolImport, M.local);\n        },\n\n        ImportNamespaceSpecifier: function(M) {\n            return new AST_NameMapping({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                foreign_name: new AST_SymbolImportForeign({ name: \"*\" }),\n                name: from_moz_symbol(AST_SymbolImport, M.local)\n            });\n        },\n\n        ImportExpression: function(M) {\n            const args = [from_moz(M.source)];\n            if (M.options) {\n                args.push(from_moz(M.options));\n            }\n            return new AST_Call({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz({\n                    type: \"Identifier\",\n                    name: \"import\"\n                }),\n                optional: false,\n                args\n            });\n        },\n\n        ExportAllDeclaration: function(M) {\n            var foreign_name = M.exported == null ?\n                new AST_SymbolExportForeign({ name: \"*\" }) :\n                from_moz_symbol(AST_SymbolExportForeign, M.exported, M.exported.type === \"Literal\");\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_names: [\n                    new AST_NameMapping({\n                        start: my_start_token(M),\n                        end: my_end_token(M),\n                        name: new AST_SymbolExport({ name: \"*\" }),\n                        foreign_name: foreign_name\n                    })\n                ],\n                module_name: from_moz(M.source),\n                attributes: import_attributes_from_moz(M.attributes || M.assertions)\n            });\n        },\n\n        ExportNamedDeclaration: function(M) {\n            if (M.declaration) {\n                // export const, export function, ...\n                return new AST_Export({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    exported_definition: from_moz(M.declaration),\n                    exported_names: null,\n                    module_name: null,\n                    attributes: null,\n                });\n            } else {\n                return new AST_Export({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    exported_definition: null,\n                    exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(from_moz) : [],\n                    module_name: from_moz(M.source),\n                    attributes: import_attributes_from_moz(M.attributes || M.assertions),\n                });\n            }\n        },\n\n        ExportDefaultDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_value: from_moz(M.declaration),\n                is_default: true\n            });\n        },\n\n        ExportSpecifier: function(M) {\n            return new AST_NameMapping({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                foreign_name: from_moz_symbol(AST_SymbolExportForeign, M.exported, M.exported.type === \"Literal\"),\n                name: from_moz_symbol(AST_SymbolExport, M.local, M.local.type === \"Literal\"),\n            });\n        },\n\n        Literal: function(M) {\n            var val = M.value, args = {\n                start  : my_start_token(M),\n                end    : my_end_token(M)\n            };\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = {\n                    source: rx.pattern,\n                    flags: rx.flags\n                };\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                const rx_source = M.raw || val;\n                const match = rx_source.match(/^\\/(.*)\\/(\\w*)$/);\n                if (!match) throw new Error(\"Invalid regex source \" + rx_source);\n                const [_, source, flags] = match;\n                args.value = { source, flags };\n                return new AST_RegExp(args);\n            }\n            const bi = typeof M.value === \"bigint\" ? M.value.toString() : M.bigint;\n            if (typeof bi === \"string\") {\n                args.value = bi;\n                args.raw = M.raw;\n                return new AST_BigInt(args);\n            }\n            if (val === null) return new AST_Null(args);\n            switch (typeof val) {\n              case \"string\":\n                args.quote = \"\\\"\";\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                args.value = val;\n                args.raw = M.raw || val.toString();\n                return new AST_Number(args);\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n\n        MetaProperty: function(M) {\n            if (M.meta.name === \"new\" && M.property.name === \"target\") {\n                return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            } else if (M.meta.name === \"import\" && M.property.name === \"meta\") {\n                return new AST_ImportMeta({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            }\n        },\n\n        Identifier: function(M) {\n            return new AST_SymbolRef({\n                start : my_start_token(M),\n                end   : my_end_token(M),\n                name  : M.name\n            });\n        },\n\n        EmptyStatement: function(M) {\n            return new AST_EmptyStatement({\n                start: my_start_token(M),\n                end: my_end_token(M)\n            });\n        },\n\n        BlockStatement: function(M) {\n            return new AST_BlockStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: M.body.map(from_moz)\n            });\n        },\n\n        IfStatement: function(M) {\n            return new AST_If({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                body: from_moz(M.consequent),\n                alternative: from_moz(M.alternate)\n            });\n        },\n\n        LabeledStatement: function(M) {\n            try {\n                const label = from_moz_symbol(AST_Label, M.label);\n                FROM_MOZ_LABELS.push(label);\n\n                const stat = new AST_LabeledStatement({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    label,\n                    body: from_moz(M.body)\n                });\n\n                return stat;\n            } finally {\n                FROM_MOZ_LABELS.pop();\n            }\n        },\n\n        BreakStatement: function(M) {\n            return new AST_Break({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                label: from_moz_label_ref(M.label),\n            });\n        },\n\n        ContinueStatement: function(M) {\n            return new AST_Continue({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                label: from_moz_label_ref(M.label),\n            });\n        },\n\n        WithStatement: function(M) {\n            return new AST_With({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.object),\n                body: from_moz(M.body)\n            });\n        },\n\n        SwitchStatement: function(M) {\n            return new AST_Switch({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.discriminant),\n                body: M.cases.map(from_moz)\n            });\n        },\n\n        ReturnStatement: function(M) {\n            return new AST_Return({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: from_moz(M.argument)\n            });\n        },\n\n        ThrowStatement: function(M) {\n            return new AST_Throw({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: from_moz(M.argument)\n            });\n        },\n\n        WhileStatement: function(M) {\n            return new AST_While({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                body: from_moz(M.body)\n            });\n        },\n\n        DoWhileStatement: function(M) {\n            return new AST_Do({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                body: from_moz(M.body)\n            });\n        },\n\n        ForStatement: function(M) {\n            return new AST_For({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.init),\n                condition: from_moz(M.test),\n                step: from_moz(M.update),\n                body: from_moz(M.body)\n            });\n        },\n\n        ForInStatement: function(M) {\n            return new AST_ForIn({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body)\n            });\n        },\n\n        ForOfStatement: function(M) {\n            return new AST_ForOf({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body),\n                await: M.await\n            });\n        },\n\n        AwaitExpression: function(M) {\n            return new AST_Await({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n\n        YieldExpression: function(M) {\n            return new AST_Yield({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument),\n                is_star: M.delegate\n            });\n        },\n\n        DebuggerStatement: function(M) {\n            return new AST_Debugger({\n                start: my_start_token(M),\n                end: my_end_token(M)\n            });\n        },\n\n        CatchClause: function(M) {\n            return new AST_Catch({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argname: M.param ? from_moz_pattern(M.param, AST_SymbolCatch) : null,\n                body: from_moz(M.body).body\n            });\n        },\n\n        ThisExpression: function(M) {\n            return new AST_This({\n                start: my_start_token(M),\n                name: \"this\",\n                end: my_end_token(M)\n            });\n        },\n\n        Super: function(M) {\n            return new AST_Super({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"super\",\n            });\n        },\n\n        BinaryExpression: function(M) {\n            if (M.left.type === \"PrivateIdentifier\") {\n                return new AST_PrivateIn({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    key: new AST_SymbolPrivateProperty({\n                        start: my_start_token(M.left),\n                        end: my_end_token(M.left),\n                        name: M.left.name\n                    }),\n                    value: from_moz(M.right),\n                });\n            }\n            return new AST_Binary({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                operator: M.operator,\n                left: from_moz(M.left),\n                right: from_moz(M.right)\n            });\n        },\n\n        LogicalExpression: function(M) {\n            return new AST_Binary({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                operator: M.operator,\n                left: from_moz(M.left),\n                right: from_moz(M.right)\n            });\n        },\n\n        AssignmentExpression: function(M) {\n            return new AST_Assign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                operator: M.operator,\n                logical: M.operator === \"??=\" || M.operator === \"&&=\" || M.operator === \"||=\",\n                left: from_moz(M.left),\n                right: from_moz(M.right)\n            });\n        },\n\n        ConditionalExpression: function(M) {\n            return new AST_Conditional({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                consequent: from_moz(M.consequent),\n                alternative: from_moz(M.alternate)\n            });\n        },\n\n        NewExpression: function(M) {\n            return new AST_New({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.callee),\n                args: M.arguments.map(from_moz)\n            });\n        },\n\n        CallExpression: function(M) {\n            return new AST_Call({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.callee),\n                optional: M.optional,\n                args: M.arguments.map(from_moz)\n            });\n        }\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    MOZ_TO_ME.ClassDeclaration =\n    MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {\n        return new (M.type === \"ClassDeclaration\" ? AST_DefClass : AST_ClassExpression)({\n            start    : my_start_token(M),\n            end      : my_end_token(M),\n            name     : M.id && from_moz_symbol(M.type === \"ClassDeclaration\" ? AST_SymbolDefClass : AST_SymbolClass, M.id),\n            extends  : from_moz(M.superClass),\n            properties: M.body.body.map(from_moz)\n        });\n    };\n\n    def_to_moz(AST_EmptyStatement, function To_Moz_EmptyStatement() {\n        return {\n            type: \"EmptyStatement\"\n        };\n    });\n    def_to_moz(AST_BlockStatement, function To_Moz_BlockStatement(M) {\n        return {\n            type: \"BlockStatement\",\n            body: M.body.map(to_moz)\n        };\n    });\n    def_to_moz(AST_If, function To_Moz_IfStatement(M) {\n        return {\n            type: \"IfStatement\",\n            test: to_moz(M.condition),\n            consequent: to_moz(M.body),\n            alternate: to_moz(M.alternative)\n        };\n    });\n    def_to_moz(AST_LabeledStatement, function To_Moz_LabeledStatement(M) {\n        return {\n            type: \"LabeledStatement\",\n            label: to_moz(M.label),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_Break, function To_Moz_BreakStatement(M) {\n        return {\n            type: \"BreakStatement\",\n            label: to_moz(M.label)\n        };\n    });\n    def_to_moz(AST_Continue, function To_Moz_ContinueStatement(M) {\n        return {\n            type: \"ContinueStatement\",\n            label: to_moz(M.label)\n        };\n    });\n    def_to_moz(AST_With, function To_Moz_WithStatement(M) {\n        return {\n            type: \"WithStatement\",\n            object: to_moz(M.expression),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_Switch, function To_Moz_SwitchStatement(M) {\n        return {\n            type: \"SwitchStatement\",\n            discriminant: to_moz(M.expression),\n            cases: M.body.map(to_moz)\n        };\n    });\n    def_to_moz(AST_Return, function To_Moz_ReturnStatement(M) {\n        return {\n            type: \"ReturnStatement\",\n            argument: to_moz(M.value)\n        };\n    });\n    def_to_moz(AST_Throw, function To_Moz_ThrowStatement(M) {\n        return {\n            type: \"ThrowStatement\",\n            argument: to_moz(M.value)\n        };\n    });\n    def_to_moz(AST_While, function To_Moz_WhileStatement(M) {\n        return {\n            type: \"WhileStatement\",\n            test: to_moz(M.condition),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_Do, function To_Moz_DoWhileStatement(M) {\n        return {\n            type: \"DoWhileStatement\",\n            test: to_moz(M.condition),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_For, function To_Moz_ForStatement(M) {\n        return {\n            type: \"ForStatement\",\n            init: to_moz(M.init),\n            test: to_moz(M.condition),\n            update: to_moz(M.step),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_ForIn, function To_Moz_ForInStatement(M) {\n        return {\n            type: \"ForInStatement\",\n            left: to_moz(M.init),\n            right: to_moz(M.object),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_ForOf, function To_Moz_ForOfStatement(M) {\n        return {\n            type: \"ForOfStatement\",\n            left: to_moz(M.init),\n            right: to_moz(M.object),\n            body: to_moz(M.body),\n            await: M.await\n        };\n    });\n    def_to_moz(AST_Await, function To_Moz_AwaitExpression(M) {\n        return {\n            type: \"AwaitExpression\",\n            argument: to_moz(M.expression)\n        };\n    });\n    def_to_moz(AST_Yield, function To_Moz_YieldExpression(M) {\n        return {\n            type: \"YieldExpression\",\n            argument: to_moz(M.expression),\n            delegate: M.is_star\n        };\n    });\n    def_to_moz(AST_Debugger, function To_Moz_DebuggerStatement() {\n        return {\n            type: \"DebuggerStatement\"\n        };\n    });\n    def_to_moz(AST_VarDefLike, function To_Moz_VariableDeclarator(M) {\n        return {\n            type: \"VariableDeclarator\",\n            id: to_moz(M.name),\n            init: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_This, function To_Moz_ThisExpression() {\n        return {\n            type: \"ThisExpression\"\n        };\n    });\n    def_to_moz(AST_Super, function To_Moz_Super() {\n        return {\n            type: \"Super\"\n        };\n    });\n    def_to_moz(AST_Conditional, function To_Moz_ConditionalExpression(M) {\n        return {\n            type: \"ConditionalExpression\",\n            test: to_moz(M.condition),\n            consequent: to_moz(M.consequent),\n            alternate: to_moz(M.alternative)\n        };\n    });\n    def_to_moz(AST_New, function To_Moz_NewExpression(M) {\n        return {\n            type: \"NewExpression\",\n            callee: to_moz(M.expression),\n            arguments: M.args.map(to_moz)\n        };\n    });\n    def_to_moz(AST_Call, function To_Moz_CallExpression(M) {\n        if (M.expression instanceof AST_SymbolRef && M.expression.name === \"import\") {\n            const [source, options] = M.args.map(to_moz);\n            return {\n                type: \"ImportExpression\",\n                source,\n                options: options || null\n            };\n        }\n\n        return {\n            type: \"CallExpression\",\n            callee: to_moz(M.expression),\n            optional: M.optional,\n            arguments: M.args.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_Expansion, function To_Moz_Spread(M) {\n        return {\n            type: to_moz_in_destructuring() ? \"RestElement\" : \"SpreadElement\",\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.prefix),\n            quasi: to_moz(M.template_string)\n        };\n    });\n\n    def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {\n        var quasis = [];\n        var expressions = [];\n        for (var i = 0; i < M.segments.length; i++) {\n            if (i % 2 !== 0) {\n                expressions.push(to_moz(M.segments[i]));\n            } else {\n                quasis.push({\n                    type: \"TemplateElement\",\n                    value: {\n                        raw: M.segments[i].raw,\n                        cooked: M.segments[i].value\n                    },\n                    tail: i === M.segments.length - 1\n                });\n            }\n        }\n        return {\n            type: \"TemplateLiteral\",\n            quasis: quasis,\n            expressions: expressions\n        };\n    });\n\n    def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz_pattern),\n            generator: M.is_generator,\n            async: M.async,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Function, function To_Moz_FunctionExpression(M) {\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz_pattern),\n            generator: M.is_generator || false,\n            async: M.async || false,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {\n        var body = M.body.length === 1 && M.body[0] instanceof AST_Return && M.body[0].value\n            ? to_moz(M.body[0].value)\n            : {\n                type: \"BlockStatement\",\n                body: M.body.map(to_moz)\n            };\n        return {\n            type: \"ArrowFunctionExpression\",\n            params: M.argnames.map(to_moz_pattern),\n            async: M.async,\n            body: body,\n        };\n    });\n\n    def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {\n        if (M.is_array) {\n            return {\n                type: \"ArrayPattern\",\n                elements: M.names.map(\n                    M => M instanceof AST_Hole ? null : to_moz_pattern(M)\n                ),\n            };\n        }\n        return {\n            type: \"ObjectPattern\",\n            properties: M.names.map(M => {\n                if (M instanceof AST_ObjectKeyVal) {\n                    var computed = M.computed_key();\n                    const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n\n                    return {\n                        type: \"Property\",\n                        computed,\n                        kind: \"init\",\n                        key: key,\n                        method: false,\n                        shorthand,\n                        value: to_moz_pattern(M.value)\n                    };\n                } else {\n                    return to_moz_pattern(M);\n                }\n            }),\n        };\n    });\n\n    def_to_moz(AST_DefaultAssign, function To_Moz_AssignmentExpression(M) {\n        return {\n            type: \"AssignmentPattern\",\n            left: to_moz_pattern(M.left),\n            right: to_moz(M.right),\n        };\n    });\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: {\n                type: \"Literal\",\n                value: M.value,\n                raw: M.print_to_string()\n            },\n            directive: M.value\n        };\n    });\n\n    def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: to_moz(M.body)\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M.body),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally)\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: M.argname != null ? to_moz_pattern(M.argname) : null,\n            body: to_moz_block(M)\n        };\n    });\n\n    def_to_moz(AST_DefinitionsLike, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind:\n                M instanceof AST_Const ? \"const\" :\n                M instanceof AST_Let ? \"let\" :\n                M instanceof AST_Using ? (M.await ? \"await using\" : \"using\") :\n                \"var\",\n            declarations: M.definitions.map(to_moz)\n        };\n    });\n\n    function import_attributes_to_moz(attribute) {\n        const import_attributes = [];\n        if (attribute) {\n            for (const { key, value } of attribute.properties) {\n                const key_moz = is_basic_identifier_string(key)\n                    ? { type: \"Identifier\", name: key }\n                    : { type: \"Literal\", value: key, raw: JSON.stringify(key) };\n                import_attributes.push({\n                    type: \"ImportAttribute\",\n                    key: key_moz,\n                    value: to_moz(value)\n                });\n            }\n        }\n        return import_attributes;\n    }\n\n    def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {\n        if (M.exported_names) {\n            var first_exported = M.exported_names[0];\n            if (first_exported && first_exported.name.name === \"*\" && !first_exported.name.quote) {\n                var foreign_name = first_exported.foreign_name;\n                var exported = foreign_name.name === \"*\" && !foreign_name.quote\n                    ? null\n                    : to_moz(foreign_name);\n                return {\n                    type: \"ExportAllDeclaration\",\n                    source: to_moz(M.module_name),\n                    exported: exported,\n                    attributes: import_attributes_to_moz(M.attributes)\n                };\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.exported_names.map(function (name_mapping) {\n                    return {\n                        type: \"ExportSpecifier\",\n                        exported: to_moz(name_mapping.foreign_name),\n                        local: to_moz(name_mapping.name)\n                    };\n                }),\n                declaration: to_moz(M.exported_definition),\n                source: to_moz(M.module_name),\n                attributes: import_attributes_to_moz(M.attributes)\n            };\n        }\n\n        if (M.is_default) {\n            return {\n                type: \"ExportDefaultDeclaration\",\n                declaration: to_moz(M.exported_value || M.exported_definition),\n            };\n        } else {\n            return {\n                type: \"ExportNamedDeclaration\",\n                declaration: to_moz(M.exported_value || M.exported_definition),\n                specifiers: [],\n                source: null,\n            };\n        }\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = [];\n        if (M.imported_name) {\n            specifiers.push({\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.imported_name)\n            });\n        }\n        if (M.imported_names) {\n            var first_imported_foreign_name = M.imported_names[0].foreign_name;\n            if (first_imported_foreign_name.name === \"*\" && !first_imported_foreign_name.quote) {\n                specifiers.push({\n                    type: \"ImportNamespaceSpecifier\",\n                    local: to_moz(M.imported_names[0].name)\n                });\n            } else {\n                M.imported_names.forEach(function(name_mapping) {\n                    specifiers.push({\n                        type: \"ImportSpecifier\",\n                        local: to_moz(name_mapping.name),\n                        imported: to_moz(name_mapping.foreign_name)\n                    });\n                });\n            }\n        }\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.module_name),\n            attributes: import_attributes_to_moz(M.attributes)\n        };\n    });\n\n    def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"import\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"meta\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n        return {\n            type: \"SequenceExpression\",\n            expressions: M.expressions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: false,\n            property: {\n                type: \"PrivateIdentifier\",\n                name: M.property\n            },\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var isComputed = M instanceof AST_Sub;\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: isComputed,\n            property: isComputed ? to_moz(M.property) : {type: \"Identifier\", name: M.property},\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {\n        return {\n            type: \"ChainExpression\",\n            expression: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        if (M.operator == \"=\" && to_moz_in_destructuring()) {\n            return {\n                type: \"AssignmentPattern\",\n                left: to_moz(M.left),\n                right: to_moz(M.right)\n            };\n        }\n\n        const type = M.operator == \"&&\" || M.operator == \"||\" || M.operator === \"??\"\n            ? \"LogicalExpression\"\n            : \"BinaryExpression\";\n\n        return {\n            type,\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Assign, function To_Moz_AssignmentExpression(M) {\n        return {\n            type: \"AssignmentExpression\",\n            operator: M.operator,\n            left: to_moz(M.left),\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_PrivateIn, function To_Moz_BinaryExpression_PrivateIn(M) {\n        return {\n            type: \"BinaryExpression\",\n            left: { type: \"PrivateIdentifier\", name: M.key.name },\n            operator: \"in\",\n            right: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n        return {\n            type: \"ObjectExpression\",\n            properties: M.properties.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {\n        var computed = M.computed_key();\n        const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n\n        var kind;\n        if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else\n        if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {\n            const kind = M instanceof AST_PrivateGetter ? \"get\" : \"set\";\n            return {\n                type: \"MethodDefinition\",\n                computed: false,\n                kind: kind,\n                static: M.static,\n                key: {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.name\n                },\n                value: to_moz(M.value)\n            };\n        }\n        if (M instanceof AST_ClassPrivateProperty) {\n            return {\n                type: \"PropertyDefinition\",\n                key: {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.name\n                },\n                value: to_moz(M.value),\n                computed: false,\n                static: M.static\n            };\n        }\n        if (M instanceof AST_ClassProperty) {\n            return {\n                type: \"PropertyDefinition\",\n                key,\n                value: to_moz(M.value),\n                computed,\n                static: M.static\n            };\n        }\n        if (parent instanceof AST_Class) {\n            return {\n                type: \"MethodDefinition\",\n                computed: computed,\n                kind: kind,\n                static: M.static,\n                key: to_moz(M.key),\n                value: to_moz(M.value)\n            };\n        }\n        return {\n            type: \"Property\",\n            computed: computed,\n            method: false,\n            shorthand,\n            kind: kind,\n            key: key,\n            value: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_ObjectKeyVal, function To_Moz_Property(M) {\n        var computed = M.computed_key();\n        const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n\n        return {\n            type: \"Property\",\n            computed: computed,\n            shorthand: shorthand,\n            method: false,\n            kind: \"init\",\n            key: key,\n            value: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {\n        const computed = M.computed_key();\n        const [_always_false, key] = to_moz_property_key(M.key, computed, M.quote, M.value);\n\n        if (parent instanceof AST_Object) {\n            return {\n                type: \"Property\",\n                kind: \"init\",\n                computed,\n                method: true,\n                shorthand: false,\n                key,\n                value: to_moz(M.value),\n            };\n        }\n\n        return {\n            type: \"MethodDefinition\",\n            kind: !computed && M.key.name === \"constructor\" ? \"constructor\" : \"method\",\n            computed,\n            key,\n            value: to_moz(M.value),\n            static: M.static,\n        };\n    });\n\n    def_to_moz(AST_PrivateMethod, function To_Moz_MethodDefinition(M) {\n        return {\n            type: \"MethodDefinition\",\n            kind: \"method\",\n            key: { type: \"PrivateIdentifier\", name: M.key.name },\n            value: to_moz(M.value),\n            computed: false,\n            static: M.static,\n        };\n    });\n\n    def_to_moz(AST_Class, function To_Moz_Class(M) {\n        var type = M instanceof AST_ClassExpression ? \"ClassExpression\" : \"ClassDeclaration\";\n        return {\n            type: type,\n            superClass: to_moz(M.extends),\n            id: M.name ? to_moz(M.name) : null,\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz)\n            }\n        };\n    });\n\n    def_to_moz(AST_ClassStaticBlock, function To_Moz_StaticBlock(M) {\n        return {\n            type: \"StaticBlock\",\n            body: M.body.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {\n        if (\n            (M instanceof AST_SymbolMethod && parent.quote) ||\n            ((\n                M instanceof AST_SymbolImportForeign ||\n                M instanceof AST_SymbolExportForeign ||\n                M instanceof AST_SymbolExport\n                ) && M.quote)\n         ) {\n            return {\n                type: \"Literal\",\n                value: M.name\n            };\n        }\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def ? def.mangled_name || def.name : M.name\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        const pattern = M.value.source;\n        const flags = M.value.flags;\n        return {\n            type: \"Literal\",\n            value: null,\n            raw: M.print_to_string(),\n            regex: { pattern, flags }\n        };\n    });\n\n    def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.raw || M.print_to_string()\n        };\n    });\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value)\n        };\n    });\n\n    def_to_moz(AST_BigInt, M => ({\n        type: \"Literal\",\n        // value cannot be represented natively\n        // see: https://github.com/estree/estree/blob/master/es2020.md#bigintliteral\n        value: null,\n        // `M.value` is a string that may be a hex number representation.\n        // but \"bigint\" property should have only decimal digits\n        bigint: typeof BigInt === \"function\" ? BigInt(M.value).toString() : M.value,\n        raw: M.raw,\n    }));\n\n    AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() { return null; });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n\n    /* -----[ tools ]----- */\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            start && start.line || 0,\n            start && start.column || 0,\n            range ? range [0] : moznode.start,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            end && end.line || 0,\n            end && end.column || 0,\n            range ? range [0] : moznode.end,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    var FROM_MOZ_LABELS = null;\n\n    function from_moz(node) {\n        if (node == null) return null;\n        return MOZ_TO_ME[node.type](node);\n    }\n\n    function from_moz_quote(moz_key, computed) {\n        if (!computed && moz_key.type === \"Literal\" && typeof moz_key.value === \"string\") {\n            return '\"';\n        } else {\n            return \"\";\n        }\n    }\n\n    function from_moz_symbol(symbol_type, M, has_quote) {\n        return new symbol_type({\n            start: my_start_token(M),\n            quote: has_quote ? '\"' : undefined,\n            name: M.type === \"Identifier\" ? M.name : String(M.value),\n            end: my_end_token(M),\n        });\n    }\n\n    function from_moz_lambda(M, is_method) {\n        return new (is_method ? AST_Accessor : AST_Function)({\n            start: my_start_token(M),\n            end: my_end_token(M),\n            name: M.id && from_moz_symbol(is_method ? AST_SymbolMethod : AST_SymbolLambda, M.id),\n            argnames: M.params.map(M => from_moz_pattern(M, AST_SymbolFunarg)),\n            is_generator: M.generator,\n            async: M.async,\n            body: normalize_directives(from_moz(M.body).body)\n        });\n    }\n\n    function from_moz_pattern(M, sym_type) {\n        switch (M.type) {\n            case \"ObjectPattern\":\n                return new AST_Destructuring({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    names: M.properties.map(p => from_moz_pattern(p, sym_type)),\n                    is_array: false\n                });\n\n            case \"Property\":\n                var key = M.key;\n                var args = {\n                    start    : my_start_token(key || M.value),\n                    end      : my_end_token(M.value),\n                    key      : key.type == \"Identifier\" ? key.name : String(key.value),\n                    quote    : !M.computed && key.type === \"Literal\" && typeof key.value === \"string\"\n                                ? '\"'\n                                : \"\",\n                    value    : from_moz_pattern(M.value, sym_type)\n                };\n                if (M.computed) {\n                    args.key = from_moz(M.key);\n                }\n                return new AST_ObjectKeyVal(args);\n\n            case \"ArrayPattern\":\n                return new AST_Destructuring({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    names: M.elements.map(function(elm) {\n                        if (elm === null) {\n                            return new AST_Hole();\n                        }\n                        return from_moz_pattern(elm, sym_type);\n                    }),\n                    is_array: true\n                });\n\n            case \"SpreadElement\":\n            case \"RestElement\":\n                return new AST_Expansion({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    expression: from_moz_pattern(M.argument, sym_type),\n                });\n\n            case \"AssignmentPattern\":\n                return new AST_DefaultAssign({\n                    start : my_start_token(M),\n                    end   : my_end_token(M),\n                    left  : from_moz_pattern(M.left, sym_type),\n                    operator: \"=\",\n                    right : from_moz(M.right),\n                });\n\n            case \"Identifier\":\n                return new sym_type({\n                    start : my_start_token(M),\n                    end   : my_end_token(M),\n                    name  : M.name,\n                });\n\n            default:\n                throw new Error(\"Invalid node type for destructuring: \" + M.type);\n        }\n    }\n\n    function from_moz_label_ref(m_label) {\n        if (!m_label) return null;\n\n        const label = from_moz_symbol(AST_LabelRef, m_label);\n\n        let i = FROM_MOZ_LABELS.length;\n        while (i--) {\n            const label_origin = FROM_MOZ_LABELS[i];\n\n            if (label.name === label_origin.name) {\n                label.thedef = label_origin;\n                break;\n            }\n        }\n\n        return label;\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_labels = FROM_MOZ_LABELS;\n        FROM_MOZ_LABELS = [];\n        var ast = from_moz(node);\n        FROM_MOZ_LABELS = save_labels;\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (!(start && end)) {\n            return moznode;\n        }\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function(parent) {\n            return set_moz_loc(this, handler(this, parent));\n        });\n    }\n\n    var TO_MOZ_STACK = null;\n\n    function to_moz(node) {\n        if (TO_MOZ_STACK === null) { TO_MOZ_STACK = []; }\n        TO_MOZ_STACK.push(node);\n        var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;\n        TO_MOZ_STACK.pop();\n        if (TO_MOZ_STACK.length === 0) { TO_MOZ_STACK = null; }\n        return ast;\n    }\n\n    /** Object property keys can be number literals, string literals, or raw names. Additionally they can be shorthand. We decide that here. */\n    function to_moz_property_key(key, computed = false, quote = false, value = null) {\n        if (computed) {\n            return [false, to_moz(key)];\n        }\n\n        const key_name = typeof key === \"string\" ? key : key.name;\n        let moz_key;\n        if (quote) {\n            moz_key = { type: \"Literal\", value: key_name, raw: JSON.stringify(key_name) };\n        } else if (\"\" + +key_name === key_name && +key_name >= 0) {\n            // representable as a number\n            moz_key = { type: \"Literal\", value: +key_name, raw: JSON.stringify(+key_name) };\n        } else {\n            moz_key = { type: \"Identifier\", name: key_name };\n        }\n\n        const shorthand =\n            moz_key.type === \"Identifier\"\n            && moz_key.name === key_name\n            && (value instanceof AST_Symbol && value.name === key_name\n                || value instanceof AST_DefaultAssign && value.left.name === key_name);\n        return [shorthand, moz_key];\n    }\n\n    function to_moz_pattern(node) {\n        if (node instanceof AST_Expansion) {\n            return {\n                type: \"RestElement\",\n                argument: to_moz_pattern(node.expression),\n            };\n        }\n\n        if ((\n            node instanceof AST_Symbol\n            || node instanceof AST_Destructuring\n            || node instanceof AST_DefaultAssign\n            || node instanceof AST_PropAccess\n        )) {\n            // Plain translation\n            return to_moz(node);\n        }\n\n        throw new Error(node.TYPE);\n    }\n\n    function to_moz_in_destructuring() {\n        var i = TO_MOZ_STACK.length;\n        while (i--) {\n            if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz)\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body\n        };\n    }\n})();\n\n// return true if the node at the top of the stack (that means the\n// innermost node in the current output) is lexically the first in\n// a statement.\nfunction first_in_statement(stack) {\n    let node = stack.parent(-1);\n    for (let i = 0, p; p = stack.parent(i); i++) {\n        if (p instanceof AST_Statement && p.body === node)\n            return true;\n        if ((p instanceof AST_Sequence && p.expressions[0] === node) ||\n            (p.TYPE === \"Call\" && p.expression === node) ||\n            (p instanceof AST_PrefixedTemplateString && p.prefix === node) ||\n            (p instanceof AST_Dot && p.expression === node) ||\n            (p instanceof AST_Sub && p.expression === node) ||\n            (p instanceof AST_Chain && p.expression === node) ||\n            (p instanceof AST_Conditional && p.condition === node) ||\n            (p instanceof AST_Binary && p.left === node) ||\n            (p instanceof AST_UnaryPostfix && p.expression === node)\n        ) {\n            node = p;\n        } else {\n            return false;\n        }\n    }\n}\n\n// Returns whether the leftmost item in the expression is an object\nfunction left_is_object(node) {\n    if (node instanceof AST_Object) return true;\n    if (node instanceof AST_Sequence) return left_is_object(node.expressions[0]);\n    if (node.TYPE === \"Call\") return left_is_object(node.expression);\n    if (node instanceof AST_PrefixedTemplateString) return left_is_object(node.prefix);\n    if (node instanceof AST_Dot || node instanceof AST_Sub) return left_is_object(node.expression);\n    if (node instanceof AST_Chain) return left_is_object(node.expression);\n    if (node instanceof AST_Conditional) return left_is_object(node.condition);\n    if (node instanceof AST_Binary) return left_is_object(node.left);\n    if (node instanceof AST_UnaryPostfix) return left_is_object(node.expression);\n    return false;\n}\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nconst CODE_LINE_BREAK = 10;\nconst CODE_SPACE = 32;\n\nconst r_annotation = /[@#]__(PURE|INLINE|NOINLINE)__/;\n\nfunction is_some_comments(comment) {\n    // multiline comment\n    return (\n        (comment.type === \"comment2\" || comment.type === \"comment1\")\n        && /@preserve|@copyright|@lic|@cc_on|^\\**!/i.test(comment.value)\n    );\n}\n\nconst ROPE_COMMIT_WHEN = 8 * 1000;\nclass Rope {\n    constructor() {\n        this.committed = \"\";\n        this.current = \"\";\n    }\n\n    append(str) {\n        /** When `this.current` is too long, commit it. */\n        if (this.current.length > ROPE_COMMIT_WHEN) {\n            this.committed += this.current + str;\n            this.current = \"\";\n        } else {\n            this.current += str;\n        }\n    }\n\n    insertAt(char, index) {\n        const { committed, current } = this;\n        if (index < committed.length) {\n            this.committed = committed.slice(0, index) + char + committed.slice(index);\n        } else if (index === committed.length) {\n            this.committed += char;\n        } else {\n            index -= committed.length;\n            this.committed += current.slice(0, index) + char;\n            this.current = current.slice(index);\n        }\n    }\n\n    charAt(index) {\n        const { committed } = this;\n        if (index < committed.length) return committed[index];\n        return this.current[index - committed.length];\n    }\n\n    charCodeAt(index) {\n        const { committed } = this;\n        if (index < committed.length) return committed.charCodeAt(index);\n        return this.current.charCodeAt(index - committed.length);\n    }\n\n    length() {\n        return this.committed.length + this.current.length;\n    }\n\n    expectDirective() {\n        // /^$|[;{][\\s\\n]*$/\n\n        let ch, n = this.length();\n\n        if (n <= 0) return true;\n\n        // Skip N whitespace from the end\n        while (\n            (ch = this.charCodeAt(--n))\n            && (ch == CODE_SPACE || ch == CODE_LINE_BREAK)\n        );\n\n        // either \";\", or \"{\", or the string ended\n        return !ch || ch === 59 || ch === 123;\n    }\n\n    hasNLB() {\n        let n = this.length() - 1;\n        while (n >= 0) {\n            const code = this.charCodeAt(n--);\n\n            if (code === CODE_LINE_BREAK) return true;\n            if (code !== CODE_SPACE) return false;\n        }\n        return true;\n    }\n\n\n    toString() {\n        return this.committed + this.current;\n    }\n}\n\nfunction OutputStream(options) {\n\n    var readonly = !options;\n    options = defaults(options, {\n        ascii_only           : false,\n        beautify             : false,\n        braces               : false,\n        comments             : \"some\",\n        ecma                 : 5,\n        ie8                  : false,\n        indent_level         : 4,\n        indent_start         : 0,\n        inline_script        : true,\n        keep_numbers         : false,\n        keep_quoted_props    : false,\n        max_line_len         : false,\n        preamble             : null,\n        preserve_annotations : false,\n        quote_keys           : false,\n        quote_style          : 0,\n        safari10             : false,\n        semicolons           : true,\n        shebang              : true,\n        shorthand            : undefined,\n        source_map           : null,\n        webkit               : false,\n        width                : 80,\n        wrap_iife            : false,\n        wrap_func_args       : false,\n\n        _destroy_ast         : false\n    }, true);\n\n    if (options.shorthand === undefined)\n        options.shorthand = options.ecma > 5;\n\n    // Convert comment option to RegExp if necessary and set up comments filter\n    var comment_filter = return_false; // Default case, throw all comments away\n    if (options.comments) {\n        let comments = options.comments;\n        if (typeof options.comments === \"string\" && /^\\/.*\\/[a-zA-Z]*$/.test(options.comments)) {\n            var regex_pos = options.comments.lastIndexOf(\"/\");\n            comments = new RegExp(\n                options.comments.substr(1, regex_pos - 1),\n                options.comments.substr(regex_pos + 1)\n            );\n        }\n        if (comments instanceof RegExp) {\n            comment_filter = function(comment) {\n                return comment.type != \"comment5\" && comments.test(comment.value);\n            };\n        } else if (typeof comments === \"function\") {\n            comment_filter = function(comment) {\n                return comment.type != \"comment5\" && comments(this, comment);\n            };\n        } else if (comments === \"some\") {\n            comment_filter = is_some_comments;\n        } else { // NOTE includes \"all\" option\n            comment_filter = return_true;\n        }\n    }\n\n    if (options.preserve_annotations) {\n        let prev_comment_filter = comment_filter;\n        comment_filter = function (comment) {\n            return r_annotation.test(comment.value) || prev_comment_filter.apply(this, arguments);\n        };\n    }\n\n    var indentation = 0;\n    var current_col = 0;\n    var current_line = 1;\n    var current_pos = 0;\n    var OUTPUT = new Rope();\n    let printed_comments = new Set();\n\n    var to_utf8 = options.ascii_only ? function(str, identifier = false, regexp = false) {\n        if (options.ecma >= 2015 && !options.safari10 && !regexp) {\n            str = str.replace(/[\\ud800-\\udbff][\\udc00-\\udfff]/g, function(ch) {\n                var code = get_full_char_code(ch, 0).toString(16);\n                return \"\\\\u{\" + code + \"}\";\n            });\n        }\n        return str.replace(/[\\u0000-\\u001f\\u007f-\\uffff]/g, function(ch) {\n            var code = ch.charCodeAt(0).toString(16);\n            if (code.length <= 2 && !identifier) {\n                while (code.length < 2) code = \"0\" + code;\n                return \"\\\\x\" + code;\n            } else {\n                while (code.length < 4) code = \"0\" + code;\n                return \"\\\\u\" + code;\n            }\n        });\n    } : function(str) {\n        return str.replace(/[\\ud800-\\udbff][\\udc00-\\udfff]|([\\ud800-\\udbff]|[\\udc00-\\udfff])/g, function(match, lone) {\n            if (lone) {\n                return \"\\\\u\" + lone.charCodeAt(0).toString(16);\n            }\n            return match;\n        });\n    };\n\n    function make_string(str, quote) {\n        var dq = 0, sq = 0;\n        str = str.replace(/[\\\\\\b\\f\\n\\r\\v\\t\\x22\\x27\\u2028\\u2029\\0\\ufeff]/g,\n          function(s, i) {\n            switch (s) {\n              case '\"': ++dq; return '\"';\n              case \"'\": ++sq; return \"'\";\n              case \"\\\\\": return \"\\\\\\\\\";\n              case \"\\n\": return \"\\\\n\";\n              case \"\\r\": return \"\\\\r\";\n              case \"\\t\": return \"\\\\t\";\n              case \"\\b\": return \"\\\\b\";\n              case \"\\f\": return \"\\\\f\";\n              case \"\\x0B\": return options.ie8 ? \"\\\\x0B\" : \"\\\\v\";\n              case \"\\u2028\": return \"\\\\u2028\";\n              case \"\\u2029\": return \"\\\\u2029\";\n              case \"\\ufeff\": return \"\\\\ufeff\";\n              case \"\\0\":\n                  return /[0-9]/.test(get_full_char(str, i+1)) ? \"\\\\x00\" : \"\\\\0\";\n            }\n            return s;\n        });\n        function quote_single() {\n            return \"'\" + str.replace(/\\x27/g, \"\\\\'\") + \"'\";\n        }\n        function quote_double() {\n            return '\"' + str.replace(/\\x22/g, '\\\\\"') + '\"';\n        }\n        function quote_template() {\n            return \"`\" + str.replace(/`/g, \"\\\\`\") + \"`\";\n        }\n        str = to_utf8(str);\n        if (quote === \"`\") return quote_template();\n        switch (options.quote_style) {\n          case 1:\n            return quote_single();\n          case 2:\n            return quote_double();\n          case 3:\n            return quote == \"'\" ? quote_single() : quote_double();\n          default:\n            return dq > sq ? quote_single() : quote_double();\n        }\n    }\n\n    function encode_string(str, quote) {\n        var ret = make_string(str, quote);\n        if (options.inline_script) {\n            ret = ret.replace(/<\\x2f(script)([>\\/\\t\\n\\f\\r ])/gi, \"<\\\\/$1$2\");\n            ret = ret.replace(/\\x3c!--/g, \"\\\\x3c!--\");\n            ret = ret.replace(/--\\x3e/g, \"--\\\\x3e\");\n        }\n        return ret;\n    }\n\n    function make_name(name) {\n        name = name.toString();\n        name = to_utf8(name, true);\n        return name;\n    }\n\n    function make_indent(back) {\n        return \" \".repeat(options.indent_start + indentation - back * options.indent_level);\n    }\n\n    /* -----[ beautification/minification ]----- */\n\n    var has_parens = false;\n    var might_need_space = false;\n    var might_need_semicolon = false;\n    var might_add_newline = 0;\n    var need_newline_indented = false;\n    var need_space = false;\n    var newline_insert = -1;\n    var last = \"\";\n    var mapping_token, mapping_name, mappings = options.source_map && [];\n\n    var do_add_mapping = mappings ? function() {\n        mappings.forEach(function(mapping) {\n            try {\n                let { name, token } = mapping;\n                if (name !== false) {\n                    if (token.type == \"name\" || token.type === \"privatename\") {\n                        name = token.value;\n                    } else if (name instanceof AST_Symbol) {\n                        name = token.type === \"string\" ? token.value : name.name;\n                    }\n                }\n                options.source_map.add(\n                    mapping.token.file,\n                    mapping.line, mapping.col,\n                    mapping.token.line, mapping.token.col,\n                    is_basic_identifier_string(name) ? name : undefined\n                );\n            } catch(ex) {\n                // Ignore bad mapping\n            }\n        });\n        mappings = [];\n    } : noop;\n\n    var ensure_line_len = options.max_line_len ? function() {\n        if (current_col > options.max_line_len) {\n            if (might_add_newline) {\n                OUTPUT.insertAt(\"\\n\", might_add_newline);\n                const len_after_newline = OUTPUT.length() - might_add_newline - 1;\n                if (mappings) {\n                    var delta = len_after_newline - current_col;\n                    mappings.forEach(function(mapping) {\n                        mapping.line++;\n                        mapping.col += delta;\n                    });\n                }\n                current_line++;\n                current_pos++;\n                current_col = len_after_newline;\n            }\n        }\n        if (might_add_newline) {\n            might_add_newline = 0;\n            do_add_mapping();\n        }\n    } : noop;\n\n    var requireSemicolonChars = makePredicate(\"( [ + * / - , . `\");\n\n    function print(str) {\n        str = String(str);\n        var ch = get_full_char(str, 0);\n        if (need_newline_indented && ch) {\n            need_newline_indented = false;\n            if (ch !== \"\\n\") {\n                print(\"\\n\");\n                indent();\n            }\n        }\n        if (need_space && ch) {\n            need_space = false;\n            if (!/[\\s;})]/.test(ch)) {\n                space();\n            }\n        }\n        newline_insert = -1;\n        var prev = last.charAt(last.length - 1);\n        if (might_need_semicolon) {\n            might_need_semicolon = false;\n\n            if (prev === \":\" && ch === \"}\" || (!ch || !\";}\".includes(ch)) && prev !== \";\") {\n                if (options.semicolons || requireSemicolonChars.has(ch)) {\n                    OUTPUT.append(\";\");\n                    current_col++;\n                    current_pos++;\n                } else {\n                    ensure_line_len();\n                    if (current_col > 0) {\n                        OUTPUT.append(\"\\n\");\n                        current_pos++;\n                        current_line++;\n                        current_col = 0;\n                    }\n\n                    if (/^\\s+$/.test(str)) {\n                        // reset the semicolon flag, since we didn't print one\n                        // now and might still have to later\n                        might_need_semicolon = true;\n                    }\n                }\n\n                if (!options.beautify)\n                    might_need_space = false;\n            }\n        }\n\n        if (might_need_space) {\n            if ((is_identifier_char(prev)\n                    && (is_identifier_char(ch) || ch == \"\\\\\"))\n                || (ch == \"/\" && ch == prev)\n                || ((ch == \"+\" || ch == \"-\") && ch == last)\n            ) {\n                OUTPUT.append(\" \");\n                current_col++;\n                current_pos++;\n            }\n            might_need_space = false;\n        }\n\n        if (mapping_token) {\n            mappings.push({\n                token: mapping_token,\n                name: mapping_name,\n                line: current_line,\n                col: current_col\n            });\n            mapping_token = false;\n            if (!might_add_newline) do_add_mapping();\n        }\n\n        OUTPUT.append(str);\n        has_parens = str[str.length - 1] == \"(\";\n        current_pos += str.length;\n        var a = str.split(/\\r?\\n/), n = a.length - 1;\n        current_line += n;\n        current_col += a[0].length;\n        if (n > 0) {\n            ensure_line_len();\n            current_col = a[n].length;\n        }\n        last = str;\n    }\n\n    var star = function() {\n        print(\"*\");\n    };\n\n    var space = options.beautify ? function() {\n        print(\" \");\n    } : function() {\n        might_need_space = true;\n    };\n\n    var indent = options.beautify ? function(half) {\n        if (options.beautify) {\n            print(make_indent(half ? 0.5 : 0));\n        }\n    } : noop;\n\n    var with_indent = options.beautify ? function(col, cont) {\n        if (col === true) col = next_indent();\n        var save_indentation = indentation;\n        indentation = col;\n        var ret = cont();\n        indentation = save_indentation;\n        return ret;\n    } : function(col, cont) { return cont(); };\n\n    var newline = options.beautify ? function() {\n        if (newline_insert < 0) return print(\"\\n\");\n        if (OUTPUT.charAt(newline_insert) != \"\\n\") {\n            OUTPUT.insertAt(\"\\n\", newline_insert);\n            current_pos++;\n            current_line++;\n        }\n        newline_insert++;\n    } : options.max_line_len ? function() {\n        ensure_line_len();\n        might_add_newline = OUTPUT.length();\n    } : noop;\n\n    var semicolon = options.beautify ? function() {\n        print(\";\");\n    } : function() {\n        might_need_semicolon = true;\n    };\n\n    function force_semicolon() {\n        might_need_semicolon = false;\n        print(\";\");\n    }\n\n    function next_indent() {\n        return indentation + options.indent_level;\n    }\n\n    function with_block(cont) {\n        var ret;\n        print(\"{\");\n        newline();\n        with_indent(next_indent(), function() {\n            ret = cont();\n        });\n        indent();\n        print(\"}\");\n        return ret;\n    }\n\n    function with_parens(cont) {\n        print(\"(\");\n        //XXX: still nice to have that for argument lists\n        //var ret = with_indent(current_col, cont);\n        var ret = cont();\n        print(\")\");\n        return ret;\n    }\n\n    function with_square(cont) {\n        print(\"[\");\n        //var ret = with_indent(current_col, cont);\n        var ret = cont();\n        print(\"]\");\n        return ret;\n    }\n\n    function comma() {\n        print(\",\");\n        space();\n    }\n\n    function colon() {\n        print(\":\");\n        space();\n    }\n\n    var add_mapping = mappings ? function(token, name) {\n        mapping_token = token;\n        mapping_name = name;\n    } : noop;\n\n    function get() {\n        if (might_add_newline) {\n            ensure_line_len();\n        }\n        return OUTPUT.toString();\n    }\n\n    function filter_comment(comment) {\n        if (!options.preserve_annotations) {\n            comment = comment.replace(r_annotation, \" \");\n        }\n        if (/^\\s*$/.test(comment)) {\n            return \"\";\n        }\n        return comment.replace(/(<\\s*\\/\\s*)(script)/i, \"<\\\\/$2\");\n    }\n\n    function prepend_comments(node) {\n        var self = this;\n        var start = node.start;\n        if (!start) return;\n        var printed_comments = self.printed_comments;\n\n        // There cannot be a newline between return/yield and its value.\n        const keyword_with_value = \n            node instanceof AST_Exit && node.value\n            || (node instanceof AST_Await || node instanceof AST_Yield)\n                && node.expression;\n\n        if (\n            start.comments_before\n            && printed_comments.has(start.comments_before)\n        ) {\n            if (keyword_with_value) {\n                start.comments_before = [];\n            } else {\n                return;\n            }\n        }\n\n        var comments = start.comments_before;\n        if (!comments) {\n            comments = start.comments_before = [];\n        }\n        printed_comments.add(comments);\n\n        if (keyword_with_value) {\n            var tw = new TreeWalker(function(node) {\n                var parent = tw.parent();\n                if (parent instanceof AST_Exit\n                    || parent instanceof AST_Await\n                    || parent instanceof AST_Yield\n                    || parent instanceof AST_Binary && parent.left === node\n                    || parent.TYPE == \"Call\" && parent.expression === node\n                    || parent instanceof AST_Conditional && parent.condition === node\n                    || parent instanceof AST_Dot && parent.expression === node\n                    || parent instanceof AST_Sequence && parent.expressions[0] === node\n                    || parent instanceof AST_Sub && parent.expression === node\n                    || parent instanceof AST_UnaryPostfix) {\n                    if (!node.start) return;\n                    var text = node.start.comments_before;\n                    if (text && !printed_comments.has(text)) {\n                        printed_comments.add(text);\n                        comments = comments.concat(text);\n                    }\n                } else {\n                    return true;\n                }\n            });\n            tw.push(node);\n            keyword_with_value.walk(tw);\n        }\n\n        if (current_pos == 0) {\n            if (comments.length > 0 && options.shebang && comments[0].type === \"comment5\"\n                && !printed_comments.has(comments[0])) {\n                print(\"#!\" + comments.shift().value + \"\\n\");\n                indent();\n            }\n            var preamble = options.preamble;\n            if (preamble) {\n                print(preamble.replace(/\\r\\n?|[\\n\\u2028\\u2029]|\\s*$/g, \"\\n\"));\n            }\n        }\n\n        comments = comments.filter(comment_filter, node).filter(c => !printed_comments.has(c));\n        if (comments.length == 0) return;\n        var last_nlb = OUTPUT.hasNLB();\n        comments.forEach(function(c, i) {\n            printed_comments.add(c);\n            if (!last_nlb) {\n                if (c.nlb) {\n                    print(\"\\n\");\n                    indent();\n                    last_nlb = true;\n                } else if (i > 0) {\n                    space();\n                }\n            }\n\n            if (/comment[134]/.test(c.type)) {\n                var value = filter_comment(c.value);\n                if (value) {\n                    print(\"//\" + value + \"\\n\");\n                    indent();\n                }\n                last_nlb = true;\n            } else if (c.type == \"comment2\") {\n                var value = filter_comment(c.value);\n                if (value) {\n                    print(\"/*\" + value + \"*/\");\n                }\n                last_nlb = false;\n            }\n        });\n        if (!last_nlb) {\n            if (start.nlb) {\n                print(\"\\n\");\n                indent();\n            } else {\n                space();\n            }\n        }\n    }\n\n    function append_comments(node, tail) {\n        var self = this;\n        var token = node.end;\n        if (!token) return;\n        var printed_comments = self.printed_comments;\n        var comments = token[tail ? \"comments_before\" : \"comments_after\"];\n        if (!comments || printed_comments.has(comments)) return;\n        if (!(node instanceof AST_Statement || comments.every((c) =>\n            !/comment[134]/.test(c.type)\n        ))) return;\n        printed_comments.add(comments);\n        var insert = OUTPUT.length();\n        comments.filter(comment_filter, node).forEach(function(c, i) {\n            if (printed_comments.has(c)) return;\n            printed_comments.add(c);\n            need_space = false;\n            if (need_newline_indented) {\n                print(\"\\n\");\n                indent();\n                need_newline_indented = false;\n            } else if (c.nlb && (i > 0 || !OUTPUT.hasNLB())) {\n                print(\"\\n\");\n                indent();\n            } else if (i > 0 || !tail) {\n                space();\n            }\n            if (/comment[134]/.test(c.type)) {\n                const value = filter_comment(c.value);\n                if (value) {\n                    print(\"//\" + value);\n                }\n                need_newline_indented = true;\n            } else if (c.type == \"comment2\") {\n                const value = filter_comment(c.value);\n                if (value) {\n                    print(\"/*\" + value + \"*/\");\n                }\n                need_space = true;\n            }\n        });\n        if (OUTPUT.length() > insert) newline_insert = insert;\n    }\n\n    /**\n     * When output.option(\"_destroy_ast\") is enabled, destroy the function.\n     * Call this after printing it.\n     */\n    const gc_scope =\n      options[\"_destroy_ast\"]\n        ? function gc_scope(scope) {\n            scope.body.length = 0;\n            scope.argnames.length = 0;\n        }\n        : noop;\n\n    var stack = [];\n    return {\n        get             : get,\n        toString        : get,\n        indent          : indent,\n        in_directive    : false,\n        use_asm         : null,\n        active_scope    : null,\n        indentation     : function() { return indentation; },\n        current_width   : function() { return current_col - indentation; },\n        should_break    : function() { return options.width && this.current_width() >= options.width; },\n        has_parens      : function() { return has_parens; },\n        newline         : newline,\n        print           : print,\n        star            : star,\n        space           : space,\n        comma           : comma,\n        colon           : colon,\n        last            : function() { return last; },\n        semicolon       : semicolon,\n        force_semicolon : force_semicolon,\n        to_utf8         : to_utf8,\n        print_name      : function(name) { print(make_name(name)); },\n        print_string    : function(str, quote, escape_directive) {\n            var encoded = encode_string(str, quote);\n            if (escape_directive === true && !encoded.includes(\"\\\\\")) {\n                // Insert semicolons to break directive prologue\n                if (!OUTPUT.expectDirective()) {\n                    force_semicolon();\n                }\n                force_semicolon();\n            }\n            print(encoded);\n        },\n        print_template_string_chars: function(str) {\n            var encoded = encode_string(str, \"`\").replace(/\\${/g, \"\\\\${\");\n            return print(encoded.substr(1, encoded.length - 2));\n        },\n        encode_string   : encode_string,\n        next_indent     : next_indent,\n        with_indent     : with_indent,\n        with_block      : with_block,\n        with_parens     : with_parens,\n        with_square     : with_square,\n        add_mapping     : add_mapping,\n        option          : function(opt) { return options[opt]; },\n        gc_scope,\n        printed_comments: printed_comments,\n        prepend_comments: readonly ? noop : prepend_comments,\n        append_comments : readonly || comment_filter === return_false ? noop : append_comments,\n        line            : function() { return current_line; },\n        col             : function() { return current_col; },\n        pos             : function() { return current_pos; },\n        push_node       : function(node) { stack.push(node); },\n        pop_node        : function() { return stack.pop(); },\n        parent          : function(n) {\n            return stack[stack.length - 2 - (n || 0)];\n        }\n    };\n\n}\n\n/* -----[ code generators ]----- */\n\n(function() {\n\n    /* -----[ utils ]----- */\n\n    function DEFPRINT(nodetype, generator) {\n        nodetype.DEFMETHOD(\"_codegen\", generator);\n    }\n\n    AST_Node.DEFMETHOD(\"print\", function(output, force_parens) {\n        var self = this, generator = self._codegen;\n        if (self instanceof AST_Scope) {\n            output.active_scope = self;\n        } else if (!output.use_asm && self instanceof AST_Directive && self.value == \"use asm\") {\n            output.use_asm = output.active_scope;\n        }\n        function doit() {\n            output.prepend_comments(self);\n            self.add_source_map(output);\n            generator(self, output);\n            output.append_comments(self);\n        }\n        output.push_node(self);\n        if (force_parens || self.needs_parens(output)) {\n            output.with_parens(doit);\n        } else {\n            doit();\n        }\n        output.pop_node();\n        if (self === output.use_asm) {\n            output.use_asm = null;\n        }\n    });\n    AST_Node.DEFMETHOD(\"_print\", AST_Node.prototype.print);\n\n    AST_Node.DEFMETHOD(\"print_to_string\", function(options) {\n        var output = OutputStream(options);\n        this.print(output);\n        return output.get();\n    });\n\n    /* -----[ PARENTHESES ]----- */\n\n    function PARENS(nodetype, func) {\n        if (Array.isArray(nodetype)) {\n            nodetype.forEach(function(nodetype) {\n                PARENS(nodetype, func);\n            });\n        } else {\n            nodetype.DEFMETHOD(\"needs_parens\", func);\n        }\n    }\n\n    PARENS(AST_Node, return_false);\n\n    // a function expression needs parens around it when it's provably\n    // the first token to appear in a statement.\n    PARENS(AST_Function, function(output) {\n        if (!output.has_parens() && first_in_statement(output)) {\n            return true;\n        }\n\n        if (output.option(\"webkit\")) {\n            var p = output.parent();\n            if (p instanceof AST_PropAccess && p.expression === this) {\n                return true;\n            }\n        }\n\n        if (output.option(\"wrap_iife\")) {\n            var p = output.parent();\n            if (p instanceof AST_Call && p.expression === this) {\n                return true;\n            }\n        }\n\n        if (output.option(\"wrap_func_args\")) {\n            var p = output.parent();\n            if (p instanceof AST_Call && p.args.includes(this)) {\n                return true;\n            }\n        }\n\n        return false;\n    });\n\n    PARENS(AST_Arrow, function(output) {\n        var p = output.parent();\n\n        if (\n            output.option(\"wrap_func_args\")\n            && p instanceof AST_Call\n            && p.args.includes(this)\n        ) {\n            return true;\n        }\n        return p instanceof AST_PropAccess && p.expression === this\n            || p instanceof AST_Conditional && p.condition === this;\n    });\n\n    // same goes for an object literal (as in AST_Function), because\n    // otherwise {...} would be interpreted as a block of code.\n    PARENS(AST_Object, function(output) {\n        return !output.has_parens() && first_in_statement(output);\n    });\n\n    PARENS(AST_ClassExpression, first_in_statement);\n\n    PARENS(AST_Unary, function(output) {\n        var p = output.parent();\n        return p instanceof AST_PropAccess && p.expression === this\n            || p instanceof AST_Call && p.expression === this\n            || p instanceof AST_Binary\n                && p.operator === \"**\"\n                && this instanceof AST_UnaryPrefix\n                && p.left === this\n                && this.operator !== \"++\"\n                && this.operator !== \"--\";\n    });\n\n    PARENS(AST_Await, function(output) {\n        var p = output.parent();\n        return p instanceof AST_PropAccess && p.expression === this\n            || p instanceof AST_Call && p.expression === this\n            || p instanceof AST_Binary && p.operator === \"**\" && p.left === this\n            || output.option(\"safari10\") && p instanceof AST_UnaryPrefix;\n    });\n\n    PARENS(AST_Sequence, function(output) {\n        var p = output.parent();\n        return p instanceof AST_Call                          // (foo, bar)() or foo(1, (2, 3), 4)\n            || p instanceof AST_Unary                         // !(foo, bar, baz)\n            || p instanceof AST_Binary                        // 1 + (2, 3) + 4 ==> 8\n            || p instanceof AST_VarDefLike                    // var a = (1, 2), b = a + a; ==> b == 4\n            || p instanceof AST_PropAccess                    // (1, {foo:2}).foo or (1, {foo:2})[\"foo\"] ==> 2\n            || p instanceof AST_Array                         // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]\n            || p instanceof AST_ObjectProperty                // { foo: (1, 2) }.foo ==> 2\n            || p instanceof AST_Conditional                   /* (false, true) ? (a = 10, b = 20) : (c = 30)\n                                                               * ==> 20 (side effect, set a := 10 and b := 20) */\n            || p instanceof AST_Arrow                         // x => (x, x)\n            || p instanceof AST_DefaultAssign                 // x => (x = (0, function(){}))\n            || p instanceof AST_Expansion                     // [...(a, b)]\n            || p instanceof AST_ForOf && this === p.object    // for (e of (foo, bar)) {}\n            || p instanceof AST_Yield                         // yield (foo, bar)\n            || p instanceof AST_Export                        // export default (foo, bar)\n        ;\n    });\n\n    PARENS(AST_Binary, function(output) {\n        var p = output.parent();\n        // (foo && bar)()\n        if (p instanceof AST_Call && p.expression === this)\n            return true;\n        // typeof (foo && bar)\n        if (p instanceof AST_Unary)\n            return true;\n        // (foo && bar)[\"prop\"], (foo && bar).prop\n        if (p instanceof AST_PropAccess && p.expression === this)\n            return true;\n        // this deals with precedence: 3 * (2 + 1)\n        if (p instanceof AST_Binary) {\n            const parent_op = p.operator;\n            const op = this.operator;\n\n            // It is forbidden for ?? to be used with || or && without parens.\n            if (op === \"??\" && (parent_op === \"||\" || parent_op === \"&&\")) {\n                return true;\n            }\n            if (parent_op === \"??\" && (op === \"||\" || op === \"&&\")) {\n                return true;\n            }\n\n            const pp = PRECEDENCE[parent_op];\n            const sp = PRECEDENCE[op];\n            if (pp > sp\n                || (pp == sp\n                    && (this === p.right || parent_op == \"**\"))) {\n                return true;\n            }\n        }\n        if (p instanceof AST_PrivateIn) {\n            const op = this.operator;\n\n            const pp = PRECEDENCE[\"in\"];\n            const sp = PRECEDENCE[op];\n            if (pp > sp || (pp == sp && this === p.value)) {\n                return true;\n            }\n        }\n    });\n\n    PARENS(AST_PrivateIn, function(output) {\n        var p = output.parent();\n        // (#x in this)()\n        if (p instanceof AST_Call && p.expression === this) {\n            return true;\n        }\n        // typeof (#x in this)\n        if (p instanceof AST_Unary) {\n            return true;\n        }\n        // (#x in this)[\"prop\"], (#x in this).prop\n        if (p instanceof AST_PropAccess && p.expression === this) {\n            return true;\n        }\n        // same precedence as regular in operator\n        if (p instanceof AST_Binary) {\n            const parent_op = p.operator;\n\n            const pp = PRECEDENCE[parent_op];\n            const sp = PRECEDENCE[\"in\"];\n            if (pp > sp\n                || (pp == sp\n                    && (this === p.right || parent_op == \"**\"))) {\n                return true;\n            }\n        }\n        // rules are the same as binary in, but the class differs\n        if (p instanceof AST_PrivateIn && this === p.value) {\n            return true;\n        }\n    });\n\n    PARENS(AST_Yield, function(output) {\n        var p = output.parent();\n        // (yield 1) + (yield 2)\n        // a = yield 3\n        if (p instanceof AST_Binary && p.operator !== \"=\")\n            return true;\n        // (yield 1)()\n        // new (yield 1)()\n        if (p instanceof AST_Call && p.expression === this)\n            return true;\n        // (yield 1) ? yield 2 : yield 3\n        if (p instanceof AST_Conditional && p.condition === this)\n            return true;\n        // -(yield 4)\n        if (p instanceof AST_Unary)\n            return true;\n        // (yield x).foo\n        // (yield x)['foo']\n        if (p instanceof AST_PropAccess && p.expression === this)\n            return true;\n    });\n\n    PARENS(AST_Chain, function(output) {\n        var p = output.parent();\n        if (!(p instanceof AST_Call || p instanceof AST_PropAccess)) return false;\n        return p.expression === this;\n    });\n\n    PARENS(AST_PropAccess, function(output) {\n        var p = output.parent();\n        if (p instanceof AST_New && p.expression === this) {\n            // i.e. new (foo.bar().baz)\n            //\n            // if there's one call into this subtree, then we need\n            // parens around it too, otherwise the call will be\n            // interpreted as passing the arguments to the upper New\n            // expression.\n            return walk(this, node => {\n                if (node instanceof AST_Scope) return true;\n                if (node instanceof AST_Call) {\n                    return walk_abort;  // makes walk() return true.\n                }\n            });\n        }\n    });\n\n    PARENS(AST_Call, function(output) {\n        var p = output.parent(), p1;\n        if (p instanceof AST_New && p.expression === this\n            || p instanceof AST_Export && p.is_default && this.expression instanceof AST_Function)\n            return true;\n\n        // workaround for Safari bug.\n        // https://bugs.webkit.org/show_bug.cgi?id=123506\n        return this.expression instanceof AST_Function\n            && p instanceof AST_PropAccess\n            && p.expression === this\n            && (p1 = output.parent(1)) instanceof AST_Assign\n            && p1.left === p;\n    });\n\n    PARENS(AST_New, function(output) {\n        var p = output.parent();\n        if (this.args.length === 0\n            && (p instanceof AST_PropAccess // (new Date).getTime(), (new Date)[\"getTime\"]()\n                || p instanceof AST_Call && p.expression === this\n                || p instanceof AST_PrefixedTemplateString && p.prefix === this)) // (new foo)(bar)\n            return true;\n    });\n\n    PARENS(AST_Number, function(output) {\n        var p = output.parent();\n        if (p instanceof AST_PropAccess && p.expression === this) {\n            var value = this.getValue();\n            if (value < 0 || /^0/.test(make_num(value))) {\n                return true;\n            }\n        }\n    });\n\n    PARENS(AST_BigInt, function(output) {\n        var p = output.parent();\n        if (p instanceof AST_PropAccess && p.expression === this) {\n            var value = this.getValue();\n            if (value.startsWith(\"-\")) {\n                return true;\n            }\n        }\n    });\n\n    PARENS([ AST_Assign, AST_Conditional ], function(output) {\n        var p = output.parent();\n        // !(a = false)  true\n        if (p instanceof AST_Unary)\n            return true;\n        // 1 + (a = 2) + 3  6, side effect setting a = 2\n        if (p instanceof AST_Binary && !(p instanceof AST_Assign))\n            return true;\n        // (a = func)() or new (a = Object)()\n        if (p instanceof AST_Call && p.expression === this)\n            return true;\n        // (a = foo) ? bar : baz\n        if (p instanceof AST_Conditional && p.condition === this)\n            return true;\n        // (a = foo)[\"prop\"] or (a = foo).prop\n        if (p instanceof AST_PropAccess && p.expression === this)\n            return true;\n        // ({a, b} = {a: 1, b: 2}), a destructuring assignment\n        if (this instanceof AST_Assign && this.left instanceof AST_Destructuring && this.left.is_array === false)\n            return true;\n    });\n\n    /* -----[ PRINTERS ]----- */\n\n    DEFPRINT(AST_Directive, function(self, output) {\n        output.print_string(self.value, self.quote);\n        output.semicolon();\n    });\n\n    DEFPRINT(AST_Expansion, function (self, output) {\n        output.print(\"...\");\n        self.expression.print(output);\n    });\n\n    DEFPRINT(AST_Destructuring, function (self, output) {\n        output.print(self.is_array ? \"[\" : \"{\");\n        var len = self.names.length;\n        self.names.forEach(function (name, i) {\n            if (i > 0) output.comma();\n            name.print(output);\n            // If the final element is a hole, we need to make sure it\n            // doesn't look like a trailing comma, by inserting an actual\n            // trailing comma.\n            if (i == len - 1 && name instanceof AST_Hole) output.comma();\n        });\n        output.print(self.is_array ? \"]\" : \"}\");\n    });\n\n    DEFPRINT(AST_Debugger, function(self, output) {\n        output.print(\"debugger\");\n        output.semicolon();\n    });\n\n    /* -----[ statements ]----- */\n\n    function display_body(body, is_toplevel, output, allow_directives) {\n        var last = body.length - 1;\n        output.in_directive = allow_directives;\n        body.forEach(function(stmt, i) {\n            if (output.in_directive === true && !(stmt instanceof AST_Directive ||\n                stmt instanceof AST_EmptyStatement ||\n                (stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String)\n            )) {\n                output.in_directive = false;\n            }\n            if (!(stmt instanceof AST_EmptyStatement)) {\n                output.indent();\n                stmt.print(output);\n                if (!(i == last && is_toplevel)) {\n                    output.newline();\n                    if (is_toplevel) output.newline();\n                }\n            }\n            if (output.in_directive === true &&\n                stmt instanceof AST_SimpleStatement &&\n                stmt.body instanceof AST_String\n            ) {\n                output.in_directive = false;\n            }\n        });\n        output.in_directive = false;\n    }\n\n    AST_StatementWithBody.DEFMETHOD(\"_do_print_body\", function(output) {\n        print_maybe_braced_body(this.body, output);\n    });\n\n    DEFPRINT(AST_Statement, function(self, output) {\n        self.body.print(output);\n        output.semicolon();\n    });\n    DEFPRINT(AST_Toplevel, function(self, output) {\n        display_body(self.body, true, output, true);\n        output.print(\"\");\n    });\n    DEFPRINT(AST_LabeledStatement, function(self, output) {\n        self.label.print(output);\n        output.colon();\n        self.body.print(output);\n    });\n    DEFPRINT(AST_SimpleStatement, function(self, output) {\n        self.body.print(output);\n        output.semicolon();\n    });\n    function print_braced_empty(self, output) {\n        output.print(\"{\");\n        output.with_indent(output.next_indent(), function() {\n            output.append_comments(self, true);\n        });\n        output.add_mapping(self.end);\n        output.print(\"}\");\n    }\n    function print_braced(self, output, allow_directives) {\n        if (self.body.length > 0) {\n            output.with_block(function() {\n                display_body(self.body, false, output, allow_directives);\n                output.add_mapping(self.end);\n            });\n        } else print_braced_empty(self, output);\n    }\n    DEFPRINT(AST_BlockStatement, function(self, output) {\n        print_braced(self, output);\n    });\n    DEFPRINT(AST_EmptyStatement, function(self, output) {\n        output.semicolon();\n    });\n    DEFPRINT(AST_Do, function(self, output) {\n        output.print(\"do\");\n        output.space();\n        make_block(self.body, output);\n        output.space();\n        output.print(\"while\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        output.semicolon();\n    });\n    DEFPRINT(AST_While, function(self, output) {\n        output.print(\"while\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        output.space();\n        self._do_print_body(output);\n    });\n    DEFPRINT(AST_For, function(self, output) {\n        output.print(\"for\");\n        output.space();\n        output.with_parens(function() {\n            if (self.init) {\n                if (self.init instanceof AST_DefinitionsLike) {\n                    self.init.print(output);\n                } else {\n                    parenthesize_for_noin(self.init, output, true);\n                }\n                output.print(\";\");\n                output.space();\n            } else {\n                output.print(\";\");\n            }\n            if (self.condition) {\n                self.condition.print(output);\n                output.print(\";\");\n                output.space();\n            } else {\n                output.print(\";\");\n            }\n            if (self.step) {\n                self.step.print(output);\n            }\n        });\n        output.space();\n        self._do_print_body(output);\n    });\n    DEFPRINT(AST_ForIn, function(self, output) {\n        output.print(\"for\");\n        if (self.await) {\n            output.space();\n            output.print(\"await\");\n        }\n        output.space();\n        output.with_parens(function() {\n            self.init.print(output);\n            output.space();\n            output.print(self instanceof AST_ForOf ? \"of\" : \"in\");\n            output.space();\n            self.object.print(output);\n        });\n        output.space();\n        self._do_print_body(output);\n    });\n    DEFPRINT(AST_With, function(self, output) {\n        output.print(\"with\");\n        output.space();\n        output.with_parens(function() {\n            self.expression.print(output);\n        });\n        output.space();\n        self._do_print_body(output);\n    });\n\n    /* -----[ functions ]----- */\n    AST_Lambda.DEFMETHOD(\"_do_print\", function(output, nokeyword) {\n        var self = this;\n        if (!nokeyword) {\n            if (self.async) {\n                output.print(\"async\");\n                output.space();\n            }\n            output.print(\"function\");\n            if (self.is_generator) {\n                output.star();\n            }\n            if (self.name) {\n                output.space();\n            }\n        }\n        if (self.name instanceof AST_Symbol) {\n            self.name.print(output);\n        } else if (nokeyword && self.name instanceof AST_Node) {\n            output.with_square(function() {\n                self.name.print(output); // Computed method name\n            });\n        }\n        output.with_parens(function() {\n            self.argnames.forEach(function(arg, i) {\n                if (i) output.comma();\n                arg.print(output);\n            });\n        });\n        output.space();\n        print_braced(self, output, true);\n    });\n    DEFPRINT(AST_Lambda, function(self, output) {\n        self._do_print(output);\n        output.gc_scope(self);\n    });\n\n    DEFPRINT(AST_PrefixedTemplateString, function(self, output) {\n        var tag = self.prefix;\n        var parenthesize_tag = tag instanceof AST_Lambda\n            || tag instanceof AST_Binary\n            || tag instanceof AST_Conditional\n            || tag instanceof AST_Sequence\n            || tag instanceof AST_Unary\n            || tag instanceof AST_Dot && tag.expression instanceof AST_Object;\n        if (parenthesize_tag) output.print(\"(\");\n        self.prefix.print(output);\n        if (parenthesize_tag) output.print(\")\");\n        self.template_string.print(output);\n    });\n    DEFPRINT(AST_TemplateString, function(self, output) {\n        var is_tagged = output.parent() instanceof AST_PrefixedTemplateString;\n\n        output.print(\"`\");\n        for (var i = 0; i < self.segments.length; i++) {\n            if (!(self.segments[i] instanceof AST_TemplateSegment)) {\n                output.print(\"${\");\n                self.segments[i].print(output);\n                output.print(\"}\");\n            } else if (is_tagged) {\n                output.print(self.segments[i].raw);\n            } else {\n                output.print_template_string_chars(self.segments[i].value);\n            }\n        }\n        output.print(\"`\");\n    });\n    DEFPRINT(AST_TemplateSegment, function(self, output) {\n        output.print_template_string_chars(self.value);\n    });\n\n    AST_Arrow.DEFMETHOD(\"_do_print\", function(output) {\n        var self = this;\n        var parent = output.parent();\n        var needs_parens = (parent instanceof AST_Binary &&\n                !(parent instanceof AST_Assign) &&\n                !(parent instanceof AST_DefaultAssign)) ||\n            parent instanceof AST_Unary ||\n            (parent instanceof AST_Call && self === parent.expression);\n        if (needs_parens) { output.print(\"(\"); }\n        if (self.async) {\n            output.print(\"async\");\n            output.space();\n        }\n        if (self.argnames.length === 1 && self.argnames[0] instanceof AST_Symbol) {\n            self.argnames[0].print(output);\n        } else {\n            output.with_parens(function() {\n                self.argnames.forEach(function(arg, i) {\n                    if (i) output.comma();\n                    arg.print(output);\n                });\n            });\n        }\n        output.space();\n        output.print(\"=>\");\n        output.space();\n        const first_statement = self.body[0];\n        if (\n            self.body.length === 1\n            && first_statement instanceof AST_Return\n        ) {\n            const returned = first_statement.value;\n            if (!returned) {\n                output.print(\"{}\");\n            } else if (left_is_object(returned)) {\n                output.print(\"(\");\n                returned.print(output);\n                output.print(\")\");\n            } else {\n                returned.print(output);\n            }\n        } else {\n            print_braced(self, output);\n        }\n        if (needs_parens) { output.print(\")\"); }\n        output.gc_scope(self);\n    });\n\n    /* -----[ exits ]----- */\n    AST_Exit.DEFMETHOD(\"_do_print\", function(output, kind) {\n        output.print(kind);\n        if (this.value) {\n            output.space();\n            const comments = this.value.start.comments_before;\n            if (comments && comments.length && !output.printed_comments.has(comments)) {\n                output.print(\"(\");\n                this.value.print(output);\n                output.print(\")\");\n            } else {\n                this.value.print(output);\n            }\n        }\n        output.semicolon();\n    });\n    DEFPRINT(AST_Return, function(self, output) {\n        self._do_print(output, \"return\");\n    });\n    DEFPRINT(AST_Throw, function(self, output) {\n        self._do_print(output, \"throw\");\n    });\n\n    /* -----[ yield ]----- */\n\n    DEFPRINT(AST_Yield, function(self, output) {\n        var star = self.is_star ? \"*\" : \"\";\n        output.print(\"yield\" + star);\n        if (self.expression) {\n            output.space();\n            self.expression.print(output);\n        }\n    });\n\n    DEFPRINT(AST_Await, function(self, output) {\n        output.print(\"await\");\n        output.space();\n        var e = self.expression;\n        var parens = !(\n               e instanceof AST_Call\n            || e instanceof AST_SymbolRef\n            || e instanceof AST_PropAccess\n            || e instanceof AST_Unary\n            || e instanceof AST_Constant\n            || e instanceof AST_Await\n            || e instanceof AST_Object\n        );\n        if (parens) output.print(\"(\");\n        self.expression.print(output);\n        if (parens) output.print(\")\");\n    });\n\n    /* -----[ loop control ]----- */\n    AST_LoopControl.DEFMETHOD(\"_do_print\", function(output, kind) {\n        output.print(kind);\n        if (this.label) {\n            output.space();\n            this.label.print(output);\n        }\n        output.semicolon();\n    });\n    DEFPRINT(AST_Break, function(self, output) {\n        self._do_print(output, \"break\");\n    });\n    DEFPRINT(AST_Continue, function(self, output) {\n        self._do_print(output, \"continue\");\n    });\n\n    /* -----[ if ]----- */\n    function make_then(self, output) {\n        var b = self.body;\n        if (output.option(\"braces\")\n            || output.option(\"ie8\") && b instanceof AST_Do)\n            return make_block(b, output);\n        // The squeezer replaces \"block\"-s that contain only a single\n        // statement with the statement itself; technically, the AST\n        // is correct, but this can create problems when we output an\n        // IF having an ELSE clause where the THEN clause ends in an\n        // IF *without* an ELSE block (then the outer ELSE would refer\n        // to the inner IF).  This function checks for this case and\n        // adds the block braces if needed.\n        if (!b) return output.force_semicolon();\n        while (true) {\n            if (b instanceof AST_If) {\n                if (!b.alternative) {\n                    make_block(self.body, output);\n                    return;\n                }\n                b = b.alternative;\n            } else if (b instanceof AST_StatementWithBody) {\n                b = b.body;\n            } else break;\n        }\n        print_maybe_braced_body(self.body, output);\n    }\n    DEFPRINT(AST_If, function(self, output) {\n        output.print(\"if\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        output.space();\n        if (self.alternative) {\n            make_then(self, output);\n            output.space();\n            output.print(\"else\");\n            output.space();\n            if (self.alternative instanceof AST_If)\n                self.alternative.print(output);\n            else\n                print_maybe_braced_body(self.alternative, output);\n        } else {\n            self._do_print_body(output);\n        }\n    });\n\n    /* -----[ switch ]----- */\n    DEFPRINT(AST_Switch, function(self, output) {\n        output.print(\"switch\");\n        output.space();\n        output.with_parens(function() {\n            self.expression.print(output);\n        });\n        output.space();\n        var last = self.body.length - 1;\n        if (last < 0) print_braced_empty(self, output);\n        else output.with_block(function() {\n            self.body.forEach(function(branch, i) {\n                output.indent(true);\n                branch.print(output);\n                if (i < last && branch.body.length > 0)\n                    output.newline();\n            });\n        });\n    });\n    AST_SwitchBranch.DEFMETHOD(\"_do_print_body\", function(output) {\n        output.newline();\n        this.body.forEach(function(stmt) {\n            output.indent();\n            stmt.print(output);\n            output.newline();\n        });\n    });\n    DEFPRINT(AST_Default, function(self, output) {\n        output.print(\"default:\");\n        self._do_print_body(output);\n    });\n    DEFPRINT(AST_Case, function(self, output) {\n        output.print(\"case\");\n        output.space();\n        self.expression.print(output);\n        output.print(\":\");\n        self._do_print_body(output);\n    });\n\n    /* -----[ exceptions ]----- */\n    DEFPRINT(AST_Try, function(self, output) {\n        output.print(\"try\");\n        output.space();\n        self.body.print(output);\n        if (self.bcatch) {\n            output.space();\n            self.bcatch.print(output);\n        }\n        if (self.bfinally) {\n            output.space();\n            self.bfinally.print(output);\n        }\n    });\n    DEFPRINT(AST_TryBlock, function(self, output) {\n        print_braced(self, output);\n    });\n    DEFPRINT(AST_Catch, function(self, output) {\n        output.print(\"catch\");\n        if (self.argname) {\n            output.space();\n            output.with_parens(function() {\n                self.argname.print(output);\n            });\n        }\n        output.space();\n        print_braced(self, output);\n    });\n    DEFPRINT(AST_Finally, function(self, output) {\n        output.print(\"finally\");\n        output.space();\n        print_braced(self, output);\n    });\n\n    /* -----[ var/const ]----- */\n    AST_DefinitionsLike.DEFMETHOD(\"_do_print\", function(output, kind) {\n        output.print(kind);\n        output.space();\n        this.definitions.forEach(function(def, i) {\n            if (i) output.comma();\n            def.print(output);\n        });\n        var p = output.parent();\n        var in_for = p instanceof AST_For || p instanceof AST_ForIn;\n        var output_semicolon = !in_for || p && p.init !== this;\n        if (output_semicolon)\n            output.semicolon();\n    });\n    DEFPRINT(AST_Let, function(self, output) {\n        self._do_print(output, \"let\");\n    });\n    DEFPRINT(AST_Var, function(self, output) {\n        self._do_print(output, \"var\");\n    });\n    DEFPRINT(AST_Const, function(self, output) {\n        self._do_print(output, \"const\");\n    });\n    DEFPRINT(AST_Using, function(self, output) {\n        self._do_print(output, self.await ? \"await using\" : \"using\");\n    });\n    DEFPRINT(AST_Import, function(self, output) {\n        output.print(\"import\");\n        output.space();\n        if (self.imported_name) {\n            self.imported_name.print(output);\n        }\n        if (self.imported_name && self.imported_names) {\n            output.print(\",\");\n            output.space();\n        }\n        if (self.imported_names) {\n            if (self.imported_names.length === 1 &&\n                self.imported_names[0].foreign_name.name === \"*\" &&\n                !self.imported_names[0].foreign_name.quote) {\n                self.imported_names[0].print(output);\n            } else {\n                output.print(\"{\");\n                self.imported_names.forEach(function (name_import, i) {\n                    output.space();\n                    name_import.print(output);\n                    if (i < self.imported_names.length - 1) {\n                        output.print(\",\");\n                    }\n                });\n                output.space();\n                output.print(\"}\");\n            }\n        }\n        if (self.imported_name || self.imported_names) {\n            output.space();\n            output.print(\"from\");\n            output.space();\n        }\n        self.module_name.print(output);\n        if (self.attributes) {\n            output.print(\"with\");\n            self.attributes.print(output);\n        }\n        output.semicolon();\n    });\n    DEFPRINT(AST_ImportMeta, function(self, output) {\n        output.print(\"import.meta\");\n    });\n\n    DEFPRINT(AST_NameMapping, function(self, output) {\n        var is_import = output.parent() instanceof AST_Import;\n        var definition = self.name.definition();\n        var foreign_name = self.foreign_name;\n        var names_are_different =\n            (definition && definition.mangled_name || self.name.name) !==\n            foreign_name.name;\n        if (!names_are_different &&\n            foreign_name.name === \"*\" &&\n            !!foreign_name.quote != !!self.name.quote) {\n                // export * as \"*\"\n            names_are_different = true;\n        }\n        var foreign_name_is_name = !foreign_name.quote;\n        if (names_are_different) {\n            if (is_import) {\n                if (foreign_name_is_name) {\n                    output.print(foreign_name.name);\n                } else {\n                    output.print_string(foreign_name.name, foreign_name.quote);\n                }\n            } else {\n                if (!self.name.quote) {\n                    self.name.print(output);\n                } else {\n                    output.print_string(self.name.name, self.name.quote);\n                }\n                \n            }\n            output.space();\n            output.print(\"as\");\n            output.space();\n            if (is_import) {\n                self.name.print(output);\n            } else {\n                if (foreign_name_is_name) {\n                    output.print(foreign_name.name);\n                } else {\n                    output.print_string(foreign_name.name, foreign_name.quote);\n                }\n            }\n        } else {\n            if (!self.name.quote) {\n                self.name.print(output);\n            } else {\n                output.print_string(self.name.name, self.name.quote);\n            }\n        }\n    });\n\n    DEFPRINT(AST_Export, function(self, output) {\n        output.print(\"export\");\n        output.space();\n        if (self.is_default) {\n            output.print(\"default\");\n            output.space();\n        }\n        if (self.exported_names) {\n            if (self.exported_names.length === 1 &&\n                self.exported_names[0].name.name === \"*\" &&\n                !self.exported_names[0].name.quote) {\n                    self.exported_names[0].print(output);\n            } else {\n                output.print(\"{\");\n                self.exported_names.forEach(function(name_export, i) {\n                    output.space();\n                    name_export.print(output);\n                    if (i < self.exported_names.length - 1) {\n                        output.print(\",\");\n                    }\n                });\n                output.space();\n                output.print(\"}\");\n            }\n        } else if (self.exported_value) {\n            self.exported_value.print(output);\n        } else if (self.exported_definition) {\n            self.exported_definition.print(output);\n            if (self.exported_definition instanceof AST_Definitions) return;\n        }\n        if (self.module_name) {\n            output.space();\n            output.print(\"from\");\n            output.space();\n            self.module_name.print(output);\n        }\n        if (self.attributes) {\n            output.print(\"with\");\n            self.attributes.print(output);\n        }\n        if (self.exported_value\n                && !(self.exported_value instanceof AST_Defun ||\n                    self.exported_value instanceof AST_Function ||\n                    self.exported_value instanceof AST_Class)\n            || self.module_name\n            || self.exported_names\n        ) {\n            output.semicolon();\n        }\n    });\n\n    function parenthesize_for_noin(node, output, noin) {\n        var parens = false;\n        // need to take some precautions here:\n        //    https://github.com/mishoo/UglifyJS2/issues/60\n        if (noin) {\n            parens = walk(node, node => {\n                // Don't go into scopes -- except arrow functions:\n                // https://github.com/terser/terser/issues/1019#issuecomment-877642607\n                if (node instanceof AST_Scope && !(node instanceof AST_Arrow)) {\n                    return true;\n                }\n                if (\n                    node instanceof AST_Binary && node.operator == \"in\"\n                    || node instanceof AST_PrivateIn\n                ) {\n                    return walk_abort;  // makes walk() return true\n                }\n            });\n        }\n        node.print(output, parens);\n    }\n\n    DEFPRINT(AST_VarDefLike, function(self, output) {\n        self.name.print(output);\n        if (self.value) {\n            output.space();\n            output.print(\"=\");\n            output.space();\n            var p = output.parent(1);\n            var noin = p instanceof AST_For || p instanceof AST_ForIn;\n            parenthesize_for_noin(self.value, output, noin);\n        }\n    });\n\n    /* -----[ other expressions ]----- */\n    DEFPRINT(AST_Call, function(self, output) {\n        self.expression.print(output);\n        if (self instanceof AST_New && self.args.length === 0)\n            return;\n        if (self.expression instanceof AST_Call || self.expression instanceof AST_Lambda) {\n            output.add_mapping(self.start);\n        }\n        if (self.optional) output.print(\"?.\");\n        output.with_parens(function() {\n            self.args.forEach(function(expr, i) {\n                if (i) output.comma();\n                expr.print(output);\n            });\n        });\n    });\n    DEFPRINT(AST_New, function(self, output) {\n        output.print(\"new\");\n        output.space();\n        AST_Call.prototype._codegen(self, output);\n    });\n\n    AST_Sequence.DEFMETHOD(\"_do_print\", function(output) {\n        this.expressions.forEach(function(node, index) {\n            if (index > 0) {\n                output.comma();\n                if (output.should_break()) {\n                    output.newline();\n                    output.indent();\n                }\n            }\n            node.print(output);\n        });\n    });\n    DEFPRINT(AST_Sequence, function(self, output) {\n        self._do_print(output);\n        // var p = output.parent();\n        // if (p instanceof AST_Statement) {\n        //     output.with_indent(output.next_indent(), function(){\n        //         self._do_print(output);\n        //     });\n        // } else {\n        //     self._do_print(output);\n        // }\n    });\n    DEFPRINT(AST_Dot, function(self, output) {\n        var expr = self.expression;\n        expr.print(output);\n        var prop = self.property;\n        var print_computed = ALL_RESERVED_WORDS.has(prop)\n            ? output.option(\"ie8\")\n            : !is_identifier_string(\n                prop,\n                output.option(\"ecma\") >= 2015 && !output.option(\"safari10\")\n            );\n\n        if (self.optional) output.print(\"?.\");\n\n        if (print_computed) {\n            output.print(\"[\");\n            output.add_mapping(self.end);\n            output.print_string(prop);\n            output.print(\"]\");\n        } else {\n            if (expr instanceof AST_Number && expr.getValue() >= 0) {\n                if (!/[xa-f.)]/i.test(output.last())) {\n                    output.print(\".\");\n                }\n            }\n            if (!self.optional) output.print(\".\");\n            // the name after dot would be mapped about here.\n            output.add_mapping(self.end);\n            output.print_name(prop);\n        }\n    });\n    DEFPRINT(AST_DotHash, function(self, output) {\n        var expr = self.expression;\n        expr.print(output);\n        var prop = self.property;\n\n        if (self.optional) output.print(\"?\");\n        output.print(\".#\");\n        output.add_mapping(self.end);\n        output.print_name(prop);\n    });\n    DEFPRINT(AST_Sub, function(self, output) {\n        self.expression.print(output);\n        if (self.optional) output.print(\"?.\");\n        output.print(\"[\");\n        self.property.print(output);\n        output.print(\"]\");\n    });\n    DEFPRINT(AST_Chain, function(self, output) {\n        self.expression.print(output);\n    });\n    DEFPRINT(AST_UnaryPrefix, function(self, output) {\n        var op = self.operator;\n        if (op === \"--\" && output.last().endsWith(\"!\")) {\n            // avoid printing \"<!--\"\n            output.print(\" \");\n        }\n        output.print(op);\n        if (/^[a-z]/i.test(op)\n            || (/[+-]$/.test(op)\n                && self.expression instanceof AST_UnaryPrefix\n                && /^[+-]/.test(self.expression.operator))) {\n            output.space();\n        }\n        self.expression.print(output);\n    });\n    DEFPRINT(AST_UnaryPostfix, function(self, output) {\n        self.expression.print(output);\n        output.print(self.operator);\n    });\n    DEFPRINT(AST_Binary, function(self, output) {\n        var op = self.operator;\n        self.left.print(output);\n        if (op[0] == \">\" /* \">>\" \">>>\" \">\" \">=\" */\n            && output.last().endsWith(\"--\")) {\n            // space is mandatory to avoid outputting -->\n            output.print(\" \");\n        } else {\n            // the space is optional depending on \"beautify\"\n            output.space();\n        }\n        output.print(op);\n        output.space();\n        self.right.print(output);\n    });\n    DEFPRINT(AST_Conditional, function(self, output) {\n        self.condition.print(output);\n        output.space();\n        output.print(\"?\");\n        output.space();\n        self.consequent.print(output);\n        output.space();\n        output.colon();\n        self.alternative.print(output);\n    });\n\n    /* -----[ literals ]----- */\n    DEFPRINT(AST_Array, function(self, output) {\n        output.with_square(function() {\n            var a = self.elements, len = a.length;\n            if (len > 0) output.space();\n            a.forEach(function(exp, i) {\n                if (i) output.comma();\n                exp.print(output);\n                // If the final element is a hole, we need to make sure it\n                // doesn't look like a trailing comma, by inserting an actual\n                // trailing comma.\n                if (i === len - 1 && exp instanceof AST_Hole)\n                  output.comma();\n            });\n            if (len > 0) output.space();\n        });\n    });\n    DEFPRINT(AST_Object, function(self, output) {\n        if (self.properties.length > 0) output.with_block(function() {\n            self.properties.forEach(function(prop, i) {\n                if (i) {\n                    output.print(\",\");\n                    output.newline();\n                }\n                output.indent();\n                prop.print(output);\n            });\n            output.newline();\n        });\n        else print_braced_empty(self, output);\n    });\n    DEFPRINT(AST_Class, function(self, output) {\n        output.print(\"class\");\n        output.space();\n        if (self.name) {\n            self.name.print(output);\n            output.space();\n        }\n        if (self.extends) {\n            var parens = (\n                   !(self.extends instanceof AST_SymbolRef)\n                && !(self.extends instanceof AST_PropAccess)\n                && !(self.extends instanceof AST_ClassExpression)\n                && !(self.extends instanceof AST_Function)\n            );\n            output.print(\"extends\");\n            if (parens) {\n                output.print(\"(\");\n            } else {\n                output.space();\n            }\n            self.extends.print(output);\n            if (parens) {\n                output.print(\")\");\n            } else {\n                output.space();\n            }\n        }\n        if (self.properties.length > 0) output.with_block(function() {\n            self.properties.forEach(function(prop, i) {\n                if (i) {\n                    output.newline();\n                }\n                output.indent();\n                prop.print(output);\n            });\n            output.newline();\n        });\n        else output.print(\"{}\");\n    });\n    DEFPRINT(AST_NewTarget, function(self, output) {\n        output.print(\"new.target\");\n    });\n\n    /** Prints a prop name. Returns whether it can be used as a shorthand. */\n    function print_property_name(key, quote, output) {\n        if (output.option(\"quote_keys\")) {\n            output.print_string(key);\n            return false;\n        }\n        if (\"\" + +key == key && key >= 0) {\n            if (output.option(\"keep_numbers\")) {\n                output.print(key);\n                return false;\n            }\n            output.print(make_num(key));\n            return false;\n        }\n        var print_string = ALL_RESERVED_WORDS.has(key)\n            ? output.option(\"ie8\")\n            : (\n                output.option(\"ecma\") < 2015 || output.option(\"safari10\")\n                    ? !is_basic_identifier_string(key)\n                    : !is_identifier_string(key, true)\n            );\n        if (print_string || (quote && output.option(\"keep_quoted_props\"))) {\n            output.print_string(key, quote);\n            return false;\n        }\n        output.print_name(key);\n        return true;\n    }\n\n    DEFPRINT(AST_ObjectKeyVal, function(self, output) {\n        function get_name(self) {\n            var def = self.definition();\n            return def ? def.mangled_name || def.name : self.name;\n        }\n\n        const try_shorthand = output.option(\"shorthand\") && !(self.key instanceof AST_Node);\n        if (\n            try_shorthand\n            && self.value instanceof AST_Symbol\n            && get_name(self.value) === self.key\n            && !ALL_RESERVED_WORDS.has(self.key)\n        ) {\n            const was_shorthand = print_property_name(self.key, self.quote, output);\n            if (!was_shorthand) {\n                output.colon();\n                self.value.print(output);\n            }\n        } else if (\n            try_shorthand\n            && self.value instanceof AST_DefaultAssign\n            && self.value.left instanceof AST_Symbol\n            && get_name(self.value.left) === self.key\n        ) {\n            const was_shorthand = print_property_name(self.key, self.quote, output);\n            if (!was_shorthand) {\n                output.colon();\n                self.value.left.print(output);\n            }\n            output.space();\n            output.print(\"=\");\n            output.space();\n            self.value.right.print(output);\n        } else {\n            if (!(self.key instanceof AST_Node)) {\n                print_property_name(self.key, self.quote, output);\n            } else {\n                output.with_square(function() {\n                    self.key.print(output);\n                });\n            }\n            output.colon();\n            self.value.print(output);\n        }\n    });\n    DEFPRINT(AST_ClassPrivateProperty, (self, output) => {\n        if (self.static) {\n            output.print(\"static\");\n            output.space();\n        }\n\n        output.print(\"#\");\n        \n        print_property_name(self.key.name, undefined, output);\n\n        if (self.value) {\n            output.print(\"=\");\n            self.value.print(output);\n        }\n\n        output.semicolon();\n    });\n    DEFPRINT(AST_ClassProperty, (self, output) => {\n        if (self.static) {\n            output.print(\"static\");\n            output.space();\n        }\n\n        if (self.key instanceof AST_SymbolClassProperty) {\n            print_property_name(self.key.name, self.quote, output);\n        } else {\n            output.print(\"[\");\n            self.key.print(output);\n            output.print(\"]\");\n        }\n\n        if (self.value) {\n            output.print(\"=\");\n            self.value.print(output);\n        }\n\n        output.semicolon();\n    });\n    AST_ObjectProperty.DEFMETHOD(\"_print_getter_setter\", function(type, is_private, output) {\n        var self = this;\n        if (self.static) {\n            output.print(\"static\");\n            output.space();\n        }\n        if (type) {\n            output.print(type);\n            output.space();\n        }\n        if (self.key instanceof AST_SymbolMethod) {\n            if (is_private) output.print(\"#\");\n            print_property_name(self.key.name, self.quote, output);\n            self.key.add_source_map(output);\n        } else {\n            output.with_square(function() {\n                self.key.print(output);\n            });\n        }\n        self.value._do_print(output, true);\n    });\n    DEFPRINT(AST_ObjectSetter, function(self, output) {\n        self._print_getter_setter(\"set\", false, output);\n    });\n    DEFPRINT(AST_ObjectGetter, function(self, output) {\n        self._print_getter_setter(\"get\", false, output);\n    });\n    DEFPRINT(AST_PrivateSetter, function(self, output) {\n        self._print_getter_setter(\"set\", true, output);\n    });\n    DEFPRINT(AST_PrivateGetter, function(self, output) {\n        self._print_getter_setter(\"get\", true, output);\n    });\n    DEFPRINT(AST_ConciseMethod, function(self, output) {\n        var type;\n        if (self.value.is_generator && self.value.async) {\n            type = \"async*\";\n        } else if (self.value.is_generator) {\n            type = \"*\";\n        } else if (self.value.async) {\n            type = \"async\";\n        }\n        self._print_getter_setter(type, false, output);\n    });\n    DEFPRINT(AST_PrivateMethod, function(self, output) {\n        var type;\n        if (self.value.is_generator && self.value.async) {\n            type = \"async*\";\n        } else if (self.value.is_generator) {\n            type = \"*\";\n        } else if (self.value.async) {\n            type = \"async\";\n        }\n        self._print_getter_setter(type, true, output);\n    });\n    DEFPRINT(AST_PrivateIn, function(self, output) {\n        self.key.print(output);\n        output.space();\n        output.print(\"in\");\n        output.space();\n        self.value.print(output);\n    });\n    DEFPRINT(AST_SymbolPrivateProperty, function(self, output) {\n        output.print(\"#\" + self.name);\n    });\n    DEFPRINT(AST_ClassStaticBlock, function (self, output) {\n        output.print(\"static\");\n        output.space();\n        print_braced(self, output);\n    });\n    AST_Symbol.DEFMETHOD(\"_do_print\", function(output) {\n        var def = this.definition();\n        output.print_name(def ? def.mangled_name || def.name : this.name);\n    });\n    DEFPRINT(AST_Symbol, function (self, output) {\n        self._do_print(output);\n    });\n    DEFPRINT(AST_Hole, noop);\n    DEFPRINT(AST_This, function(self, output) {\n        output.print(\"this\");\n    });\n    DEFPRINT(AST_Super, function(self, output) {\n        output.print(\"super\");\n    });\n    DEFPRINT(AST_Constant, function(self, output) {\n        output.print(self.getValue());\n    });\n    DEFPRINT(AST_String, function(self, output) {\n        output.print_string(self.getValue(), self.quote, output.in_directive);\n    });\n    DEFPRINT(AST_Number, function(self, output) {\n        if ((output.option(\"keep_numbers\") || output.use_asm) && self.raw) {\n            output.print(self.raw);\n        } else {\n            output.print(make_num(self.getValue()));\n        }\n    });\n    DEFPRINT(AST_BigInt, function(self, output) {\n        if (output.option(\"keep_numbers\") && self.raw) {\n            output.print(self.raw);\n        } else {\n            output.print(self.getValue() + \"n\");\n        }\n    });\n\n    const r_slash_script = /(<\\s*\\/\\s*script)/i;\n    const r_starts_with_script = /^\\s*script/i;\n    const slash_script_replace = (_, $1) => $1.replace(\"/\", \"\\\\/\");\n    DEFPRINT(AST_RegExp, function(self, output) {\n        let { source, flags } = self.getValue();\n        source = regexp_source_fix(source);\n        flags = flags ? sort_regexp_flags(flags) : \"\";\n\n        // Avoid outputting end of script tag\n        source = source.replace(r_slash_script, slash_script_replace);\n        if (r_starts_with_script.test(source) && output.last().endsWith(\"<\")) {\n            output.print(\" \");\n        }\n\n        output.print(output.to_utf8(`/${source}/${flags}`, false, true));\n\n        const parent = output.parent();\n        if (\n            parent instanceof AST_Binary\n            && /^\\w/.test(parent.operator)\n            && parent.left === self\n        ) {\n            output.print(\" \");\n        }\n    });\n\n    /** if, for, while, may or may not have braces surrounding its body */\n    function print_maybe_braced_body(stat, output) {\n        if (output.option(\"braces\")) {\n            make_block(stat, output);\n        } else {\n            if (!stat || stat instanceof AST_EmptyStatement)\n                output.force_semicolon();\n            else if ((stat instanceof AST_DefinitionsLike && !(stat instanceof AST_Var)) || stat instanceof AST_Class)\n                make_block(stat, output);\n            else\n                stat.print(output);\n        }\n    }\n\n    function best_of(a) {\n        var best = a[0], len = best.length;\n        for (var i = 1; i < a.length; ++i) {\n            if (a[i].length < len) {\n                best = a[i];\n                len = best.length;\n            }\n        }\n        return best;\n    }\n\n    function make_num(num) {\n        var str = num.toString(10).replace(/^0\\./, \".\").replace(\"e+\", \"e\");\n        var candidates = [ str ];\n        if (Math.floor(num) === num) {\n            if (num < 0) {\n                candidates.push(\"-0x\" + (-num).toString(16).toLowerCase());\n            } else {\n                candidates.push(\"0x\" + num.toString(16).toLowerCase());\n            }\n        }\n        var match, len, digits;\n        if (match = /^\\.0+/.exec(str)) {\n            len = match[0].length;\n            digits = str.slice(len);\n            candidates.push(digits + \"e-\" + (digits.length + len - 1));\n        } else if (match = /0+$/.exec(str)) {\n            len = match[0].length;\n            candidates.push(str.slice(0, -len) + \"e\" + len);\n        } else if (match = /^(\\d)\\.(\\d+)e(-?\\d+)$/.exec(str)) {\n            candidates.push(match[1] + match[2] + \"e\" + (match[3] - match[2].length));\n        }\n        return best_of(candidates);\n    }\n\n    function make_block(stmt, output) {\n        if (!stmt || stmt instanceof AST_EmptyStatement)\n            output.print(\"{}\");\n        else if (stmt instanceof AST_BlockStatement)\n            stmt.print(output);\n        else output.with_block(function() {\n            output.indent();\n            stmt.print(output);\n            output.newline();\n        });\n    }\n\n    /* -----[ source map generators ]----- */\n\n    function DEFMAP(nodetype, generator) {\n        nodetype.forEach(function(nodetype) {\n            nodetype.DEFMETHOD(\"add_source_map\", generator);\n        });\n    }\n\n    DEFMAP([\n        // We could easily add info for ALL nodes, but it seems to me that\n        // would be quite wasteful, hence this noop in the base class.\n        AST_Node,\n        // since the label symbol will mark it\n        AST_LabeledStatement,\n        AST_Toplevel,\n    ], noop);\n\n    // XXX: I'm not exactly sure if we need it for all of these nodes,\n    // or if we should add even more.\n    DEFMAP([\n        AST_Array,\n        AST_BlockStatement,\n        AST_Catch,\n        AST_Class,\n        AST_Constant,\n        AST_Debugger,\n        AST_DefinitionsLike,\n        AST_Directive,\n        AST_Finally,\n        AST_Jump,\n        AST_Lambda,\n        AST_New,\n        AST_Object,\n        AST_StatementWithBody,\n        AST_Symbol,\n        AST_Switch,\n        AST_SwitchBranch,\n        AST_TemplateString,\n        AST_TemplateSegment,\n        AST_Try,\n    ], function(output) {\n        output.add_mapping(this.start);\n    });\n\n    DEFMAP([\n        AST_ObjectGetter,\n        AST_ObjectSetter,\n        AST_PrivateGetter,\n        AST_PrivateSetter,\n        AST_ConciseMethod,\n        AST_PrivateMethod,\n    ], function(output) {\n        output.add_mapping(this.start, false /*name handled below*/);\n    });\n\n    DEFMAP([\n        AST_SymbolMethod,\n        AST_SymbolPrivateProperty\n    ], function(output) {\n        const tok_type = this.end && this.end.type;\n        if (tok_type === \"name\" || tok_type === \"privatename\") {\n            output.add_mapping(this.end, this.name);\n        } else {\n            output.add_mapping(this.end);\n        }\n    });\n\n    DEFMAP([ AST_ObjectProperty ], function(output) {\n        output.add_mapping(this.start, this.key);\n    });\n})();\n\nconst shallow_cmp = (node1, node2) => {\n    return (\n        node1 === null && node2 === null\n        || node1.TYPE === node2.TYPE && node1.shallow_cmp(node2)\n    );\n};\n\nconst equivalent_to = (tree1, tree2) => {\n    if (!shallow_cmp(tree1, tree2)) return false;\n    const walk_1_state = [tree1];\n    const walk_2_state = [tree2];\n\n    const walk_1_push = walk_1_state.push.bind(walk_1_state);\n    const walk_2_push = walk_2_state.push.bind(walk_2_state);\n\n    while (walk_1_state.length && walk_2_state.length) {\n        const node_1 = walk_1_state.pop();\n        const node_2 = walk_2_state.pop();\n\n        if (!shallow_cmp(node_1, node_2)) return false;\n\n        node_1._children_backwards(walk_1_push);\n        node_2._children_backwards(walk_2_push);\n\n        if (walk_1_state.length !== walk_2_state.length) {\n            // Different number of children\n            return false;\n        }\n    }\n\n    return walk_1_state.length == 0 && walk_2_state.length == 0;\n};\n\nconst pass_through = () => true;\n\nAST_Node.prototype.shallow_cmp = function () {\n    throw new Error(\"did not find a shallow_cmp function for \" + this.constructor.name);\n};\n\nAST_Debugger.prototype.shallow_cmp = pass_through;\n\nAST_Directive.prototype.shallow_cmp = function(other) {\n    return this.value === other.value;\n};\n\nAST_SimpleStatement.prototype.shallow_cmp = pass_through;\n\nAST_Block.prototype.shallow_cmp = pass_through;\n\nAST_EmptyStatement.prototype.shallow_cmp = pass_through;\n\nAST_LabeledStatement.prototype.shallow_cmp = function(other) {\n    return this.label.name === other.label.name;\n};\n\nAST_Do.prototype.shallow_cmp = pass_through;\n\nAST_While.prototype.shallow_cmp = pass_through;\n\nAST_For.prototype.shallow_cmp = function(other) {\n    return (this.init == null ? other.init == null : this.init === other.init) && (this.condition == null ? other.condition == null : this.condition === other.condition) && (this.step == null ? other.step == null : this.step === other.step);\n};\n\nAST_ForIn.prototype.shallow_cmp = pass_through;\n\nAST_ForOf.prototype.shallow_cmp = pass_through;\n\nAST_With.prototype.shallow_cmp = pass_through;\n\nAST_Toplevel.prototype.shallow_cmp = pass_through;\n\nAST_Expansion.prototype.shallow_cmp = pass_through;\n\nAST_Lambda.prototype.shallow_cmp = function(other) {\n    return this.is_generator === other.is_generator && this.async === other.async;\n};\n\nAST_Destructuring.prototype.shallow_cmp = function(other) {\n    return this.is_array === other.is_array;\n};\n\nAST_PrefixedTemplateString.prototype.shallow_cmp = pass_through;\n\nAST_TemplateString.prototype.shallow_cmp = pass_through;\n\nAST_TemplateSegment.prototype.shallow_cmp = function(other) {\n    return this.value === other.value;\n};\n\nAST_Jump.prototype.shallow_cmp = pass_through;\n\nAST_LoopControl.prototype.shallow_cmp = pass_through;\n\nAST_Await.prototype.shallow_cmp = pass_through;\n\nAST_Yield.prototype.shallow_cmp = function(other) {\n    return this.is_star === other.is_star;\n};\n\nAST_If.prototype.shallow_cmp = function(other) {\n    return this.alternative == null ? other.alternative == null : this.alternative === other.alternative;\n};\n\nAST_Switch.prototype.shallow_cmp = pass_through;\n\nAST_SwitchBranch.prototype.shallow_cmp = pass_through;\n\nAST_Try.prototype.shallow_cmp = function(other) {\n    return (this.body === other.body) && (this.bcatch == null ? other.bcatch == null : this.bcatch === other.bcatch) && (this.bfinally == null ? other.bfinally == null : this.bfinally === other.bfinally);\n};\n\nAST_Catch.prototype.shallow_cmp = function(other) {\n    return this.argname == null ? other.argname == null : this.argname === other.argname;\n};\n\nAST_Finally.prototype.shallow_cmp = pass_through;\n\nAST_DefinitionsLike.prototype.shallow_cmp = pass_through;\n\nAST_VarDefLike.prototype.shallow_cmp = function(other) {\n    return this.value == null ? other.value == null : this.value === other.value;\n};\n\nAST_NameMapping.prototype.shallow_cmp = pass_through;\n\nAST_Import.prototype.shallow_cmp = function(other) {\n    return (this.imported_name == null ? other.imported_name == null : this.imported_name === other.imported_name) && (this.imported_names == null ? other.imported_names == null : this.imported_names === other.imported_names) && (this.attributes == null ? other.attributes == null : this.attributes === other.attributes);\n};\n\nAST_ImportMeta.prototype.shallow_cmp = pass_through;\n\nAST_Export.prototype.shallow_cmp = function(other) {\n    return (this.exported_definition == null ? other.exported_definition == null : this.exported_definition === other.exported_definition) && (this.exported_value == null ? other.exported_value == null : this.exported_value === other.exported_value) && (this.exported_names == null ? other.exported_names == null : this.exported_names === other.exported_names) && (this.attributes == null ? other.attributes == null : this.attributes === other.attributes) && this.module_name === other.module_name && this.is_default === other.is_default;\n};\n\nAST_Call.prototype.shallow_cmp = pass_through;\n\nAST_Sequence.prototype.shallow_cmp = pass_through;\n\nAST_PropAccess.prototype.shallow_cmp = pass_through;\n\nAST_Chain.prototype.shallow_cmp = pass_through;\n\nAST_Dot.prototype.shallow_cmp = function(other) {\n    return this.property === other.property;\n};\n\nAST_DotHash.prototype.shallow_cmp = function(other) {\n    return this.property === other.property;\n};\n\nAST_Unary.prototype.shallow_cmp = function(other) {\n    return this.operator === other.operator;\n};\n\nAST_Binary.prototype.shallow_cmp = function(other) {\n    return this.operator === other.operator;\n};\n\nAST_PrivateIn.prototype.shallow_cmp = pass_through;\n\nAST_Conditional.prototype.shallow_cmp = pass_through;\n\nAST_Array.prototype.shallow_cmp = pass_through;\n\nAST_Object.prototype.shallow_cmp = pass_through;\n\nAST_ObjectProperty.prototype.shallow_cmp = pass_through;\n\nAST_ObjectKeyVal.prototype.shallow_cmp = function(other) {\n    return this.key === other.key && this.quote === other.quote;\n};\n\nAST_ObjectSetter.prototype.shallow_cmp = function(other) {\n    return this.static === other.static;\n};\n\nAST_ObjectGetter.prototype.shallow_cmp = function(other) {\n    return this.static === other.static;\n};\n\nAST_ConciseMethod.prototype.shallow_cmp = function(other) {\n    return this.static === other.static;\n};\n\nAST_PrivateMethod.prototype.shallow_cmp = function(other) {\n    return this.static === other.static;\n};\n\nAST_Class.prototype.shallow_cmp = function(other) {\n    return (this.name == null ? other.name == null : this.name === other.name) && (this.extends == null ? other.extends == null : this.extends === other.extends);\n};\n\nAST_ClassProperty.prototype.shallow_cmp = function(other) {\n    return this.static === other.static\n        && (typeof this.key === \"string\"\n            ? this.key === other.key\n            : true /* AST_Node handled elsewhere */);\n};\n\nAST_ClassPrivateProperty.prototype.shallow_cmp = function(other) {\n    return this.static === other.static;\n};\n\nAST_Symbol.prototype.shallow_cmp = function(other) {\n    return this.name === other.name;\n};\n\nAST_NewTarget.prototype.shallow_cmp = pass_through;\n\nAST_This.prototype.shallow_cmp = pass_through;\n\nAST_Super.prototype.shallow_cmp = pass_through;\n\nAST_String.prototype.shallow_cmp = function(other) {\n    return this.value === other.value;\n};\n\nAST_Number.prototype.shallow_cmp = function(other) {\n    return this.value === other.value;\n};\n\nAST_BigInt.prototype.shallow_cmp = function(other) {\n    return this.value === other.value;\n};\n\nAST_RegExp.prototype.shallow_cmp = function (other) {\n    return (\n        this.value.flags === other.value.flags\n        && this.value.source === other.value.source\n    );\n};\n\nAST_Atom.prototype.shallow_cmp = pass_through;\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nconst MASK_EXPORT_DONT_MANGLE = 1 << 0;\nconst MASK_EXPORT_WANT_MANGLE = 1 << 1;\n\nlet function_defs = null;\nlet unmangleable_names = null;\n/**\n * When defined, there is a function declaration somewhere that's inside of a block.\n * See https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics\n*/\nlet scopes_with_block_defuns = null;\n\nclass SymbolDef {\n    constructor(scope, orig, init) {\n        this.name = orig.name;\n        this.orig = [ orig ];\n        this.init = init;\n        this.eliminated = 0;\n        this.assignments = 0;\n        this.scope = scope;\n        this.replaced = 0;\n        this.global = false;\n        this.export = 0;\n        this.mangled_name = null;\n        this.undeclared = false;\n        this.id = SymbolDef.next_id++;\n        this.chained = false;\n        this.direct_access = false;\n        this.escaped = 0;\n        this.recursive_refs = 0;\n        this.references = [];\n        this.should_replace = undefined;\n        this.single_use = false;\n        this.fixed = false;\n        Object.seal(this);\n    }\n    fixed_value() {\n        if (!this.fixed || this.fixed instanceof AST_Node) return this.fixed;\n        return this.fixed();\n    }\n    unmangleable(options) {\n        if (!options) options = {};\n\n        if (\n            function_defs &&\n            function_defs.has(this.id) &&\n            keep_name(options.keep_fnames, this.orig[0].name)\n        ) return true;\n\n        return this.global && !options.toplevel\n            || (this.export & MASK_EXPORT_DONT_MANGLE)\n            || this.undeclared\n            || !options.eval && this.scope.pinned()\n            || (this.orig[0] instanceof AST_SymbolLambda\n                  || this.orig[0] instanceof AST_SymbolDefun) && keep_name(options.keep_fnames, this.orig[0].name)\n            || this.orig[0] instanceof AST_SymbolMethod\n            || (this.orig[0] instanceof AST_SymbolClass\n                  || this.orig[0] instanceof AST_SymbolDefClass) && keep_name(options.keep_classnames, this.orig[0].name);\n    }\n    mangle(options) {\n        const cache = options.cache && options.cache.props;\n        if (this.global && cache && cache.has(this.name)) {\n            this.mangled_name = cache.get(this.name);\n        } else if (!this.mangled_name && !this.unmangleable(options)) {\n            var s = this.scope;\n            var sym = this.orig[0];\n            if (options.ie8 && sym instanceof AST_SymbolLambda)\n                s = s.parent_scope;\n            const redefinition = redefined_catch_def(this);\n            this.mangled_name = redefinition\n                ? redefinition.mangled_name || redefinition.name\n                : s.next_mangled(options, this);\n            if (this.global && cache) {\n                cache.set(this.name, this.mangled_name);\n            }\n        }\n    }\n}\n\nSymbolDef.next_id = 1;\n\nfunction redefined_catch_def(def) {\n    if (def.orig[0] instanceof AST_SymbolCatch\n        && def.scope.is_block_scope()\n    ) {\n        return def.scope.get_defun_scope().variables.get(def.name);\n    }\n}\n\nAST_Scope.DEFMETHOD(\"figure_out_scope\", function(options, { parent_scope = undefined, toplevel = this } = {}) {\n    options = defaults(options, {\n        cache: null,\n        ie8: false,\n        safari10: false,\n        module: false,\n    });\n\n    if (!(toplevel instanceof AST_Toplevel)) {\n        throw new Error(\"Invalid toplevel scope\");\n    }\n\n    // pass 1: setup scope chaining and handle definitions\n    var scope = this.parent_scope = parent_scope;\n    var labels = new Map();\n    var defun = null;\n    var in_destructuring = null;\n    var for_scopes = [];\n    var tw = new TreeWalker((node, descend) => {\n        if (node.is_block_scope()) {\n            const save_scope = scope;\n            node.block_scope = scope = new AST_Scope(node);\n            scope._block_scope = true;\n            scope.init_scope_vars(save_scope);\n            scope.uses_with = save_scope.uses_with;\n            scope.uses_eval = save_scope.uses_eval;\n\n            if (options.safari10) {\n                if (node instanceof AST_For || node instanceof AST_ForIn || node instanceof AST_ForOf) {\n                    for_scopes.push(scope);\n                }\n            }\n\n            if (node instanceof AST_Switch) {\n                // XXX: HACK! Ensure the switch expression gets the correct scope (the parent scope) and the body gets the contained scope\n                // AST_Switch has a scope within the body, but it itself \"is a block scope\"\n                // This means the switched expression has to belong to the outer scope\n                // while the body inside belongs to the switch itself.\n                // This is pretty nasty and warrants an AST change\n                const the_block_scope = scope;\n                scope = save_scope;\n                node.expression.walk(tw);\n                scope = the_block_scope;\n                for (let i = 0; i < node.body.length; i++) {\n                    node.body[i].walk(tw);\n                }\n            } else {\n                descend();\n            }\n            scope = save_scope;\n            return true;\n        }\n        if (node instanceof AST_Destructuring) {\n            const save_destructuring = in_destructuring;\n            in_destructuring = node;\n            descend();\n            in_destructuring = save_destructuring;\n            return true;\n        }\n        if (node instanceof AST_Scope) {\n            node.init_scope_vars(scope);\n            var save_scope = scope;\n            var save_defun = defun;\n            var save_labels = labels;\n            defun = scope = node;\n            labels = new Map();\n            descend();\n            scope = save_scope;\n            defun = save_defun;\n            labels = save_labels;\n            return true;        // don't descend again in TreeWalker\n        }\n        if (node instanceof AST_LabeledStatement) {\n            var l = node.label;\n            if (labels.has(l.name)) {\n                throw new Error(string_template(\"Label {name} defined twice\", l));\n            }\n            labels.set(l.name, l);\n            descend();\n            labels.delete(l.name);\n            return true;        // no descend again\n        }\n        if (node instanceof AST_With) {\n            for (var s = scope; s; s = s.parent_scope)\n                s.uses_with = true;\n            return;\n        }\n        if (node instanceof AST_Symbol) {\n            node.scope = scope;\n        }\n        if (node instanceof AST_Label) {\n            node.thedef = node;\n            node.references = [];\n        }\n        if (node instanceof AST_SymbolLambda) {\n            defun.def_function(node, node.name == \"arguments\" ? undefined : defun);\n        } else if (node instanceof AST_SymbolDefun) {\n            // Careful here, the scope where this should be defined is\n            // the parent scope.  The reason is that we enter a new\n            // scope when we encounter the AST_Defun node (which is\n            // instanceof AST_Scope) but we get to the symbol a bit\n            // later.\n            const closest_scope = defun.parent_scope;\n\n            // In strict mode, function definitions are block-scoped\n            node.scope = tw.directives[\"use strict\"]\n                ? closest_scope\n                : closest_scope.get_defun_scope();\n\n            mark_export(node.scope.def_function(node, defun), 1);\n        } else if (node instanceof AST_SymbolClass) {\n            mark_export(defun.def_variable(node, defun), 1);\n        } else if (node instanceof AST_SymbolImport) {\n            scope.def_variable(node);\n        } else if (node instanceof AST_SymbolDefClass) {\n            // This deals with the name of the class being available\n            // inside the class.\n            mark_export((node.scope = defun.parent_scope).def_function(node, defun), 1);\n        } else if (\n            node instanceof AST_SymbolVar\n            || node instanceof AST_SymbolLet\n            || node instanceof AST_SymbolConst\n            || node instanceof AST_SymbolUsing\n            || node instanceof AST_SymbolCatch\n        ) {\n            var def;\n            if (node instanceof AST_SymbolBlockDeclaration) {\n                def = scope.def_variable(node, null);\n            } else {\n                def = defun.def_variable(node, node.TYPE == \"SymbolVar\" ? null : undefined);\n            }\n            if (!def.orig.every((sym) => {\n                if (sym === node) return true;\n                if (node instanceof AST_SymbolBlockDeclaration) {\n                    return sym instanceof AST_SymbolLambda;\n                }\n                return !(sym instanceof AST_SymbolLet || sym instanceof AST_SymbolConst || sym instanceof AST_SymbolUsing);\n            })) {\n                js_error(\n                    `\"${node.name}\" is redeclared`,\n                    node.start.file,\n                    node.start.line,\n                    node.start.col,\n                    node.start.pos\n                );\n            }\n            if (!(node instanceof AST_SymbolFunarg)) mark_export(def, 2);\n            if (defun !== scope) {\n                node.mark_enclosed();\n                var def = scope.find_variable(node);\n                if (node.thedef !== def) {\n                    node.thedef = def;\n                    node.reference();\n                }\n            }\n        } else if (node instanceof AST_LabelRef) {\n            var sym = labels.get(node.name);\n            if (!sym) throw new Error(string_template(\"Undefined label {name} [{line},{col}]\", {\n                name: node.name,\n                line: node.start.line,\n                col: node.start.col\n            }));\n            node.thedef = sym;\n        }\n        if (!(scope instanceof AST_Toplevel) && (node instanceof AST_Export || node instanceof AST_Import)) {\n            js_error(\n                `\"${node.TYPE}\" statement may only appear at the top level`,\n                node.start.file,\n                node.start.line,\n                node.start.col,\n                node.start.pos\n            );\n        }\n    });\n\n    if (options.module) {\n        tw.directives[\"use strict\"] = true;\n    }\n\n    this.walk(tw);\n\n    function mark_export(def, level) {\n        if (in_destructuring) {\n            var i = 0;\n            do {\n                level++;\n            } while (tw.parent(i++) !== in_destructuring);\n        }\n        var node = tw.parent(level);\n        if (def.export = node instanceof AST_Export ? MASK_EXPORT_DONT_MANGLE : 0) {\n            var exported = node.exported_definition;\n            if ((exported instanceof AST_Defun || exported instanceof AST_DefClass) && node.is_default) {\n                def.export = MASK_EXPORT_WANT_MANGLE;\n            }\n        }\n    }\n\n    // pass 2: find back references and eval\n    const is_toplevel = this instanceof AST_Toplevel;\n    if (is_toplevel) {\n        this.globals = new Map();\n    }\n\n    var tw = new TreeWalker(node => {\n        if (node instanceof AST_LoopControl && node.label) {\n            node.label.thedef.references.push(node);\n            return true;\n        }\n        if (node instanceof AST_SymbolRef) {\n            var name = node.name;\n            if (name == \"eval\" && tw.parent() instanceof AST_Call) {\n                for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) {\n                    s.uses_eval = true;\n                }\n            }\n            var sym;\n            if (tw.parent() instanceof AST_NameMapping && tw.parent(1).module_name\n                || !(sym = node.scope.find_variable(name))) {\n\n                sym = toplevel.def_global(node);\n                if (node instanceof AST_SymbolExport) sym.export = MASK_EXPORT_DONT_MANGLE;\n            } else if (sym.scope instanceof AST_Lambda && name == \"arguments\") {\n                sym.scope.get_defun_scope().uses_arguments = true;\n            }\n            node.thedef = sym;\n            node.reference();\n            if (node.scope.is_block_scope()\n                && !(sym.orig[0] instanceof AST_SymbolBlockDeclaration)) {\n                node.scope = node.scope.get_defun_scope();\n            }\n            return true;\n        }\n        // ensure mangling works if catch reuses a scope variable\n        var def;\n        if (node instanceof AST_SymbolCatch && (def = redefined_catch_def(node.definition()))) {\n            var s = node.scope;\n            while (s) {\n                push_uniq(s.enclosed, def);\n                if (s === def.scope) break;\n                s = s.parent_scope;\n            }\n        }\n    });\n    this.walk(tw);\n\n    // pass 3: work around IE8 and Safari catch scope bugs\n    if (options.ie8 || options.safari10) {\n        walk(this, node => {\n            if (node instanceof AST_SymbolCatch) {\n                var name = node.name;\n                var refs = node.thedef.references;\n                var scope = node.scope.get_defun_scope();\n                var def = scope.find_variable(name)\n                    || toplevel.globals.get(name)\n                    || scope.def_variable(node);\n                refs.forEach(function(ref) {\n                    ref.thedef = def;\n                    ref.reference();\n                });\n                node.thedef = def;\n                node.reference();\n                return true;\n            }\n        });\n    }\n\n    // pass 4: add symbol definitions to loop scopes\n    // Safari/Webkit bug workaround - loop init let variable shadowing argument.\n    // https://github.com/mishoo/UglifyJS2/issues/1753\n    // https://bugs.webkit.org/show_bug.cgi?id=171041\n    if (options.safari10) {\n        for (const scope of for_scopes) {\n            scope.parent_scope.variables.forEach(function(def) {\n                push_uniq(scope.enclosed, def);\n            });\n        }\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"def_global\", function(node) {\n    var globals = this.globals, name = node.name;\n    if (globals.has(name)) {\n        return globals.get(name);\n    } else {\n        var g = new SymbolDef(this, node);\n        g.undeclared = true;\n        g.global = true;\n        globals.set(name, g);\n        return g;\n    }\n});\n\nAST_Scope.DEFMETHOD(\"init_scope_vars\", function(parent_scope) {\n    this.variables = new Map();         // map name to AST_SymbolVar (variables defined in this scope; includes functions)\n    this.uses_with = false;             // will be set to true if this or some nested scope uses the `with` statement\n    this.uses_eval = false;             // will be set to true if this or nested scope uses the global `eval`\n    this.parent_scope = parent_scope;   // the parent scope\n    this.enclosed = [];                 // a list of variables from this or outer scope(s) that are referenced from this or inner scopes\n    this.cname = -1;                    // the current index for mangling functions/variables\n});\n\nAST_Scope.DEFMETHOD(\"conflicting_def\", function (name) {\n    return (\n        this.enclosed.find(def => def.name === name)\n        || this.variables.has(name)\n        || (this.parent_scope && this.parent_scope.conflicting_def(name))\n    );\n});\n\nAST_Scope.DEFMETHOD(\"conflicting_def_shallow\", function (name) {\n    return (\n        this.enclosed.find(def => def.name === name)\n        || this.variables.has(name)\n    );\n});\n\nAST_Scope.DEFMETHOD(\"add_child_scope\", function (scope) {\n    // `scope` is going to be moved into `this` right now.\n    // Update the required scopes' information\n\n    if (scope.parent_scope === this) return;\n\n    scope.parent_scope = this;\n\n    // Propagate to this.uses_arguments from arrow functions\n    if ((scope instanceof AST_Arrow) && (this instanceof AST_Lambda && !this.uses_arguments)) {\n        this.uses_arguments = walk(scope, node => {\n            if (\n                node instanceof AST_SymbolRef\n                && node.scope instanceof AST_Lambda\n                && node.name === \"arguments\"\n            ) {\n                return walk_abort;\n            }\n\n            if (node instanceof AST_Lambda && !(node instanceof AST_Arrow)) {\n                return true;\n            }\n        });\n    }\n\n    this.uses_with = this.uses_with || scope.uses_with;\n    this.uses_eval = this.uses_eval || scope.uses_eval;\n\n    const scope_ancestry = (() => {\n        const ancestry = [];\n        let cur = this;\n        do {\n            ancestry.push(cur);\n        } while ((cur = cur.parent_scope));\n        ancestry.reverse();\n        return ancestry;\n    })();\n\n    const new_scope_enclosed_set = new Set(scope.enclosed);\n    const to_enclose = [];\n    for (const scope_topdown of scope_ancestry) {\n        to_enclose.forEach(e => push_uniq(scope_topdown.enclosed, e));\n        for (const def of scope_topdown.variables.values()) {\n            if (new_scope_enclosed_set.has(def)) {\n                push_uniq(to_enclose, def);\n                push_uniq(scope_topdown.enclosed, def);\n            }\n        }\n    }\n});\n\nfunction find_scopes_visible_from(scopes) {\n    const found_scopes = new Set();\n\n    for (const scope of new Set(scopes)) {\n        (function bubble_up(scope) {\n            if (scope == null || found_scopes.has(scope)) return;\n\n            found_scopes.add(scope);\n\n            bubble_up(scope.parent_scope);\n        })(scope);\n    }\n\n    return [...found_scopes];\n}\n\n// Creates a symbol during compression\nAST_Scope.DEFMETHOD(\"create_symbol\", function(SymClass, {\n    source,\n    tentative_name,\n    scope,\n    conflict_scopes = [scope],\n    init = null\n} = {}) {\n    let symbol_name;\n\n    conflict_scopes = find_scopes_visible_from(conflict_scopes);\n\n    if (tentative_name) {\n        // Implement hygiene (no new names are conflicting with existing names)\n        tentative_name =\n            symbol_name =\n            tentative_name.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, \"_\");\n\n        let i = 0;\n        while (conflict_scopes.find(s => s.conflicting_def_shallow(symbol_name))) {\n            symbol_name = tentative_name + \"$\" + i++;\n        }\n    }\n\n    if (!symbol_name) {\n        throw new Error(\"No symbol name could be generated in create_symbol()\");\n    }\n\n    const symbol = make_node(SymClass, source, {\n        name: symbol_name,\n        scope\n    });\n\n    this.def_variable(symbol, init || null);\n\n    symbol.mark_enclosed();\n\n    return symbol;\n});\n\n\nAST_Node.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Class.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Lambda.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Toplevel.DEFMETHOD(\"is_block_scope\", return_false);\nAST_SwitchBranch.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Block.DEFMETHOD(\"is_block_scope\", return_true);\nAST_Scope.DEFMETHOD(\"is_block_scope\", function () {\n    return this._block_scope || false;\n});\nAST_IterationStatement.DEFMETHOD(\"is_block_scope\", return_true);\n\nAST_Lambda.DEFMETHOD(\"init_scope_vars\", function() {\n    AST_Scope.prototype.init_scope_vars.apply(this, arguments);\n    this.uses_arguments = false;\n    this.def_variable(new AST_SymbolFunarg({\n        name: \"arguments\",\n        start: this.start,\n        end: this.end\n    }));\n});\n\nAST_Arrow.DEFMETHOD(\"init_scope_vars\", function() {\n    AST_Scope.prototype.init_scope_vars.apply(this, arguments);\n    this.uses_arguments = false;\n});\n\nAST_Symbol.DEFMETHOD(\"mark_enclosed\", function() {\n    var def = this.definition();\n    var s = this.scope;\n    while (s) {\n        push_uniq(s.enclosed, def);\n        if (s === def.scope) break;\n        s = s.parent_scope;\n    }\n});\n\nAST_Symbol.DEFMETHOD(\"reference\", function() {\n    this.definition().references.push(this);\n    this.mark_enclosed();\n});\n\nAST_Scope.DEFMETHOD(\"find_variable\", function(name) {\n    if (name instanceof AST_Symbol) name = name.name;\n    return this.variables.get(name)\n        || (this.parent_scope && this.parent_scope.find_variable(name));\n});\n\nAST_Scope.DEFMETHOD(\"def_function\", function(symbol, init) {\n    var def = this.def_variable(symbol, init);\n    if (!def.init || def.init instanceof AST_Defun) def.init = init;\n    return def;\n});\n\nAST_Scope.DEFMETHOD(\"def_variable\", function(symbol, init) {\n    var def = this.variables.get(symbol.name);\n    if (def) {\n        def.orig.push(symbol);\n        if (def.init && (def.scope !== symbol.scope || def.init instanceof AST_Function)) {\n            def.init = init;\n        }\n    } else {\n        def = new SymbolDef(this, symbol, init);\n        this.variables.set(symbol.name, def);\n        def.global = !this.parent_scope;\n    }\n    return symbol.thedef = def;\n});\n\nfunction next_mangled(scope, options) {\n    let defun_scope;\n    if (\n        scopes_with_block_defuns\n        && (defun_scope = scope.get_defun_scope())\n        && scopes_with_block_defuns.has(defun_scope)\n    ) {\n        scope = defun_scope;\n    }\n\n    var ext = scope.enclosed;\n    var nth_identifier = options.nth_identifier;\n    out: while (true) {\n        var m = nth_identifier.get(++scope.cname);\n        if (ALL_RESERVED_WORDS.has(m)) continue; // skip over \"do\"\n\n        // https://github.com/mishoo/UglifyJS2/issues/242 -- do not\n        // shadow a name reserved from mangling.\n        if (options.reserved.has(m)) continue;\n\n        // Functions with short names might collide with base54 output\n        // and therefore cause collisions when keep_fnames is true.\n        if (unmangleable_names && unmangleable_names.has(m)) continue out;\n\n        // we must ensure that the mangled name does not shadow a name\n        // from some parent scope that is referenced in this or in\n        // inner scopes.\n        for (let i = ext.length; --i >= 0;) {\n            const def = ext[i];\n            const name = def.mangled_name || (def.unmangleable(options) && def.name);\n            if (m == name) continue out;\n        }\n        return m;\n    }\n}\n\nAST_Scope.DEFMETHOD(\"next_mangled\", function(options) {\n    return next_mangled(this, options);\n});\n\nAST_Toplevel.DEFMETHOD(\"next_mangled\", function(options) {\n    let name;\n    const mangled_names = this.mangled_names;\n    do {\n        name = next_mangled(this, options);\n    } while (mangled_names.has(name));\n    return name;\n});\n\nAST_Function.DEFMETHOD(\"next_mangled\", function(options, def) {\n    // #179, #326\n    // in Safari strict mode, something like (function x(x){...}) is a syntax error;\n    // a function expression's argument cannot shadow the function expression's name\n\n    var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();\n\n    // the function's mangled_name is null when keep_fnames is true\n    var tricky_name = tricky_def ? tricky_def.mangled_name || tricky_def.name : null;\n\n    while (true) {\n        var name = next_mangled(this, options);\n        if (!tricky_name || tricky_name != name)\n            return name;\n    }\n});\n\nAST_Symbol.DEFMETHOD(\"unmangleable\", function(options) {\n    var def = this.definition();\n    return !def || def.unmangleable(options);\n});\n\n// labels are always mangleable\nAST_Label.DEFMETHOD(\"unmangleable\", return_false);\n\nAST_Symbol.DEFMETHOD(\"unreferenced\", function() {\n    return !this.definition().references.length && !this.scope.pinned();\n});\n\nAST_Symbol.DEFMETHOD(\"definition\", function() {\n    return this.thedef;\n});\n\nAST_Symbol.DEFMETHOD(\"global\", function() {\n    return this.thedef.global;\n});\n\n/**\n * Format the mangler options (if any) into their appropriate types\n */\nfunction format_mangler_options(options) {\n    options = defaults(options, {\n        eval        : false,\n        nth_identifier : base54,\n        ie8         : false,\n        keep_classnames: false,\n        keep_fnames : false,\n        module      : false,\n        reserved    : [],\n        toplevel    : false,\n    });\n    if (options.module) options.toplevel = true;\n    if (!Array.isArray(options.reserved)\n        && !(options.reserved instanceof Set)\n    ) {\n        options.reserved = [];\n    }\n    options.reserved = new Set(options.reserved);\n    // Never mangle arguments\n    options.reserved.add(\"arguments\");\n    return options;\n}\n\nAST_Toplevel.DEFMETHOD(\"mangle_names\", function(options) {\n    options = format_mangler_options(options);\n    var nth_identifier = options.nth_identifier;\n\n    // We only need to mangle declaration nodes.  Special logic wired\n    // into the code generator will display the mangled name if it's\n    // present (and for AST_SymbolRef-s it'll use the mangled name of\n    // the AST_SymbolDeclaration that it points to).\n    var lname = -1;\n    var to_mangle = [];\n\n    if (options.keep_fnames) {\n        function_defs = new Set();\n    }\n\n    const mangled_names = this.mangled_names = new Set();\n    unmangleable_names = new Set();\n\n    if (options.cache) {\n        this.globals.forEach(collect);\n        if (options.cache.props) {\n            options.cache.props.forEach(function(mangled_name) {\n                mangled_names.add(mangled_name);\n            });\n        }\n    }\n\n    var tw = new TreeWalker(function(node, descend) {\n        if (node instanceof AST_LabeledStatement) {\n            // lname is incremented when we get to the AST_Label\n            var save_nesting = lname;\n            descend();\n            lname = save_nesting;\n            return true;        // don't descend again in TreeWalker\n        }\n        if (\n            node instanceof AST_Defun\n            && !(tw.parent() instanceof AST_Scope)\n        ) {\n            scopes_with_block_defuns = scopes_with_block_defuns || new Set();\n            scopes_with_block_defuns.add(node.parent_scope.get_defun_scope());\n        }\n        if (node instanceof AST_Scope) {\n            node.variables.forEach(collect);\n            return;\n        }\n        if (node.is_block_scope()) {\n            node.block_scope.variables.forEach(collect);\n            return;\n        }\n        if (\n            function_defs\n            && node instanceof AST_VarDef\n            && node.value instanceof AST_Lambda\n            && !node.value.name\n            && keep_name(options.keep_fnames, node.name.name)\n        ) {\n            function_defs.add(node.name.definition().id);\n            return;\n        }\n        if (node instanceof AST_Label) {\n            let name;\n            do {\n                name = nth_identifier.get(++lname);\n            } while (ALL_RESERVED_WORDS.has(name));\n            node.mangled_name = name;\n            return true;\n        }\n        if (!(options.ie8 || options.safari10) && node instanceof AST_SymbolCatch) {\n            to_mangle.push(node.definition());\n            return;\n        }\n    });\n\n    this.walk(tw);\n\n    if (options.keep_fnames || options.keep_classnames) {\n        // Collect a set of short names which are unmangleable,\n        // for use in avoiding collisions in next_mangled.\n        to_mangle.forEach(def => {\n            if (def.name.length < 6 && def.unmangleable(options)) {\n                unmangleable_names.add(def.name);\n            }\n        });\n    }\n\n    to_mangle.forEach(def => { def.mangle(options); });\n\n    function_defs = null;\n    unmangleable_names = null;\n    scopes_with_block_defuns = null;\n\n    function collect(symbol) {\n        if (symbol.export & MASK_EXPORT_DONT_MANGLE) {\n            unmangleable_names.add(symbol.name);\n        } else if (!options.reserved.has(symbol.name)) {\n            to_mangle.push(symbol);\n        }\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"find_colliding_names\", function(options) {\n    const cache = options.cache && options.cache.props;\n    const avoid = new Set();\n    options.reserved.forEach(to_avoid);\n    this.globals.forEach(add_def);\n    this.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Scope) node.variables.forEach(add_def);\n        if (node instanceof AST_SymbolCatch) add_def(node.definition());\n    }));\n    return avoid;\n\n    function to_avoid(name) {\n        avoid.add(name);\n    }\n\n    function add_def(def) {\n        var name = def.name;\n        if (def.global && cache && cache.has(name)) name = cache.get(name);\n        else if (!def.unmangleable(options)) return;\n        to_avoid(name);\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"expand_names\", function(options) {\n    options = format_mangler_options(options);\n    var nth_identifier = options.nth_identifier;\n    if (nth_identifier.reset && nth_identifier.sort) {\n        nth_identifier.reset();\n        nth_identifier.sort();\n    }\n    var avoid = this.find_colliding_names(options);\n    var cname = 0;\n    this.globals.forEach(rename);\n    this.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Scope) node.variables.forEach(rename);\n        if (node instanceof AST_SymbolCatch) rename(node.definition());\n    }));\n\n    function next_name() {\n        var name;\n        do {\n            name = nth_identifier.get(cname++);\n        } while (avoid.has(name) || ALL_RESERVED_WORDS.has(name));\n        return name;\n    }\n\n    function rename(def) {\n        if (def.global && options.cache) return;\n        if (def.unmangleable(options)) return;\n        if (options.reserved.has(def.name)) return;\n        const redefinition = redefined_catch_def(def);\n        const name = def.name = redefinition ? redefinition.name : next_name();\n        def.orig.forEach(function(sym) {\n            sym.name = name;\n        });\n        def.references.forEach(function(sym) {\n            sym.name = name;\n        });\n    }\n});\n\nAST_Node.DEFMETHOD(\"tail_node\", return_this);\nAST_Sequence.DEFMETHOD(\"tail_node\", function() {\n    return this.expressions[this.expressions.length - 1];\n});\n\nAST_Toplevel.DEFMETHOD(\"compute_char_frequency\", function(options) {\n    options = format_mangler_options(options);\n    var nth_identifier = options.nth_identifier;\n    if (!nth_identifier.reset || !nth_identifier.consider || !nth_identifier.sort) {\n        // If the identifier mangler is invariant, skip computing character frequency.\n        return;\n    }\n    nth_identifier.reset();\n\n    try {\n        AST_Node.prototype.print = function(stream, force_parens) {\n            this._print(stream, force_parens);\n            if (this instanceof AST_Symbol && !this.unmangleable(options)) {\n                nth_identifier.consider(this.name, -1);\n            } else if (options.properties) {\n                if (this instanceof AST_DotHash) {\n                    nth_identifier.consider(\"#\" + this.property, -1);\n                } else if (this instanceof AST_Dot) {\n                    nth_identifier.consider(this.property, -1);\n                } else if (this instanceof AST_Sub) {\n                    skip_string(this.property);\n                }\n            }\n        };\n        nth_identifier.consider(this.print_to_string(), 1);\n    } finally {\n        AST_Node.prototype.print = AST_Node.prototype._print;\n    }\n    nth_identifier.sort();\n\n    function skip_string(node) {\n        if (node instanceof AST_String) {\n            nth_identifier.consider(node.value, -1);\n        } else if (node instanceof AST_Conditional) {\n            skip_string(node.consequent);\n            skip_string(node.alternative);\n        } else if (node instanceof AST_Sequence) {\n            skip_string(node.tail_node());\n        }\n    }\n});\n\nconst base54 = (() => {\n    const leading = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\".split(\"\");\n    const digits = \"0123456789\".split(\"\");\n    let chars;\n    let frequency;\n    function reset() {\n        frequency = new Map();\n        leading.forEach(function(ch) {\n            frequency.set(ch, 0);\n        });\n        digits.forEach(function(ch) {\n            frequency.set(ch, 0);\n        });\n    }\n    function consider(str, delta) {\n        for (var i = str.length; --i >= 0;) {\n            frequency.set(str[i], frequency.get(str[i]) + delta);\n        }\n    }\n    function compare(a, b) {\n        return frequency.get(b) - frequency.get(a);\n    }\n    function sort() {\n        chars = mergeSort(leading, compare).concat(mergeSort(digits, compare));\n    }\n    // Ensure this is in a usable initial state.\n    reset();\n    sort();\n    function base54(num) {\n        var ret = \"\", base = 54;\n        num++;\n        do {\n            num--;\n            ret += chars[num % base];\n            num = Math.floor(num / base);\n            base = 64;\n        } while (num > 0);\n        return ret;\n    }\n\n    return {\n        get: base54,\n        consider,\n        reset,\n        sort\n    };\n})();\n\nlet mangle_options = undefined;\nAST_Node.prototype.size = function (compressor, stack) {\n    mangle_options = compressor && compressor._mangle_options;\n\n    let size = 0;\n    walk_parent(this, (node, info) => {\n        size += node._size(info);\n\n        // Braceless arrow functions have fake \"return\" statements\n        if (node instanceof AST_Arrow && node.is_braceless()) {\n            size += node.body[0].value._size(info);\n            return true;\n        }\n    }, stack || (compressor && compressor.stack));\n\n    // just to save a bit of memory\n    mangle_options = undefined;\n\n    return size;\n};\n\nAST_Node.prototype._size = () => 0;\n\nAST_Debugger.prototype._size = () => 8;\n\nAST_Directive.prototype._size = function () {\n    // TODO string encoding stuff\n    return 2 + this.value.length;\n};\n\n/** Count commas/semicolons necessary to show a list of expressions/statements */\nconst list_overhead = (array) => array.length && array.length - 1;\n\nAST_Block.prototype._size = function () {\n    return 2 + list_overhead(this.body);\n};\n\nAST_Toplevel.prototype._size = function() {\n    return list_overhead(this.body);\n};\n\nAST_EmptyStatement.prototype._size = () => 1;\n\nAST_LabeledStatement.prototype._size = () => 2;  // x:\n\nAST_Do.prototype._size = () => 9;\n\nAST_While.prototype._size = () => 7;\n\nAST_For.prototype._size = () => 8;\n\nAST_ForIn.prototype._size = () => 8;\n// AST_ForOf inherits ^\n\nAST_With.prototype._size = () => 6;\n\nAST_Expansion.prototype._size = () => 3;\n\nconst lambda_modifiers = func =>\n    (func.is_generator ? 1 : 0) + (func.async ? 6 : 0);\n\nAST_Accessor.prototype._size = function () {\n    return lambda_modifiers(this) + 4 + list_overhead(this.argnames) + list_overhead(this.body);\n};\n\nAST_Function.prototype._size = function (info) {\n    const first = !!first_in_statement(info);\n    return (first * 2) + lambda_modifiers(this) + 12 + list_overhead(this.argnames) + list_overhead(this.body);\n};\n\nAST_Defun.prototype._size = function () {\n    return lambda_modifiers(this) + 13 + list_overhead(this.argnames) + list_overhead(this.body);\n};\n\nAST_Arrow.prototype._size = function () {\n    let args_and_arrow = 2 + list_overhead(this.argnames);\n\n    if (\n        !(\n            this.argnames.length === 1\n            && this.argnames[0] instanceof AST_Symbol\n        )\n    ) {\n        args_and_arrow += 2; // parens around the args\n    }\n\n    const body_overhead = this.is_braceless() ? 0 : list_overhead(this.body) + 2;\n\n    return lambda_modifiers(this) + args_and_arrow + body_overhead;\n};\n\nAST_Destructuring.prototype._size = () => 2;\n\nAST_TemplateString.prototype._size = function () {\n    return 2 + (Math.floor(this.segments.length / 2) * 3);  /* \"${}\" */\n};\n\nAST_TemplateSegment.prototype._size = function () {\n    return this.value.length;\n};\n\nAST_Return.prototype._size = function () {\n    return this.value ? 7 : 6;\n};\n\nAST_Throw.prototype._size = () => 6;\n\nAST_Break.prototype._size = function () {\n    return this.label ? 6 : 5;\n};\n\nAST_Continue.prototype._size = function () {\n    return this.label ? 9 : 8;\n};\n\nAST_If.prototype._size = () => 4;\n\nAST_Switch.prototype._size = function () {\n    return 8 + list_overhead(this.body);\n};\n\nAST_Case.prototype._size = function () {\n    return 5 + list_overhead(this.body);\n};\n\nAST_Default.prototype._size = function () {\n    return 8 + list_overhead(this.body);\n};\n\nAST_Try.prototype._size = () => 3;\n\nAST_Catch.prototype._size = function () {\n    let size = 7 + list_overhead(this.body);\n    if (this.argname) {\n        size += 2;\n    }\n    return size;\n};\n\nAST_Finally.prototype._size = function () {\n    return 7 + list_overhead(this.body);\n};\n\nAST_Var.prototype._size = function () {\n    return 4 + list_overhead(this.definitions);\n};\n\nAST_Let.prototype._size = function () {\n    return 4 + list_overhead(this.definitions);\n};\n\nAST_Const.prototype._size = function () {\n    return 6 + list_overhead(this.definitions);\n};\n\nAST_Using.prototype._size = function () {\n    const await_size = this.await ? 6 : 0;\n    return await_size + 6 + list_overhead(this.definitions);\n};\n\nAST_VarDefLike.prototype._size = function () {\n    return this.value ? 1 : 0;\n};\n\nAST_NameMapping.prototype._size = function () {\n    // foreign name isn't mangled\n    return this.name ? 4 : 0;\n};\n\nAST_Import.prototype._size = function () {\n    // import\n    let size = 6;\n\n    if (this.imported_name) size += 1;\n\n    // from\n    if (this.imported_name || this.imported_names) size += 5;\n\n    // braces, and the commas\n    if (this.imported_names) {\n        size += 2 + list_overhead(this.imported_names);\n    }\n\n    return size;\n};\n\nAST_ImportMeta.prototype._size = () => 11;\n\nAST_Export.prototype._size = function () {\n    let size = 7 + (this.is_default ? 8 : 0);\n\n    if (this.exported_value) {\n        size += this.exported_value._size();\n    }\n\n    if (this.exported_names) {\n        // Braces and commas\n        size += 2 + list_overhead(this.exported_names);\n    }\n\n    if (this.module_name) {\n        // \"from \"\n        size += 5;\n    }\n\n    return size;\n};\n\nAST_Call.prototype._size = function () {\n    if (this.optional) {\n        return 4 + list_overhead(this.args);\n    }\n    return 2 + list_overhead(this.args);\n};\n\nAST_New.prototype._size = function () {\n    return 6 + list_overhead(this.args);\n};\n\nAST_Sequence.prototype._size = function () {\n    return list_overhead(this.expressions);\n};\n\nAST_Dot.prototype._size = function () {\n    if (this.optional) {\n        return this.property.length + 2;\n    }\n    return this.property.length + 1;\n};\n\nAST_DotHash.prototype._size = function () {\n    if (this.optional) {\n        return this.property.length + 3;\n    }\n    return this.property.length + 2;\n};\n\nAST_Sub.prototype._size = function () {\n    return this.optional ? 4 : 2;\n};\n\nAST_Unary.prototype._size = function () {\n    if (this.operator === \"typeof\") return 7;\n    if (this.operator === \"void\") return 5;\n    return this.operator.length;\n};\n\nAST_Binary.prototype._size = function (info) {\n    if (this.operator === \"in\") return 4;\n\n    let size = this.operator.length;\n\n    if (\n        (this.operator === \"+\" || this.operator === \"-\")\n        && this.right instanceof AST_Unary && this.right.operator === this.operator\n    ) {\n        // 1+ +a > needs space between the +\n        size += 1;\n    }\n\n    if (this.needs_parens(info)) {\n        size += 2;\n    }\n\n    return size;\n};\n\nAST_Conditional.prototype._size = () => 3;\n\nAST_Array.prototype._size = function () {\n    return 2 + list_overhead(this.elements);\n};\n\nAST_Object.prototype._size = function (info) {\n    let base = 2;\n    if (first_in_statement(info)) {\n        base += 2; // parens\n    }\n    return base + list_overhead(this.properties);\n};\n\n/*#__INLINE__*/\nconst key_size = key =>\n    typeof key === \"string\" ? key.length : 0;\n\nAST_ObjectKeyVal.prototype._size = function () {\n    return key_size(this.key) + 1;\n};\n\n/*#__INLINE__*/\nconst static_size = is_static => is_static ? 7 : 0;\n\nAST_ObjectGetter.prototype._size = function () {\n    return 5 + static_size(this.static) + key_size(this.key);\n};\n\nAST_ObjectSetter.prototype._size = function () {\n    return 5 + static_size(this.static) + key_size(this.key);\n};\n\nAST_ConciseMethod.prototype._size = function () {\n    return static_size(this.static) + key_size(this.key);\n};\n\nAST_PrivateMethod.prototype._size = function () {\n    return AST_ConciseMethod.prototype._size.call(this) + 1;\n};\n\nAST_PrivateGetter.prototype._size = function () {\n    return AST_ConciseMethod.prototype._size.call(this) + 4;\n};\n\nAST_PrivateSetter.prototype._size = function () {\n    return AST_ConciseMethod.prototype._size.call(this) + 4;\n};\n\nAST_PrivateIn.prototype._size = function () {\n    return 5; // \"#\", and \" in \"\n};\n\nAST_Class.prototype._size = function () {\n    return (\n        (this.name ? 8 : 7)\n        + (this.extends ? 8 : 0)\n    );\n};\n\nAST_ClassStaticBlock.prototype._size = function () {\n    // \"static{}\" + semicolons\n    return 8 + list_overhead(this.body);\n};\n\nAST_ClassProperty.prototype._size = function () {\n    return (\n        static_size(this.static)\n        + (typeof this.key === \"string\" ? this.key.length + 2 : 0)\n        + (this.value ? 1 : 0)\n    );\n};\n\nAST_ClassPrivateProperty.prototype._size = function () {\n    return AST_ClassProperty.prototype._size.call(this) + 1;\n};\n\nAST_Symbol.prototype._size = function () {\n    if (!(mangle_options && this.thedef && !this.thedef.unmangleable(mangle_options))) {\n        return this.name.length;\n    } else {\n        return 1;\n    }\n};\n\n// TODO take propmangle into account\nAST_SymbolClassProperty.prototype._size = function () {\n    return this.name.length;\n};\n\nAST_SymbolRef.prototype._size = AST_SymbolDeclaration.prototype._size = function () {\n    if (this.name === \"arguments\") return 9;\n\n    return AST_Symbol.prototype._size.call(this);\n};\n\nAST_NewTarget.prototype._size = () => 10;\n\nAST_SymbolImportForeign.prototype._size = function () {\n    return this.name.length;\n};\n\nAST_SymbolExportForeign.prototype._size = function () {\n    return this.name.length;\n};\n\nAST_This.prototype._size = () => 4;\n\nAST_Super.prototype._size = () => 5;\n\nAST_String.prototype._size = function () {\n    return this.value.length + 2;\n};\n\nAST_Number.prototype._size = function () {\n    const { value } = this;\n    if (value === 0) return 1;\n    if (value > 0 && Math.floor(value) === value) {\n        return Math.floor(Math.log10(value) + 1);\n    }\n    return value.toString().length;\n};\n\nAST_BigInt.prototype._size = function () {\n    return this.value.length;\n};\n\nAST_RegExp.prototype._size = function () {\n    return this.value.toString().length;\n};\n\nAST_Null.prototype._size = () => 4;\n\nAST_NaN.prototype._size = () => 3;\n\nAST_Undefined.prototype._size = () => 6; // \"void 0\"\n\nAST_Hole.prototype._size = () => 0;  // comma is taken into account by list_overhead()\n\nAST_Infinity.prototype._size = () => 8;\n\nAST_True.prototype._size = () => 4;\n\nAST_False.prototype._size = () => 5;\n\nAST_Await.prototype._size = () => 6;\n\nAST_Yield.prototype._size = () => 6;\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n// bitfield flags to be stored in node.flags.\n// These are set and unset during compression, and store information in the node without requiring multiple fields.\nconst UNUSED = 0b00000001;\nconst TRUTHY = 0b00000010;\nconst FALSY = 0b00000100;\nconst UNDEFINED = 0b00001000;\nconst INLINED = 0b00010000;\n// Nodes to which values are ever written. Used when keep_assign is part of the unused option string.\nconst WRITE_ONLY = 0b00100000;\n\n// information specific to a single compression pass\nconst SQUEEZED = 0b0000000100000000;\nconst OPTIMIZED = 0b0000001000000000;\nconst TOP = 0b0000010000000000;\nconst CLEAR_BETWEEN_PASSES = SQUEEZED | OPTIMIZED | TOP;\n\nconst has_flag = (node, flag) => node.flags & flag;\nconst set_flag = (node, flag) => { node.flags |= flag; };\nconst clear_flag = (node, flag) => { node.flags &= ~flag; };\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nfunction merge_sequence(array, node) {\n    if (node instanceof AST_Sequence) {\n        array.push(...node.expressions);\n    } else {\n        array.push(node);\n    }\n    return array;\n}\n\nfunction make_sequence(orig, expressions) {\n    if (expressions.length == 1) return expressions[0];\n    if (expressions.length == 0) throw new Error(\"trying to create a sequence with length zero!\");\n    return make_node(AST_Sequence, orig, {\n        expressions: expressions.reduce(merge_sequence, [])\n    });\n}\n\nfunction make_empty_function(self) {\n    return make_node(AST_Function, self, {\n        uses_arguments: false,\n        argnames: [],\n        body: [],\n        is_generator: false,\n        async: false,\n        variables: new Map(),\n        uses_with: false,\n        uses_eval: false,\n        parent_scope: null,\n        enclosed: [],\n        cname: 0,\n        block_scope: undefined,\n    });\n}\n\nfunction make_node_from_constant(val, orig) {\n    switch (typeof val) {\n      case \"string\":\n        return make_node(AST_String, orig, {\n            value: val\n        });\n      case \"number\":\n        if (isNaN(val)) return make_node(AST_NaN, orig);\n        if (isFinite(val)) {\n            return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {\n                operator: \"-\",\n                expression: make_node(AST_Number, orig, { value: -val })\n            }) : make_node(AST_Number, orig, { value: val });\n        }\n        return val < 0 ? make_node(AST_UnaryPrefix, orig, {\n            operator: \"-\",\n            expression: make_node(AST_Infinity, orig)\n        }) : make_node(AST_Infinity, orig);\n      case \"bigint\":\n        return make_node(AST_BigInt, orig, { value: val.toString() });\n      case \"boolean\":\n        return make_node(val ? AST_True : AST_False, orig);\n      case \"undefined\":\n        return make_node(AST_Undefined, orig);\n      default:\n        if (val === null) {\n            return make_node(AST_Null, orig, { value: null });\n        }\n        if (val instanceof RegExp) {\n            return make_node(AST_RegExp, orig, {\n                value: {\n                    source: regexp_source_fix(val.source),\n                    flags: val.flags\n                }\n            });\n        }\n        throw new Error(string_template(\"Can't handle constant of type: {type}\", {\n            type: typeof val\n        }));\n    }\n}\n\nfunction best_of_expression(ast1, ast2) {\n    return ast1.size() > ast2.size() ? ast2 : ast1;\n}\n\nfunction best_of_statement(ast1, ast2) {\n    return best_of_expression(\n        make_node(AST_SimpleStatement, ast1, {\n            body: ast1\n        }),\n        make_node(AST_SimpleStatement, ast2, {\n            body: ast2\n        })\n    ).body;\n}\n\n/** Find which node is smaller, and return that */\nfunction best_of(compressor, ast1, ast2) {\n    if (first_in_statement(compressor)) {\n        return best_of_statement(ast1, ast2);\n    } else {\n        return best_of_expression(ast1, ast2);\n    }\n}\n\n/** Simplify an object property's key, if possible */\nfunction get_simple_key(key) {\n    if (key instanceof AST_Constant) {\n        return key.getValue();\n    }\n    if (key instanceof AST_UnaryPrefix\n        && key.operator == \"void\"\n        && key.expression instanceof AST_Constant) {\n        return undefined;\n    }\n    return key;\n}\n\nfunction read_property(obj, key) {\n    key = get_simple_key(key);\n    if (key instanceof AST_Node) return;\n\n    var value;\n    if (obj instanceof AST_Array) {\n        var elements = obj.elements;\n        if (key == \"length\") return make_node_from_constant(elements.length, obj);\n        if (typeof key == \"number\" && key in elements) value = elements[key];\n    } else if (obj instanceof AST_Object) {\n        key = \"\" + key;\n        var props = obj.properties;\n        for (var i = props.length; --i >= 0;) {\n            var prop = props[i];\n            if (!(prop instanceof AST_ObjectKeyVal)) return;\n            if (!value && props[i].key === key) value = props[i].value;\n        }\n    }\n\n    return value instanceof AST_SymbolRef && value.fixed_value() || value;\n}\n\nfunction has_break_or_continue(loop, parent) {\n    var found = false;\n    var tw = new TreeWalker(function(node) {\n        if (found || node instanceof AST_Scope) return true;\n        if (node instanceof AST_LoopControl && tw.loopcontrol_target(node) === loop) {\n            return found = true;\n        }\n    });\n    if (parent instanceof AST_LabeledStatement) tw.push(parent);\n    tw.push(loop);\n    loop.body.walk(tw);\n    return found;\n}\n\n// we shouldn't compress (1,func)(something) to\n// func(something) because that changes the meaning of\n// the func (becomes lexical instead of global).\nfunction maintain_this_binding(parent, orig, val) {\n    if (requires_sequence_to_maintain_binding(parent, orig, val)) {\n        const zero = make_node(AST_Number, orig, { value: 0 });\n        return make_sequence(orig, [ zero, val ]);\n    } else {\n        return val;\n    }\n}\n\n/** Detect (1, x.noThis)(), (0, eval)(), which need sequences */\nfunction requires_sequence_to_maintain_binding(parent, orig, val) {\n    return (\n        parent instanceof AST_UnaryPrefix && parent.operator == \"delete\"\n        || parent instanceof AST_Call && parent.expression === orig\n            && (\n                val instanceof AST_Chain\n                || val instanceof AST_PropAccess\n                || val instanceof AST_SymbolRef && val.name == \"eval\"\n            )\n    );\n}\n\nfunction is_func_expr(node) {\n    return node instanceof AST_Arrow || node instanceof AST_Function;\n}\n\n/**\n * Used to determine whether the node can benefit from negation.\n * Not the case with arrow functions (you need an extra set of parens). */\nfunction is_iife_call(node) {\n    if (node.TYPE != \"Call\") return false;\n    return node.expression instanceof AST_Function || is_iife_call(node.expression);\n}\n\nfunction is_empty(thing) {\n    if (thing === null) return true;\n    if (thing instanceof AST_EmptyStatement) return true;\n    if (thing instanceof AST_BlockStatement) return thing.body.length == 0;\n    return false;\n}\n\nconst identifier_atom = makePredicate(\"Infinity NaN undefined\");\nfunction is_identifier_atom(node) {\n    return node instanceof AST_Infinity\n        || node instanceof AST_NaN\n        || node instanceof AST_Undefined;\n}\n\n/** Check if this is a SymbolRef node which has one def of a certain AST type */\nfunction is_ref_of(ref, type) {\n    if (!(ref instanceof AST_SymbolRef)) return false;\n    var orig = ref.definition().orig;\n    for (var i = orig.length; --i >= 0;) {\n        if (orig[i] instanceof type) return true;\n    }\n}\n\n/**Can we turn { block contents... } into just the block contents ?\n * Not if one of these is inside.\n **/\nfunction can_be_evicted_from_block(node) {\n    return !(\n        node instanceof AST_DefClass ||\n        node instanceof AST_Defun ||\n        node instanceof AST_Let ||\n        node instanceof AST_Const ||\n        node instanceof AST_Using ||\n        node instanceof AST_Export ||\n        node instanceof AST_Import\n    );\n}\n\nfunction as_statement_array(thing) {\n    if (thing === null) return [];\n    if (thing instanceof AST_BlockStatement) return thing.body;\n    if (thing instanceof AST_EmptyStatement) return [];\n    if (thing instanceof AST_Statement) return [ thing ];\n    throw new Error(\"Can't convert thing to statement array\");\n}\n\nfunction is_reachable(scope_node, defs) {\n    const find_ref = node => {\n        if (node instanceof AST_SymbolRef && defs.includes(node.definition())) {\n            return walk_abort;\n        }\n    };\n\n    return walk_parent(scope_node, (node, info) => {\n        if (node instanceof AST_Scope && node !== scope_node) {\n            var parent = info.parent();\n\n            if (\n                parent instanceof AST_Call\n                && parent.expression === node\n                // Async/Generators aren't guaranteed to sync evaluate all of\n                // their body steps, so it's possible they close over the variable.\n                && !(node.async || node.is_generator)\n            ) {\n                return;\n            }\n\n            if (walk(node, find_ref)) return walk_abort;\n\n            return true;\n        }\n    });\n}\n\n/** Check if a ref refers to the name of a function/class it's defined within */\nfunction is_recursive_ref(tw, def) {\n    var node;\n    for (var i = 0; node = tw.parent(i); i++) {\n        if (node instanceof AST_Lambda || node instanceof AST_Class) {\n            var name = node.name;\n            if (name && name.definition() === def) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// TODO this only works with AST_Defun, shouldn't it work for other ways of defining functions?\nfunction retain_top_func(fn, compressor) {\n    return compressor.top_retain\n        && fn instanceof AST_Defun\n        && has_flag(fn, TOP)\n        && fn.name\n        && compressor.top_retain(fn.name.definition());\n}\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n// Lists of native methods, useful for `unsafe` option which assumes they exist.\n// Note: Lots of methods and functions are missing here, in case they aren't pure\n// or not available in all JS environments.\n\nfunction make_nested_lookup(obj) {\n    const out = new Map();\n    for (var key of Object.keys(obj)) {\n        out.set(key, makePredicate(obj[key]));\n    }\n\n    const does_have = (global_name, fname) => {\n        const inner_map = out.get(global_name);\n        return inner_map != null && inner_map.has(fname);\n    };\n    return does_have;\n}\n\n// Objects which are safe to access without throwing or causing a side effect.\n// Usually we'd check the `unsafe` option first but these are way too common for that\nconst pure_prop_access_globals = new Set([\n    \"Number\",\n    \"String\",\n    \"Array\",\n    \"Object\",\n    \"Function\",\n    \"Promise\",\n]);\n\nconst object_methods = [\n    \"constructor\",\n    \"toString\",\n    \"valueOf\",\n];\n\nconst is_pure_native_method = make_nested_lookup({\n    Array: [\n        \"at\",\n        \"flat\",\n        \"includes\",\n        \"indexOf\",\n        \"join\",\n        \"lastIndexOf\",\n        \"slice\",\n        ...object_methods,\n    ],\n    Boolean: object_methods,\n    Function: object_methods,\n    Number: [\n        \"toExponential\",\n        \"toFixed\",\n        \"toPrecision\",\n        ...object_methods,\n    ],\n    Object: object_methods,\n    RegExp: [\n        \"test\",\n        ...object_methods,\n    ],\n    String: [\n        \"at\",\n        \"charAt\",\n        \"charCodeAt\",\n        \"charPointAt\",\n        \"concat\",\n        \"endsWith\",\n        \"fromCharCode\",\n        \"fromCodePoint\",\n        \"includes\",\n        \"indexOf\",\n        \"italics\",\n        \"lastIndexOf\",\n        \"localeCompare\",\n        \"match\",\n        \"matchAll\",\n        \"normalize\",\n        \"padStart\",\n        \"padEnd\",\n        \"repeat\",\n        \"replace\",\n        \"replaceAll\",\n        \"search\",\n        \"slice\",\n        \"split\",\n        \"startsWith\",\n        \"substr\",\n        \"substring\",\n        \"repeat\",\n        \"toLocaleLowerCase\",\n        \"toLocaleUpperCase\",\n        \"toLowerCase\",\n        \"toUpperCase\",\n        \"trim\",\n        \"trimEnd\",\n        \"trimStart\",\n        ...object_methods,\n    ],\n});\n\nconst is_pure_native_fn = make_nested_lookup({\n    Array: [\n        \"isArray\",\n    ],\n    Math: [\n        \"abs\",\n        \"acos\",\n        \"asin\",\n        \"atan\",\n        \"ceil\",\n        \"cos\",\n        \"exp\",\n        \"floor\",\n        \"log\",\n        \"round\",\n        \"sin\",\n        \"sqrt\",\n        \"tan\",\n        \"atan2\",\n        \"pow\",\n        \"max\",\n        \"min\",\n    ],\n    Number: [\n        \"isFinite\",\n        \"isNaN\",\n    ],\n    Object: [\n        \"create\",\n        \"getOwnPropertyDescriptor\",\n        \"getOwnPropertyNames\",\n        \"getPrototypeOf\",\n        \"isExtensible\",\n        \"isFrozen\",\n        \"isSealed\",\n        \"hasOwn\",\n        \"keys\",\n    ],\n    String: [\n        \"fromCharCode\",\n    ],\n});\n\n// Known numeric values which come with JS environments\nconst is_pure_native_value = make_nested_lookup({\n    Math: [\n        \"E\",\n        \"LN10\",\n        \"LN2\",\n        \"LOG2E\",\n        \"LOG10E\",\n        \"PI\",\n        \"SQRT1_2\",\n        \"SQRT2\",\n    ],\n    Number: [\n        \"MAX_VALUE\",\n        \"MIN_VALUE\",\n        \"NaN\",\n        \"NEGATIVE_INFINITY\",\n        \"POSITIVE_INFINITY\",\n    ],\n});\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n// Functions and methods to infer certain facts about expressions\n// It's not always possible to be 100% sure about something just by static analysis,\n// so `true` means yes, and `false` means maybe\n\nconst is_undeclared_ref = (node) =>\n    node instanceof AST_SymbolRef && node.definition().undeclared;\n\nconst bitwise_binop = makePredicate(\"<<< >> << & | ^ ~\");\nconst lazy_op = makePredicate(\"&& || ??\");\nconst unary_side_effects = makePredicate(\"delete ++ --\");\n\n// methods to determine whether an expression has a boolean result type\n(function(def_is_boolean) {\n    const unary_bool = makePredicate(\"! delete\");\n    const binary_bool = makePredicate(\"in instanceof == != === !== < <= >= >\");\n    def_is_boolean(AST_Node, return_false);\n    def_is_boolean(AST_UnaryPrefix, function() {\n        return unary_bool.has(this.operator);\n    });\n    def_is_boolean(AST_Binary, function() {\n        return binary_bool.has(this.operator)\n            || lazy_op.has(this.operator)\n                && this.left.is_boolean()\n                && this.right.is_boolean();\n    });\n    def_is_boolean(AST_Conditional, function() {\n        return this.consequent.is_boolean() && this.alternative.is_boolean();\n    });\n    def_is_boolean(AST_Assign, function() {\n        return this.operator == \"=\" && this.right.is_boolean();\n    });\n    def_is_boolean(AST_Sequence, function() {\n        return this.tail_node().is_boolean();\n    });\n    def_is_boolean(AST_True, return_true);\n    def_is_boolean(AST_False, return_true);\n})(function(node, func) {\n    node.DEFMETHOD(\"is_boolean\", func);\n});\n\n// methods to determine if an expression has a numeric result type\n(function(def_is_number) {\n    def_is_number(AST_Node, return_false);\n    def_is_number(AST_Number, return_true);\n    const unary = makePredicate(\"+ - ~ ++ --\");\n    def_is_number(AST_Unary, function(compressor) {\n        return unary.has(this.operator) && this.expression.is_number(compressor);\n    });\n    const numeric_ops = makePredicate(\"- * / % & | ^ << >> >>>\");\n    def_is_number(AST_Binary, function(compressor) {\n        if (this.operator === \"+\") {\n            // Both sides need to be `number`. Or one is a `number` and the other is number-ish.\n            return this.left.is_number(compressor) && this.right.is_number_or_bigint(compressor)\n                || this.right.is_number(compressor) && this.left.is_number_or_bigint(compressor);\n        } else if (numeric_ops.has(this.operator)) {\n            return this.left.is_number(compressor) || this.right.is_number(compressor);\n        } else {\n            return false;\n        }\n    });\n    def_is_number(AST_Assign, function(compressor) {\n        return (this.operator === \"=\" || numeric_ops.has(this.operator.slice(0, -1)))\n            && this.right.is_number(compressor);\n    });\n    def_is_number(AST_Sequence, function(compressor) {\n        return this.tail_node().is_number(compressor);\n    });\n    def_is_number(AST_Conditional, function(compressor) {\n        return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_number\", func);\n});\n\n// methods to determine if an expression returns a BigInt\n(function(def_is_bigint) {\n    def_is_bigint(AST_Node, return_false);\n    def_is_bigint(AST_BigInt, return_true);\n    const unary = makePredicate(\"+ - ~ ++ --\");\n    def_is_bigint(AST_Unary, function(compressor) {\n        return unary.has(this.operator) && this.expression.is_bigint(compressor);\n    });\n    const numeric_ops = makePredicate(\"- * / % & | ^ << >>\");\n    def_is_bigint(AST_Binary, function(compressor) {\n        if (this.operator === \"+\") {\n            return this.left.is_bigint(compressor) && this.right.is_number_or_bigint(compressor)\n                || this.right.is_bigint(compressor) && this.left.is_number_or_bigint(compressor);\n        } else if (numeric_ops.has(this.operator)) {\n            return this.left.is_bigint(compressor) || this.right.is_bigint(compressor);\n        } else {\n            return false;\n        }\n    });\n    def_is_bigint(AST_Assign, function(compressor) {\n        return (numeric_ops.has(this.operator.slice(0, -1)) || this.operator == \"=\")\n            && this.right.is_bigint(compressor);\n    });\n    def_is_bigint(AST_Sequence, function(compressor) {\n        return this.tail_node().is_bigint(compressor);\n    });\n    def_is_bigint(AST_Conditional, function(compressor) {\n        return this.consequent.is_bigint(compressor) && this.alternative.is_bigint(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_bigint\", func);\n});\n\n// methods to determine if an expression is a number or a bigint\n(function(def_is_number_or_bigint) {\n    def_is_number_or_bigint(AST_Node, return_false);\n    def_is_number_or_bigint(AST_Number, return_true);\n    def_is_number_or_bigint(AST_BigInt, return_true);\n    const numeric_unary_ops = makePredicate(\"+ - ~ ++ --\");\n    def_is_number_or_bigint(AST_Unary, function(_compressor) {\n        return numeric_unary_ops.has(this.operator);\n    });\n    const numeric_ops = makePredicate(\"- * / % & | ^ << >>\");\n    def_is_number_or_bigint(AST_Binary, function(compressor) {\n        return this.operator === \"+\"\n            ? this.left.is_number_or_bigint(compressor) && this.right.is_number_or_bigint(compressor)\n            : numeric_ops.has(this.operator);\n    });\n    def_is_number_or_bigint(AST_Assign, function(compressor) {\n        return numeric_ops.has(this.operator.slice(0, -1))\n            || this.operator == \"=\" && this.right.is_number_or_bigint(compressor);\n    });\n    def_is_number_or_bigint(AST_Sequence, function(compressor) {\n        return this.tail_node().is_number_or_bigint(compressor);\n    });\n    def_is_number_or_bigint(AST_Conditional, function(compressor) {\n        return this.consequent.is_number_or_bigint(compressor) && this.alternative.is_number_or_bigint(compressor);\n    });\n}(function (node, func) {\n    node.DEFMETHOD(\"is_number_or_bigint\", func);\n}));\n\n\n// methods to determine if an expression is a 32 bit integer (IE results from bitwise ops, or is an integer constant fitting in that size\n(function(def_is_32_bit_integer) {\n    def_is_32_bit_integer(AST_Node, return_false);\n    def_is_32_bit_integer(AST_Number, function(_compressor) {\n        return this.value === (this.value | 0);\n    });\n    def_is_32_bit_integer(AST_UnaryPrefix, function(compressor) {\n        return this.operator == \"~\" ? this.expression.is_number(compressor)\n            : this.operator === \"+\" ? this.expression.is_32_bit_integer(compressor)\n            : false;\n    });\n    def_is_32_bit_integer(AST_Binary, function(compressor) {\n        return bitwise_binop.has(this.operator)\n            && (this.left.is_number(compressor) || this.right.is_number(compressor));\n    });\n}(function (node, func) {\n    node.DEFMETHOD(\"is_32_bit_integer\", func);\n}));\n\n// methods to determine if an expression has a string result type\n(function(def_is_string) {\n    def_is_string(AST_Node, return_false);\n    def_is_string(AST_String, return_true);\n    def_is_string(AST_TemplateString, return_true);\n    def_is_string(AST_UnaryPrefix, function() {\n        return this.operator == \"typeof\";\n    });\n    def_is_string(AST_Binary, function(compressor) {\n        return this.operator == \"+\" &&\n            (this.left.is_string(compressor) || this.right.is_string(compressor));\n    });\n    def_is_string(AST_Assign, function(compressor) {\n        return (this.operator == \"=\" || this.operator == \"+=\") && this.right.is_string(compressor);\n    });\n    def_is_string(AST_Sequence, function(compressor) {\n        return this.tail_node().is_string(compressor);\n    });\n    def_is_string(AST_Conditional, function(compressor) {\n        return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_string\", func);\n});\n\nfunction is_undefined(node, compressor) {\n    return (\n        has_flag(node, UNDEFINED)\n        || node instanceof AST_Undefined\n        || node instanceof AST_UnaryPrefix\n            && node.operator == \"void\"\n            && !node.expression.has_side_effects(compressor)\n    );\n}\n\n// Is the node explicitly null or undefined.\nfunction is_null_or_undefined(node, compressor) {\n    let fixed;\n    return (\n        node instanceof AST_Null\n        || is_undefined(node, compressor)\n        || (\n            node instanceof AST_SymbolRef\n            && (fixed = node.definition().fixed) instanceof AST_Node\n            && is_nullish(fixed, compressor)\n        )\n    );\n}\n\n// Find out if this expression is optionally chained from a base-point that we\n// can statically analyze as null or undefined.\nfunction is_nullish_shortcircuited(node, compressor) {\n    if (node instanceof AST_PropAccess || node instanceof AST_Call) {\n        return (\n            (node.optional && is_null_or_undefined(node.expression, compressor))\n            || is_nullish_shortcircuited(node.expression, compressor)\n        );\n    }\n    if (node instanceof AST_Chain) return is_nullish_shortcircuited(node.expression, compressor);\n    return false;\n}\n\n// Find out if something is == null, or can short circuit into nullish.\n// Used to optimize ?. and ??\nfunction is_nullish(node, compressor) {\n    if (is_null_or_undefined(node, compressor)) return true;\n    return is_nullish_shortcircuited(node, compressor);\n}\n\n// Determine if expression might cause side effects\n// If there's a possibility that a node may change something when it's executed, this returns true\n(function(def_has_side_effects) {\n    def_has_side_effects(AST_Node, return_true);\n\n    def_has_side_effects(AST_EmptyStatement, return_false);\n    def_has_side_effects(AST_Constant, return_false);\n    def_has_side_effects(AST_This, return_false);\n\n    function any(list, compressor) {\n        for (var i = list.length; --i >= 0;)\n            if (list[i].has_side_effects(compressor))\n                return true;\n        return false;\n    }\n\n    def_has_side_effects(AST_Block, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Call, function(compressor) {\n        if (\n            !this.is_callee_pure(compressor)\n            && (!this.expression.is_call_pure(compressor)\n                || this.expression.has_side_effects(compressor))\n        ) {\n            return true;\n        }\n        return any(this.args, compressor);\n    });\n    def_has_side_effects(AST_Switch, function(compressor) {\n        return this.expression.has_side_effects(compressor)\n            || any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Case, function(compressor) {\n        return this.expression.has_side_effects(compressor)\n            || any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Try, function(compressor) {\n        return this.body.has_side_effects(compressor)\n            || this.bcatch && this.bcatch.has_side_effects(compressor)\n            || this.bfinally && this.bfinally.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_If, function(compressor) {\n        return this.condition.has_side_effects(compressor)\n            || this.body && this.body.has_side_effects(compressor)\n            || this.alternative && this.alternative.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_ImportMeta, return_false);\n    def_has_side_effects(AST_LabeledStatement, function(compressor) {\n        return this.body.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_SimpleStatement, function(compressor) {\n        return this.body.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Lambda, return_false);\n    def_has_side_effects(AST_Class, function (compressor) {\n        if (this.extends && this.extends.has_side_effects(compressor)) {\n            return true;\n        }\n        return any(this.properties, compressor);\n    });\n    def_has_side_effects(AST_ClassStaticBlock, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Binary, function(compressor) {\n        return this.left.has_side_effects(compressor)\n            || this.right.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Assign, return_true);\n    def_has_side_effects(AST_Conditional, function(compressor) {\n        return this.condition.has_side_effects(compressor)\n            || this.consequent.has_side_effects(compressor)\n            || this.alternative.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Unary, function(compressor) {\n        return unary_side_effects.has(this.operator)\n            || this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_SymbolRef, function(compressor) {\n        return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n    });\n    def_has_side_effects(AST_SymbolClassProperty, return_false);\n    def_has_side_effects(AST_SymbolDeclaration, return_false);\n    def_has_side_effects(AST_Object, function(compressor) {\n        return any(this.properties, compressor);\n    });\n    def_has_side_effects(AST_ObjectKeyVal, function(compressor) {\n        return (\n            this.computed_key() && this.key.has_side_effects(compressor)\n            || this.value && this.value.has_side_effects(compressor)\n        );\n    });\n    def_has_side_effects([\n        AST_ClassProperty,\n        AST_ClassPrivateProperty,\n    ], function(compressor) {\n        return (\n            this.computed_key() && this.key.has_side_effects(compressor)\n            || this.static && this.value && this.value.has_side_effects(compressor)\n        );\n    });\n    def_has_side_effects([\n        AST_PrivateMethod,\n        AST_PrivateGetter,\n        AST_PrivateSetter,\n        AST_ConciseMethod,\n        AST_ObjectGetter,\n        AST_ObjectSetter,\n    ], function(compressor) {\n        return this.computed_key() && this.key.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Array, function(compressor) {\n        return any(this.elements, compressor);\n    });\n    def_has_side_effects(AST_Dot, function(compressor) {\n        if (is_nullish(this, compressor)) {\n            return this.expression.has_side_effects(compressor);\n        }\n        if (!this.optional && this.expression.may_throw_on_access(compressor)) {\n            return true;\n        }\n\n        return this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Sub, function(compressor) {\n        if (is_nullish(this, compressor)) {\n            return this.expression.has_side_effects(compressor);\n        }\n        if (!this.optional && this.expression.may_throw_on_access(compressor)) {\n            return true;\n        }\n\n        var property = this.property.has_side_effects(compressor);\n        if (property && this.optional) return true; // \"?.\" is a condition\n\n        return property || this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Chain, function (compressor) {\n        return this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Sequence, function(compressor) {\n        return any(this.expressions, compressor);\n    });\n    def_has_side_effects(AST_Definitions, function(compressor) {\n        return any(this.definitions, compressor);\n    });\n    def_has_side_effects(AST_VarDef, function() {\n        return this.value != null;\n    });\n    def_has_side_effects(AST_TemplateSegment, return_false);\n    def_has_side_effects(AST_TemplateString, function(compressor) {\n        return any(this.segments, compressor);\n    });\n})(function(node_or_nodes, func) {\n    for (const node of [].concat(node_or_nodes)) {\n        node.DEFMETHOD(\"has_side_effects\", func);\n    }\n});\n\n// determine if expression may throw\n(function(def_may_throw) {\n    def_may_throw(AST_Node, return_true);\n\n    def_may_throw(AST_Constant, return_false);\n    def_may_throw(AST_EmptyStatement, return_false);\n    def_may_throw(AST_Lambda, return_false);\n    def_may_throw(AST_SymbolDeclaration, return_false);\n    def_may_throw(AST_This, return_false);\n    def_may_throw(AST_ImportMeta, return_false);\n\n    function any(list, compressor) {\n        for (var i = list.length; --i >= 0;)\n            if (list[i].may_throw(compressor))\n                return true;\n        return false;\n    }\n\n    def_may_throw(AST_Class, function(compressor) {\n        if (this.extends && this.extends.may_throw(compressor)) return true;\n        return any(this.properties, compressor);\n    });\n    def_may_throw(AST_ClassStaticBlock, function (compressor) {\n        return any(this.body, compressor);\n    });\n\n    def_may_throw(AST_Array, function(compressor) {\n        return any(this.elements, compressor);\n    });\n    def_may_throw(AST_Assign, function(compressor) {\n        if (this.right.may_throw(compressor)) return true;\n        if (!compressor.has_directive(\"use strict\")\n            && this.operator == \"=\"\n            && this.left instanceof AST_SymbolRef) {\n            return false;\n        }\n        return this.left.may_throw(compressor);\n    });\n    def_may_throw(AST_Binary, function(compressor) {\n        return this.left.may_throw(compressor)\n            || this.right.may_throw(compressor);\n    });\n    def_may_throw(AST_Block, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_may_throw(AST_Call, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n        if (any(this.args, compressor)) return true;\n        if (this.is_callee_pure(compressor)) return false;\n        if (this.expression.may_throw(compressor)) return true;\n        return !(this.expression instanceof AST_Lambda)\n            || any(this.expression.body, compressor);\n    });\n    def_may_throw(AST_Case, function(compressor) {\n        return this.expression.may_throw(compressor)\n            || any(this.body, compressor);\n    });\n    def_may_throw(AST_Conditional, function(compressor) {\n        return this.condition.may_throw(compressor)\n            || this.consequent.may_throw(compressor)\n            || this.alternative.may_throw(compressor);\n    });\n    def_may_throw(AST_Definitions, function(compressor) {\n        return any(this.definitions, compressor);\n    });\n    def_may_throw(AST_If, function(compressor) {\n        return this.condition.may_throw(compressor)\n            || this.body && this.body.may_throw(compressor)\n            || this.alternative && this.alternative.may_throw(compressor);\n    });\n    def_may_throw(AST_LabeledStatement, function(compressor) {\n        return this.body.may_throw(compressor);\n    });\n    def_may_throw(AST_Object, function(compressor) {\n        return any(this.properties, compressor);\n    });\n    def_may_throw(AST_ObjectKeyVal, function(compressor) {\n        return (\n            this.computed_key() && this.key.may_throw(compressor)\n            || this.value ? this.value.may_throw(compressor) : false\n        );\n    });\n    def_may_throw([\n        AST_ClassProperty,\n        AST_ClassPrivateProperty,\n    ], function(compressor) {\n        return (\n            this.computed_key() && this.key.may_throw(compressor)\n            || this.static && this.value && this.value.may_throw(compressor)\n        );\n    });\n    def_may_throw([\n        AST_ConciseMethod,\n        AST_ObjectGetter,\n        AST_ObjectSetter,\n    ], function(compressor) {\n        return this.computed_key() && this.key.may_throw(compressor);\n    });\n    def_may_throw([\n        AST_PrivateMethod,\n        AST_PrivateGetter,\n        AST_PrivateSetter,\n    ], return_false);\n    def_may_throw(AST_Return, function(compressor) {\n        return this.value && this.value.may_throw(compressor);\n    });\n    def_may_throw(AST_Sequence, function(compressor) {\n        return any(this.expressions, compressor);\n    });\n    def_may_throw(AST_SimpleStatement, function(compressor) {\n        return this.body.may_throw(compressor);\n    });\n    def_may_throw(AST_Dot, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_Sub, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.may_throw(compressor)\n            || this.property.may_throw(compressor);\n    });\n    def_may_throw(AST_Chain, function(compressor) {\n        return this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_Switch, function(compressor) {\n        return this.expression.may_throw(compressor)\n            || any(this.body, compressor);\n    });\n    def_may_throw(AST_SymbolRef, function(compressor) {\n        return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n    });\n    def_may_throw(AST_SymbolClassProperty, return_false);\n    def_may_throw(AST_Try, function(compressor) {\n        return this.bcatch ? this.bcatch.may_throw(compressor) : this.body.may_throw(compressor)\n            || this.bfinally && this.bfinally.may_throw(compressor);\n    });\n    def_may_throw(AST_Unary, function(compressor) {\n        if (this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef)\n            return false;\n        return this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_VarDef, function(compressor) {\n        if (!this.value) return false;\n        return this.value.may_throw(compressor);\n    });\n})(function(node_or_nodes, func) {\n    for (const node of [].concat(node_or_nodes)) {\n        node.DEFMETHOD(\"may_throw\", func);\n    }\n});\n\n// determine if expression is constant\n(function(def_is_constant_expression) {\n    function all_refs_local(scope) {\n        let result = true;\n        walk(this, node => {\n            if (node instanceof AST_SymbolRef) {\n                if (has_flag(this, INLINED)) {\n                    result = false;\n                    return walk_abort;\n                }\n                var def = node.definition();\n                if (\n                    member(def, this.enclosed)\n                    && !this.variables.has(def.name)\n                ) {\n                    if (scope) {\n                        var scope_def = scope.find_variable(node);\n                        if (def.undeclared ? !scope_def : scope_def === def) {\n                            result = \"f\";\n                            return true;\n                        }\n                    }\n                    result = false;\n                    return walk_abort;\n                }\n                return true;\n            }\n            if (node instanceof AST_This && this instanceof AST_Arrow) {\n                result = false;\n                return walk_abort;\n            }\n        });\n        return result;\n    }\n\n    def_is_constant_expression(AST_Node, return_false);\n    def_is_constant_expression(AST_Constant, return_true);\n    def_is_constant_expression(AST_Class, function(scope) {\n        if (this.extends && !this.extends.is_constant_expression(scope)) {\n            return false;\n        }\n\n        for (const prop of this.properties) {\n            if (prop.computed_key() && !prop.key.is_constant_expression(scope)) {\n                return false;\n            }\n            if (prop.static && prop.value && !prop.value.is_constant_expression(scope)) {\n                return false;\n            }\n            if (prop instanceof AST_ClassStaticBlock) {\n                return false;\n            }\n        }\n\n        return all_refs_local.call(this, scope);\n    });\n    def_is_constant_expression(AST_Lambda, all_refs_local);\n    def_is_constant_expression(AST_Unary, function() {\n        return this.expression.is_constant_expression();\n    });\n    def_is_constant_expression(AST_Binary, function() {\n        return this.left.is_constant_expression()\n            && this.right.is_constant_expression();\n    });\n    def_is_constant_expression(AST_Array, function() {\n        return this.elements.every((l) => l.is_constant_expression());\n    });\n    def_is_constant_expression(AST_Object, function() {\n        return this.properties.every((l) => l.is_constant_expression());\n    });\n    def_is_constant_expression(AST_ObjectProperty, function() {\n        return !!(!(this.key instanceof AST_Node) && this.value && this.value.is_constant_expression());\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_constant_expression\", func);\n});\n\n\n// may_throw_on_access()\n// returns true if this node may be null, undefined or contain `AST_Accessor`\n(function(def_may_throw_on_access) {\n    AST_Node.DEFMETHOD(\"may_throw_on_access\", function(compressor) {\n        return !compressor.option(\"pure_getters\")\n            || this._dot_throw(compressor);\n    });\n\n    function is_strict(compressor) {\n        return /strict/.test(compressor.option(\"pure_getters\"));\n    }\n\n    def_may_throw_on_access(AST_Node, is_strict);\n    def_may_throw_on_access(AST_Null, return_true);\n    def_may_throw_on_access(AST_Undefined, return_true);\n    def_may_throw_on_access(AST_Constant, return_false);\n    def_may_throw_on_access(AST_Array, return_false);\n    def_may_throw_on_access(AST_Object, function(compressor) {\n        if (!is_strict(compressor)) return false;\n        for (var i = this.properties.length; --i >=0;)\n            if (this.properties[i]._dot_throw(compressor)) return true;\n        return false;\n    });\n    // Do not be as strict with classes as we are with objects.\n    // Hopefully the community is not going to abuse static getters and setters.\n    // https://github.com/terser/terser/issues/724#issuecomment-643655656\n    def_may_throw_on_access(AST_Class, return_false);\n    def_may_throw_on_access(AST_ObjectProperty, return_false);\n    def_may_throw_on_access(AST_ObjectGetter, return_true);\n    def_may_throw_on_access(AST_Expansion, function(compressor) {\n        return this.expression._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Function, return_false);\n    def_may_throw_on_access(AST_Arrow, return_false);\n    def_may_throw_on_access(AST_UnaryPostfix, return_false);\n    def_may_throw_on_access(AST_UnaryPrefix, function() {\n        return this.operator == \"void\";\n    });\n    def_may_throw_on_access(AST_Binary, function(compressor) {\n        return (this.operator == \"&&\" || this.operator == \"||\" || this.operator == \"??\")\n            && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));\n    });\n    def_may_throw_on_access(AST_Assign, function(compressor) {\n        if (this.logical) return true;\n\n        return this.operator == \"=\"\n            && this.right._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Conditional, function(compressor) {\n        return this.consequent._dot_throw(compressor)\n            || this.alternative._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Dot, function(compressor) {\n        if (!is_strict(compressor)) return false;\n\n        if (this.property == \"prototype\") {\n            return !(\n                this.expression instanceof AST_Function\n                || this.expression instanceof AST_Class\n            );\n        }\n        return true;\n    });\n    def_may_throw_on_access(AST_Chain, function(compressor) {\n        return this.expression._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Sequence, function(compressor) {\n        return this.tail_node()._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_SymbolRef, function(compressor) {\n        if (this.name === \"arguments\" && this.scope instanceof AST_Lambda) return false;\n        if (has_flag(this, UNDEFINED)) return true;\n        if (!is_strict(compressor)) return false;\n        if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;\n        if (this.is_immutable()) return false;\n        var fixed = this.fixed_value();\n        return !fixed || fixed._dot_throw(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"_dot_throw\", func);\n});\n\nfunction is_lhs(node, parent) {\n    if (parent instanceof AST_Unary && unary_side_effects.has(parent.operator)) return parent.expression;\n    if (parent instanceof AST_Assign && parent.left === node) return node;\n    if (parent instanceof AST_ForIn && parent.init === node) return node;\n}\n\n// method to negate an expression\n(function(def_negate) {\n    function basic_negation(exp) {\n        return make_node(AST_UnaryPrefix, exp, {\n            operator: \"!\",\n            expression: exp\n        });\n    }\n    function best(orig, alt, first_in_statement) {\n        var negated = basic_negation(orig);\n        if (first_in_statement) {\n            var stat = make_node(AST_SimpleStatement, alt, {\n                body: alt\n            });\n            return best_of_expression(negated, stat) === stat ? alt : negated;\n        }\n        return best_of_expression(negated, alt);\n    }\n    def_negate(AST_Node, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_Statement, function() {\n        throw new Error(\"Cannot negate a statement\");\n    });\n    def_negate(AST_Function, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_Class, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_Arrow, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_UnaryPrefix, function() {\n        if (this.operator == \"!\")\n            return this.expression;\n        return basic_negation(this);\n    });\n    def_negate(AST_Sequence, function(compressor) {\n        var expressions = this.expressions.slice();\n        expressions.push(expressions.pop().negate(compressor));\n        return make_sequence(this, expressions);\n    });\n    def_negate(AST_Conditional, function(compressor, first_in_statement) {\n        var self = this.clone();\n        self.consequent = self.consequent.negate(compressor);\n        self.alternative = self.alternative.negate(compressor);\n        return best(this, self, first_in_statement);\n    });\n    def_negate(AST_Binary, function(compressor, first_in_statement) {\n        var self = this.clone(), op = this.operator;\n        if (compressor.option(\"unsafe_comps\")) {\n            switch (op) {\n              case \"<=\" : self.operator = \">\"  ; return self;\n              case \"<\"  : self.operator = \">=\" ; return self;\n              case \">=\" : self.operator = \"<\"  ; return self;\n              case \">\"  : self.operator = \"<=\" ; return self;\n            }\n        }\n        switch (op) {\n          case \"==\" : self.operator = \"!=\"; return self;\n          case \"!=\" : self.operator = \"==\"; return self;\n          case \"===\": self.operator = \"!==\"; return self;\n          case \"!==\": self.operator = \"===\"; return self;\n          case \"&&\":\n            self.operator = \"||\";\n            self.left = self.left.negate(compressor, first_in_statement);\n            self.right = self.right.negate(compressor);\n            return best(this, self, first_in_statement);\n          case \"||\":\n            self.operator = \"&&\";\n            self.left = self.left.negate(compressor, first_in_statement);\n            self.right = self.right.negate(compressor);\n            return best(this, self, first_in_statement);\n        }\n        return basic_negation(this);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"negate\", function(compressor, first_in_statement) {\n        return func.call(this, compressor, first_in_statement);\n    });\n});\n\n(function (def_bitwise_negate) {\n    function basic_bitwise_negation(exp) {\n        return make_node(AST_UnaryPrefix, exp, {\n            operator: \"~\",\n            expression: exp\n        });\n    }\n\n    def_bitwise_negate(AST_Node, function(_compressor) {\n        return basic_bitwise_negation(this);\n    });\n\n    def_bitwise_negate(AST_Number, function(_compressor) {\n        const neg = ~this.value;\n        if (neg.toString().length > this.value.toString().length) {\n            return basic_bitwise_negation(this);\n        }\n        return make_node(AST_Number, this, { value: neg });\n    });\n\n    def_bitwise_negate(AST_UnaryPrefix, function(compressor, in_32_bit_context) {\n        if (\n            this.operator == \"~\"\n            && (\n                this.expression.is_32_bit_integer(compressor) ||\n                (in_32_bit_context != null ? in_32_bit_context : compressor.in_32_bit_context())\n            )\n        ) {\n            return this.expression;\n        } else {\n            return basic_bitwise_negation(this);\n        }\n    });\n})(function (node, func) {\n    node.DEFMETHOD(\"bitwise_negate\", func);\n});\n\n// Is the callee of this function pure?\nvar global_pure_fns = makePredicate(\"Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError\");\nAST_Call.DEFMETHOD(\"is_callee_pure\", function(compressor) {\n    if (compressor.option(\"unsafe\")) {\n        var expr = this.expression;\n        var first_arg = (this.args && this.args[0] && this.args[0].evaluate(compressor));\n        if (\n            expr.expression && expr.expression.name === \"hasOwnProperty\" &&\n            (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)\n        ) {\n            return false;\n        }\n        if (is_undeclared_ref(expr) && global_pure_fns.has(expr.name)) return true;\n        if (\n            expr instanceof AST_Dot\n            && is_undeclared_ref(expr.expression)\n            && is_pure_native_fn(expr.expression.name, expr.property)\n        ) {\n            return true;\n        }\n    }\n    if ((this instanceof AST_New) && compressor.option(\"pure_new\")) {\n        return true;\n    }\n    if (compressor.option(\"side_effects\") && has_annotation(this, _PURE)) {\n        return true;\n    }\n    return !compressor.pure_funcs(this);\n});\n\n// If I call this, is it a pure function?\nAST_Node.DEFMETHOD(\"is_call_pure\", return_false);\nAST_Dot.DEFMETHOD(\"is_call_pure\", function(compressor) {\n    if (!compressor.option(\"unsafe\")) return;\n    const expr = this.expression;\n\n    let native_obj;\n    if (expr instanceof AST_Array) {\n        native_obj = \"Array\";\n    } else if (expr.is_boolean()) {\n        native_obj = \"Boolean\";\n    } else if (expr.is_number(compressor)) {\n        native_obj = \"Number\";\n    } else if (expr instanceof AST_RegExp) {\n        native_obj = \"RegExp\";\n    } else if (expr.is_string(compressor)) {\n        native_obj = \"String\";\n    } else if (!this.may_throw_on_access(compressor)) {\n        native_obj = \"Object\";\n    }\n    return native_obj != null && is_pure_native_method(native_obj, this.property);\n});\n\n// tell me if a statement aborts\nconst aborts = (thing) => thing && thing.aborts();\n\n(function(def_aborts) {\n    def_aborts(AST_Statement, return_null);\n    def_aborts(AST_Jump, return_this);\n    function block_aborts() {\n        for (var i = 0; i < this.body.length; i++) {\n            if (aborts(this.body[i])) {\n                return this.body[i];\n            }\n        }\n        return null;\n    }\n    def_aborts(AST_Import, return_null);\n    def_aborts(AST_BlockStatement, block_aborts);\n    def_aborts(AST_SwitchBranch, block_aborts);\n    def_aborts(AST_DefClass, function () {\n        for (const prop of this.properties) {\n            if (prop instanceof AST_ClassStaticBlock) {\n                if (prop.aborts()) return prop;\n            }\n        }\n        return null;\n    });\n    def_aborts(AST_ClassStaticBlock, block_aborts);\n    def_aborts(AST_If, function() {\n        return this.alternative && aborts(this.body) && aborts(this.alternative) && this;\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"aborts\", func);\n});\n\nAST_Node.DEFMETHOD(\"contains_this\", function() {\n    return walk(this, node => {\n        if (node instanceof AST_This) return walk_abort;\n        if (\n            node !== this\n            && node instanceof AST_Scope\n            && !(node instanceof AST_Arrow)\n        ) {\n            return true;\n        }\n    });\n});\n\nfunction is_modified(compressor, tw, node, value, level, immutable) {\n    var parent = tw.parent(level);\n    var lhs = is_lhs(node, parent);\n    if (lhs) return lhs;\n    if (!immutable\n        && parent instanceof AST_Call\n        && parent.expression === node\n        && !(value instanceof AST_Arrow)\n        && !(value instanceof AST_Class)\n        && !parent.is_callee_pure(compressor)\n        && (!(value instanceof AST_Function)\n            || !(parent instanceof AST_New) && value.contains_this())) {\n        return true;\n    }\n    if (parent instanceof AST_Array) {\n        return is_modified(compressor, tw, parent, parent, level + 1);\n    }\n    if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n        var obj = tw.parent(level + 1);\n        return is_modified(compressor, tw, obj, obj, level + 2);\n    }\n    if (parent instanceof AST_PropAccess && parent.expression === node) {\n        var prop = read_property(value, parent.property);\n        return !immutable && is_modified(compressor, tw, parent, prop, level + 1);\n    }\n}\n\n/**\n * Check if a node may be used by the expression it's in\n * void (0, 1, {node}, 2) -> false\n * console.log(0, {node}) -> true\n */\nfunction is_used_in_expression(tw) {\n    for (let p = -1, node, parent; node = tw.parent(p), parent = tw.parent(p + 1); p++) {\n        if (parent instanceof AST_Sequence) {\n            const nth_expression = parent.expressions.indexOf(node);\n            if (nth_expression !== parent.expressions.length - 1) {\n                // Detect (0, x.noThis)() constructs\n                const grandparent = tw.parent(p + 2);\n                if (\n                    parent.expressions.length > 2\n                    || parent.expressions.length === 1\n                    || !requires_sequence_to_maintain_binding(grandparent, parent, parent.expressions[1])\n                ) {\n                    return false;\n                }\n                return true;\n            } else {\n                continue;\n            }\n        }\n        if (parent instanceof AST_Unary) {\n            const op = parent.operator;\n            if (op === \"void\") {\n                return false;\n            }\n            if (op === \"typeof\" || op === \"+\" || op === \"-\" || op === \"!\" || op === \"~\") {\n                continue;\n            }\n        }\n        if (\n            parent instanceof AST_SimpleStatement\n            || parent instanceof AST_LabeledStatement\n        ) {\n            return false;\n        }\n        if (parent instanceof AST_Scope) {\n            return false;\n        }\n        return true;\n    }\n\n    return true;\n}\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n// methods to evaluate a constant expression\n\nfunction def_eval(node, func) {\n    node.DEFMETHOD(\"_eval\", func);\n}\n\n// Used to propagate a nullish short-circuit signal upwards through the chain.\nconst nullish = Symbol(\"This AST_Chain is nullish\");\n\n// If the node has been successfully reduced to a constant,\n// then its value is returned; otherwise the element itself\n// is returned.\n// They can be distinguished as constant value is never a\n// descendant of AST_Node.\nAST_Node.DEFMETHOD(\"evaluate\", function (compressor) {\n    if (!compressor.option(\"evaluate\"))\n        return this;\n    var val = this._eval(compressor, 1);\n    if (!val || val instanceof RegExp)\n        return val;\n    if (typeof val == \"function\" || typeof val == \"object\" || val == nullish)\n        return this;\n\n    // Evaluated strings can be larger than the original expression\n    if (typeof val === \"string\") {\n        const unevaluated_size = this.size(compressor);\n        if (val.length + 2 > unevaluated_size) return this;\n    }\n\n    return val;\n});\n\nvar unaryPrefix = makePredicate(\"! ~ - + void\");\nAST_Node.DEFMETHOD(\"is_constant\", function () {\n    // Accomodate when compress option evaluate=false\n    // as well as the common constant expressions !0 and -1\n    if (this instanceof AST_Constant) {\n        return !(this instanceof AST_RegExp);\n    } else {\n        return this instanceof AST_UnaryPrefix\n            && unaryPrefix.has(this.operator)\n            && (\n                // `this.expression` may be an `AST_RegExp`,\n                // so not only `.is_constant()`.\n                this.expression instanceof AST_Constant\n                || this.expression.is_constant()\n            );\n    }\n});\n\ndef_eval(AST_Statement, function () {\n    throw new Error(string_template(\"Cannot evaluate a statement [{file}:{line},{col}]\", this.start));\n});\n\ndef_eval(AST_Lambda, return_this);\ndef_eval(AST_Class, return_this);\ndef_eval(AST_Node, return_this);\ndef_eval(AST_Constant, function () {\n    return this.getValue();\n});\n\nconst supports_bigint = typeof BigInt === \"function\";\ndef_eval(AST_BigInt, function () {\n    if (supports_bigint) {\n        return BigInt(this.value);\n    } else {\n        return this;\n    }\n});\n\ndef_eval(AST_RegExp, function (compressor) {\n    let evaluated = compressor.evaluated_regexps.get(this.value);\n    if (evaluated === undefined && regexp_is_safe(this.value.source)) {\n        try {\n            const { source, flags } = this.value;\n            evaluated = new RegExp(source, flags);\n        } catch (e) {\n            evaluated = null;\n        }\n        compressor.evaluated_regexps.set(this.value, evaluated);\n    }\n    return evaluated || this;\n});\n\ndef_eval(AST_TemplateString, function () {\n    if (this.segments.length !== 1) return this;\n    return this.segments[0].value;\n});\n\ndef_eval(AST_Function, function (compressor) {\n    if (compressor.option(\"unsafe\")) {\n        var fn = function () { };\n        fn.node = this;\n        fn.toString = () => this.print_to_string();\n        return fn;\n    }\n    return this;\n});\n\ndef_eval(AST_Array, function (compressor, depth) {\n    if (compressor.option(\"unsafe\")) {\n        var elements = [];\n        for (var i = 0, len = this.elements.length; i < len; i++) {\n            var element = this.elements[i];\n            var value = element._eval(compressor, depth);\n            if (element === value)\n                return this;\n            elements.push(value);\n        }\n        return elements;\n    }\n    return this;\n});\n\ndef_eval(AST_Object, function (compressor, depth) {\n    if (compressor.option(\"unsafe\")) {\n        var val = {};\n        for (var i = 0, len = this.properties.length; i < len; i++) {\n            var prop = this.properties[i];\n            if (prop instanceof AST_Expansion)\n                return this;\n            var key = prop.key;\n            if (key instanceof AST_Symbol) {\n                key = key.name;\n            } else if (key instanceof AST_Node) {\n                key = key._eval(compressor, depth);\n                if (key === prop.key)\n                    return this;\n            }\n            if (typeof Object.prototype[key] === \"function\") {\n                return this;\n            }\n            if (prop.value instanceof AST_Function)\n                continue;\n            val[key] = prop.value._eval(compressor, depth);\n            if (val[key] === prop.value)\n                return this;\n        }\n        return val;\n    }\n    return this;\n});\n\nvar non_converting_unary = makePredicate(\"! typeof void\");\ndef_eval(AST_UnaryPrefix, function (compressor, depth) {\n    var e = this.expression;\n    if (compressor.option(\"typeofs\")\n        && this.operator == \"typeof\") {\n        // Function would be evaluated to an array and so typeof would\n        // incorrectly return 'object'. Hence making is a special case.\n        if (e instanceof AST_Lambda\n            || e instanceof AST_SymbolRef\n            && e.fixed_value() instanceof AST_Lambda) {\n            return typeof function () { };\n        }\n        if (\n            (e instanceof AST_Object\n                || e instanceof AST_Array\n                || (e instanceof AST_SymbolRef\n                    && (e.fixed_value() instanceof AST_Object\n                        || e.fixed_value() instanceof AST_Array)))\n            && !e.has_side_effects(compressor)\n        ) {\n            return typeof {};\n        }\n    }\n    if (!non_converting_unary.has(this.operator))\n        depth++;\n    e = e._eval(compressor, depth);\n    if (e === this.expression)\n        return this;\n    switch (this.operator) {\n        case \"!\": return !e;\n        case \"typeof\":\n            // typeof <RegExp> returns \"object\" or \"function\" on different platforms\n            // so cannot evaluate reliably\n            if (e instanceof RegExp)\n                return this;\n            return typeof e;\n        case \"void\": return void e;\n        case \"~\": return ~e;\n        case \"-\": return -e;\n        case \"+\": return +e;\n    }\n    return this;\n});\n\nvar non_converting_binary = makePredicate(\"&& || ?? === !==\");\nconst identity_comparison = makePredicate(\"== != === !==\");\nconst has_identity = value => typeof value === \"object\"\n    || typeof value === \"function\"\n    || typeof value === \"symbol\";\n\ndef_eval(AST_Binary, function (compressor, depth) {\n    if (!non_converting_binary.has(this.operator))\n        depth++;\n\n    var left = this.left._eval(compressor, depth);\n    if (left === this.left)\n        return this;\n    var right = this.right._eval(compressor, depth);\n    if (right === this.right)\n        return this;\n\n    if (left != null\n        && right != null\n        && identity_comparison.has(this.operator)\n        && has_identity(left)\n        && has_identity(right)\n        && typeof left === typeof right) {\n        // Do not compare by reference\n        return this;\n    }\n\n    // Do not mix BigInt and Number; Don't use `>>>` on BigInt or `/ 0n`\n    if (\n        (typeof left === \"bigint\") !== (typeof right === \"bigint\")\n        || typeof left === \"bigint\"\n            && (this.operator === \">>>\"\n                || this.operator === \"/\" && Number(right) === 0)\n    ) {\n        return this;\n    }\n\n    var result;\n    switch (this.operator) {\n        case \"&&\": result = left && right; break;\n        case \"||\": result = left || right; break;\n        case \"??\": result = left != null ? left : right; break;\n        case \"|\": result = left | right; break;\n        case \"&\": result = left & right; break;\n        case \"^\": result = left ^ right; break;\n        case \"+\": result = left + right; break;\n        case \"*\": result = left * right; break;\n        case \"**\": result = left ** right; break;\n        case \"/\": result = left / right; break;\n        case \"%\": result = left % right; break;\n        case \"-\": result = left - right; break;\n        case \"<<\": result = left << right; break;\n        case \">>\": result = left >> right; break;\n        case \">>>\": result = left >>> right; break;\n        case \"==\": result = left == right; break;\n        case \"===\": result = left === right; break;\n        case \"!=\": result = left != right; break;\n        case \"!==\": result = left !== right; break;\n        case \"<\": result = left < right; break;\n        case \"<=\": result = left <= right; break;\n        case \">\": result = left > right; break;\n        case \">=\": result = left >= right; break;\n        default:\n            return this;\n    }\n    if (typeof result === \"number\" && isNaN(result) && compressor.find_parent(AST_With)) {\n        // leave original expression as is\n        return this;\n    }\n    return result;\n});\n\ndef_eval(AST_Conditional, function (compressor, depth) {\n    var condition = this.condition._eval(compressor, depth);\n    if (condition === this.condition)\n        return this;\n    var node = condition ? this.consequent : this.alternative;\n    var value = node._eval(compressor, depth);\n    return value === node ? this : value;\n});\n\n// Set of AST_SymbolRef which are currently being evaluated.\n// Avoids infinite recursion of ._eval()\nconst reentrant_ref_eval = new Set();\ndef_eval(AST_SymbolRef, function (compressor, depth) {\n    if (reentrant_ref_eval.has(this))\n        return this;\n\n    var fixed = this.fixed_value();\n    if (!fixed)\n        return this;\n\n    reentrant_ref_eval.add(this);\n    const value = fixed._eval(compressor, depth);\n    reentrant_ref_eval.delete(this);\n\n    if (value === fixed)\n        return this;\n\n    if (value && typeof value == \"object\") {\n        var escaped = this.definition().escaped;\n        if (escaped && depth > escaped)\n            return this;\n    }\n    return value;\n});\n\nconst global_objs = { Array, Math, Number, Object, String };\n\nconst regexp_flags = new Set([\n    \"dotAll\",\n    \"global\",\n    \"ignoreCase\",\n    \"multiline\",\n    \"sticky\",\n    \"unicode\",\n]);\n\ndef_eval(AST_PropAccess, function (compressor, depth) {\n    let obj = this.expression._eval(compressor, depth + 1);\n    if (obj === nullish || (this.optional && obj == null)) return nullish;\n\n    // `.length` of strings and arrays is always safe\n    if (this.property === \"length\") {\n        if (typeof obj === \"string\") {\n            return obj.length;\n        }\n\n        const is_spreadless_array =\n            obj instanceof AST_Array\n            && obj.elements.every(el => !(el instanceof AST_Expansion));\n\n        if (\n            is_spreadless_array\n            && obj.elements.every(el => !el.has_side_effects(compressor))\n        ) {\n            return obj.elements.length;\n        }\n    }\n\n    if (compressor.option(\"unsafe\")) {\n        var key = this.property;\n        if (key instanceof AST_Node) {\n            key = key._eval(compressor, depth);\n            if (key === this.property)\n                return this;\n        }\n\n        var exp = this.expression;\n        if (is_undeclared_ref(exp)) {\n            var aa;\n            var first_arg = exp.name === \"hasOwnProperty\"\n                && key === \"call\"\n                && (aa = compressor.parent() && compressor.parent().args)\n                && (aa && aa[0]\n                    && aa[0].evaluate(compressor));\n\n            first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;\n\n            if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {\n                return this.clone();\n            }\n            if (!is_pure_native_value(exp.name, key))\n                return this;\n            obj = global_objs[exp.name];\n        } else {\n            if (obj instanceof RegExp) {\n                if (key == \"source\") {\n                    return regexp_source_fix(obj.source);\n                } else if (key == \"flags\" || regexp_flags.has(key)) {\n                    return obj[key];\n                }\n            }\n            if (!obj || obj === exp || !HOP(obj, key))\n                return this;\n\n            if (typeof obj == \"function\")\n                switch (key) {\n                    case \"name\":\n                        return obj.node.name ? obj.node.name.name : \"\";\n                    case \"length\":\n                        return obj.node.length_property();\n                    default:\n                        return this;\n                }\n        }\n        return obj[key];\n    }\n    return this;\n});\n\ndef_eval(AST_Chain, function (compressor, depth) {\n    const evaluated = this.expression._eval(compressor, depth);\n    return evaluated === nullish\n        ? undefined\n        : evaluated === this.expression\n          ? this\n          : evaluated;\n});\n\ndef_eval(AST_Call, function (compressor, depth) {\n    var exp = this.expression;\n\n    const callee = exp._eval(compressor, depth);\n    if (callee === nullish || (this.optional && callee == null)) return nullish;\n\n    if (compressor.option(\"unsafe\") && exp instanceof AST_PropAccess) {\n        var key = exp.property;\n        if (key instanceof AST_Node) {\n            key = key._eval(compressor, depth);\n            if (key === exp.property)\n                return this;\n        }\n        var val;\n        var e = exp.expression;\n        if (is_undeclared_ref(e)) {\n            var first_arg = e.name === \"hasOwnProperty\" &&\n                key === \"call\" &&\n                (this.args[0] && this.args[0].evaluate(compressor));\n\n            first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;\n\n            if ((first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)) {\n                return this.clone();\n            }\n            if (!is_pure_native_fn(e.name, key)) return this;\n            val = global_objs[e.name];\n        } else {\n            val = e._eval(compressor, depth + 1);\n            if (val === e || !val)\n                return this;\n            if (!is_pure_native_method(val.constructor.name, key))\n                return this;\n        }\n        var args = [];\n        for (var i = 0, len = this.args.length; i < len; i++) {\n            var arg = this.args[i];\n            var value = arg._eval(compressor, depth);\n            if (arg === value)\n                return this;\n            if (arg instanceof AST_Lambda)\n                return this;\n            args.push(value);\n        }\n        try {\n            return val[key].apply(val, args);\n        } catch (ex) {\n            // We don't really care\n        }\n    }\n    return this;\n});\n\n// Also a subclass of AST_Call\ndef_eval(AST_New, return_this);\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n// AST_Node#drop_side_effect_free() gets called when we don't care about the value,\n// only about side effects. We'll be defining this method for each node type in this module\n//\n// Examples:\n// foo++ -> foo++\n// 1 + func() -> func()\n// 10 -> (nothing)\n// knownPureFunc(foo++) -> foo++\n\nfunction def_drop_side_effect_free(node_or_nodes, func) {\n    for (const node of [].concat(node_or_nodes)) {\n        node.DEFMETHOD(\"drop_side_effect_free\", func);\n    }\n}\n\n// Drop side-effect-free elements from an array of expressions.\n// Returns an array of expressions with side-effects or null\n// if all elements were dropped. Note: original array may be\n// returned if nothing changed.\nfunction trim(nodes, compressor, first_in_statement) {\n    var len = nodes.length;\n    if (!len)  return null;\n\n    var ret = [], changed = false;\n    for (var i = 0; i < len; i++) {\n        var node = nodes[i].drop_side_effect_free(compressor, first_in_statement);\n        changed |= node !== nodes[i];\n        if (node) {\n            ret.push(node);\n            first_in_statement = false;\n        }\n    }\n    return changed ? ret.length ? ret : null : nodes;\n}\n\ndef_drop_side_effect_free(AST_Node, return_this);\ndef_drop_side_effect_free(AST_Constant, return_null);\ndef_drop_side_effect_free(AST_This, return_null);\n\ndef_drop_side_effect_free(AST_Call, function (compressor, first_in_statement) {\n    if (is_nullish_shortcircuited(this, compressor)) {\n        return this.expression.drop_side_effect_free(compressor, first_in_statement);\n    }\n\n    if (!this.is_callee_pure(compressor)) {\n        if (this.expression.is_call_pure(compressor)) {\n            var exprs = this.args.slice();\n            exprs.unshift(this.expression.expression);\n            exprs = trim(exprs, compressor, first_in_statement);\n            return exprs && make_sequence(this, exprs);\n        }\n        if (is_func_expr(this.expression)\n            && (!this.expression.name || !this.expression.name.definition().references.length)) {\n            var node = this.clone();\n            node.expression.process_expression(false, compressor);\n            return node;\n        }\n        return this;\n    }\n\n    var args = trim(this.args, compressor, first_in_statement);\n    return args && make_sequence(this, args);\n});\n\ndef_drop_side_effect_free(AST_Accessor, return_null);\n\ndef_drop_side_effect_free(AST_Function, return_null);\n\ndef_drop_side_effect_free(AST_Arrow, return_null);\n\ndef_drop_side_effect_free(AST_Class, function (compressor) {\n    const with_effects = [];\n\n    if (this.is_self_referential() && this.has_side_effects(compressor)) {\n        return this;\n    }\n\n    const trimmed_extends = this.extends && this.extends.drop_side_effect_free(compressor);\n    if (trimmed_extends) with_effects.push(trimmed_extends);\n\n    for (const prop of this.properties) {\n        if (prop instanceof AST_ClassStaticBlock) {\n            if (prop.has_side_effects(compressor)) {\n                return this; // Be cautious about these\n            }\n        } else {\n            const trimmed_prop = prop.drop_side_effect_free(compressor);\n            if (trimmed_prop) with_effects.push(trimmed_prop);\n        }\n    }\n\n    if (!with_effects.length)\n        return null;\n\n    const exprs = make_sequence(this, with_effects);\n    if (this instanceof AST_DefClass) {\n        // We want a statement\n        return make_node(AST_SimpleStatement, this, { body: exprs });\n    } else {\n        return exprs;\n    }\n});\n\ndef_drop_side_effect_free([\n    AST_ClassProperty,\n    AST_ClassPrivateProperty,\n], function (compressor) {\n    const key = this.computed_key() && this.key.drop_side_effect_free(compressor);\n\n    const value = this.static && this.value\n        && this.value.drop_side_effect_free(compressor);\n\n    if (key && value)\n        return make_sequence(this, [key, value]);\n    return key || value || null;\n});\n\ndef_drop_side_effect_free(AST_Binary, function (compressor, first_in_statement) {\n    var right = this.right.drop_side_effect_free(compressor);\n    if (!right)\n        return this.left.drop_side_effect_free(compressor, first_in_statement);\n    if (lazy_op.has(this.operator)) {\n        if (right === this.right)\n            return this;\n        var node = this.clone();\n        node.right = right;\n        return node;\n    } else {\n        var left = this.left.drop_side_effect_free(compressor, first_in_statement);\n        if (!left)\n            return this.right.drop_side_effect_free(compressor, first_in_statement);\n        return make_sequence(this, [left, right]);\n    }\n});\n\ndef_drop_side_effect_free(AST_Assign, function (compressor) {\n    if (this.logical)\n        return this;\n\n    var left = this.left;\n    if (left.has_side_effects(compressor)\n        || compressor.has_directive(\"use strict\")\n        && left instanceof AST_PropAccess\n        && left.expression.is_constant()) {\n        return this;\n    }\n    set_flag(this, WRITE_ONLY);\n    while (left instanceof AST_PropAccess) {\n        left = left.expression;\n    }\n    if (left.is_constant_expression(compressor.find_parent(AST_Scope))) {\n        return this.right.drop_side_effect_free(compressor);\n    }\n    return this;\n});\n\ndef_drop_side_effect_free(AST_Conditional, function (compressor) {\n    var consequent = this.consequent.drop_side_effect_free(compressor);\n    var alternative = this.alternative.drop_side_effect_free(compressor);\n    if (consequent === this.consequent && alternative === this.alternative)\n        return this;\n    if (!consequent)\n        return alternative ? make_node(AST_Binary, this, {\n            operator: \"||\",\n            left: this.condition,\n            right: alternative\n        }) : this.condition.drop_side_effect_free(compressor);\n    if (!alternative)\n        return make_node(AST_Binary, this, {\n            operator: \"&&\",\n            left: this.condition,\n            right: consequent\n        });\n    var node = this.clone();\n    node.consequent = consequent;\n    node.alternative = alternative;\n    return node;\n});\n\ndef_drop_side_effect_free(AST_Unary, function (compressor, first_in_statement) {\n    if (unary_side_effects.has(this.operator)) {\n        if (!this.expression.has_side_effects(compressor)) {\n            set_flag(this, WRITE_ONLY);\n        } else {\n            clear_flag(this, WRITE_ONLY);\n        }\n        return this;\n    }\n    if (this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef)\n        return null;\n    var expression = this.expression.drop_side_effect_free(compressor, first_in_statement);\n    if (first_in_statement && expression && is_iife_call(expression)) {\n        if (expression === this.expression && this.operator == \"!\")\n            return this;\n        return expression.negate(compressor, first_in_statement);\n    }\n    return expression;\n});\n\ndef_drop_side_effect_free(AST_SymbolRef, function (compressor) {\n    const safe_access = this.is_declared(compressor)\n        || pure_prop_access_globals.has(this.name);\n    return safe_access ? null : this;\n});\n\ndef_drop_side_effect_free(AST_Object, function (compressor, first_in_statement) {\n    var values = trim(this.properties, compressor, first_in_statement);\n    return values && make_sequence(this, values);\n});\n\ndef_drop_side_effect_free(AST_ObjectKeyVal, function (compressor, first_in_statement) {\n    const computed_key = this.key instanceof AST_Node;\n    const key = computed_key && this.key.drop_side_effect_free(compressor, first_in_statement);\n    const value = this.value.drop_side_effect_free(compressor, first_in_statement);\n    if (key && value) {\n        return make_sequence(this, [key, value]);\n    }\n    return key || value;\n});\n\ndef_drop_side_effect_free([\n    AST_ConciseMethod,\n    AST_ObjectGetter,\n    AST_ObjectSetter,\n], function () {\n    return this.computed_key() ? this.key : null;\n});\n\ndef_drop_side_effect_free([\n    AST_PrivateMethod,\n    AST_PrivateGetter,\n    AST_PrivateSetter,\n], function () {\n    return null;\n});\n\ndef_drop_side_effect_free(AST_Array, function (compressor, first_in_statement) {\n    var values = trim(this.elements, compressor, first_in_statement);\n    return values && make_sequence(this, values);\n});\n\ndef_drop_side_effect_free(AST_Dot, function (compressor, first_in_statement) {\n    if (is_nullish_shortcircuited(this, compressor)) {\n        return this.expression.drop_side_effect_free(compressor, first_in_statement);\n    }\n    if (!this.optional && this.expression.may_throw_on_access(compressor)) {\n        return this;\n    }\n\n    return this.expression.drop_side_effect_free(compressor, first_in_statement);\n});\n\ndef_drop_side_effect_free(AST_Sub, function (compressor, first_in_statement) {\n    if (is_nullish_shortcircuited(this, compressor)) {\n        return this.expression.drop_side_effect_free(compressor, first_in_statement);\n    }\n    if (!this.optional && this.expression.may_throw_on_access(compressor)) {\n        return this;\n    }\n\n    var property = this.property.drop_side_effect_free(compressor);\n    if (property && this.optional) return this;\n\n    var expression = this.expression.drop_side_effect_free(compressor, first_in_statement);\n\n    if (expression && property) return make_sequence(this, [expression, property]);\n    return expression || property;\n});\n\ndef_drop_side_effect_free(AST_Chain, function (compressor, first_in_statement) {\n    return this.expression.drop_side_effect_free(compressor, first_in_statement);\n});\n\ndef_drop_side_effect_free(AST_Sequence, function (compressor) {\n    var last = this.tail_node();\n    var expr = last.drop_side_effect_free(compressor);\n    if (expr === last)\n        return this;\n    var expressions = this.expressions.slice(0, -1);\n    if (expr)\n        expressions.push(expr);\n    if (!expressions.length) {\n        return make_node(AST_Number, this, { value: 0 });\n    }\n    return make_sequence(this, expressions);\n});\n\ndef_drop_side_effect_free(AST_Expansion, function (compressor, first_in_statement) {\n    return this.expression.drop_side_effect_free(compressor, first_in_statement);\n});\n\ndef_drop_side_effect_free(AST_TemplateSegment, return_null);\n\ndef_drop_side_effect_free(AST_TemplateString, function (compressor) {\n    var values = trim(this.segments, compressor, first_in_statement);\n    return values && make_sequence(this, values);\n});\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nconst r_keep_assign = /keep_assign/;\n\n/** Drop unused variables from this scope */\nAST_Scope.DEFMETHOD(\"drop_unused\", function(compressor) {\n    if (!compressor.option(\"unused\")) return;\n    if (compressor.has_directive(\"use asm\")) return;\n    if (!this.variables) return; // not really a scope (eg: AST_Class)\n\n    var self = this;\n    if (self.pinned()) return;\n    var drop_funcs = !(self instanceof AST_Toplevel) || compressor.toplevel.funcs;\n    var drop_vars = !(self instanceof AST_Toplevel) || compressor.toplevel.vars;\n    const assign_as_unused = r_keep_assign.test(compressor.option(\"unused\")) ? return_false : function(node) {\n        if (node instanceof AST_Assign\n            && !node.logical\n            && (has_flag(node, WRITE_ONLY) || node.operator == \"=\")\n        ) {\n            return node.left;\n        }\n        if (node instanceof AST_Unary && has_flag(node, WRITE_ONLY)) {\n            return node.expression;\n        }\n    };\n    var in_use_ids = new Map();\n    var fixed_ids = new Map();\n    if (self instanceof AST_Toplevel && compressor.top_retain) {\n        self.variables.forEach(function(def) {\n            if (compressor.top_retain(def)) {\n                in_use_ids.set(def.id, def);\n            }\n        });\n    }\n    var var_defs_by_id = new Map();\n    var initializations = new Map();\n\n    // pass 1: find out which symbols are directly used in\n    // this scope (not in nested scopes).\n    var scope = this;\n    var tw = new TreeWalker(function(node, descend) {\n        if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive(\"use strict\")) {\n            node.argnames.forEach(function(argname) {\n                if (!(argname instanceof AST_SymbolDeclaration)) return;\n                var def = argname.definition();\n                in_use_ids.set(def.id, def);\n            });\n        }\n        if (node === self) return;\n        if (node instanceof AST_Class && node.has_side_effects(compressor)) {\n            if (node.is_self_referential()) {\n                descend();\n            } else {\n                node.visit_nondeferred_class_parts(tw);\n            }\n        }\n        if (node instanceof AST_Defun || node instanceof AST_DefClass) {\n            var node_def = node.name.definition();\n            const in_export = tw.parent() instanceof AST_Export;\n            if (in_export || !drop_funcs && scope === self) {\n                if (node_def.global) {\n                    in_use_ids.set(node_def.id, node_def);\n                }\n            }\n\n            map_add(initializations, node_def.id, node);\n            return true; // don't go in nested scopes\n        }\n        // In the root scope, we drop things. In inner scopes, we just check for uses.\n        const in_root_scope = scope === self;\n        if (node instanceof AST_SymbolFunarg && in_root_scope) {\n            map_add(var_defs_by_id, node.definition().id, node);\n        }\n        if (node instanceof AST_Definitions && in_root_scope) {\n            const in_export = tw.parent() instanceof AST_Export;\n            node.definitions.forEach(function(def) {\n                if (def.name instanceof AST_SymbolVar) {\n                    map_add(var_defs_by_id, def.name.definition().id, def);\n                }\n                if (in_export || !drop_vars) {\n                    walk(def.name, node => {\n                        if (node instanceof AST_SymbolDeclaration) {\n                            const def = node.definition();\n                            if (def.global) {\n                                in_use_ids.set(def.id, def);\n                            }\n                        }\n                    });\n                }\n                if (def.name instanceof AST_Destructuring) {\n                    def.walk(tw);\n                }\n                if (def.name instanceof AST_SymbolDeclaration && def.value) {\n                    var node_def = def.name.definition();\n                    map_add(initializations, node_def.id, def.value);\n                    if (!node_def.chained && def.name.fixed_value() === def.value) {\n                        fixed_ids.set(node_def.id, def);\n                    }\n                    if (def.value.has_side_effects(compressor)) {\n                        def.value.walk(tw);\n                    }\n                }\n            });\n            return true;\n        }\n        return scan_ref_scoped(node, descend);\n    });\n    self.walk(tw);\n    // pass 2: for every used symbol we need to walk its\n    // initialization code to figure out if it uses other\n    // symbols (that may not be in_use).\n    tw = new TreeWalker(scan_ref_scoped);\n    in_use_ids.forEach(function (def) {\n        var init = initializations.get(def.id);\n        if (init) init.forEach(function(init) {\n            init.walk(tw);\n        });\n    });\n    // pass 3: we should drop declarations not in_use\n    var tt = new TreeTransformer(\n        function before(node, descend, in_list) {\n            var parent = tt.parent();\n            if (drop_vars) {\n                const sym = assign_as_unused(node);\n                if (sym instanceof AST_SymbolRef) {\n                    var def = sym.definition();\n                    var in_use = in_use_ids.has(def.id);\n                    if (node instanceof AST_Assign) {\n                        if (!in_use || fixed_ids.has(def.id) && fixed_ids.get(def.id) !== node) {\n                            const assignee = node.right.transform(tt);\n                            if (!in_use && !assignee.has_side_effects(compressor) && !is_used_in_expression(tt)) {\n                                return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });\n                            }\n                            return maintain_this_binding(parent, node, assignee);\n                        }\n                    } else if (!in_use) {\n                        return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });\n                    }\n                }\n            }\n            if (scope !== self) return;\n            var def;\n            if (node.name\n                && (node instanceof AST_ClassExpression\n                    && !keep_name(compressor.option(\"keep_classnames\"), (def = node.name.definition()).name)\n                || node instanceof AST_Function\n                    && !keep_name(compressor.option(\"keep_fnames\"), (def = node.name.definition()).name))) {\n                // any declarations with same name will overshadow\n                // name of this anonymous function and can therefore\n                // never be used anywhere\n                if (!in_use_ids.has(def.id) || def.orig.length > 1) node.name = null;\n            }\n            if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {\n                var trim =\n                    !compressor.option(\"keep_fargs\")\n                    // Is this an IIFE that won't refer to its name?\n                    || parent instanceof AST_Call\n                        && parent.expression === node\n                        && !node.pinned()\n                        && (!node.name || node.name.unreferenced());\n                for (var a = node.argnames, i = a.length; --i >= 0;) {\n                    var sym = a[i];\n                    if (sym instanceof AST_Expansion) {\n                        sym = sym.expression;\n                    }\n                    if (sym instanceof AST_DefaultAssign) {\n                        sym = sym.left;\n                    }\n                    // Do not drop destructuring arguments.\n                    // They constitute a type assertion of sorts\n                    if (\n                        !(sym instanceof AST_Destructuring)\n                        && !in_use_ids.has(sym.definition().id)\n                    ) {\n                        set_flag(sym, UNUSED);\n                        if (trim) {\n                            a.pop();\n                        }\n                    } else {\n                        trim = false;\n                    }\n                }\n            }\n            if (node instanceof AST_DefClass && node !== self) {\n                const def = node.name.definition();\n                descend(node, this);\n                const keep_class = def.global && !drop_funcs || in_use_ids.has(def.id);\n                if (!keep_class) {\n                    const kept = node.drop_side_effect_free(compressor);\n                    if (kept == null) {\n                        def.eliminated++;\n                        return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);\n                    }\n                    return kept;\n                }\n                return node;\n            }\n            if (node instanceof AST_Defun && node !== self) {\n                const def = node.name.definition();\n                const keep = def.global && !drop_funcs || in_use_ids.has(def.id);\n                if (!keep) {\n                    def.eliminated++;\n                    return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);\n                }\n            }\n            if (node instanceof AST_Definitions && !(parent instanceof AST_ForIn && parent.init === node)) {\n                var drop_block = !(parent instanceof AST_Toplevel) && !(node instanceof AST_Var);\n                // place uninitialized names at the start\n                var body = [], head = [], tail = [];\n                // for unused names whose initialization has\n                // side effects, we can cascade the init. code\n                // into the next one, or next statement.\n                var side_effects = [];\n                node.definitions.forEach(function(def) {\n                    if (def.value) def.value = def.value.transform(tt);\n                    var is_destructure = def.name instanceof AST_Destructuring;\n                    var sym = is_destructure\n                        ? new SymbolDef(null, { name: \"<destructure>\" }) /* fake SymbolDef */\n                        : def.name.definition();\n                    if (drop_block && sym.global) return tail.push(def);\n                    if (!(drop_vars || drop_block)\n                        || is_destructure\n                            && (def.name.names.length\n                                || def.name.is_array\n                                || compressor.option(\"pure_getters\") != true)\n                        || in_use_ids.has(sym.id)\n                    ) {\n                        if (def.value && fixed_ids.has(sym.id) && fixed_ids.get(sym.id) !== def) {\n                            def.value = def.value.drop_side_effect_free(compressor);\n                        }\n                        if (def.name instanceof AST_SymbolVar) {\n                            var var_defs = var_defs_by_id.get(sym.id);\n                            if (var_defs.length > 1 && (!def.value || sym.orig.indexOf(def.name) > sym.eliminated)) {\n                                if (def.value) {\n                                    var ref = make_node(AST_SymbolRef, def.name, def.name);\n                                    sym.references.push(ref);\n                                    var assign = make_node(AST_Assign, def, {\n                                        operator: \"=\",\n                                        logical: false,\n                                        left: ref,\n                                        right: def.value\n                                    });\n                                    if (fixed_ids.get(sym.id) === def) {\n                                        fixed_ids.set(sym.id, assign);\n                                    }\n                                    side_effects.push(assign.transform(tt));\n                                }\n                                remove(var_defs, def);\n                                sym.eliminated++;\n                                return;\n                            }\n                        }\n                        if (def.value) {\n                            if (side_effects.length > 0) {\n                                if (tail.length > 0) {\n                                    side_effects.push(def.value);\n                                    def.value = make_sequence(def.value, side_effects);\n                                } else {\n                                    body.push(make_node(AST_SimpleStatement, node, {\n                                        body: make_sequence(node, side_effects)\n                                    }));\n                                }\n                                side_effects = [];\n                            }\n                            tail.push(def);\n                        } else {\n                            head.push(def);\n                        }\n                    } else if (sym.orig[0] instanceof AST_SymbolCatch) {\n                        var value = def.value && def.value.drop_side_effect_free(compressor);\n                        if (value) side_effects.push(value);\n                        def.value = null;\n                        head.push(def);\n                    } else {\n                        var value = def.value && def.value.drop_side_effect_free(compressor);\n                        if (value) {\n                            side_effects.push(value);\n                        }\n                        sym.eliminated++;\n                    }\n                });\n                if (head.length > 0 || tail.length > 0) {\n                    node.definitions = head.concat(tail);\n                    body.push(node);\n                }\n                if (side_effects.length > 0) {\n                    body.push(make_node(AST_SimpleStatement, node, {\n                        body: make_sequence(node, side_effects)\n                    }));\n                }\n                switch (body.length) {\n                  case 0:\n                    return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);\n                  case 1:\n                    return body[0];\n                  default:\n                    return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, { body });\n                }\n            }\n            // certain combination of unused name + side effect leads to:\n            //    https://github.com/mishoo/UglifyJS2/issues/44\n            //    https://github.com/mishoo/UglifyJS2/issues/1830\n            //    https://github.com/mishoo/UglifyJS2/issues/1838\n            // that's an invalid AST.\n            // We fix it at this stage by moving the `var` outside the `for`.\n            if (node instanceof AST_For) {\n                descend(node, this);\n                var block;\n                if (node.init instanceof AST_BlockStatement) {\n                    block = node.init;\n                    node.init = block.body.pop();\n                    block.body.push(node);\n                }\n                if (node.init instanceof AST_SimpleStatement) {\n                    node.init = node.init.body;\n                } else if (is_empty(node.init)) {\n                    node.init = null;\n                }\n                return !block ? node : in_list ? MAP.splice(block.body) : block;\n            }\n            if (node instanceof AST_LabeledStatement\n                && node.body instanceof AST_For\n            ) {\n                descend(node, this);\n                if (node.body instanceof AST_BlockStatement) {\n                    var block = node.body;\n                    node.body = block.body.pop();\n                    block.body.push(node);\n                    return in_list ? MAP.splice(block.body) : block;\n                }\n                return node;\n            }\n            if (node instanceof AST_BlockStatement) {\n                descend(node, this);\n                if (in_list && node.body.every(can_be_evicted_from_block)) {\n                    return MAP.splice(node.body);\n                }\n                return node;\n            }\n            if (node instanceof AST_Scope && !(node instanceof AST_ClassStaticBlock)) {\n                const save_scope = scope;\n                scope = node;\n                descend(node, this);\n                scope = save_scope;\n                return node;\n            }\n        },\n        function after(node, in_list) {\n            if (node instanceof AST_Sequence) {\n                switch (node.expressions.length) {\n                    case 0: return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });\n                    case 1: return node.expressions[0];\n                }\n            }\n        }\n    );\n\n    self.transform(tt);\n\n    function scan_ref_scoped(node, descend) {\n        var node_def;\n        const sym = assign_as_unused(node);\n        if (sym instanceof AST_SymbolRef\n            && !is_ref_of(node.left, AST_SymbolBlockDeclaration)\n            && self.variables.get(sym.name) === (node_def = sym.definition())\n        ) {\n            if (node instanceof AST_Assign) {\n                node.right.walk(tw);\n                if (!node_def.chained && node.left.fixed_value() === node.right) {\n                    fixed_ids.set(node_def.id, node);\n                }\n            }\n            return true;\n        }\n        if (node instanceof AST_SymbolRef) {\n            node_def = node.definition();\n            if (!in_use_ids.has(node_def.id)) {\n                in_use_ids.set(node_def.id, node_def);\n                if (node_def.orig[0] instanceof AST_SymbolCatch) {\n                    const redef = node_def.scope.is_block_scope()\n                        && node_def.scope.get_defun_scope().variables.get(node_def.name);\n                    if (redef) in_use_ids.set(redef.id, redef);\n                }\n            }\n            return true;\n        }\n        if (node instanceof AST_Class) {\n            descend();\n            return true;\n        }\n        if (node instanceof AST_Scope && !(node instanceof AST_ClassStaticBlock)) {\n            var save_scope = scope;\n            scope = node;\n            descend();\n            scope = save_scope;\n            return true;\n        }\n    }\n});\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n/**\n * Define the method AST_Node#reduce_vars, which goes through the AST in\n * execution order to perform basic flow analysis\n */\nfunction def_reduce_vars(node, func) {\n    node.DEFMETHOD(\"reduce_vars\", func);\n}\n\ndef_reduce_vars(AST_Node, noop);\n\n/** Clear definition properties */\nfunction reset_def(compressor, def) {\n    def.assignments = 0;\n    def.chained = false;\n    def.direct_access = false;\n    def.escaped = 0;\n    def.recursive_refs = 0;\n    def.references = [];\n    def.single_use = undefined;\n    if (\n        def.scope.pinned()\n        || (def.orig[0] instanceof AST_SymbolFunarg && def.scope.uses_arguments)\n    ) {\n        def.fixed = false;\n    } else if (def.orig[0] instanceof AST_SymbolConst || !compressor.exposed(def)) {\n        def.fixed = def.init;\n    } else {\n        def.fixed = false;\n    }\n}\n\nfunction reset_variables(tw, compressor, node) {\n    node.variables.forEach(function(def) {\n        reset_def(compressor, def);\n        if (def.fixed === null) {\n            tw.defs_to_safe_ids.set(def.id, tw.safe_ids);\n            mark(tw, def, true);\n        } else if (def.fixed) {\n            tw.loop_ids.set(def.id, tw.in_loop);\n            mark(tw, def, true);\n        }\n    });\n}\n\nfunction reset_block_variables(compressor, node) {\n    if (node.block_scope) node.block_scope.variables.forEach((def) => {\n        reset_def(compressor, def);\n    });\n}\n\nfunction push(tw) {\n    tw.safe_ids = Object.create(tw.safe_ids);\n}\n\nfunction pop(tw) {\n    tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);\n}\n\nfunction mark(tw, def, safe) {\n    tw.safe_ids[def.id] = safe;\n}\n\nfunction safe_to_read(tw, def) {\n    if (def.single_use == \"m\") return false;\n    if (tw.safe_ids[def.id]) {\n        if (def.fixed == null) {\n            var orig = def.orig[0];\n            if (orig instanceof AST_SymbolFunarg || orig.name == \"arguments\") return false;\n            def.fixed = make_node(AST_Undefined, orig);\n        }\n        return true;\n    }\n    return def.fixed instanceof AST_Defun;\n}\n\nfunction safe_to_assign(tw, def, scope, value) {\n    if (def.fixed === undefined) return true;\n    let def_safe_ids;\n    if (def.fixed === null\n        && (def_safe_ids = tw.defs_to_safe_ids.get(def.id))\n    ) {\n        def_safe_ids[def.id] = false;\n        tw.defs_to_safe_ids.delete(def.id);\n        return true;\n    }\n    if (!HOP(tw.safe_ids, def.id)) return false;\n    if (!safe_to_read(tw, def)) return false;\n    if (def.fixed === false) return false;\n    if (def.fixed != null && (!value || def.references.length > def.assignments)) return false;\n    if (def.fixed instanceof AST_Defun) {\n        return value instanceof AST_Node && def.fixed.parent_scope === scope;\n    }\n    return def.orig.every((sym) => {\n        return !(sym instanceof AST_SymbolConst\n            || sym instanceof AST_SymbolDefun\n            || sym instanceof AST_SymbolLambda);\n    });\n}\n\nfunction ref_once(tw, compressor, def) {\n    return compressor.option(\"unused\")\n        && !def.scope.pinned()\n        && def.references.length - def.recursive_refs == 1\n        && tw.loop_ids.get(def.id) === tw.in_loop;\n}\n\nfunction is_immutable(value) {\n    if (!value) return false;\n    return value.is_constant()\n        || value instanceof AST_Lambda\n        || value instanceof AST_This;\n}\n\n// A definition \"escapes\" when its value can leave the point of use.\n// Example: `a = b || c`\n// In this example, \"b\" and \"c\" are escaping, because they're going into \"a\"\n//\n// def.escaped is != 0 when it escapes.\n//\n// When greater than 1, it means that N chained properties will be read off\n// of that def before an escape occurs. This is useful for evaluating\n// property accesses, where you need to know when to stop.\nfunction mark_escaped(tw, d, scope, node, value, level = 0, depth = 1) {\n    var parent = tw.parent(level);\n    if (value) {\n        if (value.is_constant()) return;\n        if (value instanceof AST_ClassExpression) return;\n    }\n\n    if (\n        parent instanceof AST_Assign && (parent.operator === \"=\" || parent.logical) && node === parent.right\n        || parent instanceof AST_Call && (node !== parent.expression || parent instanceof AST_New)\n        || parent instanceof AST_Exit && node === parent.value && node.scope !== d.scope\n        || parent instanceof AST_VarDefLike && node === parent.value\n        || parent instanceof AST_Yield && node === parent.value && node.scope !== d.scope\n    ) {\n        if (depth > 1 && !(value && value.is_constant_expression(scope))) depth = 1;\n        if (!d.escaped || d.escaped > depth) d.escaped = depth;\n        return;\n    } else if (\n        parent instanceof AST_Array\n        || parent instanceof AST_Await\n        || parent instanceof AST_Binary && lazy_op.has(parent.operator)\n        || parent instanceof AST_Conditional && node !== parent.condition\n        || parent instanceof AST_Expansion\n        || parent instanceof AST_Sequence && node === parent.tail_node()\n    ) {\n        mark_escaped(tw, d, scope, parent, parent, level + 1, depth);\n    } else if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n        var obj = tw.parent(level + 1);\n\n        mark_escaped(tw, d, scope, obj, obj, level + 2, depth);\n    } else if (parent instanceof AST_PropAccess && node === parent.expression) {\n        value = read_property(value, parent.property);\n\n        mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);\n        if (value) return;\n    }\n\n    if (level > 0) return;\n    if (parent instanceof AST_Sequence && node !== parent.tail_node()) return;\n    if (parent instanceof AST_SimpleStatement) return;\n\n    d.direct_access = true;\n}\n\nconst suppress = node => walk(node, node => {\n    if (!(node instanceof AST_Symbol)) return;\n    var d = node.definition();\n    if (!d) return;\n    if (node instanceof AST_SymbolRef) d.references.push(node);\n    d.fixed = false;\n});\n\ndef_reduce_vars(AST_Accessor, function(tw, descend, compressor) {\n    push(tw);\n    reset_variables(tw, compressor, this);\n    descend();\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Assign, function(tw, descend, compressor) {\n    var node = this;\n    if (node.left instanceof AST_Destructuring) {\n        suppress(node.left);\n        return;\n    }\n\n    const finish_walk = () => {\n        if (node.logical) {\n            node.left.walk(tw);\n\n            push(tw);\n            node.right.walk(tw);\n            pop(tw);\n\n            return true;\n        }\n    };\n\n    var sym = node.left;\n    if (!(sym instanceof AST_SymbolRef)) return finish_walk();\n\n    var def = sym.definition();\n    var safe = safe_to_assign(tw, def, sym.scope, node.right);\n    def.assignments++;\n    if (!safe) return finish_walk();\n\n    var fixed = def.fixed;\n    if (!fixed && node.operator != \"=\" && !node.logical) return finish_walk();\n\n    var eq = node.operator == \"=\";\n    var value = eq ? node.right : node;\n    if (is_modified(compressor, tw, node, value, 0)) return finish_walk();\n\n    def.references.push(sym);\n\n    if (!node.logical) {\n        if (!eq) def.chained = true;\n\n        def.fixed = eq ? function() {\n            return node.right;\n        } : function() {\n            return make_node(AST_Binary, node, {\n                operator: node.operator.slice(0, -1),\n                left: fixed instanceof AST_Node ? fixed : fixed(),\n                right: node.right\n            });\n        };\n    }\n\n    if (node.logical) {\n        mark(tw, def, false);\n        push(tw);\n        node.right.walk(tw);\n        pop(tw);\n        return true;\n    }\n\n    mark(tw, def, false);\n    node.right.walk(tw);\n    mark(tw, def, true);\n\n    mark_escaped(tw, def, sym.scope, node, value, 0, 1);\n\n    return true;\n});\n\ndef_reduce_vars(AST_Binary, function(tw) {\n    if (!lazy_op.has(this.operator)) return;\n    this.left.walk(tw);\n    push(tw);\n    this.right.walk(tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Block, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n});\n\ndef_reduce_vars(AST_Case, function(tw) {\n    push(tw);\n    this.expression.walk(tw);\n    pop(tw);\n    push(tw);\n    walk_body(this, tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Class, function(tw, descend) {\n    clear_flag(this, INLINED);\n    push(tw);\n    descend();\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_ClassStaticBlock, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n});\n\ndef_reduce_vars(AST_Conditional, function(tw) {\n    this.condition.walk(tw);\n    push(tw);\n    this.consequent.walk(tw);\n    pop(tw);\n    push(tw);\n    this.alternative.walk(tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Chain, function(tw, descend) {\n    // Chains' conditions apply left-to-right, cumulatively.\n    // If we walk normally we don't go in that order because we would pop before pushing again\n    // Solution: AST_PropAccess and AST_Call push when they are optional, and never pop.\n    // Then we pop everything when they are done being walked.\n    const safe_ids = tw.safe_ids;\n\n    descend();\n\n    // Unroll back to start\n    tw.safe_ids = safe_ids;\n    return true;\n});\n\ndef_reduce_vars(AST_Call, function (tw) {\n    this.expression.walk(tw);\n\n    if (this.optional) {\n        // Never pop -- it's popped at AST_Chain above\n        push(tw);\n    }\n\n    for (const arg of this.args) arg.walk(tw);\n\n    return true;\n});\n\ndef_reduce_vars(AST_PropAccess, function (tw) {\n    if (!this.optional) return;\n\n    this.expression.walk(tw);\n\n    // Never pop -- it's popped at AST_Chain above\n    push(tw);\n\n    if (this.property instanceof AST_Node) this.property.walk(tw);\n\n    return true;\n});\n\ndef_reduce_vars(AST_Default, function(tw, descend) {\n    push(tw);\n    descend();\n    pop(tw);\n    return true;\n});\n\nfunction mark_lambda(tw, descend, compressor) {\n    clear_flag(this, INLINED);\n    push(tw);\n    reset_variables(tw, compressor, this);\n\n    var iife;\n    if (!this.name\n        && !this.uses_arguments\n        && !this.pinned()\n        && (iife = tw.parent()) instanceof AST_Call\n        && iife.expression === this\n        && !iife.args.some(arg => arg instanceof AST_Expansion)\n        && this.argnames.every(arg_name => arg_name instanceof AST_Symbol)\n    ) {\n        // Virtually turn IIFE parameters into variable definitions:\n        //   (function(a,b) {...})(c,d) => (function() {var a=c,b=d; ...})()\n        // So existing transformation rules can work on them.\n        this.argnames.forEach((arg, i) => {\n            if (!arg.definition) return;\n            var d = arg.definition();\n            // Avoid setting fixed when there's more than one origin for a variable value\n            if (d.orig.length > 1) return;\n            if (d.fixed === undefined && (!this.uses_arguments || tw.has_directive(\"use strict\"))) {\n                d.fixed = function() {\n                    return iife.args[i] || make_node(AST_Undefined, iife);\n                };\n                tw.loop_ids.set(d.id, tw.in_loop);\n                mark(tw, d, true);\n            } else {\n                d.fixed = false;\n            }\n        });\n    }\n\n    descend();\n    pop(tw);\n\n    handle_defined_after_hoist(this);\n\n    return true;\n}\n\n/**\n * It's possible for a hoisted function to use something that's not defined yet. Example:\n *\n * hoisted();\n * var defined_after = true;\n * function hoisted() {\n *   // use defined_after\n * }\n *\n * Or even indirectly:\n *\n * B();\n * var defined_after = true;\n * function A() {\n *   // use defined_after\n * }\n * function B() {\n *   A();\n * }\n *\n * Access a variable before declaration will either throw a ReferenceError\n * (if the variable is declared with `let` or `const`),\n * or get an `undefined` (if the variable is declared with `var`).\n *\n * If the variable is inlined into the function, the behavior will change.\n *\n * This function is called on the parent to disallow inlining of such variables,\n */\nfunction handle_defined_after_hoist(parent) {\n    const defuns = [];\n    walk(parent, node => {\n        if (node === parent) return;\n        if (node instanceof AST_Defun) {\n            defuns.push(node);\n            return true;\n        }\n        if (\n            node instanceof AST_Scope\n            || node instanceof AST_SimpleStatement\n        ) return true;\n    });\n\n    // `defun` id to array of `defun` it uses\n    const defun_dependencies_map = new Map();\n    // `defun` id to array of enclosing `def` that are used by the function\n    const dependencies_map = new Map();\n    // all symbol ids that will be tracked for read/write\n    const symbols_of_interest = new Set();\n    const defuns_of_interest = new Set();\n\n    for (const defun of defuns) {\n        const fname_def = defun.name.definition();\n        const enclosing_defs = [];\n\n        for (const def of defun.enclosed) {\n            if (\n                def.fixed === false\n                || def === fname_def\n                || def.scope.get_defun_scope() !== parent\n            ) {\n                continue;\n            }\n\n            symbols_of_interest.add(def.id);\n\n            // found a reference to another function\n            if (\n                def.assignments === 0\n                && def.orig.length === 1\n                && def.orig[0] instanceof AST_SymbolDefun\n            ) {\n                defuns_of_interest.add(def.id);\n                symbols_of_interest.add(def.id);\n\n                defuns_of_interest.add(fname_def.id);\n                symbols_of_interest.add(fname_def.id);\n\n                if (!defun_dependencies_map.has(fname_def.id)) {\n                    defun_dependencies_map.set(fname_def.id, []);\n                }\n                defun_dependencies_map.get(fname_def.id).push(def.id);\n\n                continue;\n            }\n\n            enclosing_defs.push(def);\n        }\n\n        if (enclosing_defs.length) {\n            dependencies_map.set(fname_def.id, enclosing_defs);\n            defuns_of_interest.add(fname_def.id);\n            symbols_of_interest.add(fname_def.id);\n        }\n    }\n\n    // No defuns use outside constants\n    if (!dependencies_map.size) {\n        return;\n    }\n\n    // Increment to count \"symbols of interest\" (defuns or defs) that we found.\n    // These are tracked in AST order so we can check which is after which.\n    let symbol_index = 1;\n    // Map a defun ID to its first read (a `symbol_index`)\n    const defun_first_read_map = new Map();\n    // Map a symbol ID to its last write (a `symbol_index`)\n    const symbol_last_write_map = new Map();\n\n    walk_parent(parent, (node, walk_info) => {\n        if (node instanceof AST_Symbol && node.thedef) {\n            const id = node.definition().id;\n\n            symbol_index++;\n\n            // Track last-writes to symbols\n            if (symbols_of_interest.has(id)) {\n                if (node instanceof AST_SymbolDeclaration || is_lhs(node, walk_info.parent())) {\n                    symbol_last_write_map.set(id, symbol_index);\n                }\n            }\n\n            // Track first-reads of defuns (refined later)\n            if (defuns_of_interest.has(id)) {\n                if (!defun_first_read_map.has(id) && !is_recursive_ref(walk_info, id)) {\n                    defun_first_read_map.set(id, symbol_index);\n                }\n            }\n        }\n    });\n\n    // Refine `defun_first_read_map` to be as high as possible\n    for (const [defun, defun_first_read] of defun_first_read_map) {\n        // Update all dependencies of `defun`\n        const queue = new Set(defun_dependencies_map.get(defun));\n        for (const enclosed_defun of queue) {\n            let enclosed_defun_first_read = defun_first_read_map.get(enclosed_defun);\n            if (enclosed_defun_first_read != null && enclosed_defun_first_read < defun_first_read) {\n                continue;\n            }\n\n            defun_first_read_map.set(enclosed_defun, defun_first_read);\n\n            for (const enclosed_enclosed_defun of defun_dependencies_map.get(enclosed_defun) || []) {\n                queue.add(enclosed_enclosed_defun);\n            }\n        }\n    }\n\n    // ensure write-then-read order, otherwise clear `fixed`\n    // This is safe because last-writes (found_symbol_writes) are assumed to be as late as possible, and first-reads (defun_first_read_map) are assumed to be as early as possible.\n    for (const [defun, defs] of dependencies_map) {\n        const defun_first_read = defun_first_read_map.get(defun);\n        if (defun_first_read === undefined) {\n            continue;\n        }\n\n        for (const def of defs) {\n            if (def.fixed === false) {\n                continue;\n            }\n\n            let def_last_write = symbol_last_write_map.get(def.id) || 0;\n\n            if (defun_first_read < def_last_write) {\n                def.fixed = false;\n            }\n        }\n    }\n}\n\ndef_reduce_vars(AST_Lambda, mark_lambda);\n\ndef_reduce_vars(AST_Do, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    this.body.walk(tw);\n    if (has_break_or_continue(this)) {\n        pop(tw);\n        push(tw);\n    }\n    this.condition.walk(tw);\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n\ndef_reduce_vars(AST_For, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    if (this.init) this.init.walk(tw);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    if (this.condition) this.condition.walk(tw);\n    this.body.walk(tw);\n    if (this.step) {\n        if (has_break_or_continue(this)) {\n            pop(tw);\n            push(tw);\n        }\n        this.step.walk(tw);\n    }\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n\ndef_reduce_vars(AST_ForIn, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    suppress(this.init);\n    this.object.walk(tw);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n\ndef_reduce_vars(AST_If, function(tw) {\n    this.condition.walk(tw);\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    if (this.alternative) {\n        push(tw);\n        this.alternative.walk(tw);\n        pop(tw);\n    }\n    return true;\n});\n\ndef_reduce_vars(AST_LabeledStatement, function(tw) {\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_SymbolCatch, function() {\n    this.definition().fixed = false;\n});\n\ndef_reduce_vars(AST_SymbolRef, function(tw, descend, compressor) {\n    var d = this.definition();\n    d.references.push(this);\n    if (d.references.length == 1\n        && !d.fixed\n        && d.orig[0] instanceof AST_SymbolDefun) {\n        tw.loop_ids.set(d.id, tw.in_loop);\n    }\n    var fixed_value;\n    if (d.fixed === undefined || !safe_to_read(tw, d)) {\n        d.fixed = false;\n    } else if (d.fixed) {\n        fixed_value = this.fixed_value();\n        if (\n            fixed_value instanceof AST_Lambda\n            && is_recursive_ref(tw, d)\n        ) {\n            d.recursive_refs++;\n        } else if (fixed_value\n            && !compressor.exposed(d)\n            && ref_once(tw, compressor, d)\n        ) {\n            d.single_use =\n                fixed_value instanceof AST_Lambda && !fixed_value.pinned()\n                || fixed_value instanceof AST_Class\n                || d.scope === this.scope && fixed_value.is_constant_expression();\n        } else {\n            d.single_use = false;\n        }\n        if (is_modified(compressor, tw, this, fixed_value, 0, is_immutable(fixed_value))) {\n            if (d.single_use) {\n                d.single_use = \"m\";\n            } else {\n                d.fixed = false;\n            }\n        }\n    }\n    mark_escaped(tw, d, this.scope, this, fixed_value, 0, 1);\n});\n\ndef_reduce_vars(AST_Toplevel, function(tw, descend, compressor) {\n    this.globals.forEach(function(def) {\n        reset_def(compressor, def);\n    });\n    reset_variables(tw, compressor, this);\n    descend();\n    handle_defined_after_hoist(this);\n    return true;\n});\n\ndef_reduce_vars(AST_Try, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    if (this.bcatch) {\n        push(tw);\n        this.bcatch.walk(tw);\n        pop(tw);\n    }\n    if (this.bfinally) this.bfinally.walk(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Unary, function(tw) {\n    var node = this;\n    if (node.operator !== \"++\" && node.operator !== \"--\") return;\n    var exp = node.expression;\n    if (!(exp instanceof AST_SymbolRef)) return;\n    var def = exp.definition();\n    var safe = safe_to_assign(tw, def, exp.scope, true);\n    def.assignments++;\n    if (!safe) return;\n    var fixed = def.fixed;\n    if (!fixed) return;\n    def.references.push(exp);\n    def.chained = true;\n    def.fixed = function() {\n        return make_node(AST_Binary, node, {\n            operator: node.operator.slice(0, -1),\n            left: make_node(AST_UnaryPrefix, node, {\n                operator: \"+\",\n                expression: fixed instanceof AST_Node ? fixed : fixed()\n            }),\n            right: make_node(AST_Number, node, {\n                value: 1\n            })\n        });\n    };\n    mark(tw, def, true);\n    return true;\n});\n\ndef_reduce_vars(AST_VarDef, function(tw, descend) {\n    var node = this;\n    if (node.name instanceof AST_Destructuring) {\n        suppress(node.name);\n        return;\n    }\n    var d = node.name.definition();\n    if (node.value) {\n        if (safe_to_assign(tw, d, node.name.scope, node.value)) {\n            d.fixed = function() {\n                return node.value;\n            };\n            tw.loop_ids.set(d.id, tw.in_loop);\n            mark(tw, d, false);\n            descend();\n            mark(tw, d, true);\n            return true;\n        } else {\n            d.fixed = false;\n        }\n    }\n});\n\ndef_reduce_vars(AST_UsingDef, function() {\n    suppress(this.name);\n});\n\ndef_reduce_vars(AST_While, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    descend();\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nfunction loop_body(x) {\n    if (x instanceof AST_IterationStatement) {\n        return x.body instanceof AST_BlockStatement ? x.body : x;\n    }\n    return x;\n}\n\nfunction is_lhs_read_only(lhs) {\n    if (lhs instanceof AST_This) return true;\n    if (lhs instanceof AST_SymbolRef) return lhs.definition().orig[0] instanceof AST_SymbolLambda;\n    if (lhs instanceof AST_PropAccess) {\n        lhs = lhs.expression;\n        if (lhs instanceof AST_SymbolRef) {\n            if (lhs.is_immutable()) return false;\n            lhs = lhs.fixed_value();\n        }\n        if (!lhs) return true;\n        if (lhs instanceof AST_RegExp) return false;\n        if (lhs instanceof AST_Constant) return true;\n        return is_lhs_read_only(lhs);\n    }\n    return false;\n}\n\n/** var a = 1 --> var a*/\nfunction remove_initializers(var_statement) {\n    var decls = [];\n    var_statement.definitions.forEach(function(def) {\n        if (def.name instanceof AST_SymbolDeclaration) {\n            def.value = null;\n            decls.push(def);\n        } else {\n            def.declarations_as_names().forEach(name => {\n                decls.push(make_node(AST_VarDef, def, {\n                    name,\n                    value: null\n                }));\n            });\n        }\n    });\n    return decls.length ? make_node(AST_Var, var_statement, { definitions: decls }) : null;\n}\n\n/** Called on code which won't be executed but has an effect outside of itself: `var`, `function` statements, `export`, `import`. */\nfunction extract_from_unreachable_code(compressor, stat, target) {\n    walk(stat, node => {\n        if (node instanceof AST_Var) {\n            const no_initializers = remove_initializers(node);\n            if (no_initializers) target.push(no_initializers);\n            return true;\n        }\n        if (\n            node instanceof AST_Defun\n            && (node === stat || !compressor.has_directive(\"use strict\"))\n        ) {\n            target.push(node === stat ? node : make_node(AST_Var, node, {\n                definitions: [\n                    make_node(AST_VarDef, node, {\n                        name: make_node(AST_SymbolVar, node.name, node.name),\n                        value: null\n                    })\n                ]\n            }));\n            return true;\n        }\n        if (node instanceof AST_Export || node instanceof AST_Import) {\n            target.push(node);\n            return true;\n        }\n        if (node instanceof AST_Scope || node instanceof AST_Class) {\n            // Do not go into nested scopes\n            return true;\n        }\n    });\n}\n\n/** Tighten a bunch of statements together, and perform statement-level optimization. */\nfunction tighten_body(statements, compressor) {\n    const nearest_scope = compressor.find_scope();\n    const defun_scope = nearest_scope.get_defun_scope();\n    const { in_loop, in_try } = find_loop_scope_try();\n\n    var CHANGED, max_iter = 10;\n    do {\n        CHANGED = false;\n        eliminate_spurious_blocks(statements);\n        if (compressor.option(\"dead_code\")) {\n            eliminate_dead_code(statements, compressor);\n        }\n        if (compressor.option(\"if_return\")) {\n            handle_if_return(statements, compressor);\n        }\n        if (compressor.sequences_limit > 0) {\n            sequencesize(statements, compressor);\n            sequencesize_2(statements, compressor);\n        }\n        if (compressor.option(\"join_vars\")) {\n            join_consecutive_vars(statements);\n        }\n        if (compressor.option(\"collapse_vars\")) {\n            collapse(statements, compressor);\n        }\n    } while (CHANGED && max_iter-- > 0);\n\n    function find_loop_scope_try() {\n        var node = compressor.self(), level = 0, in_loop = false, in_try = false;\n        do {\n            if (node instanceof AST_IterationStatement) {\n                in_loop = true;\n            } else if (node instanceof AST_Scope) {\n                break;\n            } else if (node instanceof AST_TryBlock) {\n                in_try = true;\n            }\n        } while (node = compressor.parent(level++));\n\n        return { in_loop, in_try };\n    }\n\n    // Search from right to left for assignment-like expressions:\n    // - `var a = x;`\n    // - `a = x;`\n    // - `++a`\n    // For each candidate, scan from left to right for first usage, then try\n    // to fold assignment into the site for compression.\n    // Will not attempt to collapse assignments into or past code blocks\n    // which are not sequentially executed, e.g. loops and conditionals.\n    function collapse(statements, compressor) {\n        if (nearest_scope.pinned() || defun_scope.pinned())\n            return statements;\n        var args;\n        var candidates = [];\n        var stat_index = statements.length;\n        var scanner = new TreeTransformer(function (node) {\n            if (abort)\n                return node;\n            // Skip nodes before `candidate` as quickly as possible\n            if (!hit) {\n                if (node !== hit_stack[hit_index])\n                    return node;\n                hit_index++;\n                if (hit_index < hit_stack.length)\n                    return handle_custom_scan_order(node);\n                hit = true;\n                stop_after = find_stop(node, 0);\n                if (stop_after === node)\n                    abort = true;\n                return node;\n            }\n            // Stop immediately if these node types are encountered\n            var parent = scanner.parent();\n            if (node instanceof AST_Assign\n                    && (node.logical || node.operator != \"=\" && lhs.equivalent_to(node.left))\n                || node instanceof AST_Await\n                || node instanceof AST_Using\n                || node instanceof AST_Call && lhs instanceof AST_PropAccess && lhs.equivalent_to(node.expression)\n                ||\n                    (node instanceof AST_Call || node instanceof AST_PropAccess)\n                    && node.optional\n                || node instanceof AST_Debugger\n                || node instanceof AST_Destructuring\n                || node instanceof AST_Expansion\n                    && node.expression instanceof AST_Symbol\n                    && (\n                        node.expression instanceof AST_This\n                        || node.expression.definition().references.length > 1\n                    )\n                || node instanceof AST_IterationStatement && !(node instanceof AST_For)\n                || node instanceof AST_LoopControl\n                || node instanceof AST_Try\n                || node instanceof AST_With\n                || node instanceof AST_Yield\n                || node instanceof AST_Export\n                || node instanceof AST_Class\n                || parent instanceof AST_For && node !== parent.init\n                || !replace_all\n                    && (\n                        node instanceof AST_SymbolRef\n                        && !node.is_declared(compressor)\n                        && !pure_prop_access_globals.has(node)\n                    )\n                || node instanceof AST_SymbolRef\n                    && parent instanceof AST_Call\n                    && has_annotation(parent, _NOINLINE)\n                || node instanceof AST_ObjectProperty && node.key instanceof AST_Node\n            ) {\n                abort = true;\n                return node;\n            }\n            // Stop only if candidate is found within conditional branches\n            if (!stop_if_hit && (!lhs_local || !replace_all)\n                && (parent instanceof AST_Binary && lazy_op.has(parent.operator) && parent.left !== node\n                    || parent instanceof AST_Conditional && parent.condition !== node\n                    || parent instanceof AST_If && parent.condition !== node)) {\n                stop_if_hit = parent;\n            }\n            // Replace variable with assignment when found\n            if (\n                can_replace\n                && !(node instanceof AST_SymbolDeclaration)\n                && lhs.equivalent_to(node)\n                && !shadows(scanner.find_scope() || nearest_scope, lvalues)\n            ) {\n                if (stop_if_hit) {\n                    abort = true;\n                    return node;\n                }\n                if (is_lhs(node, parent)) {\n                    if (value_def)\n                        replaced++;\n                    return node;\n                } else {\n                    replaced++;\n                    if (value_def && candidate instanceof AST_VarDef)\n                        return node;\n                }\n                CHANGED = abort = true;\n                if (candidate instanceof AST_UnaryPostfix) {\n                    return make_node(AST_UnaryPrefix, candidate, candidate);\n                }\n                if (candidate instanceof AST_VarDef) {\n                    var def = candidate.name.definition();\n                    var value = candidate.value;\n                    if (def.references.length - def.replaced == 1 && !compressor.exposed(def)) {\n                        def.replaced++;\n                        if (funarg && is_identifier_atom(value)) {\n                            return value.transform(compressor);\n                        } else {\n                            return maintain_this_binding(parent, node, value);\n                        }\n                    }\n                    return make_node(AST_Assign, candidate, {\n                        operator: \"=\",\n                        logical: false,\n                        left: make_node(AST_SymbolRef, candidate.name, candidate.name),\n                        right: value\n                    });\n                }\n                clear_flag(candidate, WRITE_ONLY);\n                return candidate;\n            }\n            // These node types have child nodes that execute sequentially,\n            // but are otherwise not safe to scan into or beyond them.\n            var sym;\n            if (node instanceof AST_Call\n                || node instanceof AST_Exit\n                && (side_effects || lhs instanceof AST_PropAccess || may_modify(lhs))\n                || node instanceof AST_PropAccess\n                && (side_effects || node.expression.may_throw_on_access(compressor))\n                || node instanceof AST_SymbolRef\n                && ((lvalues.has(node.name) && lvalues.get(node.name).modified) || side_effects && may_modify(node))\n                || node instanceof AST_VarDef && node.value\n                && (lvalues.has(node.name.name) || side_effects && may_modify(node.name))\n                || node instanceof AST_Using\n                || (sym = is_lhs(node.left, node))\n                && (sym instanceof AST_PropAccess || lvalues.has(sym.name))\n                || may_throw\n                && (in_try ? node.has_side_effects(compressor) : side_effects_external(node))) {\n                stop_after = node;\n                if (node instanceof AST_Scope)\n                    abort = true;\n            }\n            return handle_custom_scan_order(node);\n        }, function (node) {\n            if (abort)\n                return;\n            if (stop_after === node)\n                abort = true;\n            if (stop_if_hit === node)\n                stop_if_hit = null;\n        });\n\n        var multi_replacer = new TreeTransformer(function (node) {\n            if (abort)\n                return node;\n            // Skip nodes before `candidate` as quickly as possible\n            if (!hit) {\n                if (node !== hit_stack[hit_index])\n                    return node;\n                hit_index++;\n                if (hit_index < hit_stack.length)\n                    return;\n                hit = true;\n                return node;\n            }\n            // Replace variable when found\n            if (node instanceof AST_SymbolRef\n                && node.name == def.name) {\n                if (!--replaced)\n                    abort = true;\n                if (is_lhs(node, multi_replacer.parent()))\n                    return node;\n                def.replaced++;\n                value_def.replaced--;\n                return candidate.value;\n            }\n            // Skip (non-executed) functions and (leading) default case in switch statements\n            if (node instanceof AST_Default || node instanceof AST_Scope)\n                return node;\n        });\n\n        while (--stat_index >= 0) {\n            // Treat parameters as collapsible in IIFE, i.e.\n            //   function(a, b){ ... }(x());\n            // would be translated into equivalent assignments:\n            //   var a = x(), b = undefined;\n            if (stat_index == 0 && compressor.option(\"unused\"))\n                extract_args();\n            // Find collapsible assignments\n            var hit_stack = [];\n            extract_candidates(statements[stat_index]);\n            while (candidates.length > 0) {\n                hit_stack = candidates.pop();\n                var hit_index = 0;\n                var candidate = hit_stack[hit_stack.length - 1];\n                var value_def = null;\n                var stop_after = null;\n                var stop_if_hit = null;\n                var lhs = get_lhs(candidate);\n                if (!lhs || is_lhs_read_only(lhs) || lhs.has_side_effects(compressor))\n                    continue;\n                // Locate symbols which may execute code outside of scanning range\n                var lvalues = get_lvalues(candidate);\n                var lhs_local = is_lhs_local(lhs);\n                if (lhs instanceof AST_SymbolRef) {\n                    lvalues.set(lhs.name, { def: lhs.definition(), modified: false });\n                }\n                var side_effects = value_has_side_effects(candidate);\n                var replace_all = replace_all_symbols();\n                var may_throw = candidate.may_throw(compressor);\n                var funarg = candidate.name instanceof AST_SymbolFunarg;\n                var hit = funarg;\n                var abort = false, replaced = 0, can_replace = !args || !hit;\n                if (!can_replace) {\n                    for (\n                        let j = compressor.self().argnames.lastIndexOf(candidate.name) + 1;\n                        !abort && j < args.length;\n                        j++\n                    ) {\n                        args[j].transform(scanner);\n                    }\n                    can_replace = true;\n                }\n                for (var i = stat_index; !abort && i < statements.length; i++) {\n                    statements[i].transform(scanner);\n                }\n                if (value_def) {\n                    var def = candidate.name.definition();\n                    if (abort && def.references.length - def.replaced > replaced)\n                        replaced = false;\n                    else {\n                        abort = false;\n                        hit_index = 0;\n                        hit = funarg;\n                        for (var i = stat_index; !abort && i < statements.length; i++) {\n                            statements[i].transform(multi_replacer);\n                        }\n                        value_def.single_use = false;\n                    }\n                }\n                if (replaced && !remove_candidate(candidate))\n                    statements.splice(stat_index, 1);\n            }\n        }\n\n        function handle_custom_scan_order(node) {\n            // Skip (non-executed) functions\n            if (node instanceof AST_Scope)\n                return node;\n\n            // Scan case expressions first in a switch statement\n            if (node instanceof AST_Switch) {\n                node.expression = node.expression.transform(scanner);\n                for (var i = 0, len = node.body.length; !abort && i < len; i++) {\n                    var branch = node.body[i];\n                    if (branch instanceof AST_Case) {\n                        if (!hit) {\n                            if (branch !== hit_stack[hit_index])\n                                continue;\n                            hit_index++;\n                        }\n                        branch.expression = branch.expression.transform(scanner);\n                        if (!replace_all)\n                            break;\n                    }\n                }\n                abort = true;\n                return node;\n            }\n        }\n\n        function redefined_within_scope(def, scope) {\n            if (def.global)\n                return false;\n            let cur_scope = def.scope;\n            while (cur_scope && cur_scope !== scope) {\n                if (cur_scope.variables.has(def.name)) {\n                    return true;\n                }\n                cur_scope = cur_scope.parent_scope;\n            }\n            return false;\n        }\n\n        function has_overlapping_symbol(fn, arg, fn_strict) {\n            var found = false, scan_this = !(fn instanceof AST_Arrow);\n            arg.walk(new TreeWalker(function (node, descend) {\n                if (found)\n                    return true;\n                if (node instanceof AST_SymbolRef && (fn.variables.has(node.name) || redefined_within_scope(node.definition(), fn))) {\n                    var s = node.definition().scope;\n                    if (s !== defun_scope)\n                        while (s = s.parent_scope) {\n                            if (s === defun_scope)\n                                return true;\n                        }\n                    return found = true;\n                }\n                if ((fn_strict || scan_this) && node instanceof AST_This) {\n                    return found = true;\n                }\n                if (node instanceof AST_Scope && !(node instanceof AST_Arrow)) {\n                    var prev = scan_this;\n                    scan_this = false;\n                    descend();\n                    scan_this = prev;\n                    return true;\n                }\n            }));\n            return found;\n        }\n\n        function arg_is_injectable(arg) {\n            if (arg instanceof AST_Expansion) return false;\n            const contains_await = walk(arg, (node) => {\n                if (node instanceof AST_Await) return walk_abort;\n            });\n            if (contains_await) return false;\n            return true;\n        }\n        function extract_args() {\n            var iife, fn = compressor.self();\n            if (is_func_expr(fn)\n                && !fn.name\n                && !fn.uses_arguments\n                && !fn.pinned()\n                && (iife = compressor.parent()) instanceof AST_Call\n                && iife.expression === fn\n                && iife.args.every(arg_is_injectable)\n            ) {\n                var fn_strict = compressor.has_directive(\"use strict\");\n                if (fn_strict && !member(fn_strict, fn.body))\n                    fn_strict = false;\n                var len = fn.argnames.length;\n                args = iife.args.slice(len);\n                var names = new Set();\n                for (var i = len; --i >= 0;) {\n                    var sym = fn.argnames[i];\n                    var arg = iife.args[i];\n                    // The following two line fix is a duplicate of the fix at\n                    // https://github.com/terser/terser/commit/011d3eb08cefe6922c7d1bdfa113fc4aeaca1b75\n                    // This might mean that these two pieces of code (one here in collapse_vars and another in reduce_vars\n                    // Might be doing the exact same thing.\n                    const def = sym.definition && sym.definition();\n                    const is_reassigned = def && def.orig.length > 1;\n                    if (is_reassigned)\n                        continue;\n                    args.unshift(make_node(AST_VarDef, sym, {\n                        name: sym,\n                        value: arg\n                    }));\n                    if (names.has(sym.name))\n                        continue;\n                    names.add(sym.name);\n                    if (sym instanceof AST_Expansion) {\n                        var elements = iife.args.slice(i);\n                        if (elements.every((arg) => !has_overlapping_symbol(fn, arg, fn_strict)\n                        )) {\n                            candidates.unshift([make_node(AST_VarDef, sym, {\n                                name: sym.expression,\n                                value: make_node(AST_Array, iife, {\n                                    elements: elements\n                                })\n                            })]);\n                        }\n                    } else {\n                        if (!arg) {\n                            arg = make_node(AST_Undefined, sym).transform(compressor);\n                        } else if (arg instanceof AST_Lambda && arg.pinned()\n                            || has_overlapping_symbol(fn, arg, fn_strict)) {\n                            arg = null;\n                        }\n                        if (arg)\n                            candidates.unshift([make_node(AST_VarDef, sym, {\n                                name: sym,\n                                value: arg\n                            })]);\n                    }\n                }\n            }\n        }\n\n        function extract_candidates(expr) {\n            hit_stack.push(expr);\n            if (expr instanceof AST_Assign) {\n                if (!expr.left.has_side_effects(compressor)\n                    && !(expr.right instanceof AST_Chain)) {\n                    candidates.push(hit_stack.slice());\n                }\n                extract_candidates(expr.right);\n            } else if (expr instanceof AST_Binary) {\n                extract_candidates(expr.left);\n                extract_candidates(expr.right);\n            } else if (expr instanceof AST_Call && !has_annotation(expr, _NOINLINE)) {\n                extract_candidates(expr.expression);\n                expr.args.forEach(extract_candidates);\n            } else if (expr instanceof AST_Case) {\n                extract_candidates(expr.expression);\n            } else if (expr instanceof AST_Conditional) {\n                extract_candidates(expr.condition);\n                extract_candidates(expr.consequent);\n                extract_candidates(expr.alternative);\n            } else if (expr instanceof AST_Definitions) {\n                var len = expr.definitions.length;\n                // limit number of trailing variable definitions for consideration\n                var i = len - 200;\n                if (i < 0)\n                    i = 0;\n                for (; i < len; i++) {\n                    extract_candidates(expr.definitions[i]);\n                }\n            } else if (expr instanceof AST_DWLoop) {\n                extract_candidates(expr.condition);\n                if (!(expr.body instanceof AST_Block)) {\n                    extract_candidates(expr.body);\n                }\n            } else if (expr instanceof AST_Exit) {\n                if (expr.value)\n                    extract_candidates(expr.value);\n            } else if (expr instanceof AST_For) {\n                if (expr.init)\n                    extract_candidates(expr.init);\n                if (expr.condition)\n                    extract_candidates(expr.condition);\n                if (expr.step)\n                    extract_candidates(expr.step);\n                if (!(expr.body instanceof AST_Block)) {\n                    extract_candidates(expr.body);\n                }\n            } else if (expr instanceof AST_ForIn) {\n                extract_candidates(expr.object);\n                if (!(expr.body instanceof AST_Block)) {\n                    extract_candidates(expr.body);\n                }\n            } else if (expr instanceof AST_If) {\n                extract_candidates(expr.condition);\n                if (!(expr.body instanceof AST_Block)) {\n                    extract_candidates(expr.body);\n                }\n                if (expr.alternative && !(expr.alternative instanceof AST_Block)) {\n                    extract_candidates(expr.alternative);\n                }\n            } else if (expr instanceof AST_Sequence) {\n                expr.expressions.forEach(extract_candidates);\n            } else if (expr instanceof AST_SimpleStatement) {\n                extract_candidates(expr.body);\n            } else if (expr instanceof AST_Switch) {\n                extract_candidates(expr.expression);\n                expr.body.forEach(extract_candidates);\n            } else if (expr instanceof AST_Unary) {\n                if (expr.operator == \"++\" || expr.operator == \"--\") {\n                    candidates.push(hit_stack.slice());\n                }\n            } else if (expr instanceof AST_VarDef) {\n                if (expr.value && !(expr.value instanceof AST_Chain)) {\n                    candidates.push(hit_stack.slice());\n                    extract_candidates(expr.value);\n                }\n            }\n            hit_stack.pop();\n        }\n\n        function find_stop(node, level, write_only) {\n            var parent = scanner.parent(level);\n            if (parent instanceof AST_Assign) {\n                if (write_only\n                    && !parent.logical\n                    && !(parent.left instanceof AST_PropAccess\n                        || lvalues.has(parent.left.name))) {\n                    return find_stop(parent, level + 1, write_only);\n                }\n                return node;\n            }\n            if (parent instanceof AST_Binary) {\n                if (write_only && (!lazy_op.has(parent.operator) || parent.left === node)) {\n                    return find_stop(parent, level + 1, write_only);\n                }\n                return node;\n            }\n            if (parent instanceof AST_Call)\n                return node;\n            if (parent instanceof AST_Case)\n                return node;\n            if (parent instanceof AST_Conditional) {\n                if (write_only && parent.condition === node) {\n                    return find_stop(parent, level + 1, write_only);\n                }\n                return node;\n            }\n            if (parent instanceof AST_Definitions) {\n                return find_stop(parent, level + 1, true);\n            }\n            if (parent instanceof AST_Exit) {\n                return write_only ? find_stop(parent, level + 1, write_only) : node;\n            }\n            if (parent instanceof AST_If) {\n                if (write_only && parent.condition === node) {\n                    return find_stop(parent, level + 1, write_only);\n                }\n                return node;\n            }\n            if (parent instanceof AST_IterationStatement)\n                return node;\n            if (parent instanceof AST_Sequence) {\n                return find_stop(parent, level + 1, parent.tail_node() !== node);\n            }\n            if (parent instanceof AST_SimpleStatement) {\n                return find_stop(parent, level + 1, true);\n            }\n            if (parent instanceof AST_Switch)\n                return node;\n            if (parent instanceof AST_VarDef)\n                return node;\n            return null;\n        }\n\n        function mangleable_var(var_def) {\n            var value = var_def.value;\n            if (!(value instanceof AST_SymbolRef))\n                return;\n            if (value.name == \"arguments\")\n                return;\n            var def = value.definition();\n            if (def.undeclared)\n                return;\n            return value_def = def;\n        }\n\n        function get_lhs(expr) {\n            if (expr instanceof AST_Assign && expr.logical) {\n                return false;\n            } else if (expr instanceof AST_VarDef && expr.name instanceof AST_SymbolDeclaration) {\n                var def = expr.name.definition();\n                if (!member(expr.name, def.orig))\n                    return;\n                var referenced = def.references.length - def.replaced;\n                if (!referenced)\n                    return;\n                var declared = def.orig.length - def.eliminated;\n                if (declared > 1 && !(expr.name instanceof AST_SymbolFunarg)\n                    || (referenced > 1 ? mangleable_var(expr) : !compressor.exposed(def))) {\n                    return make_node(AST_SymbolRef, expr.name, expr.name);\n                }\n            } else {\n                const lhs = expr instanceof AST_Assign\n                    ? expr.left\n                    : expr.expression;\n                return !is_ref_of(lhs, AST_SymbolConst)\n                    && !is_ref_of(lhs, AST_SymbolLet)\n                    && !is_ref_of(lhs, AST_SymbolUsing)\n                    && lhs;\n            }\n        }\n\n        function get_rvalue(expr) {\n            if (expr instanceof AST_Assign) {\n                return expr.right;\n            } else {\n                return expr.value;\n            }\n        }\n\n        function get_lvalues(expr) {\n            var lvalues = new Map();\n            if (expr instanceof AST_Unary)\n                return lvalues;\n            var tw = new TreeWalker(function (node) {\n                var sym = node;\n                while (sym instanceof AST_PropAccess)\n                    sym = sym.expression;\n                if (sym instanceof AST_SymbolRef) {\n                    const prev = lvalues.get(sym.name);\n                    if (!prev || !prev.modified) {\n                        lvalues.set(sym.name, {\n                            def: sym.definition(),\n                            modified: is_modified(compressor, tw, node, node, 0)\n                        });\n                    }\n                }\n            });\n            get_rvalue(expr).walk(tw);\n            return lvalues;\n        }\n\n        function remove_candidate(expr) {\n            if (expr.name instanceof AST_SymbolFunarg) {\n                var iife = compressor.parent(), argnames = compressor.self().argnames;\n                var index = argnames.indexOf(expr.name);\n                if (index < 0) {\n                    iife.args.length = Math.min(iife.args.length, argnames.length - 1);\n                } else {\n                    var args = iife.args;\n                    if (args[index])\n                        args[index] = make_node(AST_Number, args[index], {\n                            value: 0\n                        });\n                }\n                return true;\n            }\n            var found = false;\n            return statements[stat_index].transform(new TreeTransformer(function (node, descend, in_list) {\n                if (found)\n                    return node;\n                if (node === expr || node.body === expr) {\n                    found = true;\n                    if (node instanceof AST_VarDef) {\n                        node.value = node.name instanceof AST_SymbolConst\n                            ? make_node(AST_Undefined, node.value) // `const` always needs value.\n                            : null;\n                        return node;\n                    }\n                    return in_list ? MAP.skip : null;\n                }\n            }, function (node) {\n                if (node instanceof AST_Sequence)\n                    switch (node.expressions.length) {\n                        case 0: return null;\n                        case 1: return node.expressions[0];\n                    }\n            }));\n        }\n\n        function is_lhs_local(lhs) {\n            while (lhs instanceof AST_PropAccess)\n                lhs = lhs.expression;\n            return lhs instanceof AST_SymbolRef\n                && lhs.definition().scope.get_defun_scope() === defun_scope\n                && !(in_loop\n                    && (lvalues.has(lhs.name)\n                        || candidate instanceof AST_Unary\n                        || (candidate instanceof AST_Assign\n                            && !candidate.logical\n                            && candidate.operator != \"=\")));\n        }\n\n        function value_has_side_effects(expr) {\n            if (expr instanceof AST_Unary)\n                return unary_side_effects.has(expr.operator);\n            return get_rvalue(expr).has_side_effects(compressor);\n        }\n\n        function replace_all_symbols() {\n            if (side_effects)\n                return false;\n            if (value_def)\n                return true;\n            if (lhs instanceof AST_SymbolRef) {\n                var def = lhs.definition();\n                if (def.references.length - def.replaced == (candidate instanceof AST_VarDef ? 1 : 2)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function may_modify(sym) {\n            if (!sym.definition)\n                return true; // AST_Destructuring\n            var def = sym.definition();\n            if (def.orig.length == 1 && def.orig[0] instanceof AST_SymbolDefun)\n                return false;\n            if (def.scope.get_defun_scope() !== defun_scope)\n                return true;\n            return def.references.some((ref) =>\n                ref.scope.get_defun_scope() !== defun_scope\n            );\n        }\n\n        function side_effects_external(node, lhs) {\n            if (node instanceof AST_Assign)\n                return side_effects_external(node.left, true);\n            if (node instanceof AST_Unary)\n                return side_effects_external(node.expression, true);\n            if (node instanceof AST_VarDef)\n                return node.value && side_effects_external(node.value);\n            if (lhs) {\n                if (node instanceof AST_Dot)\n                    return side_effects_external(node.expression, true);\n                if (node instanceof AST_Sub)\n                    return side_effects_external(node.expression, true);\n                if (node instanceof AST_SymbolRef)\n                    return node.definition().scope.get_defun_scope() !== defun_scope;\n            }\n            return false;\n        }\n\n        /**\n         * Will any of the pulled-in lvalues shadow a variable in newScope or parents?\n         * similar to scope_encloses_variables_in_this_scope */\n        function shadows(my_scope, lvalues) {\n            for (const { def } of lvalues.values()) {\n                const looked_up = my_scope.find_variable(def.name);\n                if (looked_up) {\n                    if (looked_up === def) continue;\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    function eliminate_spurious_blocks(statements) {\n        var seen_dirs = [];\n        for (var i = 0; i < statements.length;) {\n            var stat = statements[i];\n            if (stat instanceof AST_BlockStatement && stat.body.every(can_be_evicted_from_block)) {\n                CHANGED = true;\n                eliminate_spurious_blocks(stat.body);\n                statements.splice(i, 1, ...stat.body);\n                i += stat.body.length;\n            } else if (stat instanceof AST_EmptyStatement) {\n                CHANGED = true;\n                statements.splice(i, 1);\n            } else if (stat instanceof AST_Directive) {\n                if (seen_dirs.indexOf(stat.value) < 0) {\n                    i++;\n                    seen_dirs.push(stat.value);\n                } else {\n                    CHANGED = true;\n                    statements.splice(i, 1);\n                }\n            } else\n                i++;\n        }\n    }\n\n    function handle_if_return(statements, compressor) {\n        var self = compressor.self();\n        var multiple_if_returns = has_multiple_if_returns(statements);\n        var in_lambda = self instanceof AST_Lambda;\n        // Prevent extremely deep nesting\n        // https://github.com/terser/terser/issues/1432\n        // https://github.com/webpack/webpack/issues/17548\n        const iteration_start = Math.min(statements.length, 500);\n        for (var i = iteration_start; --i >= 0;) {\n            var stat = statements[i];\n            var j = next_index(i);\n            var next = statements[j];\n\n            if (in_lambda && !next && stat instanceof AST_Return) {\n                if (!stat.value) {\n                    CHANGED = true;\n                    statements.splice(i, 1);\n                    continue;\n                }\n                if (stat.value instanceof AST_UnaryPrefix && stat.value.operator == \"void\") {\n                    CHANGED = true;\n                    statements[i] = make_node(AST_SimpleStatement, stat, {\n                        body: stat.value.expression\n                    });\n                    continue;\n                }\n            }\n\n            if (stat instanceof AST_If) {\n                let ab, new_else;\n\n                ab = aborts(stat.body);\n                if (\n                    can_merge_flow(ab)\n                    && (new_else = as_statement_array_with_return(stat.body, ab))\n                ) {\n                    if (ab.label) {\n                        remove(ab.label.thedef.references, ab);\n                    }\n                    CHANGED = true;\n                    stat = stat.clone();\n                    stat.condition = stat.condition.negate(compressor);\n                    stat.body = make_node(AST_BlockStatement, stat, {\n                        body: as_statement_array(stat.alternative).concat(extract_defuns())\n                    });\n                    stat.alternative = make_node(AST_BlockStatement, stat, {\n                        body: new_else\n                    });\n                    statements[i] = stat.transform(compressor);\n                    continue;\n                }\n\n                ab = aborts(stat.alternative);\n                if (\n                    can_merge_flow(ab)\n                    && (new_else = as_statement_array_with_return(stat.alternative, ab))\n                ) {\n                    if (ab.label) {\n                        remove(ab.label.thedef.references, ab);\n                    }\n                    CHANGED = true;\n                    stat = stat.clone();\n                    stat.body = make_node(AST_BlockStatement, stat.body, {\n                        body: as_statement_array(stat.body).concat(extract_defuns())\n                    });\n                    stat.alternative = make_node(AST_BlockStatement, stat.alternative, {\n                        body: new_else\n                    });\n                    statements[i] = stat.transform(compressor);\n                    continue;\n                }\n            }\n\n            if (stat instanceof AST_If && stat.body instanceof AST_Return) {\n                var value = stat.body.value;\n                //---\n                // pretty silly case, but:\n                // if (foo()) return; return; ==> foo(); return;\n                if (!value && !stat.alternative\n                    && (in_lambda && !next || next instanceof AST_Return && !next.value)) {\n                    CHANGED = true;\n                    statements[i] = make_node(AST_SimpleStatement, stat.condition, {\n                        body: stat.condition\n                    });\n                    continue;\n                }\n                //---\n                // if (foo()) return x; return y; ==> return foo() ? x : y;\n                if (value && !stat.alternative && next instanceof AST_Return && next.value) {\n                    CHANGED = true;\n                    stat = stat.clone();\n                    stat.alternative = next;\n                    statements[i] = stat.transform(compressor);\n                    statements.splice(j, 1);\n                    continue;\n                }\n                //---\n                // if (foo()) return x; [ return ; ] ==> return foo() ? x : undefined;\n                if (value && !stat.alternative\n                    && (!next && in_lambda && multiple_if_returns\n                        || next instanceof AST_Return)) {\n                    CHANGED = true;\n                    stat = stat.clone();\n                    stat.alternative = next || make_node(AST_Return, stat, {\n                        value: null\n                    });\n                    statements[i] = stat.transform(compressor);\n                    if (next)\n                        statements.splice(j, 1);\n                    continue;\n                }\n                //---\n                // if (a) return b; if (c) return d; e; ==> return a ? b : c ? d : void e;\n                //\n                // if sequences is not enabled, this can lead to an endless loop (issue #866).\n                // however, with sequences on this helps producing slightly better output for\n                // the example code.\n                var prev = statements[prev_index(i)];\n                if (compressor.option(\"sequences\") && in_lambda && !stat.alternative\n                    && prev instanceof AST_If && prev.body instanceof AST_Return\n                    && next_index(j) == statements.length && next instanceof AST_SimpleStatement) {\n                    CHANGED = true;\n                    stat = stat.clone();\n                    stat.alternative = make_node(AST_BlockStatement, next, {\n                        body: [\n                            next,\n                            make_node(AST_Return, next, {\n                                value: null\n                            })\n                        ]\n                    });\n                    statements[i] = stat.transform(compressor);\n                    statements.splice(j, 1);\n                    continue;\n                }\n            }\n        }\n\n        function has_multiple_if_returns(statements) {\n            var n = 0;\n            for (var i = statements.length; --i >= 0;) {\n                var stat = statements[i];\n                if (stat instanceof AST_If && stat.body instanceof AST_Return) {\n                    if (++n > 1)\n                        return true;\n                }\n            }\n            return false;\n        }\n\n        function is_return_void(value) {\n            return !value || value instanceof AST_UnaryPrefix && value.operator == \"void\";\n        }\n\n        function can_merge_flow(ab) {\n            if (!ab)\n                return false;\n            for (var j = i + 1, len = statements.length; j < len; j++) {\n                var stat = statements[j];\n                if (stat instanceof AST_DefinitionsLike && !(stat instanceof AST_Var))\n                    return false;\n            }\n            var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab) : null;\n            return ab instanceof AST_Return && in_lambda && is_return_void(ab.value)\n                || ab instanceof AST_Continue && self === loop_body(lct)\n                || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct;\n        }\n\n        function extract_defuns() {\n            var tail = statements.slice(i + 1);\n            statements.length = i + 1;\n            return tail.filter(function (stat) {\n                if (stat instanceof AST_Defun) {\n                    statements.push(stat);\n                    return false;\n                }\n                return true;\n            });\n        }\n\n        function as_statement_array_with_return(node, ab) {\n            var body = as_statement_array(node);\n            if (ab !== body[body.length - 1]) {\n                return undefined;\n            }\n            body = body.slice(0, -1);\n            if (!body.every(stat => can_be_evicted_from_block(stat))) {\n                return undefined;\n            }\n            if (ab.value) {\n                body.push(make_node(AST_SimpleStatement, ab.value, {\n                    body: ab.value.expression\n                }));\n            }\n            return body;\n        }\n\n        function next_index(i) {\n            for (var j = i + 1, len = statements.length; j < len; j++) {\n                var stat = statements[j];\n                if (!(stat instanceof AST_Var && declarations_only(stat))) {\n                    break;\n                }\n            }\n            return j;\n        }\n\n        function prev_index(i) {\n            for (var j = i; --j >= 0;) {\n                var stat = statements[j];\n                if (!(stat instanceof AST_Var && declarations_only(stat))) {\n                    break;\n                }\n            }\n            return j;\n        }\n    }\n\n    function eliminate_dead_code(statements, compressor) {\n        var has_quit;\n        var self = compressor.self();\n        for (var i = 0, n = 0, len = statements.length; i < len; i++) {\n            var stat = statements[i];\n            if (stat instanceof AST_LoopControl) {\n                var lct = compressor.loopcontrol_target(stat);\n                if (stat instanceof AST_Break\n                    && !(lct instanceof AST_IterationStatement)\n                    && loop_body(lct) === self\n                    || stat instanceof AST_Continue\n                    && loop_body(lct) === self) {\n                    if (stat.label) {\n                        remove(stat.label.thedef.references, stat);\n                    }\n                } else {\n                    statements[n++] = stat;\n                }\n            } else {\n                statements[n++] = stat;\n            }\n            if (aborts(stat)) {\n                has_quit = statements.slice(i + 1);\n                break;\n            }\n        }\n        statements.length = n;\n        CHANGED = n != len;\n        if (has_quit)\n            has_quit.forEach(function (stat) {\n                extract_from_unreachable_code(compressor, stat, statements);\n            });\n    }\n\n    function declarations_only(node) {\n        return node.definitions.every((var_def) => !var_def.value);\n    }\n\n    function sequencesize(statements, compressor) {\n        if (statements.length < 2)\n            return;\n        var seq = [], n = 0;\n        function push_seq() {\n            if (!seq.length)\n                return;\n            var body = make_sequence(seq[0], seq);\n            statements[n++] = make_node(AST_SimpleStatement, body, { body: body });\n            seq = [];\n        }\n        for (var i = 0, len = statements.length; i < len; i++) {\n            var stat = statements[i];\n            if (stat instanceof AST_SimpleStatement) {\n                if (seq.length >= compressor.sequences_limit)\n                    push_seq();\n                var body = stat.body;\n                if (seq.length > 0)\n                    body = body.drop_side_effect_free(compressor);\n                if (body)\n                    merge_sequence(seq, body);\n            } else if (stat instanceof AST_Definitions && declarations_only(stat)\n                || stat instanceof AST_Defun) {\n                statements[n++] = stat;\n            } else {\n                push_seq();\n                statements[n++] = stat;\n            }\n        }\n        push_seq();\n        statements.length = n;\n        if (n != len)\n            CHANGED = true;\n    }\n\n    function to_simple_statement(block, decls) {\n        if (!(block instanceof AST_BlockStatement))\n            return block;\n        var stat = null;\n        for (var i = 0, len = block.body.length; i < len; i++) {\n            var line = block.body[i];\n            if (line instanceof AST_Var && declarations_only(line)) {\n                decls.push(line);\n            } else if (stat || line instanceof AST_DefinitionsLike && !(line instanceof AST_Var)) {\n                return false;\n            } else {\n                stat = line;\n            }\n        }\n        return stat;\n    }\n\n    function sequencesize_2(statements, compressor) {\n        function cons_seq(right) {\n            n--;\n            CHANGED = true;\n            var left = prev.body;\n            return make_sequence(left, [left, right]).transform(compressor);\n        }\n        var n = 0, prev;\n        for (var i = 0; i < statements.length; i++) {\n            var stat = statements[i];\n            if (prev) {\n                if (stat instanceof AST_Exit) {\n                    stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat).transform(compressor));\n                } else if (stat instanceof AST_For) {\n                    if (!(stat.init instanceof AST_DefinitionsLike)) {\n                        const abort = walk(prev.body, node => {\n                            if (node instanceof AST_Scope)\n                                return true;\n                            if (node instanceof AST_Binary\n                                && node.operator === \"in\") {\n                                return walk_abort;\n                            }\n                        });\n                        if (!abort) {\n                            if (stat.init)\n                                stat.init = cons_seq(stat.init);\n                            else {\n                                stat.init = prev.body;\n                                n--;\n                                CHANGED = true;\n                            }\n                        }\n                    }\n                } else if (stat instanceof AST_ForIn) {\n                    if (!(stat.init instanceof AST_DefinitionsLike) || stat.init instanceof AST_Var) {\n                        stat.object = cons_seq(stat.object);\n                    }\n                } else if (stat instanceof AST_If) {\n                    stat.condition = cons_seq(stat.condition);\n                } else if (stat instanceof AST_Switch) {\n                    stat.expression = cons_seq(stat.expression);\n                } else if (stat instanceof AST_With) {\n                    stat.expression = cons_seq(stat.expression);\n                }\n            }\n            if (compressor.option(\"conditionals\") && stat instanceof AST_If) {\n                var decls = [];\n                var body = to_simple_statement(stat.body, decls);\n                var alt = to_simple_statement(stat.alternative, decls);\n                if (body !== false && alt !== false && decls.length > 0) {\n                    var len = decls.length;\n                    decls.push(make_node(AST_If, stat, {\n                        condition: stat.condition,\n                        body: body || make_node(AST_EmptyStatement, stat.body),\n                        alternative: alt\n                    }));\n                    decls.unshift(n, 1);\n                    [].splice.apply(statements, decls);\n                    i += len;\n                    n += len + 1;\n                    prev = null;\n                    CHANGED = true;\n                    continue;\n                }\n            }\n            statements[n++] = stat;\n            prev = stat instanceof AST_SimpleStatement ? stat : null;\n        }\n        statements.length = n;\n    }\n\n    function join_object_assignments(defn, body) {\n        if (!(defn instanceof AST_Definitions))\n            return;\n        var def = defn.definitions[defn.definitions.length - 1];\n        if (!(def.value instanceof AST_Object))\n            return;\n        var exprs;\n        if (body instanceof AST_Assign && !body.logical) {\n            exprs = [body];\n        } else if (body instanceof AST_Sequence) {\n            exprs = body.expressions.slice();\n        }\n        if (!exprs)\n            return;\n        var trimmed = false;\n        do {\n            var node = exprs[0];\n            if (!(node instanceof AST_Assign))\n                break;\n            if (node.operator != \"=\")\n                break;\n            if (!(node.left instanceof AST_PropAccess))\n                break;\n            var sym = node.left.expression;\n            if (!(sym instanceof AST_SymbolRef))\n                break;\n            if (def.name.name != sym.name)\n                break;\n            if (!node.right.is_constant_expression(nearest_scope))\n                break;\n            var prop = node.left.property;\n            if (prop instanceof AST_Node) {\n                prop = prop.evaluate(compressor);\n            }\n            if (prop instanceof AST_Node)\n                break;\n            prop = \"\" + prop;\n            var diff = compressor.option(\"ecma\") < 2015\n                && compressor.has_directive(\"use strict\") ? function (node) {\n                    return node.key != prop && (node.key && node.key.name != prop);\n                } : function (node) {\n                    return node.key && node.key.name != prop;\n                };\n            if (!def.value.properties.every(diff))\n                break;\n            var p = def.value.properties.filter(function (p) { return p.key === prop; })[0];\n            if (!p) {\n                def.value.properties.push(make_node(AST_ObjectKeyVal, node, {\n                    key: prop,\n                    value: node.right\n                }));\n            } else {\n                p.value = new AST_Sequence({\n                    start: p.start,\n                    expressions: [p.value.clone(), node.right.clone()],\n                    end: p.end\n                });\n            }\n            exprs.shift();\n            trimmed = true;\n        } while (exprs.length);\n        return trimmed && exprs;\n    }\n\n    function join_consecutive_vars(statements) {\n        var defs;\n        for (var i = 0, j = -1, len = statements.length; i < len; i++) {\n            var stat = statements[i];\n            var prev = statements[j];\n            if (stat instanceof AST_Definitions) {\n                if (prev && prev.TYPE == stat.TYPE) {\n                    prev.definitions = prev.definitions.concat(stat.definitions);\n                    CHANGED = true;\n                } else if (defs && defs.TYPE == stat.TYPE && declarations_only(stat)) {\n                    defs.definitions = defs.definitions.concat(stat.definitions);\n                    CHANGED = true;\n                } else {\n                    statements[++j] = stat;\n                    defs = stat;\n                }\n            } else if (\n                stat instanceof AST_Using\n                && prev instanceof AST_Using\n                && prev.await === stat.await\n            ) {\n                prev.definitions = prev.definitions.concat(stat.definitions);\n            } else if (stat instanceof AST_Exit) {\n                stat.value = extract_object_assignments(stat.value);\n            } else if (stat instanceof AST_For) {\n                var exprs = join_object_assignments(prev, stat.init);\n                if (exprs) {\n                    CHANGED = true;\n                    stat.init = exprs.length ? make_sequence(stat.init, exprs) : null;\n                    statements[++j] = stat;\n                } else if (\n                    prev instanceof AST_Var\n                    && (!stat.init || stat.init.TYPE == prev.TYPE)\n                ) {\n                    if (stat.init) {\n                        prev.definitions = prev.definitions.concat(stat.init.definitions);\n                    }\n                    stat.init = prev;\n                    statements[j] = stat;\n                    CHANGED = true;\n                } else if (\n                    defs instanceof AST_Var\n                    && stat.init instanceof AST_Var\n                    && declarations_only(stat.init)\n                ) {\n                    defs.definitions = defs.definitions.concat(stat.init.definitions);\n                    stat.init = null;\n                    statements[++j] = stat;\n                    CHANGED = true;\n                } else {\n                    statements[++j] = stat;\n                }\n            } else if (stat instanceof AST_ForIn) {\n                stat.object = extract_object_assignments(stat.object);\n            } else if (stat instanceof AST_If) {\n                stat.condition = extract_object_assignments(stat.condition);\n            } else if (stat instanceof AST_SimpleStatement) {\n                var exprs = join_object_assignments(prev, stat.body);\n                if (exprs) {\n                    CHANGED = true;\n                    if (!exprs.length)\n                        continue;\n                    stat.body = make_sequence(stat.body, exprs);\n                }\n                statements[++j] = stat;\n            } else if (stat instanceof AST_Switch) {\n                stat.expression = extract_object_assignments(stat.expression);\n            } else if (stat instanceof AST_With) {\n                stat.expression = extract_object_assignments(stat.expression);\n            } else {\n                statements[++j] = stat;\n            }\n        }\n        statements.length = j + 1;\n\n        function extract_object_assignments(value) {\n            statements[++j] = stat;\n            var exprs = join_object_assignments(prev, value);\n            if (exprs) {\n                CHANGED = true;\n                if (exprs.length) {\n                    return make_sequence(value, exprs);\n                } else if (value instanceof AST_Sequence) {\n                    return value.tail_node().left;\n                } else {\n                    return value.left;\n                }\n            }\n            return value;\n        }\n    }\n}\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n/**\n * Module that contains the inlining logic.\n *\n * @module\n *\n * The stars of the show are `inline_into_symbolref` and `inline_into_call`.\n */\n\nfunction within_array_or_object_literal(compressor) {\n    var node, level = 0;\n    while (node = compressor.parent(level++)) {\n        if (node instanceof AST_Statement) return false;\n        if (node instanceof AST_Array\n            || node instanceof AST_ObjectKeyVal\n            || node instanceof AST_Object) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction scope_encloses_variables_in_this_scope(scope, pulled_scope) {\n    for (const enclosed of pulled_scope.enclosed) {\n        if (pulled_scope.variables.has(enclosed.name)) {\n            continue;\n        }\n        const looked_up = scope.find_variable(enclosed.name);\n        if (looked_up) {\n            if (looked_up === enclosed) continue;\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * An extra check function for `top_retain` option, compare the length of const identifier\n * and init value length and return true if init value is longer than identifier. for example:\n * ```\n * // top_retain: [\"example\"]\n * const example = 100\n * ```\n * it will return false because length of \"100\" is short than identifier \"example\".\n */\nfunction is_const_symbol_short_than_init_value(def, fixed_value) {\n    if (def.orig.length === 1 && fixed_value) {\n        const init_value_length = fixed_value.size();\n        const identifer_length = def.name.length;\n        return init_value_length > identifer_length;\n    }\n    return true;\n}\n\nfunction inline_into_symbolref(self, compressor) {\n    if (compressor.in_computed_key()) return self;\n\n    const parent = compressor.parent();\n    const def = self.definition();\n    const nearest_scope = compressor.find_scope();\n    let fixed = self.fixed_value();\n    if (\n        compressor.top_retain &&\n        def.global && \n        compressor.top_retain(def) && \n        // when identifier is in top_retain option dose not mean we can always inline it.\n        // if identifier name is longer then init value, we can replace it.\n        is_const_symbol_short_than_init_value(def, fixed)\n    ) {\n        // keep it\n        def.fixed = false;\n        def.single_use = false;\n        return self;\n    }\n\n    if (dont_inline_lambda_in_loop(compressor, fixed)) return self;\n\n    let single_use = def.single_use\n        && !(parent instanceof AST_Call\n            && (parent.is_callee_pure(compressor))\n                || has_annotation(parent, _NOINLINE))\n        && !(parent instanceof AST_Export\n            && fixed instanceof AST_Lambda\n            && fixed.name);\n\n    if (single_use && fixed instanceof AST_Node) {\n        single_use =\n            !fixed.has_side_effects(compressor)\n            && !fixed.may_throw(compressor);\n    }\n\n    if (fixed instanceof AST_Class && def.scope !== self.scope) {\n        return self;\n    }\n\n    if (single_use && (fixed instanceof AST_Lambda || fixed instanceof AST_Class)) {\n        if (retain_top_func(fixed, compressor)) {\n            single_use = false;\n        } else if (def.scope !== self.scope\n            && (def.escaped == 1\n                || has_flag(fixed, INLINED)\n                || within_array_or_object_literal(compressor)\n                || !compressor.option(\"reduce_funcs\"))) {\n            single_use = false;\n        } else if (is_recursive_ref(compressor, def)) {\n            single_use = false;\n        } else if (def.scope !== self.scope || def.orig[0] instanceof AST_SymbolFunarg) {\n            single_use = fixed.is_constant_expression(self.scope);\n            if (single_use == \"f\") {\n                var scope = self.scope;\n                do {\n                    if (scope instanceof AST_Defun || is_func_expr(scope)) {\n                        set_flag(scope, INLINED);\n                    }\n                } while (scope = scope.parent_scope);\n            }\n        }\n    }\n\n    if (single_use && (fixed instanceof AST_Lambda || fixed instanceof AST_Class)) {\n        single_use =\n            def.scope === self.scope\n                && !scope_encloses_variables_in_this_scope(nearest_scope, fixed)\n            || parent instanceof AST_Call\n                && parent.expression === self\n                && !scope_encloses_variables_in_this_scope(nearest_scope, fixed)\n                && !(fixed.name && fixed.name.definition().recursive_refs > 0);\n    }\n\n    if (single_use && fixed) {\n        if (fixed instanceof AST_DefClass) {\n            set_flag(fixed, SQUEEZED);\n            fixed = make_node(AST_ClassExpression, fixed, fixed);\n        }\n        if (fixed instanceof AST_Defun) {\n            set_flag(fixed, SQUEEZED);\n            fixed = make_node(AST_Function, fixed, fixed);\n        }\n        if (def.recursive_refs > 0 && fixed.name instanceof AST_SymbolDefun) {\n            const defun_def = fixed.name.definition();\n            let lambda_def = fixed.variables.get(fixed.name.name);\n            let name = lambda_def && lambda_def.orig[0];\n            if (!(name instanceof AST_SymbolLambda)) {\n                name = make_node(AST_SymbolLambda, fixed.name, fixed.name);\n                name.scope = fixed;\n                fixed.name = name;\n                lambda_def = fixed.def_function(name);\n            }\n            walk(fixed, node => {\n                if (node instanceof AST_SymbolRef && node.definition() === defun_def) {\n                    node.thedef = lambda_def;\n                    lambda_def.references.push(node);\n                }\n            });\n        }\n        if (\n            (fixed instanceof AST_Lambda || fixed instanceof AST_Class)\n            && fixed.parent_scope !== nearest_scope\n        ) {\n            fixed = fixed.clone(true, compressor.get_toplevel());\n\n            nearest_scope.add_child_scope(fixed);\n        }\n        return fixed.optimize(compressor);\n    }\n\n    // multiple uses\n    if (fixed) {\n        let replace;\n\n        if (fixed instanceof AST_This) {\n            if (!(def.orig[0] instanceof AST_SymbolFunarg)\n                && def.references.every((ref) =>\n                    def.scope === ref.scope\n                )) {\n                replace = fixed;\n            }\n        } else {\n            var ev = fixed.evaluate(compressor);\n            if (\n                ev !== fixed\n                && (compressor.option(\"unsafe_regexp\") || !(ev instanceof RegExp))\n            ) {\n                replace = make_node_from_constant(ev, fixed);\n            }\n        }\n\n        if (replace) {\n            const name_length = self.size(compressor);\n            const replace_size = replace.size(compressor);\n\n            let overhead = 0;\n            if (compressor.option(\"unused\") && !compressor.exposed(def)) {\n                overhead =\n                    (name_length + 2 + fixed.size(compressor)) /\n                    (def.references.length - def.assignments);\n            }\n\n            if (replace_size <= name_length + overhead) {\n                return replace;\n            }\n        }\n    }\n\n    return self;\n}\n\nfunction inline_into_call(self, compressor) {\n    if (compressor.in_computed_key()) return self;\n\n    var exp = self.expression;\n    var fn = exp;\n    var simple_args = self.args.every((arg) => !(arg instanceof AST_Expansion));\n\n    if (compressor.option(\"reduce_vars\")\n        && fn instanceof AST_SymbolRef\n        && !has_annotation(self, _NOINLINE)\n    ) {\n        const fixed = fn.fixed_value();\n\n        if (\n            retain_top_func(fixed, compressor)\n            || !compressor.toplevel.funcs && exp.definition().global\n        ) {\n            return self;\n        }\n\n        fn = fixed;\n    }\n\n    if (\n        dont_inline_lambda_in_loop(compressor, fn)\n        && !has_annotation(self, _INLINE)\n    ) return self;\n\n    var is_func = fn instanceof AST_Lambda;\n\n    var stat = is_func && fn.body[0];\n    var is_regular_func = is_func && !fn.is_generator && !fn.async;\n    var can_inline = is_regular_func && compressor.option(\"inline\") && !self.is_callee_pure(compressor);\n    if (can_inline && stat instanceof AST_Return) {\n        let returned = stat.value;\n        if (!returned || returned.is_constant_expression()) {\n            if (returned) {\n                returned = returned.clone(true);\n            } else {\n                returned = make_node(AST_Undefined, self);\n            }\n            const args = self.args.concat(returned);\n            return make_sequence(self, args).optimize(compressor);\n        }\n\n        // optimize identity function\n        if (\n            fn.argnames.length === 1\n            && (fn.argnames[0] instanceof AST_SymbolFunarg)\n            && self.args.length < 2\n            && !(self.args[0] instanceof AST_Expansion)\n            && returned instanceof AST_SymbolRef\n            && returned.name === fn.argnames[0].name\n        ) {\n            const replacement =\n                (self.args[0] || make_node(AST_Undefined)).optimize(compressor);\n\n            let parent;\n            if (\n                replacement instanceof AST_PropAccess\n                && (parent = compressor.parent()) instanceof AST_Call\n                && parent.expression === self\n            ) {\n                // identity function was being used to remove `this`, like in\n                //\n                // id(bag.no_this)(...)\n                //\n                // Replace with a larger but more effish (0, bag.no_this) wrapper.\n\n                return make_sequence(self, [\n                    make_node(AST_Number, self, { value: 0 }),\n                    replacement\n                ]);\n            }\n            // replace call with first argument or undefined if none passed\n            return replacement;\n        }\n    }\n\n    if (can_inline) {\n        var scope, in_loop, level = -1;\n        let def;\n        let returned_value;\n        let nearest_scope;\n        if (simple_args\n            && !fn.uses_arguments\n            && !(compressor.parent() instanceof AST_Class)\n            && !(fn.name && fn instanceof AST_Function)\n            && (returned_value = can_flatten_body(stat))\n            && (exp === fn\n                || has_annotation(self, _INLINE)\n                || compressor.option(\"unused\")\n                    && (def = exp.definition()).references.length == 1\n                    && !is_recursive_ref(compressor, def)\n                    && fn.is_constant_expression(exp.scope))\n            && !has_annotation(self, _PURE | _NOINLINE)\n            && !fn.contains_this()\n            && can_inject_symbols()\n            && (nearest_scope = compressor.find_scope())\n            && !scope_encloses_variables_in_this_scope(nearest_scope, fn)\n            && !(function in_default_assign() {\n                    // Due to the fact function parameters have their own scope\n                    // which can't use `var something` in the function body within,\n                    // we simply don't inline into DefaultAssign.\n                    let i = 0;\n                    let p;\n                    while ((p = compressor.parent(i++))) {\n                        if (p instanceof AST_DefaultAssign) return true;\n                        if (p instanceof AST_Block) break;\n                    }\n                    return false;\n                })()\n            && !(scope instanceof AST_Class)\n        ) {\n            set_flag(fn, SQUEEZED);\n            nearest_scope.add_child_scope(fn);\n            return make_sequence(self, flatten_fn(returned_value)).optimize(compressor);\n        }\n    }\n\n    if (can_inline && has_annotation(self, _INLINE)) {\n        set_flag(fn, SQUEEZED);\n        fn = make_node(fn.CTOR === AST_Defun ? AST_Function : fn.CTOR, fn, fn);\n        fn = fn.clone(true);\n        fn.figure_out_scope({}, {\n            parent_scope: compressor.find_scope(),\n            toplevel: compressor.get_toplevel()\n        });\n\n        return make_node(AST_Call, self, {\n            expression: fn,\n            args: self.args,\n        }).optimize(compressor);\n    }\n\n    const can_drop_this_call = is_regular_func && compressor.option(\"side_effects\") && fn.body.every(is_empty);\n    if (can_drop_this_call) {\n        var args = self.args.concat(make_node(AST_Undefined, self));\n        return make_sequence(self, args).optimize(compressor);\n    }\n\n    if (compressor.option(\"negate_iife\")\n        && compressor.parent() instanceof AST_SimpleStatement\n        && is_iife_call(self)) {\n        return self.negate(compressor, true);\n    }\n\n    var ev = self.evaluate(compressor);\n    if (ev !== self) {\n        ev = make_node_from_constant(ev, self).optimize(compressor);\n        return best_of(compressor, ev, self);\n    }\n\n    return self;\n\n    function return_value(stat) {\n        if (!stat) return make_node(AST_Undefined, self);\n        if (stat instanceof AST_Return) {\n            if (!stat.value) return make_node(AST_Undefined, self);\n            return stat.value.clone(true);\n        }\n        if (stat instanceof AST_SimpleStatement) {\n            return make_node(AST_UnaryPrefix, stat, {\n                operator: \"void\",\n                expression: stat.body.clone(true)\n            });\n        }\n    }\n\n    function can_flatten_body(stat) {\n        var body = fn.body;\n        var len = body.length;\n        if (compressor.option(\"inline\") < 3) {\n            return len == 1 && return_value(stat);\n        }\n        stat = null;\n        for (var i = 0; i < len; i++) {\n            var line = body[i];\n            if (line instanceof AST_Var) {\n                if (stat && !line.definitions.every((var_def) =>\n                    !var_def.value\n                )) {\n                    return false;\n                }\n            } else if (stat) {\n                return false;\n            } else if (!(line instanceof AST_EmptyStatement)) {\n                stat = line;\n            }\n        }\n        return return_value(stat);\n    }\n\n    function can_inject_args(block_scoped, safe_to_inject) {\n        for (var i = 0, len = fn.argnames.length; i < len; i++) {\n            var arg = fn.argnames[i];\n            if (arg instanceof AST_DefaultAssign) {\n                if (has_flag(arg.left, UNUSED)) continue;\n                return false;\n            }\n            if (arg instanceof AST_Destructuring) return false;\n            if (arg instanceof AST_Expansion) {\n                if (has_flag(arg.expression, UNUSED)) continue;\n                return false;\n            }\n            if (has_flag(arg, UNUSED)) continue;\n            if (!safe_to_inject\n                || block_scoped.has(arg.name)\n                || identifier_atom.has(arg.name)\n                || scope.conflicting_def(arg.name)) {\n                return false;\n            }\n            if (in_loop) in_loop.push(arg.definition());\n        }\n        return true;\n    }\n\n    function can_inject_vars(block_scoped, safe_to_inject) {\n        var len = fn.body.length;\n        for (var i = 0; i < len; i++) {\n            var stat = fn.body[i];\n            if (!(stat instanceof AST_Var)) continue;\n            if (!safe_to_inject) return false;\n            for (var j = stat.definitions.length; --j >= 0;) {\n                var name = stat.definitions[j].name;\n                if (name instanceof AST_Destructuring\n                    || block_scoped.has(name.name)\n                    || identifier_atom.has(name.name)\n                    || scope.conflicting_def(name.name)) {\n                    return false;\n                }\n                if (in_loop) in_loop.push(name.definition());\n            }\n        }\n        return true;\n    }\n\n    function can_inject_symbols() {\n        var block_scoped = new Set();\n        do {\n            scope = compressor.parent(++level);\n            if (scope.is_block_scope() && scope.block_scope) {\n                // TODO this is sometimes undefined during compression.\n                // But it should always have a value!\n                scope.block_scope.variables.forEach(function (variable) {\n                    block_scoped.add(variable.name);\n                });\n            }\n            if (scope instanceof AST_Catch) {\n                // TODO can we delete? AST_Catch is a block scope.\n                if (scope.argname) {\n                    block_scoped.add(scope.argname.name);\n                }\n            } else if (scope instanceof AST_IterationStatement) {\n                in_loop = [];\n            } else if (scope instanceof AST_SymbolRef) {\n                if (scope.fixed_value() instanceof AST_Scope) return false;\n            }\n        } while (!(scope instanceof AST_Scope));\n\n        var safe_to_inject = !(scope instanceof AST_Toplevel) || compressor.toplevel.vars;\n        var inline = compressor.option(\"inline\");\n        if (!can_inject_vars(block_scoped, inline >= 3 && safe_to_inject)) return false;\n        if (!can_inject_args(block_scoped, inline >= 2 && safe_to_inject)) return false;\n        return !in_loop || in_loop.length == 0 || !is_reachable(fn, in_loop);\n    }\n\n    function append_var(decls, expressions, name, value) {\n        var def = name.definition();\n\n        // Name already exists, only when a function argument had the same name\n        const already_appended = scope.variables.has(name.name);\n        if (!already_appended) {\n            scope.variables.set(name.name, def);\n            scope.enclosed.push(def);\n            decls.push(make_node(AST_VarDef, name, {\n                name: name,\n                value: null\n            }));\n        }\n\n        var sym = make_node(AST_SymbolRef, name, name);\n        def.references.push(sym);\n        if (value) expressions.push(make_node(AST_Assign, self, {\n            operator: \"=\",\n            logical: false,\n            left: sym,\n            right: value.clone()\n        }));\n    }\n\n    function flatten_args(decls, expressions) {\n        var len = fn.argnames.length;\n        for (var i = self.args.length; --i >= len;) {\n            expressions.push(self.args[i]);\n        }\n        for (i = len; --i >= 0;) {\n            var name = fn.argnames[i];\n            var value = self.args[i];\n            if (has_flag(name, UNUSED) || !name.name || scope.conflicting_def(name.name)) {\n                if (value) expressions.push(value);\n            } else {\n                var symbol = make_node(AST_SymbolVar, name, name);\n                name.definition().orig.push(symbol);\n                if (!value && in_loop) value = make_node(AST_Undefined, self);\n                append_var(decls, expressions, symbol, value);\n            }\n        }\n        decls.reverse();\n        expressions.reverse();\n    }\n\n    function flatten_vars(decls, expressions) {\n        var pos = expressions.length;\n        for (var i = 0, lines = fn.body.length; i < lines; i++) {\n            var stat = fn.body[i];\n            if (!(stat instanceof AST_Var)) continue;\n            for (var j = 0, defs = stat.definitions.length; j < defs; j++) {\n                var var_def = stat.definitions[j];\n                var name = var_def.name;\n                append_var(decls, expressions, name, var_def.value);\n                if (in_loop && fn.argnames.every((argname) =>\n                    argname.name != name.name\n                )) {\n                    var def = fn.variables.get(name.name);\n                    var sym = make_node(AST_SymbolRef, name, name);\n                    def.references.push(sym);\n                    expressions.splice(pos++, 0, make_node(AST_Assign, var_def, {\n                        operator: \"=\",\n                        logical: false,\n                        left: sym,\n                        right: make_node(AST_Undefined, name)\n                    }));\n                }\n            }\n        }\n    }\n\n    function flatten_fn(returned_value) {\n        var decls = [];\n        var expressions = [];\n        flatten_args(decls, expressions);\n        flatten_vars(decls, expressions);\n        expressions.push(returned_value);\n\n        if (decls.length) {\n            const i = scope.body.indexOf(compressor.parent(level - 1)) + 1;\n            scope.body.splice(i, 0, make_node(AST_Var, fn, {\n                definitions: decls\n            }));\n        }\n\n        return expressions.map(exp => exp.clone(true));\n    }\n}\n\n/** prevent inlining functions into loops, for performance reasons */\nfunction dont_inline_lambda_in_loop(compressor, maybe_lambda) {\n    return (\n        (maybe_lambda instanceof AST_Lambda || maybe_lambda instanceof AST_Class)\n        && !!compressor.is_within_loop()\n    );\n}\n\n(function(def_find_defs) {\n    function to_node(value, orig) {\n        if (value instanceof AST_Node) {\n            if (!(value instanceof AST_Constant)) {\n                // Value may be a function, an array including functions and even a complex assign / block expression,\n                // so it should never be shared in different places.\n                // Otherwise wrong information may be used in the compression phase\n                value = value.clone(true);\n            }\n            return make_node(value.CTOR, orig, value);\n        }\n        if (Array.isArray(value)) return make_node(AST_Array, orig, {\n            elements: value.map(function(value) {\n                return to_node(value, orig);\n            })\n        });\n        if (value && typeof value == \"object\") {\n            var props = [];\n            for (var key in value) if (HOP(value, key)) {\n                props.push(make_node(AST_ObjectKeyVal, orig, {\n                    key: key,\n                    value: to_node(value[key], orig)\n                }));\n            }\n            return make_node(AST_Object, orig, {\n                properties: props\n            });\n        }\n        return make_node_from_constant(value, orig);\n    }\n\n    AST_Toplevel.DEFMETHOD(\"resolve_defines\", function(compressor) {\n        if (!compressor.option(\"global_defs\")) return this;\n        this.figure_out_scope({ ie8: compressor.option(\"ie8\") });\n        return this.transform(new TreeTransformer(function(node) {\n            var def = node._find_defs(compressor, \"\");\n            if (!def) return;\n            var level = 0, child = node, parent;\n            while (parent = this.parent(level++)) {\n                if (!(parent instanceof AST_PropAccess)) break;\n                if (parent.expression !== child) break;\n                child = parent;\n            }\n            if (is_lhs(child, parent)) {\n                return;\n            }\n            return def;\n        }));\n    });\n    def_find_defs(AST_Node, noop);\n    def_find_defs(AST_Chain, function(compressor, suffix) {\n        return this.expression._find_defs(compressor, suffix);\n    });\n    def_find_defs(AST_Dot, function(compressor, suffix) {\n        return this.expression._find_defs(compressor, \".\" + this.property + suffix);\n    });\n    def_find_defs(AST_SymbolDeclaration, function() {\n        if (!this.global()) return;\n    });\n    def_find_defs(AST_SymbolRef, function(compressor, suffix) {\n        if (!this.global()) return;\n        var defines = compressor.option(\"global_defs\");\n        var name = this.name + suffix;\n        if (HOP(defines, name)) return to_node(defines[name], this);\n    });\n    def_find_defs(AST_ImportMeta, function(compressor, suffix) {\n        var defines = compressor.option(\"global_defs\");\n        var name = \"import.meta\" + suffix;\n        if (HOP(defines, name)) return to_node(defines[name], this);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"_find_defs\", func);\n});\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nclass Compressor extends TreeWalker {\n    constructor(options, { false_by_default = false, mangle_options = false }) {\n        super();\n        if (options.defaults !== undefined && !options.defaults) false_by_default = true;\n        this.options = defaults(options, {\n            arguments     : false,\n            arrows        : !false_by_default,\n            booleans      : !false_by_default,\n            booleans_as_integers : false,\n            collapse_vars : !false_by_default,\n            comparisons   : !false_by_default,\n            computed_props: !false_by_default,\n            conditionals  : !false_by_default,\n            dead_code     : !false_by_default,\n            defaults      : true,\n            directives    : !false_by_default,\n            drop_console  : false,\n            drop_debugger : !false_by_default,\n            ecma          : 5,\n            evaluate      : !false_by_default,\n            expression    : false,\n            global_defs   : false,\n            hoist_funs    : false,\n            hoist_props   : !false_by_default,\n            hoist_vars    : false,\n            ie8           : false,\n            if_return     : !false_by_default,\n            inline        : !false_by_default,\n            join_vars     : !false_by_default,\n            keep_classnames: false,\n            keep_fargs    : true,\n            keep_fnames   : false,\n            keep_infinity : false,\n            lhs_constants : !false_by_default,\n            loops         : !false_by_default,\n            module        : false,\n            negate_iife   : !false_by_default,\n            passes        : 1,\n            properties    : !false_by_default,\n            pure_getters  : !false_by_default && \"strict\",\n            pure_funcs    : null,\n            pure_new      : false,\n            reduce_funcs  : !false_by_default,\n            reduce_vars   : !false_by_default,\n            sequences     : !false_by_default,\n            side_effects  : !false_by_default,\n            switches      : !false_by_default,\n            top_retain    : null,\n            toplevel      : !!(options && options[\"top_retain\"]),\n            typeofs       : !false_by_default,\n            unsafe        : false,\n            unsafe_arrows : false,\n            unsafe_comps  : false,\n            unsafe_Function: false,\n            unsafe_math   : false,\n            unsafe_symbols: false,\n            unsafe_methods: false,\n            unsafe_proto  : false,\n            unsafe_regexp : false,\n            unsafe_undefined: false,\n            unused        : !false_by_default,\n            warnings      : false  // legacy\n        }, true);\n        var global_defs = this.options[\"global_defs\"];\n        if (typeof global_defs == \"object\") for (var key in global_defs) {\n            if (key[0] === \"@\" && HOP(global_defs, key)) {\n                global_defs[key.slice(1)] = parse(global_defs[key], {\n                    expression: true\n                });\n            }\n        }\n        if (this.options[\"inline\"] === true) this.options[\"inline\"] = 3;\n        var pure_funcs = this.options[\"pure_funcs\"];\n        if (typeof pure_funcs == \"function\") {\n            this.pure_funcs = pure_funcs;\n        } else {\n            this.pure_funcs = pure_funcs ? function(node) {\n                return !pure_funcs.includes(node.expression.print_to_string());\n            } : return_true;\n        }\n        var top_retain = this.options[\"top_retain\"];\n        if (top_retain instanceof RegExp) {\n            this.top_retain = function(def) {\n                return top_retain.test(def.name);\n            };\n        } else if (typeof top_retain == \"function\") {\n            this.top_retain = top_retain;\n        } else if (top_retain) {\n            if (typeof top_retain == \"string\") {\n                top_retain = top_retain.split(/,/);\n            }\n            this.top_retain = function(def) {\n                return top_retain.includes(def.name);\n            };\n        }\n        if (this.options[\"module\"]) {\n            this.directives[\"use strict\"] = true;\n            this.options[\"toplevel\"] = true;\n        }\n        var toplevel = this.options[\"toplevel\"];\n        this.toplevel = typeof toplevel == \"string\" ? {\n            funcs: /funcs/.test(toplevel),\n            vars: /vars/.test(toplevel)\n        } : {\n            funcs: toplevel,\n            vars: toplevel\n        };\n        var sequences = this.options[\"sequences\"];\n        this.sequences_limit = sequences == 1 ? 800 : sequences | 0;\n        this.evaluated_regexps = new Map();\n        this._toplevel = undefined;\n        this._mangle_options = mangle_options\n            ? format_mangler_options(mangle_options)\n            : mangle_options;\n    }\n\n    mangle_options() {\n        var nth_identifier = this._mangle_options && this._mangle_options.nth_identifier || base54;\n        var module = this._mangle_options && this._mangle_options.module || this.option(\"module\");\n        return { ie8: this.option(\"ie8\"), nth_identifier, module };\n    }\n\n    option(key) {\n        return this.options[key];\n    }\n\n    exposed(def) {\n        if (def.export) return true;\n        if (def.global) for (var i = 0, len = def.orig.length; i < len; i++)\n            if (!this.toplevel[def.orig[i] instanceof AST_SymbolDefun ? \"funcs\" : \"vars\"])\n                return true;\n        return false;\n    }\n\n    in_boolean_context() {\n        if (!this.option(\"booleans\")) return false;\n        var self = this.self();\n        for (var i = 0, p; p = this.parent(i); i++) {\n            if (p instanceof AST_SimpleStatement\n                || p instanceof AST_Conditional && p.condition === self\n                || p instanceof AST_DWLoop && p.condition === self\n                || p instanceof AST_For && p.condition === self\n                || p instanceof AST_If && p.condition === self\n                || p instanceof AST_UnaryPrefix && p.operator == \"!\" && p.expression === self) {\n                return true;\n            }\n            if (\n                p instanceof AST_Binary\n                    && (\n                        p.operator == \"&&\"\n                        || p.operator == \"||\"\n                        || p.operator == \"??\"\n                    )\n                || p instanceof AST_Conditional\n                || p.tail_node() === self\n            ) {\n                self = p;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    /** True if compressor.self()'s result will be turned into a 32-bit integer.\n     * ex:\n     * ~{expr}\n     * (1, 2, {expr}) | 0\n     **/\n    in_32_bit_context(other_operand_must_be_number) {\n        if (!this.option(\"evaluate\")) return false;\n        var self = this.self();\n        for (var i = 0, p; p = this.parent(i); i++) {\n            if (p instanceof AST_Binary && bitwise_binop.has(p.operator)) {\n                if (other_operand_must_be_number) {\n                    return (self === p.left ? p.right : p.left).is_number(this);\n                } else {\n                    return true;\n                }\n            }\n            if (p instanceof AST_UnaryPrefix) {\n                return p.operator === \"~\";\n            }\n            if (\n                p instanceof AST_Binary\n                    && (\n                        // Don't talk about p.left. Can change branch taken\n                        p.operator == \"&&\" && p.right === self\n                        || p.operator == \"||\" && p.right === self\n                        || p.operator == \"??\" && p.right === self\n                    )\n                || p instanceof AST_Conditional && p.condition !== self\n                || p.tail_node() === self\n            ) {\n                self = p;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    in_computed_key() {\n        if (!this.option(\"evaluate\")) return false;\n        var self = this.self();\n        for (var i = 0, p; p = this.parent(i); i++) {\n            if (p instanceof AST_ObjectProperty && p.key === self) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    get_toplevel() {\n        return this._toplevel;\n    }\n\n    compress(toplevel) {\n        toplevel = toplevel.resolve_defines(this);\n        this._toplevel = toplevel;\n        if (this.option(\"expression\")) {\n            this._toplevel.process_expression(true);\n        }\n        var passes = +this.options.passes || 1;\n        var min_count = 1 / 0;\n        var stopping = false;\n        var mangle = this.mangle_options();\n        for (var pass = 0; pass < passes; pass++) {\n            this._toplevel.figure_out_scope(mangle);\n            if (pass === 0 && this.option(\"drop_console\")) {\n                // must be run before reduce_vars and compress pass\n                this._toplevel = this._toplevel.drop_console(this.option(\"drop_console\"));\n            }\n            if (pass > 0 || this.option(\"reduce_vars\")) {\n                this._toplevel.reset_opt_flags(this);\n            }\n            this._toplevel = this._toplevel.transform(this);\n            if (passes > 1) {\n                let count = 0;\n                walk(this._toplevel, () => { count++; });\n                if (count < min_count) {\n                    min_count = count;\n                    stopping = false;\n                } else if (stopping) {\n                    break;\n                } else {\n                    stopping = true;\n                }\n            }\n        }\n        if (this.option(\"expression\")) {\n            this._toplevel.process_expression(false);\n        }\n        toplevel = this._toplevel;\n        this._toplevel = undefined;\n        return toplevel;\n    }\n\n    before(node, descend) {\n        if (has_flag(node, SQUEEZED)) return node;\n        var was_scope = false;\n        if (node instanceof AST_Scope) {\n            node = node.hoist_properties(this);\n            node = node.hoist_declarations(this);\n            was_scope = true;\n        }\n        // Before https://github.com/mishoo/UglifyJS2/pull/1602 AST_Node.optimize()\n        // would call AST_Node.transform() if a different instance of AST_Node is\n        // produced after def_optimize().\n        // This corrupts TreeWalker.stack, which cause AST look-ups to malfunction.\n        // Migrate and defer all children's AST_Node.transform() to below, which\n        // will now happen after this parent AST_Node has been properly substituted\n        // thus gives a consistent AST snapshot.\n        descend(node, this);\n        // Existing code relies on how AST_Node.optimize() worked, and omitting the\n        // following replacement call would result in degraded efficiency of both\n        // output and performance.\n        descend(node, this);\n        var opt = node.optimize(this);\n        if (was_scope && opt instanceof AST_Scope) {\n            opt.drop_unused(this);\n            descend(opt, this);\n        }\n        if (opt === node) set_flag(opt, SQUEEZED);\n        return opt;\n    }\n\n    /** Alternative to plain is_lhs() which doesn't work within .optimize() */\n    is_lhs() {\n        const self = this.stack[this.stack.length - 1];\n        const parent = this.stack[this.stack.length - 2];\n        return is_lhs(self, parent);\n    }\n}\n\n\nfunction def_optimize(node, optimizer) {\n    node.DEFMETHOD(\"optimize\", function(compressor) {\n        var self = this;\n        if (has_flag(self, OPTIMIZED)) return self;\n        if (compressor.has_directive(\"use asm\")) return self;\n        var opt = optimizer(self, compressor);\n        set_flag(opt, OPTIMIZED);\n        return opt;\n    });\n}\n\ndef_optimize(AST_Node, function(self) {\n    return self;\n});\n\nAST_Toplevel.DEFMETHOD(\"drop_console\", function(options) {\n    const isArray = Array.isArray(options);\n    const tt = new TreeTransformer(function(self) {\n        if (self.TYPE !== \"Call\") {\n            return;\n        }\n\n        var exp = self.expression;\n\n        if (!(exp instanceof AST_PropAccess)) {\n            return;\n        }\n\n        var name = exp.expression;\n        var property = exp.property;\n        var depth = 2;\n        while (name.expression) {\n            property = name.property;\n            name = name.expression;\n            depth++;\n        }\n\n        if (isArray && !options.includes(property)) {\n            return;\n        }\n\n        if (is_undeclared_ref(name) && name.name == \"console\") {\n            if (\n                depth === 3\n                && ![\"call\", \"apply\"].includes(exp.property)\n                && is_used_in_expression(tt)\n            ) {\n                // a (used) call to Function.prototype methods (eg: console.log.bind(console))\n                // but not .call and .apply which would also return undefined.\n                exp.expression = make_empty_function(self);\n                set_flag(exp.expression, SQUEEZED);\n                self.args = [];\n            } else {\n                return make_node(AST_Undefined, self);\n            }\n        }\n    });\n\n    return this.transform(tt);\n});\n\nAST_Node.DEFMETHOD(\"equivalent_to\", function(node) {\n    return equivalent_to(this, node);\n});\n\nAST_Scope.DEFMETHOD(\"process_expression\", function(insert, compressor) {\n    var self = this;\n    var tt = new TreeTransformer(function(node) {\n        if (insert && node instanceof AST_SimpleStatement) {\n            return make_node(AST_Return, node, {\n                value: node.body\n            });\n        }\n        if (!insert && node instanceof AST_Return) {\n            if (compressor) {\n                var value = node.value && node.value.drop_side_effect_free(compressor, true);\n                return value\n                    ? make_node(AST_SimpleStatement, node, { body: value })\n                    : make_node(AST_EmptyStatement, node);\n            }\n            return make_node(AST_SimpleStatement, node, {\n                body: node.value || make_node(AST_UnaryPrefix, node, {\n                    operator: \"void\",\n                    expression: make_node(AST_Number, node, {\n                        value: 0\n                    })\n                })\n            });\n        }\n        if (node instanceof AST_Class || node instanceof AST_Lambda && node !== self) {\n            return node;\n        }\n        if (node instanceof AST_Block) {\n            var index = node.body.length - 1;\n            if (index >= 0) {\n                node.body[index] = node.body[index].transform(tt);\n            }\n        } else if (node instanceof AST_If) {\n            node.body = node.body.transform(tt);\n            if (node.alternative) {\n                node.alternative = node.alternative.transform(tt);\n            }\n        } else if (node instanceof AST_With) {\n            node.body = node.body.transform(tt);\n        }\n        return node;\n    });\n    self.transform(tt);\n});\n\nAST_Toplevel.DEFMETHOD(\"reset_opt_flags\", function(compressor) {\n    const self = this;\n    const reduce_vars = compressor.option(\"reduce_vars\");\n\n    const preparation = new TreeWalker(function(node, descend) {\n        clear_flag(node, CLEAR_BETWEEN_PASSES);\n        if (reduce_vars) {\n            if (compressor.top_retain\n                && node instanceof AST_Defun  // Only functions are retained\n                && preparation.parent() === self\n            ) {\n                set_flag(node, TOP);\n            }\n            return node.reduce_vars(preparation, descend, compressor);\n        }\n    });\n    // Stack of look-up tables to keep track of whether a `SymbolDef` has been\n    // properly assigned before use:\n    // - `push()` & `pop()` when visiting conditional branches\n    preparation.safe_ids = Object.create(null);\n    preparation.in_loop = null;\n    preparation.loop_ids = new Map();\n    preparation.defs_to_safe_ids = new Map();\n    self.walk(preparation);\n});\n\nAST_Symbol.DEFMETHOD(\"fixed_value\", function() {\n    var fixed = this.thedef.fixed;\n    if (!fixed || fixed instanceof AST_Node) return fixed;\n    return fixed();\n});\n\nAST_SymbolRef.DEFMETHOD(\"is_immutable\", function() {\n    var orig = this.definition().orig;\n    return orig.length == 1 && orig[0] instanceof AST_SymbolLambda;\n});\n\nfunction find_variable(compressor, name) {\n    var scope, i = 0;\n    while (scope = compressor.parent(i++)) {\n        if (scope instanceof AST_Scope) break;\n        if (scope instanceof AST_Catch && scope.argname) {\n            scope = scope.argname.definition().scope;\n            break;\n        }\n    }\n    return scope.find_variable(name);\n}\n\nvar global_names = makePredicate(\"Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError\");\nAST_SymbolRef.DEFMETHOD(\"is_declared\", function(compressor) {\n    return !this.definition().undeclared\n        || compressor.option(\"unsafe\") && global_names.has(this.name);\n});\n\n/* -----[ optimizers ]----- */\n\nvar directives = new Set([\"use asm\", \"use strict\"]);\ndef_optimize(AST_Directive, function(self, compressor) {\n    if (compressor.option(\"directives\")\n        && (!directives.has(self.value) || compressor.has_directive(self.value) !== self)) {\n        return make_node(AST_EmptyStatement, self);\n    }\n    return self;\n});\n\ndef_optimize(AST_Debugger, function(self, compressor) {\n    if (compressor.option(\"drop_debugger\"))\n        return make_node(AST_EmptyStatement, self);\n    return self;\n});\n\ndef_optimize(AST_LabeledStatement, function(self, compressor) {\n    if (self.body instanceof AST_Break\n        && compressor.loopcontrol_target(self.body) === self.body) {\n        return make_node(AST_EmptyStatement, self);\n    }\n    return self.label.references.length == 0 ? self.body : self;\n});\n\ndef_optimize(AST_Block, function(self, compressor) {\n    tighten_body(self.body, compressor);\n    return self;\n});\n\nfunction can_be_extracted_from_if_block(node) {\n    return !(\n        node instanceof AST_Const\n        || node instanceof AST_Let\n        || node instanceof AST_Using\n        || node instanceof AST_Class\n    );\n}\n\ndef_optimize(AST_BlockStatement, function(self, compressor) {\n    tighten_body(self.body, compressor);\n    switch (self.body.length) {\n      case 1:\n        if (!compressor.has_directive(\"use strict\")\n            && compressor.parent() instanceof AST_If\n            && can_be_extracted_from_if_block(self.body[0])\n            || can_be_evicted_from_block(self.body[0])) {\n            return self.body[0];\n        }\n        break;\n      case 0: return make_node(AST_EmptyStatement, self);\n    }\n    return self;\n});\n\nfunction opt_AST_Lambda(self, compressor) {\n    tighten_body(self.body, compressor);\n    if (compressor.option(\"side_effects\")\n        && self.body.length == 1\n        && self.body[0] === compressor.has_directive(\"use strict\")) {\n        self.body.length = 0;\n    }\n    return self;\n}\ndef_optimize(AST_Lambda, opt_AST_Lambda);\n\nAST_Scope.DEFMETHOD(\"hoist_declarations\", function(compressor) {\n    var self = this;\n    if (compressor.has_directive(\"use asm\")) return self;\n\n    var hoist_funs = compressor.option(\"hoist_funs\");\n    var hoist_vars = compressor.option(\"hoist_vars\");\n\n    if (hoist_funs || hoist_vars) {\n        var dirs = [];\n        var hoisted = [];\n        var vars = new Map(), vars_found = 0, var_decl = 0;\n        // let's count var_decl first, we seem to waste a lot of\n        // space if we hoist `var` when there's only one.\n        walk(self, node => {\n            if (node instanceof AST_Scope && node !== self)\n                return true;\n            if (node instanceof AST_Var) {\n                ++var_decl;\n                return true;\n            }\n        });\n        hoist_vars = hoist_vars && var_decl > 1;\n        var tt = new TreeTransformer(\n            function before(node) {\n                if (node !== self) {\n                    if (node instanceof AST_Directive) {\n                        dirs.push(node);\n                        return make_node(AST_EmptyStatement, node);\n                    }\n                    if (hoist_funs && node instanceof AST_Defun\n                        && !(tt.parent() instanceof AST_Export)\n                        && tt.parent() === self) {\n                        hoisted.push(node);\n                        return make_node(AST_EmptyStatement, node);\n                    }\n                    if (\n                        hoist_vars\n                        && node instanceof AST_Var\n                        && !node.definitions.some(def => def.name instanceof AST_Destructuring)\n                    ) {\n                        node.definitions.forEach(function(def) {\n                            vars.set(def.name.name, def);\n                            ++vars_found;\n                        });\n                        var seq = node.to_assignments(compressor);\n                        var p = tt.parent();\n                        if (p instanceof AST_ForIn && p.init === node) {\n                            if (seq == null) {\n                                var def = node.definitions[0].name;\n                                return make_node(AST_SymbolRef, def, def);\n                            }\n                            return seq;\n                        }\n                        if (p instanceof AST_For && p.init === node) {\n                            return seq;\n                        }\n                        if (!seq) return make_node(AST_EmptyStatement, node);\n                        return make_node(AST_SimpleStatement, node, {\n                            body: seq\n                        });\n                    }\n                    if (node instanceof AST_Scope)\n                        return node; // to avoid descending in nested scopes\n                }\n            }\n        );\n        self = self.transform(tt);\n        if (vars_found > 0) {\n            // collect only vars which don't show up in self's arguments list\n            var defs = [];\n            const is_lambda = self instanceof AST_Lambda;\n            const args_as_names = is_lambda ? self.args_as_names() : null;\n            vars.forEach((def, name) => {\n                if (is_lambda && args_as_names.some((x) => x.name === def.name.name)) {\n                    vars.delete(name);\n                } else {\n                    def = def.clone();\n                    def.value = null;\n                    defs.push(def);\n                    vars.set(name, def);\n                }\n            });\n            if (defs.length > 0) {\n                // try to merge in assignments\n                for (var i = 0; i < self.body.length;) {\n                    if (self.body[i] instanceof AST_SimpleStatement) {\n                        var expr = self.body[i].body, sym, assign;\n                        if (expr instanceof AST_Assign\n                            && expr.operator == \"=\"\n                            && (sym = expr.left) instanceof AST_Symbol\n                            && vars.has(sym.name)\n                        ) {\n                            var def = vars.get(sym.name);\n                            if (def.value) break;\n                            def.value = expr.right;\n                            remove(defs, def);\n                            defs.push(def);\n                            self.body.splice(i, 1);\n                            continue;\n                        }\n                        if (expr instanceof AST_Sequence\n                            && (assign = expr.expressions[0]) instanceof AST_Assign\n                            && assign.operator == \"=\"\n                            && (sym = assign.left) instanceof AST_Symbol\n                            && vars.has(sym.name)\n                        ) {\n                            var def = vars.get(sym.name);\n                            if (def.value) break;\n                            def.value = assign.right;\n                            remove(defs, def);\n                            defs.push(def);\n                            self.body[i].body = make_sequence(expr, expr.expressions.slice(1));\n                            continue;\n                        }\n                    }\n                    if (self.body[i] instanceof AST_EmptyStatement) {\n                        self.body.splice(i, 1);\n                        continue;\n                    }\n                    if (self.body[i] instanceof AST_BlockStatement) {\n                        self.body.splice(i, 1, ...self.body[i].body);\n                        continue;\n                    }\n                    break;\n                }\n                defs = make_node(AST_Var, self, {\n                    definitions: defs\n                });\n                hoisted.push(defs);\n            }\n        }\n        self.body = dirs.concat(hoisted, self.body);\n    }\n    return self;\n});\n\nAST_Scope.DEFMETHOD(\"hoist_properties\", function(compressor) {\n    var self = this;\n    if (!compressor.option(\"hoist_props\") || compressor.has_directive(\"use asm\")) return self;\n    var top_retain = self instanceof AST_Toplevel && compressor.top_retain || return_false;\n    var defs_by_id = new Map();\n    var hoister = new TreeTransformer(function(node, descend) {\n        if (node instanceof AST_VarDef) {\n            const sym = node.name;\n            let def;\n            let value;\n            if (sym.scope === self\n                && !(sym instanceof AST_SymbolUsing)\n                && (def = sym.definition()).escaped != 1\n                && !def.assignments\n                && !def.direct_access\n                && !def.single_use\n                && !compressor.exposed(def)\n                && !top_retain(def)\n                && (value = sym.fixed_value()) === node.value\n                && value instanceof AST_Object\n                && !value.properties.some(prop =>\n                    prop instanceof AST_Expansion || prop.computed_key()\n                )\n            ) {\n                descend(node, this);\n                const defs = new Map();\n                const assignments = [];\n                value.properties.forEach(({ key, value }) => {\n                    const scope = hoister.find_scope();\n                    const symbol = self.create_symbol(sym.CTOR, {\n                        source: sym,\n                        scope,\n                        conflict_scopes: new Set([\n                            scope,\n                            ...sym.definition().references.map(ref => ref.scope)\n                        ]),\n                        tentative_name: sym.name + \"_\" + key\n                    });\n\n                    defs.set(String(key), symbol.definition());\n\n                    assignments.push(make_node(AST_VarDef, node, {\n                        name: symbol,\n                        value\n                    }));\n                });\n                defs_by_id.set(def.id, defs);\n                return MAP.splice(assignments);\n            }\n        } else if (node instanceof AST_PropAccess\n            && node.expression instanceof AST_SymbolRef\n        ) {\n            const defs = defs_by_id.get(node.expression.definition().id);\n            if (defs) {\n                const def = defs.get(String(get_simple_key(node.property)));\n                const sym = make_node(AST_SymbolRef, node, {\n                    name: def.name,\n                    scope: node.expression.scope,\n                    thedef: def\n                });\n                sym.reference({});\n                return sym;\n            }\n        }\n    });\n    return self.transform(hoister);\n});\n\ndef_optimize(AST_SimpleStatement, function(self, compressor) {\n    if (compressor.option(\"side_effects\")) {\n        var body = self.body;\n        var node = body.drop_side_effect_free(compressor, true);\n        if (!node) {\n            return make_node(AST_EmptyStatement, self);\n        }\n        if (node !== body) {\n            return make_node(AST_SimpleStatement, self, { body: node });\n        }\n    }\n    return self;\n});\n\ndef_optimize(AST_While, function(self, compressor) {\n    return compressor.option(\"loops\") ? make_node(AST_For, self, self).optimize(compressor) : self;\n});\n\ndef_optimize(AST_Do, function(self, compressor) {\n    if (!compressor.option(\"loops\")) return self;\n    var cond = self.condition.tail_node().evaluate(compressor);\n    if (!(cond instanceof AST_Node)) {\n        if (cond) return make_node(AST_For, self, {\n            body: make_node(AST_BlockStatement, self.body, {\n                body: [\n                    self.body,\n                    make_node(AST_SimpleStatement, self.condition, {\n                        body: self.condition\n                    })\n                ]\n            })\n        }).optimize(compressor);\n        if (!has_break_or_continue(self, compressor.parent())) {\n            return make_node(AST_BlockStatement, self.body, {\n                body: [\n                    self.body,\n                    make_node(AST_SimpleStatement, self.condition, {\n                        body: self.condition\n                    })\n                ]\n            }).optimize(compressor);\n        }\n    }\n    return self;\n});\n\nfunction if_break_in_loop(self, compressor) {\n    var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;\n    if (compressor.option(\"dead_code\") && is_break(first)) {\n        var body = [];\n        if (self.init instanceof AST_Statement) {\n            body.push(self.init);\n        } else if (self.init) {\n            body.push(make_node(AST_SimpleStatement, self.init, {\n                body: self.init\n            }));\n        }\n        if (self.condition) {\n            body.push(make_node(AST_SimpleStatement, self.condition, {\n                body: self.condition\n            }));\n        }\n        extract_from_unreachable_code(compressor, self.body, body);\n        return make_node(AST_BlockStatement, self, {\n            body: body\n        });\n    }\n    if (first instanceof AST_If) {\n        if (is_break(first.body)) {\n            if (self.condition) {\n                self.condition = make_node(AST_Binary, self.condition, {\n                    left: self.condition,\n                    operator: \"&&\",\n                    right: first.condition.negate(compressor),\n                });\n            } else {\n                self.condition = first.condition.negate(compressor);\n            }\n            drop_it(first.alternative);\n        } else if (is_break(first.alternative)) {\n            if (self.condition) {\n                self.condition = make_node(AST_Binary, self.condition, {\n                    left: self.condition,\n                    operator: \"&&\",\n                    right: first.condition,\n                });\n            } else {\n                self.condition = first.condition;\n            }\n            drop_it(first.body);\n        }\n    }\n    return self;\n\n    function is_break(node) {\n        return node instanceof AST_Break\n            && compressor.loopcontrol_target(node) === compressor.self();\n    }\n\n    function drop_it(rest) {\n        rest = as_statement_array(rest);\n        if (self.body instanceof AST_BlockStatement) {\n            self.body = self.body.clone();\n            self.body.body = rest.concat(self.body.body.slice(1));\n            self.body = self.body.transform(compressor);\n        } else {\n            self.body = make_node(AST_BlockStatement, self.body, {\n                body: rest\n            }).transform(compressor);\n        }\n        self = if_break_in_loop(self, compressor);\n    }\n}\n\ndef_optimize(AST_For, function(self, compressor) {\n    if (!compressor.option(\"loops\")) return self;\n    if (compressor.option(\"side_effects\") && self.init) {\n        self.init = self.init.drop_side_effect_free(compressor);\n    }\n    if (self.condition) {\n        var cond = self.condition.evaluate(compressor);\n        if (!(cond instanceof AST_Node)) {\n            if (cond) self.condition = null;\n            else if (!compressor.option(\"dead_code\")) {\n                var orig = self.condition;\n                self.condition = make_node_from_constant(cond, self.condition);\n                self.condition = best_of_expression(self.condition.transform(compressor), orig);\n            }\n        }\n        if (compressor.option(\"dead_code\")) {\n            if (cond instanceof AST_Node) cond = self.condition.tail_node().evaluate(compressor);\n            if (!cond) {\n                var body = [];\n                extract_from_unreachable_code(compressor, self.body, body);\n                if (self.init instanceof AST_Statement) {\n                    body.push(self.init);\n                } else if (self.init) {\n                    body.push(make_node(AST_SimpleStatement, self.init, {\n                        body: self.init\n                    }));\n                }\n                body.push(make_node(AST_SimpleStatement, self.condition, {\n                    body: self.condition\n                }));\n                return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n            }\n        }\n    }\n    return if_break_in_loop(self, compressor);\n});\n\ndef_optimize(AST_If, function(self, compressor) {\n    if (is_empty(self.alternative)) self.alternative = null;\n\n    if (!compressor.option(\"conditionals\")) return self;\n    // if condition can be statically determined, drop\n    // one of the blocks.  note, statically determined implies\n    // has no side effects; also it doesn't work for cases like\n    // `x && true`, though it probably should.\n    var cond = self.condition.evaluate(compressor);\n    if (!compressor.option(\"dead_code\") && !(cond instanceof AST_Node)) {\n        var orig = self.condition;\n        self.condition = make_node_from_constant(cond, orig);\n        self.condition = best_of_expression(self.condition.transform(compressor), orig);\n    }\n    if (compressor.option(\"dead_code\")) {\n        if (cond instanceof AST_Node) cond = self.condition.tail_node().evaluate(compressor);\n        if (!cond) {\n            var body = [];\n            extract_from_unreachable_code(compressor, self.body, body);\n            body.push(make_node(AST_SimpleStatement, self.condition, {\n                body: self.condition\n            }));\n            if (self.alternative) body.push(self.alternative);\n            return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n        } else if (!(cond instanceof AST_Node)) {\n            var body = [];\n            body.push(make_node(AST_SimpleStatement, self.condition, {\n                body: self.condition\n            }));\n            body.push(self.body);\n            if (self.alternative) {\n                extract_from_unreachable_code(compressor, self.alternative, body);\n            }\n            return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n        }\n    }\n    var negated = self.condition.negate(compressor);\n    var self_condition_length = self.condition.size();\n    var negated_length = negated.size();\n    var negated_is_best = negated_length < self_condition_length;\n    if (self.alternative && negated_is_best) {\n        negated_is_best = false; // because we already do the switch here.\n        // no need to swap values of self_condition_length and negated_length\n        // here because they are only used in an equality comparison later on.\n        self.condition = negated;\n        var tmp = self.body;\n        self.body = self.alternative || make_node(AST_EmptyStatement, self);\n        self.alternative = tmp;\n    }\n    if (is_empty(self.body) && is_empty(self.alternative)) {\n        return make_node(AST_SimpleStatement, self.condition, {\n            body: self.condition.clone()\n        }).optimize(compressor);\n    }\n    if (self.body instanceof AST_SimpleStatement\n        && self.alternative instanceof AST_SimpleStatement) {\n        return make_node(AST_SimpleStatement, self, {\n            body: make_node(AST_Conditional, self, {\n                condition   : self.condition,\n                consequent  : self.body.body,\n                alternative : self.alternative.body\n            })\n        }).optimize(compressor);\n    }\n    if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {\n        if (self_condition_length === negated_length && !negated_is_best\n            && self.condition instanceof AST_Binary && self.condition.operator == \"||\") {\n            // although the code length of self.condition and negated are the same,\n            // negated does not require additional surrounding parentheses.\n            // see https://github.com/mishoo/UglifyJS2/issues/979\n            negated_is_best = true;\n        }\n        if (negated_is_best) return make_node(AST_SimpleStatement, self, {\n            body: make_node(AST_Binary, self, {\n                operator : \"||\",\n                left     : negated,\n                right    : self.body.body\n            })\n        }).optimize(compressor);\n        return make_node(AST_SimpleStatement, self, {\n            body: make_node(AST_Binary, self, {\n                operator : \"&&\",\n                left     : self.condition,\n                right    : self.body.body\n            })\n        }).optimize(compressor);\n    }\n    if (self.body instanceof AST_EmptyStatement\n        && self.alternative instanceof AST_SimpleStatement) {\n        return make_node(AST_SimpleStatement, self, {\n            body: make_node(AST_Binary, self, {\n                operator : \"||\",\n                left     : self.condition,\n                right    : self.alternative.body\n            })\n        }).optimize(compressor);\n    }\n    if (self.body instanceof AST_Exit\n        && self.alternative instanceof AST_Exit\n        && self.body.TYPE == self.alternative.TYPE) {\n        return make_node(self.body.CTOR, self, {\n            value: make_node(AST_Conditional, self, {\n                condition   : self.condition,\n                consequent  : self.body.value || make_node(AST_Undefined, self.body),\n                alternative : self.alternative.value || make_node(AST_Undefined, self.alternative)\n            }).transform(compressor)\n        }).optimize(compressor);\n    }\n    if (self.body instanceof AST_If\n        && !self.body.alternative\n        && !self.alternative) {\n        self = make_node(AST_If, self, {\n            condition: make_node(AST_Binary, self.condition, {\n                operator: \"&&\",\n                left: self.condition,\n                right: self.body.condition\n            }),\n            body: self.body.body,\n            alternative: null\n        });\n    }\n    if (aborts(self.body)) {\n        if (self.alternative) {\n            var alt = self.alternative;\n            self.alternative = null;\n            return make_node(AST_BlockStatement, self, {\n                body: [ self, alt ]\n            }).optimize(compressor);\n        }\n    }\n    if (aborts(self.alternative)) {\n        var body = self.body;\n        self.body = self.alternative;\n        self.condition = negated_is_best ? negated : self.condition.negate(compressor);\n        self.alternative = null;\n        return make_node(AST_BlockStatement, self, {\n            body: [ self, body ]\n        }).optimize(compressor);\n    }\n    return self;\n});\n\ndef_optimize(AST_Switch, function(self, compressor) {\n    if (!compressor.option(\"switches\")) return self;\n    var branch;\n    var value = self.expression.evaluate(compressor);\n    if (!(value instanceof AST_Node)) {\n        var orig = self.expression;\n        self.expression = make_node_from_constant(value, orig);\n        self.expression = best_of_expression(self.expression.transform(compressor), orig);\n    }\n    if (!compressor.option(\"dead_code\")) return self;\n    if (value instanceof AST_Node) {\n        value = self.expression.tail_node().evaluate(compressor);\n    }\n    var decl = [];\n    var body = [];\n    var default_branch;\n    var exact_match;\n    // - compress self.body into `body`\n    // - find and deduplicate default branch\n    // - find the exact match (`case 1234` inside `switch(1234)`)\n    for (var i = 0, len = self.body.length; i < len && !exact_match; i++) {\n        branch = self.body[i];\n        if (branch instanceof AST_Default) {\n            if (!default_branch) {\n                default_branch = branch;\n            } else {\n                eliminate_branch(branch, body[body.length - 1]);\n            }\n        } else if (!(value instanceof AST_Node)) {\n            var exp = branch.expression.evaluate(compressor);\n            if (!(exp instanceof AST_Node) && exp !== value) {\n                eliminate_branch(branch, body[body.length - 1]);\n                continue;\n            }\n            if (exp instanceof AST_Node && !exp.has_side_effects(compressor)) {\n                exp = branch.expression.tail_node().evaluate(compressor);\n            }\n            if (exp === value) {\n                exact_match = branch;\n                if (default_branch) {\n                    var default_index = body.indexOf(default_branch);\n                    body.splice(default_index, 1);\n                    eliminate_branch(default_branch, body[default_index - 1]);\n                    default_branch = null;\n                }\n            }\n        }\n        body.push(branch);\n    }\n    // i < len if we found an exact_match. eliminate the rest\n    while (i < len) eliminate_branch(self.body[i++], body[body.length - 1]);\n    self.body = body;\n\n    let default_or_exact = default_branch || exact_match;\n    default_branch = null;\n    exact_match = null;\n\n    // group equivalent branches so they will be located next to each other,\n    // that way the next micro-optimization will merge them.\n    // ** bail micro-optimization if not a simple switch case with breaks\n    if (body.every((branch, i) =>\n        (branch === default_or_exact || branch.expression instanceof AST_Constant)\n        && (branch.body.length === 0 || aborts(branch) || body.length - 1 === i))\n    ) {\n        for (let i = 0; i < body.length; i++) {\n            const branch = body[i];\n            for (let j = i + 1; j < body.length; j++) {\n                const next = body[j];\n                if (next.body.length === 0) continue;\n                const last_branch = j === (body.length - 1);\n                const equivalentBranch = branches_equivalent(next, branch, false);\n                if (equivalentBranch || (last_branch && branches_equivalent(next, branch, true))) {\n                    if (!equivalentBranch && last_branch) {\n                        next.body.push(make_node(AST_Break));\n                    }\n\n                    // let's find previous siblings with inert fallthrough...\n                    let x = j - 1;\n                    let fallthroughDepth = 0;\n                    while (x > i) {\n                        if (is_inert_body(body[x--])) {\n                            fallthroughDepth++;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    const plucked = body.splice(j - fallthroughDepth, 1 + fallthroughDepth);\n                    body.splice(i + 1, 0, ...plucked);\n                    i += plucked.length;\n                }\n            }\n        }\n    }\n\n    // merge equivalent branches in a row\n    for (let i = 0; i < body.length; i++) {\n        let branch = body[i];\n        if (branch.body.length === 0) continue;\n        if (!aborts(branch)) continue;\n\n        for (let j = i + 1; j < body.length; i++, j++) {\n            let next = body[j];\n            if (next.body.length === 0) continue;\n            if (\n                branches_equivalent(next, branch, false)\n                || (j === body.length - 1 && branches_equivalent(next, branch, true))\n            ) {\n                branch.body = [];\n                branch = next;\n                continue;\n            }\n            break;\n        }\n    }\n\n    // Prune any empty branches at the end of the switch statement.\n    {\n        let i = body.length - 1;\n        for (; i >= 0; i--) {\n            let bbody = body[i].body;\n            while (is_break(bbody[bbody.length - 1], compressor)) bbody.pop();\n            if (!is_inert_body(body[i])) break;\n        }\n        // i now points to the index of a branch that contains a body. By incrementing, it's\n        // pointing to the first branch that's empty.\n        i++;\n        if (!default_or_exact || body.indexOf(default_or_exact) >= i) {\n            // The default behavior is to do nothing. We can take advantage of that to\n            // remove all case expressions that are side-effect free that also do\n            // nothing, since they'll default to doing nothing. But we can't remove any\n            // case expressions before one that would side-effect, since they may cause\n            // the side-effect to be skipped.\n            for (let j = body.length - 1; j >= i; j--) {\n                let branch = body[j];\n                if (branch === default_or_exact) {\n                    default_or_exact = null;\n                    eliminate_branch(body.pop());\n                } else if (!branch.expression.has_side_effects(compressor)) {\n                    eliminate_branch(body.pop());\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n\n    // Prune side-effect free branches that fall into default.\n    DEFAULT: if (default_or_exact) {\n        let default_index = body.indexOf(default_or_exact);\n        let default_body_index = default_index;\n        for (; default_body_index < body.length - 1; default_body_index++) {\n            if (!is_inert_body(body[default_body_index])) break;\n        }\n        if (default_body_index < body.length - 1) {\n            break DEFAULT;\n        }\n\n        let side_effect_index = body.length - 1;\n        for (; side_effect_index >= 0; side_effect_index--) {\n            let branch = body[side_effect_index];\n            if (branch === default_or_exact) continue;\n            if (branch.expression.has_side_effects(compressor)) break;\n        }\n        // If the default behavior comes after any side-effect case expressions,\n        // then we can fold all side-effect free cases into the default branch.\n        // If the side-effect case is after the default, then any side-effect\n        // free cases could prevent the side-effect from occurring.\n        if (default_body_index > side_effect_index) {\n            let prev_body_index = default_index - 1;\n            for (; prev_body_index >= 0; prev_body_index--) {\n                if (!is_inert_body(body[prev_body_index])) break;\n            }\n            let before = Math.max(side_effect_index, prev_body_index) + 1;\n            let after = default_index;\n            if (side_effect_index > default_index) {\n                // If the default falls into the same body as a side-effect\n                // case, then we need preserve that case and only prune the\n                // cases after it.\n                after = side_effect_index;\n                body[side_effect_index].body = body[default_body_index].body;\n            } else {\n                // The default will be the last branch.\n                default_or_exact.body = body[default_body_index].body;\n            }\n\n            // Prune everything after the default (or last side-effect case)\n            // until the next case with a body.\n            body.splice(after + 1, default_body_index - after);\n            // Prune everything before the default that falls into it.\n            body.splice(before, default_index - before);\n        }\n    }\n\n    // See if we can remove the switch entirely if all cases (the default) fall into the same case body.\n    DEFAULT: if (default_or_exact) {\n        let i = body.findIndex(branch => !is_inert_body(branch));\n        let caseBody;\n        // `i` is equal to one of the following:\n        // - `-1`, there is no body in the switch statement.\n        // - `body.length - 1`, all cases fall into the same body.\n        // - anything else, there are multiple bodies in the switch.\n        if (i === body.length - 1) {\n            // All cases fall into the case body.\n            let branch = body[i];\n            if (has_nested_break(self)) break DEFAULT;\n\n            // This is the last case body, and we've already pruned any breaks, so it's\n            // safe to hoist.\n            caseBody = make_node(AST_BlockStatement, branch, {\n                body: branch.body\n            });\n            branch.body = [];\n        } else if (i !== -1) {\n            // If there are multiple bodies, then we cannot optimize anything.\n            break DEFAULT;\n        }\n\n        let sideEffect = body.find(\n            branch => branch !== default_or_exact && branch.expression.has_side_effects(compressor)\n        );\n        // If no cases cause a side-effect, we can eliminate the switch entirely.\n        if (!sideEffect) {\n            return make_node(AST_BlockStatement, self, {\n                body: decl.concat(\n                    statement(self.expression),\n                    default_or_exact.expression ? statement(default_or_exact.expression) : [],\n                    caseBody || []\n                )\n            }).optimize(compressor);\n        }\n\n        // If we're this far, either there was no body or all cases fell into the same body.\n        // If there was no body, then we don't need a default branch (because the default is\n        // do nothing). If there was a body, we'll extract it to after the switch, so the\n        // switch's new default is to do nothing and we can still prune it.\n        const default_index = body.indexOf(default_or_exact);\n        body.splice(default_index, 1);\n        default_or_exact = null;\n\n        if (caseBody) {\n            // Recurse into switch statement one more time so that we can append the case body\n            // outside of the switch. This recursion will only happen once since we've pruned\n            // the default case.\n            return make_node(AST_BlockStatement, self, {\n                body: decl.concat(self, caseBody)\n            }).optimize(compressor);\n        }\n        // If we fall here, there is a default branch somewhere, there are no case bodies,\n        // and there's a side-effect somewhere. Just let the below paths take care of it.\n    }\n\n    // Reintegrate `decl` (var statements)\n    if (body.length > 0) {\n        body[0].body = decl.concat(body[0].body);\n    }\n    if (body.length == 0) {\n        return make_node(AST_BlockStatement, self, {\n            body: decl.concat(statement(self.expression))\n        }).optimize(compressor);\n    }\n\n    if (body.length == 1 && !has_nested_break(self)) {\n        // This is the last case body, and we've already pruned any breaks, so it's\n        // safe to hoist.\n        let branch = body[0];\n        return make_node(AST_If, self, {\n            condition: make_node(AST_Binary, self, {\n                operator: \"===\",\n                left: self.expression,\n                right: branch.expression,\n            }),\n            body: make_node(AST_BlockStatement, branch, {\n                body: branch.body\n            }),\n            alternative: null\n        }).optimize(compressor);\n    }\n    if (body.length === 2 && default_or_exact && !has_nested_break(self)) {\n        let branch = body[0] === default_or_exact ? body[1] : body[0];\n        let exact_exp = default_or_exact.expression && statement(default_or_exact.expression);\n        if (aborts(body[0])) {\n            // Only the first branch body could have a break (at the last statement)\n            let first = body[0];\n            if (is_break(first.body[first.body.length - 1], compressor)) {\n                first.body.pop();\n            }\n            return make_node(AST_If, self, {\n                condition: make_node(AST_Binary, self, {\n                    operator: \"===\",\n                    left: self.expression,\n                    right: branch.expression,\n                }),\n                body: make_node(AST_BlockStatement, branch, {\n                    body: branch.body\n                }),\n                alternative: make_node(AST_BlockStatement, default_or_exact, {\n                    body: [].concat(\n                        exact_exp || [],\n                        default_or_exact.body\n                    )\n                })\n            }).optimize(compressor);\n        }\n        let operator = \"===\";\n        let consequent = make_node(AST_BlockStatement, branch, {\n            body: branch.body,\n        });\n        let always = make_node(AST_BlockStatement, default_or_exact, {\n            body: [].concat(\n                exact_exp || [],\n                default_or_exact.body\n            )\n        });\n        if (body[0] === default_or_exact) {\n            operator = \"!==\";\n            let tmp = always;\n            always = consequent;\n            consequent = tmp;\n        }\n        return make_node(AST_BlockStatement, self, {\n            body: [\n                make_node(AST_If, self, {\n                    condition: make_node(AST_Binary, self, {\n                        operator: operator,\n                        left: self.expression,\n                        right: branch.expression,\n                    }),\n                    body: consequent,\n                    alternative: null,\n                }),\n                always,\n            ],\n        }).optimize(compressor);\n    }\n    return self;\n\n    function eliminate_branch(branch, prev) {\n        if (prev && !aborts(prev)) {\n            prev.body = prev.body.concat(branch.body);\n        } else {\n            extract_from_unreachable_code(compressor, branch, decl);\n        }\n    }\n    function branches_equivalent(branch, prev, insertBreak) {\n        let bbody = branch.body;\n        let pbody = prev.body;\n        if (insertBreak) {\n            bbody = bbody.concat(make_node(AST_Break));\n        }\n        if (bbody.length !== pbody.length) return false;\n        let bblock = make_node(AST_BlockStatement, branch, { body: bbody });\n        let pblock = make_node(AST_BlockStatement, prev, { body: pbody });\n        return bblock.equivalent_to(pblock);\n    }\n    function statement(body) {\n        return make_node(AST_SimpleStatement, body, { body });\n    }\n    function has_nested_break(root) {\n        let has_break = false;\n\n        let tw = new TreeWalker(node => {\n            if (has_break) return true;\n            if (node instanceof AST_Lambda) return true;\n            if (node instanceof AST_SimpleStatement) return true;\n            if (!is_break(node, tw)) return;\n            let parent = tw.parent();\n            if (\n                parent instanceof AST_SwitchBranch\n                && parent.body[parent.body.length - 1] === node\n            ) {\n                return;\n            }\n            has_break = true;\n        });\n        root.walk(tw);\n        return has_break;\n    }\n    function is_break(node, stack) {\n        return node instanceof AST_Break\n            && stack.loopcontrol_target(node) === self;\n    }\n    function is_inert_body(branch) {\n        return !aborts(branch) && !make_node(AST_BlockStatement, branch, {\n            body: branch.body\n        }).has_side_effects(compressor);\n    }\n});\n\ndef_optimize(AST_Try, function(self, compressor) {\n    if (self.bcatch && self.bfinally && self.bfinally.body.every(is_empty)) self.bfinally = null;\n\n    if (compressor.option(\"dead_code\") && self.body.body.every(is_empty)) {\n        var body = [];\n        if (self.bcatch) {\n            extract_from_unreachable_code(compressor, self.bcatch, body);\n        }\n        if (self.bfinally) body.push(...self.bfinally.body);\n        return make_node(AST_BlockStatement, self, {\n            body: body\n        }).optimize(compressor);\n    }\n    return self;\n});\n\nAST_Definitions.DEFMETHOD(\"to_assignments\", function(compressor) {\n    var reduce_vars = compressor.option(\"reduce_vars\");\n    var assignments = [];\n\n    for (const def of this.definitions) {\n        if (def.value) {\n            var name = make_node(AST_SymbolRef, def.name, def.name);\n            assignments.push(make_node(AST_Assign, def, {\n                operator : \"=\",\n                logical: false,\n                left     : name,\n                right    : def.value\n            }));\n            if (reduce_vars) name.definition().fixed = false;\n        }\n        const thedef = def.name.definition();\n        thedef.eliminated++;\n        thedef.replaced--;\n    }\n\n    if (assignments.length == 0) return null;\n    return make_sequence(this, assignments);\n});\n\ndef_optimize(AST_Definitions, function(self) {\n    if (self.definitions.length == 0) {\n        return make_node(AST_EmptyStatement, self);\n    }\n    return self;\n});\n\ndef_optimize(AST_VarDef, function(self, compressor) {\n    if (\n        self.name instanceof AST_SymbolLet\n        && self.value != null\n        && is_undefined(self.value, compressor)\n    ) {\n        self.value = null;\n    }\n    return self;\n});\n\ndef_optimize(AST_Import, function(self) {\n    return self;\n});\n\ndef_optimize(AST_Call, function(self, compressor) {\n    var exp = self.expression;\n    var fn = exp;\n    inline_array_like_spread(self.args);\n    var simple_args = self.args.every((arg) => !(arg instanceof AST_Expansion));\n\n    if (compressor.option(\"reduce_vars\") && fn instanceof AST_SymbolRef) {\n        fn = fn.fixed_value();\n    }\n\n    var is_func = fn instanceof AST_Lambda;\n\n    if (is_func && fn.pinned()) return self;\n\n    if (compressor.option(\"unused\")\n        && simple_args\n        && is_func\n        && !fn.uses_arguments) {\n        var pos = 0, last = 0;\n        for (var i = 0, len = self.args.length; i < len; i++) {\n            if (fn.argnames[i] instanceof AST_Expansion) {\n                if (has_flag(fn.argnames[i].expression, UNUSED)) while (i < len) {\n                    var node = self.args[i++].drop_side_effect_free(compressor);\n                    if (node) {\n                        self.args[pos++] = node;\n                    }\n                } else while (i < len) {\n                    self.args[pos++] = self.args[i++];\n                }\n                last = pos;\n                break;\n            }\n            var trim = i >= fn.argnames.length;\n            if (trim || has_flag(fn.argnames[i], UNUSED)) {\n                var node = self.args[i].drop_side_effect_free(compressor);\n                if (node) {\n                    self.args[pos++] = node;\n                } else if (!trim) {\n                    self.args[pos++] = make_node(AST_Number, self.args[i], {\n                        value: 0\n                    });\n                    continue;\n                }\n            } else {\n                self.args[pos++] = self.args[i];\n            }\n            last = pos;\n        }\n        self.args.length = last;\n    }\n\n    if (\n        exp instanceof AST_Dot\n        && exp.expression instanceof AST_SymbolRef\n        && exp.expression.name === \"console\"\n        && exp.expression.definition().undeclared\n        && exp.property === \"assert\"\n    ) {\n        const condition = self.args[0];\n        if (condition) {\n            const value = condition.evaluate(compressor);\n    \n            if (value === 1 || value === true) {\n                return make_node(AST_Undefined, self);\n            }\n        }\n    }    \n\n    if (compressor.option(\"unsafe\") && !exp.contains_optional()) {\n        if (exp instanceof AST_Dot && exp.start.value === \"Array\" && exp.property === \"from\" && self.args.length === 1) {\n            const [argument] = self.args;\n            if (argument instanceof AST_Array) {\n                return make_node(AST_Array, argument, {\n                    elements: argument.elements\n                }).optimize(compressor);\n            }\n        }\n        if (is_undeclared_ref(exp)) switch (exp.name) {\n          case \"Array\":\n            if (self.args.length != 1) {\n                return make_node(AST_Array, self, {\n                    elements: self.args\n                }).optimize(compressor);\n            } else if (self.args[0] instanceof AST_Number && self.args[0].value <= 11) {\n                const elements = [];\n                for (let i = 0; i < self.args[0].value; i++) elements.push(new AST_Hole);\n                return new AST_Array({ elements });\n            }\n            break;\n          case \"Object\":\n            if (self.args.length == 0) {\n                return make_node(AST_Object, self, {\n                    properties: []\n                });\n            }\n            break;\n          case \"String\":\n            if (self.args.length == 0) return make_node(AST_String, self, {\n                value: \"\"\n            });\n            if (self.args.length <= 1) return make_node(AST_Binary, self, {\n                left: self.args[0],\n                operator: \"+\",\n                right: make_node(AST_String, self, { value: \"\" })\n            }).optimize(compressor);\n            break;\n          case \"Number\":\n            if (self.args.length == 0) return make_node(AST_Number, self, {\n                value: 0\n            });\n            if (self.args.length == 1 && compressor.option(\"unsafe_math\")) {\n                return make_node(AST_UnaryPrefix, self, {\n                    expression: self.args[0],\n                    operator: \"+\"\n                }).optimize(compressor);\n            }\n            break;\n          case \"Symbol\":\n            if (self.args.length == 1 && self.args[0] instanceof AST_String && compressor.option(\"unsafe_symbols\"))\n                self.args.length = 0;\n                break;\n          case \"Boolean\":\n            if (self.args.length == 0) return make_node(AST_False, self);\n            if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {\n                expression: make_node(AST_UnaryPrefix, self, {\n                    expression: self.args[0],\n                    operator: \"!\"\n                }),\n                operator: \"!\"\n            }).optimize(compressor);\n            break;\n          case \"RegExp\":\n            var params = [];\n            if (self.args.length >= 1\n                && self.args.length <= 2\n                && self.args.every((arg) => {\n                    var value = arg.evaluate(compressor);\n                    params.push(value);\n                    return arg !== value;\n                })\n                && regexp_is_safe(params[0])\n            ) {\n                let [ source, flags ] = params;\n                source = regexp_source_fix(new RegExp(source).source);\n                const rx = make_node(AST_RegExp, self, {\n                    value: { source, flags }\n                });\n                if (rx._eval(compressor) !== rx) {\n                    return rx;\n                }\n            }\n            break;\n        } else if (exp instanceof AST_Dot) switch(exp.property) {\n          case \"toString\":\n            if (self.args.length == 0 && !exp.expression.may_throw_on_access(compressor)) {\n                return make_node(AST_Binary, self, {\n                    left: make_node(AST_String, self, { value: \"\" }),\n                    operator: \"+\",\n                    right: exp.expression\n                }).optimize(compressor);\n            }\n            break;\n          case \"join\":\n            if (exp.expression instanceof AST_Array) EXIT: {\n                var separator;\n                if (self.args.length > 0) {\n                    separator = self.args[0].evaluate(compressor);\n                    if (separator === self.args[0]) break EXIT; // not a constant\n                }\n                var elements = [];\n                var consts = [];\n                for (var i = 0, len = exp.expression.elements.length; i < len; i++) {\n                    var el = exp.expression.elements[i];\n                    if (el instanceof AST_Expansion) break EXIT;\n                    var value = el.evaluate(compressor);\n                    if (value !== el) {\n                        consts.push(value);\n                    } else {\n                        if (consts.length > 0) {\n                            elements.push(make_node(AST_String, self, {\n                                value: consts.join(separator)\n                            }));\n                            consts.length = 0;\n                        }\n                        elements.push(el);\n                    }\n                }\n                if (consts.length > 0) {\n                    elements.push(make_node(AST_String, self, {\n                        value: consts.join(separator)\n                    }));\n                }\n                if (elements.length == 0) return make_node(AST_String, self, { value: \"\" });\n                if (elements.length == 1) {\n                    if (elements[0].is_string(compressor)) {\n                        return elements[0];\n                    }\n                    return make_node(AST_Binary, elements[0], {\n                        operator : \"+\",\n                        left     : make_node(AST_String, self, { value: \"\" }),\n                        right    : elements[0]\n                    });\n                }\n                if (separator == \"\") {\n                    var first;\n                    if (elements[0].is_string(compressor)\n                        || elements[1].is_string(compressor)) {\n                        first = elements.shift();\n                    } else {\n                        first = make_node(AST_String, self, { value: \"\" });\n                    }\n                    return elements.reduce(function(prev, el) {\n                        return make_node(AST_Binary, el, {\n                            operator : \"+\",\n                            left     : prev,\n                            right    : el\n                        });\n                    }, first).optimize(compressor);\n                }\n                // need this awkward cloning to not affect original element\n                // best_of will decide which one to get through.\n                var node = self.clone();\n                node.expression = node.expression.clone();\n                node.expression.expression = node.expression.expression.clone();\n                node.expression.expression.elements = elements;\n                return best_of(compressor, self, node);\n            }\n            break;\n          case \"charAt\":\n            if (exp.expression.is_string(compressor)) {\n                var arg = self.args[0];\n                var index = arg ? arg.evaluate(compressor) : 0;\n                if (index !== arg) {\n                    return make_node(AST_Sub, exp, {\n                        expression: exp.expression,\n                        property: make_node_from_constant(index | 0, arg || exp)\n                    }).optimize(compressor);\n                }\n            }\n            break;\n          case \"apply\":\n            if (self.args.length == 2 && self.args[1] instanceof AST_Array) {\n                var args = self.args[1].elements.slice();\n                args.unshift(self.args[0]);\n                return make_node(AST_Call, self, {\n                    expression: make_node(AST_Dot, exp, {\n                        expression: exp.expression,\n                        optional: false,\n                        property: \"call\"\n                    }),\n                    args: args\n                }).optimize(compressor);\n            }\n            break;\n          case \"call\":\n            var func = exp.expression;\n            if (func instanceof AST_SymbolRef) {\n                func = func.fixed_value();\n            }\n            if (func instanceof AST_Lambda && !func.contains_this()) {\n                return (self.args.length ? make_sequence(this, [\n                    self.args[0],\n                    make_node(AST_Call, self, {\n                        expression: exp.expression,\n                        args: self.args.slice(1)\n                    })\n                ]) : make_node(AST_Call, self, {\n                    expression: exp.expression,\n                    args: []\n                })).optimize(compressor);\n            }\n            break;\n        }\n    }\n\n    if (compressor.option(\"unsafe_Function\")\n        && is_undeclared_ref(exp)\n        && exp.name == \"Function\") {\n        // new Function() => function(){}\n        if (self.args.length == 0) return make_empty_function(self).optimize(compressor);\n        if (self.args.every((x) => x instanceof AST_String)) {\n            // quite a corner-case, but we can handle it:\n            //   https://github.com/mishoo/UglifyJS2/issues/203\n            // if the code argument is a constant, then we can minify it.\n            try {\n                var code = \"n(function(\" + self.args.slice(0, -1).map(function(arg) {\n                    return arg.value;\n                }).join(\",\") + \"){\" + self.args[self.args.length - 1].value + \"})\";\n                var ast = parse(code);\n                var mangle = compressor.mangle_options();\n                ast.figure_out_scope(mangle);\n                var comp = new Compressor(compressor.options, {\n                    mangle_options: compressor._mangle_options\n                });\n                ast = ast.transform(comp);\n                ast.figure_out_scope(mangle);\n                ast.compute_char_frequency(mangle);\n                ast.mangle_names(mangle);\n                var fun;\n                walk(ast, node => {\n                    if (is_func_expr(node)) {\n                        fun = node;\n                        return walk_abort;\n                    }\n                });\n                var code = OutputStream();\n                AST_BlockStatement.prototype._codegen.call(fun, fun, code);\n                self.args = [\n                    make_node(AST_String, self, {\n                        value: fun.argnames.map(function(arg) {\n                            return arg.print_to_string();\n                        }).join(\",\")\n                    }),\n                    make_node(AST_String, self.args[self.args.length - 1], {\n                        value: code.get().replace(/^{|}$/g, \"\")\n                    })\n                ];\n                return self;\n            } catch (ex) {\n                if (!(ex instanceof JS_Parse_Error)) {\n                    throw ex;\n                }\n\n                // Otherwise, it crashes at runtime. Or maybe it's nonstandard syntax.\n            }\n        }\n    }\n\n    return inline_into_call(self, compressor);\n});\n\n/** Does this node contain optional property access or optional call? */\nAST_Node.DEFMETHOD(\"contains_optional\", function() {\n    if (\n        this instanceof AST_PropAccess\n        || this instanceof AST_Call\n        || this instanceof AST_Chain\n    ) {\n        if (this.optional) {\n            return true;\n        } else {\n            return this.expression.contains_optional();\n        }\n    } else {\n        return false;\n    }\n});\n\ndef_optimize(AST_New, function(self, compressor) {\n    if (\n        compressor.option(\"unsafe\") &&\n        is_undeclared_ref(self.expression) &&\n        [\"Object\", \"RegExp\", \"Function\", \"Error\", \"Array\"].includes(self.expression.name)\n    ) return make_node(AST_Call, self, self).transform(compressor);\n    return self;\n});\n\ndef_optimize(AST_Sequence, function(self, compressor) {\n    if (!compressor.option(\"side_effects\")) return self;\n    var expressions = [];\n    filter_for_side_effects();\n    var end = expressions.length - 1;\n    trim_right_for_undefined();\n    if (end == 0) {\n        self = maintain_this_binding(compressor.parent(), compressor.self(), expressions[0]);\n        if (!(self instanceof AST_Sequence)) self = self.optimize(compressor);\n        return self;\n    }\n    self.expressions = expressions;\n    return self;\n\n    function filter_for_side_effects() {\n        var first = first_in_statement(compressor);\n        var last = self.expressions.length - 1;\n        self.expressions.forEach(function(expr, index) {\n            if (index < last) expr = expr.drop_side_effect_free(compressor, first);\n            if (expr) {\n                merge_sequence(expressions, expr);\n                first = false;\n            }\n        });\n    }\n\n    function trim_right_for_undefined() {\n        while (end > 0 && is_undefined(expressions[end], compressor)) end--;\n        if (end < expressions.length - 1) {\n            expressions[end] = make_node(AST_UnaryPrefix, self, {\n                operator   : \"void\",\n                expression : expressions[end]\n            });\n            expressions.length = end + 1;\n        }\n    }\n});\n\nAST_Unary.DEFMETHOD(\"lift_sequences\", function(compressor) {\n    if (compressor.option(\"sequences\")) {\n        if (this.expression instanceof AST_Sequence) {\n            var x = this.expression.expressions.slice();\n            var e = this.clone();\n            e.expression = x.pop();\n            x.push(e);\n            return make_sequence(this, x).optimize(compressor);\n        }\n    }\n    return this;\n});\n\ndef_optimize(AST_UnaryPostfix, function(self, compressor) {\n    return self.lift_sequences(compressor);\n});\n\ndef_optimize(AST_UnaryPrefix, function(self, compressor) {\n    var e = self.expression;\n    if (\n        self.operator == \"delete\" &&\n        !(\n            e instanceof AST_SymbolRef ||\n            e instanceof AST_PropAccess ||\n            e instanceof AST_Chain ||\n            is_identifier_atom(e)\n        )\n    ) {\n        return make_sequence(self, [e, make_node(AST_True, self)]).optimize(compressor);\n    }\n    var seq = self.lift_sequences(compressor);\n    if (seq !== self) {\n        return seq;\n    }\n    if (compressor.option(\"side_effects\") && self.operator == \"void\") {\n        e = e.drop_side_effect_free(compressor);\n        if (e) {\n            self.expression = e;\n            return self;\n        } else {\n            return make_node(AST_Undefined, self).optimize(compressor);\n        }\n    }\n    if (compressor.in_boolean_context()) {\n        switch (self.operator) {\n          case \"!\":\n            if (e instanceof AST_UnaryPrefix && e.operator == \"!\") {\n                // !!foo ==> foo, if we're in boolean context\n                return e.expression;\n            }\n            if (e instanceof AST_Binary) {\n                self = best_of(compressor, self, e.negate(compressor, first_in_statement(compressor)));\n            }\n            break;\n          case \"typeof\":\n            // typeof always returns a non-empty string, thus it's\n            // always true in booleans\n            // And we don't need to check if it's undeclared, because in typeof, that's OK\n            return (e instanceof AST_SymbolRef ? make_node(AST_True, self) : make_sequence(self, [\n                e,\n                make_node(AST_True, self)\n            ])).optimize(compressor);\n        }\n    }\n    if (self.operator == \"-\" && e instanceof AST_Infinity) {\n        e = e.transform(compressor);\n    }\n    if (e instanceof AST_Binary\n        && (self.operator == \"+\" || self.operator == \"-\")\n        && (e.operator == \"*\" || e.operator == \"/\" || e.operator == \"%\")) {\n        return make_node(AST_Binary, self, {\n            operator: e.operator,\n            left: make_node(AST_UnaryPrefix, e.left, {\n                operator: self.operator,\n                expression: e.left\n            }),\n            right: e.right\n        });\n    }\n\n    if (compressor.option(\"evaluate\")) {\n        // ~~x => x (in 32-bit context)\n        // ~~{32 bit integer} => {32 bit integer}\n        if (\n            self.operator === \"~\"\n            && self.expression instanceof AST_UnaryPrefix\n            && self.expression.operator === \"~\"\n            && (compressor.in_32_bit_context(false) || self.expression.expression.is_32_bit_integer(compressor))\n        ) {\n            return self.expression.expression;\n        }\n\n        // ~(x ^ y) => x ^ ~y\n        if (\n            self.operator === \"~\"\n            && e instanceof AST_Binary\n            && e.operator === \"^\"\n        ) {\n            if (e.left instanceof AST_UnaryPrefix && e.left.operator === \"~\") {\n                // ~(~x ^ y) => x ^ y\n                e.left = e.left.bitwise_negate(compressor, true);\n            } else {\n                e.right = e.right.bitwise_negate(compressor, true);\n            }\n            return e;\n        }\n    }\n\n    if (\n        self.operator != \"-\"\n        // avoid infinite recursion of numerals\n        || !(e instanceof AST_Number || e instanceof AST_Infinity || e instanceof AST_BigInt)\n    ) {\n        var ev = self.evaluate(compressor);\n        if (ev !== self) {\n            ev = make_node_from_constant(ev, self).optimize(compressor);\n            return best_of(compressor, ev, self);\n        }\n    }\n    return self;\n});\n\nAST_Binary.DEFMETHOD(\"lift_sequences\", function(compressor) {\n    if (compressor.option(\"sequences\")) {\n        if (this.left instanceof AST_Sequence) {\n            var x = this.left.expressions.slice();\n            var e = this.clone();\n            e.left = x.pop();\n            x.push(e);\n            return make_sequence(this, x).optimize(compressor);\n        }\n        if (this.right instanceof AST_Sequence && !this.left.has_side_effects(compressor)) {\n            var assign = this.operator == \"=\" && this.left instanceof AST_SymbolRef;\n            var x = this.right.expressions;\n            var last = x.length - 1;\n            for (var i = 0; i < last; i++) {\n                if (!assign && x[i].has_side_effects(compressor)) break;\n            }\n            if (i == last) {\n                x = x.slice();\n                var e = this.clone();\n                e.right = x.pop();\n                x.push(e);\n                return make_sequence(this, x).optimize(compressor);\n            } else if (i > 0) {\n                var e = this.clone();\n                e.right = make_sequence(this.right, x.slice(i));\n                x = x.slice(0, i);\n                x.push(e);\n                return make_sequence(this, x).optimize(compressor);\n            }\n        }\n    }\n    return this;\n});\n\nvar commutativeOperators = makePredicate(\"== === != !== * & | ^\");\nfunction is_object(node) {\n    return node instanceof AST_Array\n        || node instanceof AST_Lambda\n        || node instanceof AST_Object\n        || node instanceof AST_Class;\n}\n\ndef_optimize(AST_Binary, function(self, compressor) {\n    function reversible() {\n        return self.left.is_constant()\n            || self.right.is_constant()\n            || !self.left.has_side_effects(compressor)\n                && !self.right.has_side_effects(compressor);\n    }\n    function reverse(op) {\n        if (reversible()) {\n            if (op) self.operator = op;\n            var tmp = self.left;\n            self.left = self.right;\n            self.right = tmp;\n        }\n    }\n    if (compressor.option(\"lhs_constants\") && commutativeOperators.has(self.operator)) {\n        if (self.right.is_constant()\n            && !self.left.is_constant()) {\n            // if right is a constant, whatever side effects the\n            // left side might have could not influence the\n            // result.  hence, force switch.\n\n            if (!(self.left instanceof AST_Binary\n                  && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n                reverse();\n            }\n        }\n    }\n    self = self.lift_sequences(compressor);\n    if (compressor.option(\"comparisons\")) switch (self.operator) {\n      case \"===\":\n      case \"!==\":\n        var is_strict_comparison = true;\n        if (\n            (self.left.is_string(compressor) && self.right.is_string(compressor)) ||\n            (self.left.is_number(compressor) && self.right.is_number(compressor)) ||\n            (self.left.is_bigint(compressor) && self.right.is_bigint(compressor)) ||\n            (self.left.is_boolean() && self.right.is_boolean()) ||\n            self.left.equivalent_to(self.right)\n        ) {\n            self.operator = self.operator.substr(0, 2);\n        }\n\n        // XXX: intentionally falling down to the next case\n      case \"==\":\n      case \"!=\":\n        // void 0 == x => null == x\n        if (!is_strict_comparison && is_undefined(self.left, compressor)) {\n            self.left = make_node(AST_Null, self.left);\n        // x == void 0 => x == null\n        } else if (!is_strict_comparison && is_undefined(self.right, compressor)) {\n            self.right = make_node(AST_Null, self.right);\n        } else if (compressor.option(\"typeofs\")\n            // \"undefined\" == typeof x => undefined === x\n            && self.left instanceof AST_String\n            && self.left.value == \"undefined\"\n            && self.right instanceof AST_UnaryPrefix\n            && self.right.operator == \"typeof\") {\n            var expr = self.right.expression;\n            if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor)\n                : !(expr instanceof AST_PropAccess && compressor.option(\"ie8\"))) {\n                self.right = expr;\n                self.left = make_node(AST_Undefined, self.left).optimize(compressor);\n                if (self.operator.length == 2) self.operator += \"=\";\n            }\n        } else if (compressor.option(\"typeofs\")\n            // typeof x === \"undefined\" => x === undefined\n            && self.left instanceof AST_UnaryPrefix\n            && self.left.operator == \"typeof\"\n            && self.right instanceof AST_String\n            && self.right.value == \"undefined\") {\n            var expr = self.left.expression;\n            if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor)\n                : !(expr instanceof AST_PropAccess && compressor.option(\"ie8\"))) {\n                self.left = expr;\n                self.right = make_node(AST_Undefined, self.right).optimize(compressor);\n                if (self.operator.length == 2) self.operator += \"=\";\n            }\n        } else if (self.left instanceof AST_SymbolRef\n            // obj !== obj => false\n            && self.right instanceof AST_SymbolRef\n            && self.left.definition() === self.right.definition()\n            && is_object(self.left.fixed_value())) {\n            return make_node(self.operator[0] == \"=\" ? AST_True : AST_False, self);\n        } else if (self.left.is_32_bit_integer(compressor) && self.right.is_32_bit_integer(compressor)) {\n            const not = node => make_node(AST_UnaryPrefix, node, {\n                operator: \"!\",\n                expression: node\n            });\n            const booleanify = (node, truthy) => {\n                if (truthy) {\n                    return compressor.in_boolean_context()\n                        ? node\n                        : not(not(node));\n                } else {\n                    return not(node);\n                }\n            };\n\n            // The only falsy 32-bit integer is 0\n            if (self.left instanceof AST_Number && self.left.value === 0) {\n                return booleanify(self.right, self.operator[0] === \"!\");\n            }\n            if (self.right instanceof AST_Number && self.right.value === 0) {\n                return booleanify(self.left, self.operator[0] === \"!\");\n            }\n\n            // Mask all-bits check\n            // (x & 0xFF) != 0xFF => !(~x & 0xFF)\n            let and_op, x, mask;\n            if (\n                (and_op =\n                    self.left instanceof AST_Binary ? self.left\n                    : self.right instanceof AST_Binary ? self.right : null)\n                && (mask = and_op === self.left ? self.right : self.left)\n                && and_op.operator === \"&\"\n                && mask instanceof AST_Number\n                && mask.is_32_bit_integer(compressor)\n                && (x =\n                    and_op.left.equivalent_to(mask) ? and_op.right\n                    : and_op.right.equivalent_to(mask) ? and_op.left : null)\n            ) {\n                let optimized = booleanify(make_node(AST_Binary, self, {\n                    operator: \"&\",\n                    left: mask,\n                    right: make_node(AST_UnaryPrefix, self, {\n                        operator: \"~\",\n                        expression: x\n                    })\n                }), self.operator[0] === \"!\");\n\n                return best_of(compressor, optimized, self);\n            }\n        }\n        break;\n      case \"&&\":\n      case \"||\":\n        var lhs = self.left;\n        if (lhs.operator == self.operator) {\n            lhs = lhs.right;\n        }\n        if (lhs instanceof AST_Binary\n            && lhs.operator == (self.operator == \"&&\" ? \"!==\" : \"===\")\n            && self.right instanceof AST_Binary\n            && lhs.operator == self.right.operator\n            && (is_undefined(lhs.left, compressor) && self.right.left instanceof AST_Null\n                || lhs.left instanceof AST_Null && is_undefined(self.right.left, compressor))\n            && !lhs.right.has_side_effects(compressor)\n            && lhs.right.equivalent_to(self.right.right)) {\n            var combined = make_node(AST_Binary, self, {\n                operator: lhs.operator.slice(0, -1),\n                left: make_node(AST_Null, self),\n                right: lhs.right\n            });\n            if (lhs !== self.left) {\n                combined = make_node(AST_Binary, self, {\n                    operator: self.operator,\n                    left: self.left.left,\n                    right: combined\n                });\n            }\n            return combined;\n        }\n        break;\n    }\n    if (self.operator == \"+\" && compressor.in_boolean_context()) {\n        var ll = self.left.evaluate(compressor);\n        var rr = self.right.evaluate(compressor);\n        if (ll && typeof ll == \"string\") {\n            return make_sequence(self, [\n                self.right,\n                make_node(AST_True, self)\n            ]).optimize(compressor);\n        }\n        if (rr && typeof rr == \"string\") {\n            return make_sequence(self, [\n                self.left,\n                make_node(AST_True, self)\n            ]).optimize(compressor);\n        }\n    }\n    if (compressor.option(\"comparisons\") && self.is_boolean()) {\n        if (!(compressor.parent() instanceof AST_Binary)\n            || compressor.parent() instanceof AST_Assign) {\n            var negated = make_node(AST_UnaryPrefix, self, {\n                operator: \"!\",\n                expression: self.negate(compressor, first_in_statement(compressor))\n            });\n            self = best_of(compressor, self, negated);\n        }\n        if (compressor.option(\"unsafe_comps\")) {\n            switch (self.operator) {\n              case \"<\": reverse(\">\"); break;\n              case \"<=\": reverse(\">=\"); break;\n            }\n        }\n    }\n    if (self.operator == \"+\") {\n        if (self.right instanceof AST_String\n            && self.right.getValue() == \"\"\n            && self.left.is_string(compressor)) {\n            return self.left;\n        }\n        if (self.left instanceof AST_String\n            && self.left.getValue() == \"\"\n            && self.right.is_string(compressor)) {\n            return self.right;\n        }\n        if (self.left instanceof AST_Binary\n            && self.left.operator == \"+\"\n            && self.left.left instanceof AST_String\n            && self.left.left.getValue() == \"\"\n            && self.right.is_string(compressor)) {\n            self.left = self.left.right;\n            return self;\n        }\n    }\n    if (compressor.option(\"evaluate\")) {\n        switch (self.operator) {\n          case \"&&\":\n            var ll = has_flag(self.left, TRUTHY)\n                ? true\n                : has_flag(self.left, FALSY)\n                    ? false\n                    : self.left.evaluate(compressor);\n            if (!ll) {\n                return maintain_this_binding(compressor.parent(), compressor.self(), self.left).optimize(compressor);\n            } else if (!(ll instanceof AST_Node)) {\n                return make_sequence(self, [ self.left, self.right ]).optimize(compressor);\n            }\n            var rr = self.right.evaluate(compressor);\n            if (!rr) {\n                if (compressor.in_boolean_context()) {\n                    return make_sequence(self, [\n                        self.left,\n                        make_node(AST_False, self)\n                    ]).optimize(compressor);\n                } else {\n                    set_flag(self, FALSY);\n                }\n            } else if (!(rr instanceof AST_Node)) {\n                var parent = compressor.parent();\n                if (parent.operator == \"&&\" && parent.left === compressor.self() || compressor.in_boolean_context()) {\n                    return self.left.optimize(compressor);\n                }\n            }\n            // x || false && y ---> x ? y : false\n            if (self.left.operator == \"||\") {\n                var lr = self.left.right.evaluate(compressor);\n                if (!lr) return make_node(AST_Conditional, self, {\n                    condition: self.left.left,\n                    consequent: self.right,\n                    alternative: self.left.right\n                }).optimize(compressor);\n            }\n            break;\n          case \"||\":\n            var ll = has_flag(self.left, TRUTHY)\n              ? true\n              : has_flag(self.left, FALSY)\n                ? false\n                : self.left.evaluate(compressor);\n            if (!ll) {\n                return make_sequence(self, [ self.left, self.right ]).optimize(compressor);\n            } else if (!(ll instanceof AST_Node)) {\n                return maintain_this_binding(compressor.parent(), compressor.self(), self.left).optimize(compressor);\n            }\n            var rr = self.right.evaluate(compressor);\n            if (!rr) {\n                var parent = compressor.parent();\n                if (parent.operator == \"||\" && parent.left === compressor.self() || compressor.in_boolean_context()) {\n                    return self.left.optimize(compressor);\n                }\n            } else if (!(rr instanceof AST_Node)) {\n                if (compressor.in_boolean_context()) {\n                    return make_sequence(self, [\n                        self.left,\n                        make_node(AST_True, self)\n                    ]).optimize(compressor);\n                } else {\n                    set_flag(self, TRUTHY);\n                }\n            }\n            if (self.left.operator == \"&&\") {\n                var lr = self.left.right.evaluate(compressor);\n                if (lr && !(lr instanceof AST_Node)) return make_node(AST_Conditional, self, {\n                    condition: self.left.left,\n                    consequent: self.left.right,\n                    alternative: self.right\n                }).optimize(compressor);\n            }\n            break;\n          case \"??\":\n            if (is_nullish(self.left, compressor)) {\n                return self.right;\n            }\n\n            var ll = self.left.evaluate(compressor);\n            if (!(ll instanceof AST_Node)) {\n                // if we know the value for sure we can simply compute right away.\n                return ll == null ? self.right : self.left;\n            }\n\n            if (compressor.in_boolean_context()) {\n                const rr = self.right.evaluate(compressor);\n                if (!(rr instanceof AST_Node) && !rr) {\n                    return self.left;\n                }\n            }\n        }\n        var associative = true;\n        switch (self.operator) {\n          case \"+\":\n            // (x + \"foo\") + \"bar\" => x + \"foobar\"\n            if (self.right instanceof AST_Constant\n                && self.left instanceof AST_Binary\n                && self.left.operator == \"+\"\n                && self.left.is_string(compressor)) {\n                var binary = make_node(AST_Binary, self, {\n                    operator: \"+\",\n                    left: self.left.right,\n                    right: self.right,\n                });\n                var r = binary.optimize(compressor);\n                if (binary !== r) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: self.left.left,\n                        right: r\n                    });\n                }\n            }\n            // (x + \"foo\") + (\"bar\" + y) => (x + \"foobar\") + y\n            if (self.left instanceof AST_Binary\n                && self.left.operator == \"+\"\n                && self.left.is_string(compressor)\n                && self.right instanceof AST_Binary\n                && self.right.operator == \"+\"\n                && self.right.is_string(compressor)) {\n                var binary = make_node(AST_Binary, self, {\n                    operator: \"+\",\n                    left: self.left.right,\n                    right: self.right.left,\n                });\n                var m = binary.optimize(compressor);\n                if (binary !== m) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: make_node(AST_Binary, self.left, {\n                            operator: \"+\",\n                            left: self.left.left,\n                            right: m\n                        }),\n                        right: self.right.right\n                    });\n                }\n            }\n            // a + -b => a - b\n            if (self.right instanceof AST_UnaryPrefix\n                && self.right.operator == \"-\"\n                && self.left.is_number_or_bigint(compressor)) {\n                self = make_node(AST_Binary, self, {\n                    operator: \"-\",\n                    left: self.left,\n                    right: self.right.expression\n                });\n                break;\n            }\n            // -a + b => b - a\n            if (self.left instanceof AST_UnaryPrefix\n                && self.left.operator == \"-\"\n                && reversible()\n                && self.right.is_number_or_bigint(compressor)) {\n                self = make_node(AST_Binary, self, {\n                    operator: \"-\",\n                    left: self.right,\n                    right: self.left.expression\n                });\n                break;\n            }\n            // `foo${bar}baz` + 1 => `foo${bar}baz1`\n            if (self.left instanceof AST_TemplateString) {\n                var l = self.left;\n                var r = self.right.evaluate(compressor);\n                if (r != self.right) {\n                    l.segments[l.segments.length - 1].value += String(r);\n                    return l;\n                }\n            }\n            // 1 + `foo${bar}baz` => `1foo${bar}baz`\n            if (self.right instanceof AST_TemplateString) {\n                var r = self.right;\n                var l = self.left.evaluate(compressor);\n                if (l != self.left) {\n                    r.segments[0].value = String(l) + r.segments[0].value;\n                    return r;\n                }\n            }\n            // `1${bar}2` + `foo${bar}baz` => `1${bar}2foo${bar}baz`\n            if (self.left instanceof AST_TemplateString\n                && self.right instanceof AST_TemplateString) {\n                var l = self.left;\n                var segments = l.segments;\n                var r = self.right;\n                segments[segments.length - 1].value += r.segments[0].value;\n                for (var i = 1; i < r.segments.length; i++) {\n                    segments.push(r.segments[i]);\n                }\n                return l;\n            }\n          case \"*\":\n            associative = compressor.option(\"unsafe_math\");\n          case \"&\":\n          case \"|\":\n          case \"^\":\n            // a + +b => +b + a\n            if (\n                self.left.is_number_or_bigint(compressor)\n                && self.right.is_number_or_bigint(compressor)\n                && reversible()\n                && !(self.left instanceof AST_Binary\n                    && self.left.operator != self.operator\n                    && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n                var reversed = make_node(AST_Binary, self, {\n                    operator: self.operator,\n                    left: self.right,\n                    right: self.left\n                });\n                if (self.right instanceof AST_Constant\n                    && !(self.left instanceof AST_Constant)) {\n                    self = best_of(compressor, reversed, self);\n                } else {\n                    self = best_of(compressor, self, reversed);\n                }\n            }\n            if (associative && self.is_number_or_bigint(compressor)) {\n                // a + (b + c) => (a + b) + c\n                if (self.right instanceof AST_Binary\n                    && self.right.operator == self.operator) {\n                    self = make_node(AST_Binary, self, {\n                        operator: self.operator,\n                        left: make_node(AST_Binary, self.left, {\n                            operator: self.operator,\n                            left: self.left,\n                            right: self.right.left,\n                            start: self.left.start,\n                            end: self.right.left.end\n                        }),\n                        right: self.right.right\n                    });\n                }\n                // (n + 2) + 3 => 5 + n\n                // (2 * n) * 3 => 6 + n\n                if (self.right instanceof AST_Constant\n                    && self.left instanceof AST_Binary\n                    && self.left.operator == self.operator) {\n                    if (self.left.left instanceof AST_Constant) {\n                        self = make_node(AST_Binary, self, {\n                            operator: self.operator,\n                            left: make_node(AST_Binary, self.left, {\n                                operator: self.operator,\n                                left: self.left.left,\n                                right: self.right,\n                                start: self.left.left.start,\n                                end: self.right.end\n                            }),\n                            right: self.left.right\n                        });\n                    } else if (self.left.right instanceof AST_Constant) {\n                        self = make_node(AST_Binary, self, {\n                            operator: self.operator,\n                            left: make_node(AST_Binary, self.left, {\n                                operator: self.operator,\n                                left: self.left.right,\n                                right: self.right,\n                                start: self.left.right.start,\n                                end: self.right.end\n                            }),\n                            right: self.left.left\n                        });\n                    }\n                }\n                // (a | 1) | (2 | d) => (3 | a) | b\n                if (self.left instanceof AST_Binary\n                    && self.left.operator == self.operator\n                    && self.left.right instanceof AST_Constant\n                    && self.right instanceof AST_Binary\n                    && self.right.operator == self.operator\n                    && self.right.left instanceof AST_Constant) {\n                    self = make_node(AST_Binary, self, {\n                        operator: self.operator,\n                        left: make_node(AST_Binary, self.left, {\n                            operator: self.operator,\n                            left: make_node(AST_Binary, self.left.left, {\n                                operator: self.operator,\n                                left: self.left.right,\n                                right: self.right.left,\n                                start: self.left.right.start,\n                                end: self.right.left.end\n                            }),\n                            right: self.left.left\n                        }),\n                        right: self.right.right\n                    });\n                }\n            }\n        }\n\n        // bitwise ops\n        if (bitwise_binop.has(self.operator)) {\n            // Use De Morgan's laws\n            // z & (X | y)\n            // => z & X (given y & z === 0)\n            // => z & X | {y & z} (given y & z !== 0)\n            let y, z, x_node, y_node, z_node = self.left;\n            if (\n                self.operator === \"&\"\n                && self.right instanceof AST_Binary\n                && self.right.operator === \"|\"\n                && typeof (z = self.left.evaluate(compressor)) === \"number\"\n            ) {\n                if (typeof (y = self.right.right.evaluate(compressor)) === \"number\") {\n                    // z & (X | y)\n                    x_node = self.right.left;\n                    y_node = self.right.right;\n                } else if (typeof (y = self.right.left.evaluate(compressor)) === \"number\") {\n                    // z & (y | X)\n                    x_node = self.right.right;\n                    y_node = self.right.left;\n                }\n\n                if (x_node && y_node) {\n                    if ((y & z) === 0) {\n                        self = make_node(AST_Binary, self, {\n                            operator: self.operator,\n                            left: z_node,\n                            right: x_node\n                        });\n                    } else {\n                        const reordered_ops = make_node(AST_Binary, self, {\n                            operator: \"|\",\n                            left: make_node(AST_Binary, self, {\n                                operator: \"&\",\n                                left: x_node,\n                                right: z_node\n                            }),\n                            right: make_node_from_constant(y & z, y_node),\n                        });\n\n                        self = best_of(compressor, self, reordered_ops);\n                    }\n                }\n            }\n\n            // x | x => 0 | x\n            // x & x => 0 | x\n            if (\n                (self.operator === \"|\" || self.operator === \"&\")\n                && self.left.equivalent_to(self.right)\n                && !self.left.has_side_effects(compressor)\n                && compressor.in_32_bit_context(true)\n            ) {\n                self.left = make_node(AST_Number, self, { value: 0 });\n                self.operator = \"|\";\n            }\n\n            // ~x ^ ~y => x ^ y\n            if (\n                self.operator === \"^\"\n                && self.left instanceof AST_UnaryPrefix\n                && self.left.operator === \"~\"\n                && self.right instanceof AST_UnaryPrefix\n                && self.right.operator === \"~\"\n            ) {\n                self = make_node(AST_Binary, self, {\n                    operator: \"^\",\n                    left: self.left.expression,\n                    right: self.right.expression\n                });\n            }\n\n\n            // Shifts that do nothing\n            // {anything} >> 0 => {anything} | 0\n            // {anything} << 0 => {anything} | 0\n            if (\n                (self.operator === \"<<\" || self.operator === \">>\")\n                && self.right instanceof AST_Number && self.right.value === 0\n            ) {\n                self.operator = \"|\";\n            }\n\n            // Find useless to-bitwise conversions\n            // {32 bit integer} | 0 => {32 bit integer}\n            // {32 bit integer} ^ 0 => {32 bit integer}\n            const zero_side = self.right instanceof AST_Number && self.right.value === 0 ? self.right\n                : self.left instanceof AST_Number && self.left.value === 0 ? self.left\n                : null;\n            const non_zero_side = zero_side && (zero_side === self.right ? self.left : self.right);\n            if (\n                zero_side\n                && (self.operator === \"|\" || self.operator === \"^\")\n                && (non_zero_side.is_32_bit_integer(compressor) || compressor.in_32_bit_context(true))\n            ) {\n                return non_zero_side;\n            }\n\n            // {anything} & 0 => 0\n            if (\n                zero_side\n                && self.operator === \"&\"\n                && !non_zero_side.has_side_effects(compressor)\n                && non_zero_side.is_32_bit_integer(compressor)\n            ) {\n                return zero_side;\n            }\n\n            // ~0 is all ones, as well as -1.\n            // We can ellide some operations with it.\n            const is_full_mask = (node) =>\n                node instanceof AST_Number && node.value === -1\n                ||\n                    node instanceof AST_UnaryPrefix\n                    && node.operator === \"-\"\n                    && node.expression instanceof AST_Number\n                    && node.expression.value === 1;\n\n            const full_mask = is_full_mask(self.right) ? self.right\n                : is_full_mask(self.left) ? self.left\n                : null;\n            const other_side = (full_mask === self.right ? self.left : self.right);\n\n            // {32 bit integer} & -1 => {32 bit integer}\n            if (\n                full_mask\n                && self.operator === \"&\"\n                && (\n                    other_side.is_32_bit_integer(compressor)\n                    || compressor.in_32_bit_context(true)\n                )\n            ) {\n                return other_side;\n            }\n\n            // {anything} ^ -1 => ~{anything}\n            if (\n                full_mask\n                && self.operator === \"^\"\n                && (\n                    other_side.is_32_bit_integer(compressor)\n                    || compressor.in_32_bit_context(true)\n                )\n            ) {\n                return other_side.bitwise_negate(compressor);\n            }\n        }\n    }\n    // x && (y && z)  ==>  x && y && z\n    // x || (y || z)  ==>  x || y || z\n    // x + (\"y\" + z)  ==>  x + \"y\" + z\n    // \"x\" + (y + \"z\")==>  \"x\" + y + \"z\"\n    if (self.right instanceof AST_Binary\n        && self.right.operator == self.operator\n        && (lazy_op.has(self.operator)\n            || (self.operator == \"+\"\n                && (self.right.left.is_string(compressor)\n                    || (self.left.is_string(compressor)\n                        && self.right.right.is_string(compressor)))))\n    ) {\n        self.left = make_node(AST_Binary, self.left, {\n            operator : self.operator,\n            left     : self.left.transform(compressor),\n            right    : self.right.left.transform(compressor)\n        });\n        self.right = self.right.right.transform(compressor);\n        return self.transform(compressor);\n    }\n    var ev = self.evaluate(compressor);\n    if (ev !== self) {\n        ev = make_node_from_constant(ev, self).optimize(compressor);\n        return best_of(compressor, ev, self);\n    }\n    return self;\n});\n\ndef_optimize(AST_SymbolExport, function(self) {\n    return self;\n});\n\ndef_optimize(AST_SymbolRef, function(self, compressor) {\n    if (\n        !compressor.option(\"ie8\")\n        && is_undeclared_ref(self)\n        && !compressor.find_parent(AST_With)\n    ) {\n        switch (self.name) {\n          case \"undefined\":\n            return make_node(AST_Undefined, self).optimize(compressor);\n          case \"NaN\":\n            return make_node(AST_NaN, self).optimize(compressor);\n          case \"Infinity\":\n            return make_node(AST_Infinity, self).optimize(compressor);\n        }\n    }\n\n    if (compressor.option(\"reduce_vars\") && !compressor.is_lhs()) {\n        return inline_into_symbolref(self, compressor);\n    } else {\n        return self;\n    }\n});\n\nfunction is_atomic(lhs, self) {\n    return lhs instanceof AST_SymbolRef || lhs.TYPE === self.TYPE;\n}\n\ndef_optimize(AST_Undefined, function(self, compressor) {\n    if (compressor.option(\"unsafe_undefined\")) {\n        var undef = find_variable(compressor, \"undefined\");\n        if (undef) {\n            var ref = make_node(AST_SymbolRef, self, {\n                name   : \"undefined\",\n                scope  : undef.scope,\n                thedef : undef\n            });\n            set_flag(ref, UNDEFINED);\n            return ref;\n        }\n    }\n    var lhs = compressor.is_lhs();\n    if (lhs && is_atomic(lhs, self)) return self;\n    return make_node(AST_UnaryPrefix, self, {\n        operator: \"void\",\n        expression: make_node(AST_Number, self, {\n            value: 0\n        })\n    });\n});\n\ndef_optimize(AST_Infinity, function(self, compressor) {\n    var lhs = compressor.is_lhs();\n    if (lhs && is_atomic(lhs, self)) return self;\n    if (\n        compressor.option(\"keep_infinity\")\n        && !(lhs && !is_atomic(lhs, self))\n        && !find_variable(compressor, \"Infinity\")\n    ) {\n        return self;\n    }\n    return make_node(AST_Binary, self, {\n        operator: \"/\",\n        left: make_node(AST_Number, self, {\n            value: 1\n        }),\n        right: make_node(AST_Number, self, {\n            value: 0\n        })\n    });\n});\n\ndef_optimize(AST_NaN, function(self, compressor) {\n    var lhs = compressor.is_lhs();\n    if (lhs && !is_atomic(lhs, self)\n        || find_variable(compressor, \"NaN\")) {\n        return make_node(AST_Binary, self, {\n            operator: \"/\",\n            left: make_node(AST_Number, self, {\n                value: 0\n            }),\n            right: make_node(AST_Number, self, {\n                value: 0\n            })\n        });\n    }\n    return self;\n});\n\nconst ASSIGN_OPS = makePredicate(\"+ - / * % >> << >>> | ^ &\");\nconst ASSIGN_OPS_COMMUTATIVE = makePredicate(\"* | ^ &\");\ndef_optimize(AST_Assign, function(self, compressor) {\n    if (self.logical) {\n        return self.lift_sequences(compressor);\n    }\n\n    var def;\n    // x = x ---> x\n    if (\n        self.operator === \"=\"\n        && self.left instanceof AST_SymbolRef\n        && self.left.name !== \"arguments\"\n        && !(def = self.left.definition()).undeclared\n        && self.right.equivalent_to(self.left)\n    ) {\n        return self.right;\n    }\n\n    if (compressor.option(\"dead_code\")\n        && self.left instanceof AST_SymbolRef\n        && (def = self.left.definition()).scope === compressor.find_parent(AST_Lambda)) {\n        var level = 0, node, parent = self;\n        do {\n            node = parent;\n            parent = compressor.parent(level++);\n            if (parent instanceof AST_Exit) {\n                if (in_try(level, parent)) break;\n                if (is_reachable(def.scope, [ def ])) break;\n                if (self.operator == \"=\") return self.right;\n                def.fixed = false;\n                return make_node(AST_Binary, self, {\n                    operator: self.operator.slice(0, -1),\n                    left: self.left,\n                    right: self.right\n                }).optimize(compressor);\n            }\n        } while (parent instanceof AST_Binary && parent.right === node\n            || parent instanceof AST_Sequence && parent.tail_node() === node);\n    }\n    self = self.lift_sequences(compressor);\n\n    if (self.operator == \"=\" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary) {\n        // x = expr1 OP expr2\n        if (self.right.left instanceof AST_SymbolRef\n            && self.right.left.name == self.left.name\n            && ASSIGN_OPS.has(self.right.operator)) {\n            // x = x - 2  --->  x -= 2\n            self.operator = self.right.operator + \"=\";\n            self.right = self.right.right;\n        } else if (self.right.right instanceof AST_SymbolRef\n            && self.right.right.name == self.left.name\n            && ASSIGN_OPS_COMMUTATIVE.has(self.right.operator)\n            && !self.right.left.has_side_effects(compressor)) {\n            // x = 2 & x  --->  x &= 2\n            self.operator = self.right.operator + \"=\";\n            self.right = self.right.left;\n        }\n    }\n    return self;\n\n    function in_try(level, node) {\n        function may_assignment_throw() {\n            const right = self.right;\n            self.right = make_node(AST_Null, right);\n            const may_throw = node.may_throw(compressor);\n            self.right = right;\n\n            return may_throw;\n        }\n\n        var stop_at = self.left.definition().scope.get_defun_scope();\n        var parent;\n        while ((parent = compressor.parent(level++)) !== stop_at) {\n            if (parent instanceof AST_Try) {\n                if (parent.bfinally) return true;\n                if (parent.bcatch && may_assignment_throw()) return true;\n            }\n        }\n    }\n});\n\ndef_optimize(AST_DefaultAssign, function(self, compressor) {\n    if (!compressor.option(\"evaluate\")) {\n        return self;\n    }\n    var evaluateRight = self.right.evaluate(compressor);\n\n    // `[x = undefined] = foo` ---> `[x] = foo`\n    // `(arg = undefined) => ...` ---> `(arg) => ...` (unless `keep_fargs`)\n    // `((arg = undefined) => ...)()` ---> `((arg) => ...)()`\n    let lambda, iife;\n    if (evaluateRight === undefined) {\n        if (\n            (lambda = compressor.parent()) instanceof AST_Lambda\n                ? (\n                    compressor.option(\"keep_fargs\") === false\n                    || (iife = compressor.parent(1)).TYPE === \"Call\"\n                        && iife.expression === lambda\n                )\n                : true\n        ) {\n            self = self.left;\n        }\n    } else if (evaluateRight !== self.right) {\n        evaluateRight = make_node_from_constant(evaluateRight, self.right);\n        self.right = best_of_expression(evaluateRight, self.right);\n    }\n\n    return self;\n});\n\nfunction is_nullish_check(check, check_subject, compressor) {\n    if (check_subject.may_throw(compressor)) return false;\n\n    let nullish_side;\n\n    // foo == null\n    if (\n        check instanceof AST_Binary\n        && check.operator === \"==\"\n        // which side is nullish?\n        && (\n            (nullish_side = is_nullish(check.left, compressor) && check.left)\n            || (nullish_side = is_nullish(check.right, compressor) && check.right)\n        )\n        // is the other side the same as the check_subject\n        && (\n            nullish_side === check.left\n                ? check.right\n                : check.left\n        ).equivalent_to(check_subject)\n    ) {\n        return true;\n    }\n\n    // foo === null || foo === undefined\n    if (check instanceof AST_Binary && check.operator === \"||\") {\n        let null_cmp;\n        let undefined_cmp;\n\n        const find_comparison = cmp => {\n            if (!(\n                cmp instanceof AST_Binary\n                && (cmp.operator === \"===\" || cmp.operator === \"==\")\n            )) {\n                return false;\n            }\n\n            let found = 0;\n            let defined_side;\n\n            if (cmp.left instanceof AST_Null) {\n                found++;\n                null_cmp = cmp;\n                defined_side = cmp.right;\n            }\n            if (cmp.right instanceof AST_Null) {\n                found++;\n                null_cmp = cmp;\n                defined_side = cmp.left;\n            }\n            if (is_undefined(cmp.left, compressor)) {\n                found++;\n                undefined_cmp = cmp;\n                defined_side = cmp.right;\n            }\n            if (is_undefined(cmp.right, compressor)) {\n                found++;\n                undefined_cmp = cmp;\n                defined_side = cmp.left;\n            }\n\n            if (found !== 1) {\n                return false;\n            }\n\n            if (!defined_side.equivalent_to(check_subject)) {\n                return false;\n            }\n\n            return true;\n        };\n\n        if (!find_comparison(check.left)) return false;\n        if (!find_comparison(check.right)) return false;\n\n        if (null_cmp && undefined_cmp && null_cmp !== undefined_cmp) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\ndef_optimize(AST_Conditional, function(self, compressor) {\n    if (!compressor.option(\"conditionals\")) return self;\n    // This looks like lift_sequences(), should probably be under \"sequences\"\n    if (self.condition instanceof AST_Sequence) {\n        var expressions = self.condition.expressions.slice();\n        self.condition = expressions.pop();\n        expressions.push(self);\n        return make_sequence(self, expressions);\n    }\n    var cond = self.condition.evaluate(compressor);\n    if (cond !== self.condition) {\n        if (cond) {\n            return maintain_this_binding(compressor.parent(), compressor.self(), self.consequent);\n        } else {\n            return maintain_this_binding(compressor.parent(), compressor.self(), self.alternative);\n        }\n    }\n    var negated = cond.negate(compressor, first_in_statement(compressor));\n    if (best_of(compressor, cond, negated) === negated) {\n        self = make_node(AST_Conditional, self, {\n            condition: negated,\n            consequent: self.alternative,\n            alternative: self.consequent\n        });\n    }\n    var condition = self.condition;\n    var consequent = self.consequent;\n    var alternative = self.alternative;\n    // x?x:y --> x||y\n    if (condition instanceof AST_SymbolRef\n        && consequent instanceof AST_SymbolRef\n        && condition.definition() === consequent.definition()) {\n        return make_node(AST_Binary, self, {\n            operator: \"||\",\n            left: condition,\n            right: alternative\n        });\n    }\n    // if (foo) exp = something; else exp = something_else;\n    //                   |\n    //                   v\n    // exp = foo ? something : something_else;\n    if (\n        consequent instanceof AST_Assign\n        && alternative instanceof AST_Assign\n        && consequent.operator === alternative.operator\n        && consequent.logical === alternative.logical\n        && consequent.left.equivalent_to(alternative.left)\n        && (!self.condition.has_side_effects(compressor)\n            || consequent.operator == \"=\"\n                && !consequent.left.has_side_effects(compressor))\n    ) {\n        return make_node(AST_Assign, self, {\n            operator: consequent.operator,\n            left: consequent.left,\n            logical: consequent.logical,\n            right: make_node(AST_Conditional, self, {\n                condition: self.condition,\n                consequent: consequent.right,\n                alternative: alternative.right\n            })\n        });\n    }\n    // x ? y(a) : y(b) --> y(x ? a : b)\n    var arg_index;\n    if (consequent instanceof AST_Call\n        && alternative.TYPE === consequent.TYPE\n        && consequent.args.length > 0\n        && consequent.args.length == alternative.args.length\n        && consequent.expression.equivalent_to(alternative.expression)\n        && !self.condition.has_side_effects(compressor)\n        && !consequent.expression.has_side_effects(compressor)\n        && typeof (arg_index = single_arg_diff()) == \"number\") {\n        var node = consequent.clone();\n        node.args[arg_index] = make_node(AST_Conditional, self, {\n            condition: self.condition,\n            consequent: consequent.args[arg_index],\n            alternative: alternative.args[arg_index]\n        });\n        return node;\n    }\n    // a ? b : c ? b : d --> (a || c) ? b : d\n    if (alternative instanceof AST_Conditional\n        && consequent.equivalent_to(alternative.consequent)) {\n        return make_node(AST_Conditional, self, {\n            condition: make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: condition,\n                right: alternative.condition\n            }),\n            consequent: consequent,\n            alternative: alternative.alternative\n        }).optimize(compressor);\n    }\n\n    // a == null ? b : a -> a ?? b\n    if (\n        compressor.option(\"ecma\") >= 2020 &&\n        is_nullish_check(condition, alternative, compressor)\n    ) {\n        return make_node(AST_Binary, self, {\n            operator: \"??\",\n            left: alternative,\n            right: consequent\n        }).optimize(compressor);\n    }\n\n    // a ? b : (c, b) --> (a || c), b\n    if (alternative instanceof AST_Sequence\n        && consequent.equivalent_to(alternative.expressions[alternative.expressions.length - 1])) {\n        return make_sequence(self, [\n            make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: condition,\n                right: make_sequence(self, alternative.expressions.slice(0, -1))\n            }),\n            consequent\n        ]).optimize(compressor);\n    }\n    // a ? b : (c && b) --> (a || c) && b\n    if (alternative instanceof AST_Binary\n        && alternative.operator == \"&&\"\n        && consequent.equivalent_to(alternative.right)) {\n        return make_node(AST_Binary, self, {\n            operator: \"&&\",\n            left: make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: condition,\n                right: alternative.left\n            }),\n            right: consequent\n        }).optimize(compressor);\n    }\n    // x?y?z:a:a --> x&&y?z:a\n    if (consequent instanceof AST_Conditional\n        && consequent.alternative.equivalent_to(alternative)) {\n        return make_node(AST_Conditional, self, {\n            condition: make_node(AST_Binary, self, {\n                left: self.condition,\n                operator: \"&&\",\n                right: consequent.condition\n            }),\n            consequent: consequent.consequent,\n            alternative: alternative\n        });\n    }\n    // x ? y : y --> x, y\n    if (consequent.equivalent_to(alternative)) {\n        return make_sequence(self, [\n            self.condition,\n            consequent\n        ]).optimize(compressor);\n    }\n    // x ? y || z : z --> x && y || z\n    if (consequent instanceof AST_Binary\n        && consequent.operator == \"||\"\n        && consequent.right.equivalent_to(alternative)) {\n        return make_node(AST_Binary, self, {\n            operator: \"||\",\n            left: make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: self.condition,\n                right: consequent.left\n            }),\n            right: alternative\n        }).optimize(compressor);\n    }\n\n    const in_bool = compressor.in_boolean_context();\n    if (is_true(self.consequent)) {\n        if (is_false(self.alternative)) {\n            // c ? true : false ---> !!c\n            return booleanize(self.condition);\n        }\n        // c ? true : x ---> !!c || x\n        return make_node(AST_Binary, self, {\n            operator: \"||\",\n            left: booleanize(self.condition),\n            right: self.alternative\n        });\n    }\n    if (is_false(self.consequent)) {\n        if (is_true(self.alternative)) {\n            // c ? false : true ---> !c\n            return booleanize(self.condition.negate(compressor));\n        }\n        // c ? false : x ---> !c && x\n        return make_node(AST_Binary, self, {\n            operator: \"&&\",\n            left: booleanize(self.condition.negate(compressor)),\n            right: self.alternative\n        });\n    }\n    if (is_true(self.alternative)) {\n        // c ? x : true ---> !c || x\n        return make_node(AST_Binary, self, {\n            operator: \"||\",\n            left: booleanize(self.condition.negate(compressor)),\n            right: self.consequent\n        });\n    }\n    if (is_false(self.alternative)) {\n        // c ? x : false ---> !!c && x\n        return make_node(AST_Binary, self, {\n            operator: \"&&\",\n            left: booleanize(self.condition),\n            right: self.consequent\n        });\n    }\n\n    return self;\n\n    function booleanize(node) {\n        if (node.is_boolean()) return node;\n        // !!expression\n        return make_node(AST_UnaryPrefix, node, {\n            operator: \"!\",\n            expression: node.negate(compressor)\n        });\n    }\n\n    // AST_True or !0\n    function is_true(node) {\n        return node instanceof AST_True\n            || in_bool\n                && node instanceof AST_Constant\n                && node.getValue()\n            || (node instanceof AST_UnaryPrefix\n                && node.operator == \"!\"\n                && node.expression instanceof AST_Constant\n                && !node.expression.getValue());\n    }\n    // AST_False or !1\n    function is_false(node) {\n        return node instanceof AST_False\n            || in_bool\n                && node instanceof AST_Constant\n                && !node.getValue()\n            || (node instanceof AST_UnaryPrefix\n                && node.operator == \"!\"\n                && node.expression instanceof AST_Constant\n                && node.expression.getValue());\n    }\n\n    function single_arg_diff() {\n        var a = consequent.args;\n        var b = alternative.args;\n        for (var i = 0, len = a.length; i < len; i++) {\n            if (a[i] instanceof AST_Expansion) return;\n            if (!a[i].equivalent_to(b[i])) {\n                if (b[i] instanceof AST_Expansion) return;\n                for (var j = i + 1; j < len; j++) {\n                    if (a[j] instanceof AST_Expansion) return;\n                    if (!a[j].equivalent_to(b[j])) return;\n                }\n                return i;\n            }\n        }\n    }\n});\n\ndef_optimize(AST_Boolean, function(self, compressor) {\n    if (compressor.in_boolean_context()) return make_node(AST_Number, self, {\n        value: +self.value\n    });\n    var p = compressor.parent();\n    if (compressor.option(\"booleans_as_integers\")) {\n        if (p instanceof AST_Binary && (p.operator == \"===\" || p.operator == \"!==\")) {\n            p.operator = p.operator.replace(/=$/, \"\");\n        }\n        return make_node(AST_Number, self, {\n            value: +self.value\n        });\n    }\n    if (compressor.option(\"booleans\")) {\n        if (p instanceof AST_Binary && (p.operator == \"==\"\n                                        || p.operator == \"!=\")) {\n            return make_node(AST_Number, self, {\n                value: +self.value\n            });\n        }\n        return make_node(AST_UnaryPrefix, self, {\n            operator: \"!\",\n            expression: make_node(AST_Number, self, {\n                value: 1 - self.value\n            })\n        });\n    }\n    return self;\n});\n\nfunction safe_to_flatten(value, compressor) {\n    if (value instanceof AST_SymbolRef) {\n        value = value.fixed_value();\n    }\n    if (!value) return false;\n    if (!(value instanceof AST_Lambda || value instanceof AST_Class)) return true;\n    if (!(value instanceof AST_Lambda && value.contains_this())) return true;\n    return compressor.parent() instanceof AST_New;\n}\n\nAST_PropAccess.DEFMETHOD(\"flatten_object\", function(key, compressor) {\n    if (!compressor.option(\"properties\")) return;\n    if (key === \"__proto__\") return;\n    if (this instanceof AST_DotHash) return;\n\n    var arrows = compressor.option(\"unsafe_arrows\") && compressor.option(\"ecma\") >= 2015;\n    var expr = this.expression;\n    if (expr instanceof AST_Object) {\n        var props = expr.properties;\n\n        for (var i = props.length; --i >= 0;) {\n            var prop = props[i];\n\n            if (\"\" + (prop instanceof AST_ConciseMethod ? prop.key.name : prop.key) == key) {\n                const all_props_flattenable = props.every((p) =>\n                    (p instanceof AST_ObjectKeyVal\n                        || arrows && p instanceof AST_ConciseMethod && !p.value.is_generator\n                    )\n                    && !p.computed_key()\n                );\n\n                if (!all_props_flattenable) return;\n                if (!safe_to_flatten(prop.value, compressor)) return;\n\n                return make_node(AST_Sub, this, {\n                    expression: make_node(AST_Array, expr, {\n                        elements: props.map(function(prop) {\n                            var v = prop.value;\n                            if (v instanceof AST_Accessor) {\n                                v = make_node(AST_Function, v, v);\n                            }\n\n                            var k = prop.key;\n                            if (k instanceof AST_Node && !(k instanceof AST_SymbolMethod)) {\n                                return make_sequence(prop, [ k, v ]);\n                            }\n\n                            return v;\n                        })\n                    }),\n                    property: make_node(AST_Number, this, {\n                        value: i\n                    })\n                });\n            }\n        }\n    }\n});\n\ndef_optimize(AST_Sub, function(self, compressor) {\n    var expr = self.expression;\n    var prop = self.property;\n    if (compressor.option(\"properties\")) {\n        var key = prop.evaluate(compressor);\n        if (key !== prop) {\n            if (typeof key == \"string\") {\n                if (key == \"undefined\") {\n                    key = undefined;\n                } else {\n                    var value = parseFloat(key);\n                    if (value.toString() == key) {\n                        key = value;\n                    }\n                }\n            }\n            prop = self.property = best_of_expression(\n                prop,\n                make_node_from_constant(key, prop).transform(compressor)\n            );\n            var property = \"\" + key;\n            if (is_basic_identifier_string(property)\n                && property.length <= prop.size() + 1) {\n                return make_node(AST_Dot, self, {\n                    expression: expr,\n                    optional: self.optional,\n                    property: property,\n                    quote: prop.quote,\n                }).optimize(compressor);\n            }\n        }\n    }\n    var fn;\n    OPT_ARGUMENTS: if (compressor.option(\"arguments\")\n        && expr instanceof AST_SymbolRef\n        && expr.name == \"arguments\"\n        && expr.definition().orig.length == 1\n        && (fn = expr.scope) instanceof AST_Lambda\n        && fn.uses_arguments\n        && !(fn instanceof AST_Arrow)\n        && prop instanceof AST_Number) {\n        var index = prop.getValue();\n        var params = new Set();\n        var argnames = fn.argnames;\n        for (var n = 0; n < argnames.length; n++) {\n            if (!(argnames[n] instanceof AST_SymbolFunarg)) {\n                break OPT_ARGUMENTS; // destructuring parameter - bail\n            }\n            var param = argnames[n].name;\n            if (params.has(param)) {\n                break OPT_ARGUMENTS; // duplicate parameter - bail\n            }\n            params.add(param);\n        }\n        var argname = fn.argnames[index];\n        if (argname && compressor.has_directive(\"use strict\")) {\n            var def = argname.definition();\n            if (!compressor.option(\"reduce_vars\") || def.assignments || def.orig.length > 1) {\n                argname = null;\n            }\n        } else if (!argname && !compressor.option(\"keep_fargs\") && index < fn.argnames.length + 5) {\n            while (index >= fn.argnames.length) {\n                argname = fn.create_symbol(AST_SymbolFunarg, {\n                    source: fn,\n                    scope: fn,\n                    tentative_name: \"argument_\" + fn.argnames.length,\n                });\n                fn.argnames.push(argname);\n            }\n        }\n        if (argname) {\n            var sym = make_node(AST_SymbolRef, self, argname);\n            sym.reference({});\n            clear_flag(argname, UNUSED);\n            return sym;\n        }\n    }\n    if (compressor.is_lhs()) return self;\n    if (key !== prop) {\n        var sub = self.flatten_object(property, compressor);\n        if (sub) {\n            expr = self.expression = sub.expression;\n            prop = self.property = sub.property;\n        }\n    }\n    if (compressor.option(\"properties\") && compressor.option(\"side_effects\")\n        && prop instanceof AST_Number && expr instanceof AST_Array) {\n        var index = prop.getValue();\n        var elements = expr.elements;\n        var retValue = elements[index];\n        FLATTEN: if (safe_to_flatten(retValue, compressor)) {\n            var flatten = true;\n            var values = [];\n            for (var i = elements.length; --i > index;) {\n                var value = elements[i].drop_side_effect_free(compressor);\n                if (value) {\n                    values.unshift(value);\n                    if (flatten && value.has_side_effects(compressor)) flatten = false;\n                }\n            }\n            if (retValue instanceof AST_Expansion) break FLATTEN;\n            retValue = retValue instanceof AST_Hole ? make_node(AST_Undefined, retValue) : retValue;\n            if (!flatten) values.unshift(retValue);\n            while (--i >= 0) {\n                var value = elements[i];\n                if (value instanceof AST_Expansion) break FLATTEN;\n                value = value.drop_side_effect_free(compressor);\n                if (value) values.unshift(value);\n                else index--;\n            }\n            if (flatten) {\n                values.push(retValue);\n                return make_sequence(self, values).optimize(compressor);\n            } else return make_node(AST_Sub, self, {\n                expression: make_node(AST_Array, expr, {\n                    elements: values\n                }),\n                property: make_node(AST_Number, prop, {\n                    value: index\n                })\n            });\n        }\n    }\n    var ev = self.evaluate(compressor);\n    if (ev !== self) {\n        ev = make_node_from_constant(ev, self).optimize(compressor);\n        return best_of(compressor, ev, self);\n    }\n    return self;\n});\n\ndef_optimize(AST_Chain, function (self, compressor) {\n    if (is_nullish(self.expression, compressor)) {\n        let parent = compressor.parent();\n        // It's valid to delete a nullish optional chain, but if we optimized\n        // this to `delete undefined` then it would appear to be a syntax error\n        // when we try to optimize the delete. Thankfully, `delete 0` is fine.\n        if (parent instanceof AST_UnaryPrefix && parent.operator === \"delete\") {\n            return make_node_from_constant(0, self);\n        }\n        return make_node(AST_Undefined, self);\n    }\n    if (\n        self.expression instanceof AST_PropAccess\n        || self.expression instanceof AST_Call\n    ) {\n        return self;\n    } else {\n        // Keep the AST valid, in case the child swapped itself\n        return self.expression;\n    }\n});\n\ndef_optimize(AST_Dot, function(self, compressor) {\n    const parent = compressor.parent();\n    if (compressor.is_lhs()) return self;\n    if (compressor.option(\"unsafe_proto\")\n        && self.expression instanceof AST_Dot\n        && self.expression.property == \"prototype\") {\n        var exp = self.expression.expression;\n        if (is_undeclared_ref(exp)) switch (exp.name) {\n          case \"Array\":\n            self.expression = make_node(AST_Array, self.expression, {\n                elements: []\n            });\n            break;\n          case \"Function\":\n            self.expression = make_empty_function(self.expression);\n            break;\n          case \"Number\":\n            self.expression = make_node(AST_Number, self.expression, {\n                value: 0\n            });\n            break;\n          case \"Object\":\n            self.expression = make_node(AST_Object, self.expression, {\n                properties: []\n            });\n            break;\n          case \"RegExp\":\n            self.expression = make_node(AST_RegExp, self.expression, {\n                value: { source: \"t\", flags: \"\" }\n            });\n            break;\n          case \"String\":\n            self.expression = make_node(AST_String, self.expression, {\n                value: \"\"\n            });\n            break;\n        }\n    }\n    if (!(parent instanceof AST_Call) || !has_annotation(parent, _NOINLINE)) {\n        const sub = self.flatten_object(self.property, compressor);\n        if (sub) return sub.optimize(compressor);\n    }\n\n    if (self.expression instanceof AST_PropAccess\n        && parent instanceof AST_PropAccess) {\n        return self;\n    }\n\n    let ev = self.evaluate(compressor);\n    if (ev !== self) {\n        ev = make_node_from_constant(ev, self).optimize(compressor);\n        return best_of(compressor, ev, self);\n    }\n    return self;\n});\n\nfunction literals_in_boolean_context(self, compressor) {\n    if (compressor.in_boolean_context()) {\n        return best_of(compressor, self, make_sequence(self, [\n            self,\n            make_node(AST_True, self)\n        ]).optimize(compressor));\n    }\n    return self;\n}\n\nfunction inline_array_like_spread(elements) {\n    for (var i = 0; i < elements.length; i++) {\n        var el = elements[i];\n        if (el instanceof AST_Expansion) {\n            var expr = el.expression;\n            if (\n                expr instanceof AST_Array\n                && !expr.elements.some(elm => elm instanceof AST_Hole)\n            ) {\n                elements.splice(i, 1, ...expr.elements);\n                // Step back one, as the element at i is now new.\n                i--;\n            }\n            // In array-like spread, spreading a non-iterable value is TypeError.\n            // We therefore cant optimize anything else, unlike with object spread.\n        }\n    }\n}\n\ndef_optimize(AST_Array, function(self, compressor) {\n    var optimized = literals_in_boolean_context(self, compressor);\n    if (optimized !== self) {\n        return optimized;\n    }\n    inline_array_like_spread(self.elements);\n    return self;\n});\n\nfunction inline_object_prop_spread(props) {\n    for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if (prop instanceof AST_Expansion) {\n            const expr = prop.expression;\n            if (\n                expr instanceof AST_Object\n                && expr.properties.every(prop => prop instanceof AST_ObjectKeyVal)\n            ) {\n                props.splice(i, 1, ...expr.properties);\n                // Step back one, as the property at i is now new.\n                i--;\n            } else if ((\n                    // `expr.is_constant()` returns `false` for `AST_RegExp`, so need both.\n                    expr instanceof AST_Constant\n                    || expr.is_constant()\n                ) && !(expr instanceof AST_String)) {\n                // Unlike array-like spread, in object spread, spreading a\n                // non-iterable value silently does nothing; it is thus safe\n                // to remove. AST_String is the only iterable constant.\n                props.splice(i, 1);\n                i--;\n            }\n        }\n    }\n}\n\ndef_optimize(AST_Object, function(self, compressor) {\n    var optimized = literals_in_boolean_context(self, compressor);\n    if (optimized !== self) {\n        return optimized;\n    }\n    inline_object_prop_spread(self.properties);\n    return self;\n});\n\ndef_optimize(AST_RegExp, literals_in_boolean_context);\n\ndef_optimize(AST_Return, function(self, compressor) {\n    if (self.value && is_undefined(self.value, compressor)) {\n        self.value = null;\n    }\n    return self;\n});\n\ndef_optimize(AST_Arrow, opt_AST_Lambda);\n\ndef_optimize(AST_Function, function(self, compressor) {\n    self = opt_AST_Lambda(self, compressor);\n    if (compressor.option(\"unsafe_arrows\")\n        && compressor.option(\"ecma\") >= 2015\n        && !self.name\n        && !self.is_generator\n        && !self.uses_arguments\n        && !self.pinned()) {\n        const uses_this = walk(self, node => {\n            if (node instanceof AST_This) return walk_abort;\n        });\n        if (!uses_this) return make_node(AST_Arrow, self, self).optimize(compressor);\n    }\n    return self;\n});\n\ndef_optimize(AST_Class, function(self) {\n    for (let i = 0; i < self.properties.length; i++) {\n        const prop = self.properties[i];\n        if (prop instanceof AST_ClassStaticBlock && prop.body.length == 0) {\n            self.properties.splice(i, 1);\n            i--;\n        }\n    }\n\n    return self;\n});\n\ndef_optimize(AST_ClassStaticBlock, function(self, compressor) {\n    tighten_body(self.body, compressor);\n    return self;\n});\n\ndef_optimize(AST_Yield, function(self, compressor) {\n    if (self.expression && !self.is_star && is_undefined(self.expression, compressor)) {\n        self.expression = null;\n    }\n    return self;\n});\n\ndef_optimize(AST_TemplateString, function(self, compressor) {\n    if (\n        !compressor.option(\"evaluate\")\n        || compressor.parent() instanceof AST_PrefixedTemplateString\n    ) {\n        return self;\n    }\n\n    var segments = [];\n    for (var i = 0; i < self.segments.length; i++) {\n        var segment = self.segments[i];\n        if (segment instanceof AST_Node) {\n            var result = segment.evaluate(compressor);\n            // Evaluate to constant value\n            // Constant value shorter than ${segment}\n            if (result !== segment && (result + \"\").length <= segment.size() + \"${}\".length) {\n                // There should always be a previous and next segment if segment is a node\n                segments[segments.length - 1].value = segments[segments.length - 1].value + result + self.segments[++i].value;\n                continue;\n            }\n            // `before ${`innerBefore ${any} innerAfter`} after` => `before innerBefore ${any} innerAfter after`\n            // TODO:\n            // `before ${'test' + foo} after` => `before innerBefore ${any} innerAfter after`\n            // `before ${foo + 'test} after` => `before innerBefore ${any} innerAfter after`\n            if (segment instanceof AST_TemplateString) {\n                var inners = segment.segments;\n                segments[segments.length - 1].value += inners[0].value;\n                for (var j = 1; j < inners.length; j++) {\n                    segment = inners[j];\n                    segments.push(segment);\n                }\n                continue;\n            }\n        }\n        segments.push(segment);\n    }\n    self.segments = segments;\n\n    // `foo` => \"foo\"\n    if (segments.length == 1) {\n        return make_node(AST_String, self, segments[0]);\n    }\n\n    if (\n        segments.length === 3\n        && segments[1] instanceof AST_Node\n        && (\n            segments[1].is_string(compressor)\n            || segments[1].is_number_or_bigint(compressor)\n            || is_nullish(segments[1], compressor)\n            || compressor.option(\"unsafe\")\n        )\n    ) {\n        // `foo${bar}` => \"foo\" + bar\n        if (segments[2].value === \"\") {\n            return make_node(AST_Binary, self, {\n                operator: \"+\",\n                left: make_node(AST_String, self, {\n                    value: segments[0].value,\n                }),\n                right: segments[1],\n            });\n        }\n        // `${bar}baz` => bar + \"baz\"\n        if (segments[0].value === \"\") {\n            return make_node(AST_Binary, self, {\n                operator: \"+\",\n                left: segments[1],\n                right: make_node(AST_String, self, {\n                    value: segments[2].value,\n                }),\n            });\n        }\n    }\n    return self;\n});\n\ndef_optimize(AST_PrefixedTemplateString, function(self) {\n    return self;\n});\n\n// [\"p\"]:1 ---> p:1\n// [42]:1 ---> 42:1\nfunction lift_key(self, compressor) {\n    if (!compressor.option(\"computed_props\")) return self;\n    // save a comparison in the typical case\n    if (!(self.key instanceof AST_Constant)) return self;\n    // allow certain acceptable props as not all AST_Constants are true constants\n    if (self.key instanceof AST_String || self.key instanceof AST_Number) {\n        const key = self.key.value.toString();\n\n        if (key === \"__proto__\") return self;\n        if (key == \"constructor\"\n            && compressor.parent() instanceof AST_Class) return self;\n        if (self instanceof AST_ObjectKeyVal) {\n            self.quote = self.key.quote;\n            self.key = key;\n        } else if (self instanceof AST_ClassProperty) {\n            self.quote = self.key.quote;\n            self.key = make_node(AST_SymbolClassProperty, self.key, {\n                name: key,\n            });\n        } else {\n            self.quote = self.key.quote;\n            self.key = make_node(AST_SymbolMethod, self.key, {\n                name: key,\n            });\n        }\n    }\n    return self;\n}\n\ndef_optimize(AST_ObjectProperty, lift_key);\n\ndef_optimize(AST_ConciseMethod, function(self, compressor) {\n    lift_key(self, compressor);\n    // p(){return x;} ---> p:()=>x\n    if (compressor.option(\"arrows\")\n        && compressor.parent() instanceof AST_Object\n        && !self.value.is_generator\n        && !self.value.uses_arguments\n        && !self.value.pinned()\n        && self.value.body.length == 1\n        && self.value.body[0] instanceof AST_Return\n        && self.value.body[0].value\n        && !self.value.contains_this()) {\n        var arrow = make_node(AST_Arrow, self.value, self.value);\n        arrow.async = self.value.async;\n        arrow.is_generator = self.value.is_generator;\n        return make_node(AST_ObjectKeyVal, self, {\n            key: self.key instanceof AST_SymbolMethod ? self.key.name : self.key,\n            value: arrow,\n            quote: self.quote,\n        });\n    }\n    return self;\n});\n\ndef_optimize(AST_ObjectKeyVal, function(self, compressor) {\n    lift_key(self, compressor);\n    // p:function(){} ---> p(){}\n    // p:function*(){} ---> *p(){}\n    // p:async function(){} ---> async p(){}\n    // p:()=>{} ---> p(){}\n    // p:async()=>{} ---> async p(){}\n    var unsafe_methods = compressor.option(\"unsafe_methods\");\n    if (unsafe_methods\n        && compressor.option(\"ecma\") >= 2015\n        && (!(unsafe_methods instanceof RegExp) || unsafe_methods.test(self.key + \"\"))) {\n        var key = self.key;\n        var value = self.value;\n        var is_arrow_with_block = value instanceof AST_Arrow\n            && Array.isArray(value.body)\n            && !value.contains_this();\n        if ((is_arrow_with_block || value instanceof AST_Function) && !value.name) {\n            return make_node(AST_ConciseMethod, self, {\n                key: key instanceof AST_Node ? key : make_node(AST_SymbolMethod, self, {\n                    name: key,\n                }),\n                value: make_node(AST_Accessor, value, value),\n                quote: self.quote,\n            });\n        }\n    }\n    return self;\n});\n\ndef_optimize(AST_Destructuring, function(self, compressor) {\n    if (compressor.option(\"pure_getters\") == true\n        && compressor.option(\"unused\")\n        && !self.is_array\n        && Array.isArray(self.names)\n        && !is_destructuring_export_decl(compressor)\n        && !(self.names[self.names.length - 1] instanceof AST_Expansion)) {\n        var keep = [];\n        for (var i = 0; i < self.names.length; i++) {\n            var elem = self.names[i];\n            if (!(elem instanceof AST_ObjectKeyVal\n                && typeof elem.key == \"string\"\n                && elem.value instanceof AST_SymbolDeclaration\n                && !should_retain(compressor, elem.value.definition()))) {\n                keep.push(elem);\n            }\n        }\n        if (keep.length != self.names.length) {\n            self.names = keep;\n        }\n    }\n    return self;\n\n    function is_destructuring_export_decl(compressor) {\n        var ancestors = [/^VarDef$/, /^(Const|Let|Var)$/, /^Export$/];\n        for (var a = 0, p = 0, len = ancestors.length; a < len; p++) {\n            var parent = compressor.parent(p);\n            if (!parent) return false;\n            if (a === 0 && parent.TYPE == \"Destructuring\") continue;\n            if (!ancestors[a].test(parent.TYPE)) {\n                return false;\n            }\n            a++;\n        }\n        return true;\n    }\n\n    function should_retain(compressor, def) {\n        if (def.references.length) return true;\n        if (!def.global) return false;\n        if (compressor.toplevel.vars) {\n            if (compressor.top_retain) {\n                return compressor.top_retain(def);\n            }\n            return false;\n        }\n        return true;\n    }\n});\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n// a small wrapper around source-map and @jridgewell/source-map\nfunction* SourceMap(options) {\n    options = defaults(options, {\n        file : null,\n        root : null,\n        orig : null,\n        files: {},\n    });\n\n    var orig_map;\n    var generator = new sourceMap.SourceMapGenerator({\n        file       : options.file,\n        sourceRoot : options.root\n    });\n\n    let sourcesContent = {__proto__: null};\n    let files = options.files;\n    for (var name in files) if (HOP(files, name)) {\n        sourcesContent[name] = files[name];\n    }\n    if (options.orig) {\n        // We support both @jridgewell/source-map (which has a sync\n        // SourceMapConsumer) and source-map (which has an async\n        // SourceMapConsumer).\n        orig_map = yield new sourceMap.SourceMapConsumer(options.orig);\n        if (orig_map.sourcesContent) {\n            orig_map.sources.forEach(function(source, i) {\n                var content = orig_map.sourcesContent[i];\n                if (content) {\n                    sourcesContent[source] = content;\n                }\n            });\n        }\n    }\n\n    function add(source, gen_line, gen_col, orig_line, orig_col, name) {\n        let generatedPos = { line: gen_line, column: gen_col };\n\n        if (orig_map) {\n            var info = orig_map.originalPositionFor({\n                line: orig_line,\n                column: orig_col\n            });\n            if (info.source === null) {\n                generator.addMapping({\n                    generated: generatedPos,\n                    original: null,\n                    source: null,\n                    name: null\n                });\n                return;\n            }\n            source = info.source;\n            orig_line = info.line;\n            orig_col = info.column;\n            name = info.name || name;\n        }\n        generator.addMapping({\n            generated : generatedPos,\n            original  : { line: orig_line, column: orig_col },\n            source    : source,\n            name      : name\n        });\n        generator.setSourceContent(source, sourcesContent[source]);\n    }\n\n    function clean(map) {\n        const allNull = map.sourcesContent && map.sourcesContent.every(c => c == null);\n        if (allNull) delete map.sourcesContent;\n        if (map.file === undefined) delete map.file;\n        if (map.sourceRoot === undefined) delete map.sourceRoot;\n        return map;\n    }\n\n    function getDecoded() {\n        if (!generator.toDecodedMap) return null;\n        return clean(generator.toDecodedMap());\n    }\n\n    function getEncoded() {\n        return clean(generator.toJSON());\n    }\n\n    function destroy() {\n        // @jridgewell/source-map's SourceMapConsumer does not need to be\n        // manually freed.\n        if (orig_map && orig_map.destroy) orig_map.destroy();\n    }\n\n    return {\n        add,\n        getDecoded,\n        getEncoded,\n        destroy,\n    };\n}\n\nvar domprops = [\n    \"$&\",\n    \"$'\",\n    \"$*\",\n    \"$+\",\n    \"$1\",\n    \"$2\",\n    \"$3\",\n    \"$4\",\n    \"$5\",\n    \"$6\",\n    \"$7\",\n    \"$8\",\n    \"$9\",\n    \"$_\",\n    \"$`\",\n    \"$input\",\n    \"-moz-animation\",\n    \"-moz-animation-delay\",\n    \"-moz-animation-direction\",\n    \"-moz-animation-duration\",\n    \"-moz-animation-fill-mode\",\n    \"-moz-animation-iteration-count\",\n    \"-moz-animation-name\",\n    \"-moz-animation-play-state\",\n    \"-moz-animation-timing-function\",\n    \"-moz-appearance\",\n    \"-moz-backface-visibility\",\n    \"-moz-border-end\",\n    \"-moz-border-end-color\",\n    \"-moz-border-end-style\",\n    \"-moz-border-end-width\",\n    \"-moz-border-image\",\n    \"-moz-border-start\",\n    \"-moz-border-start-color\",\n    \"-moz-border-start-style\",\n    \"-moz-border-start-width\",\n    \"-moz-box-align\",\n    \"-moz-box-direction\",\n    \"-moz-box-flex\",\n    \"-moz-box-ordinal-group\",\n    \"-moz-box-orient\",\n    \"-moz-box-pack\",\n    \"-moz-box-sizing\",\n    \"-moz-float-edge\",\n    \"-moz-font-feature-settings\",\n    \"-moz-font-language-override\",\n    \"-moz-force-broken-image-icon\",\n    \"-moz-hyphens\",\n    \"-moz-image-region\",\n    \"-moz-margin-end\",\n    \"-moz-margin-start\",\n    \"-moz-orient\",\n    \"-moz-osx-font-smoothing\",\n    \"-moz-outline-radius\",\n    \"-moz-outline-radius-bottomleft\",\n    \"-moz-outline-radius-bottomright\",\n    \"-moz-outline-radius-topleft\",\n    \"-moz-outline-radius-topright\",\n    \"-moz-padding-end\",\n    \"-moz-padding-start\",\n    \"-moz-perspective\",\n    \"-moz-perspective-origin\",\n    \"-moz-tab-size\",\n    \"-moz-text-size-adjust\",\n    \"-moz-transform\",\n    \"-moz-transform-origin\",\n    \"-moz-transform-style\",\n    \"-moz-transition\",\n    \"-moz-transition-delay\",\n    \"-moz-transition-duration\",\n    \"-moz-transition-property\",\n    \"-moz-transition-timing-function\",\n    \"-moz-user-focus\",\n    \"-moz-user-input\",\n    \"-moz-user-modify\",\n    \"-moz-user-select\",\n    \"-moz-window-dragging\",\n    \"-webkit-align-content\",\n    \"-webkit-align-items\",\n    \"-webkit-align-self\",\n    \"-webkit-animation\",\n    \"-webkit-animation-delay\",\n    \"-webkit-animation-direction\",\n    \"-webkit-animation-duration\",\n    \"-webkit-animation-fill-mode\",\n    \"-webkit-animation-iteration-count\",\n    \"-webkit-animation-name\",\n    \"-webkit-animation-play-state\",\n    \"-webkit-animation-timing-function\",\n    \"-webkit-appearance\",\n    \"-webkit-backface-visibility\",\n    \"-webkit-background-clip\",\n    \"-webkit-background-origin\",\n    \"-webkit-background-size\",\n    \"-webkit-border-bottom-left-radius\",\n    \"-webkit-border-bottom-right-radius\",\n    \"-webkit-border-image\",\n    \"-webkit-border-radius\",\n    \"-webkit-border-top-left-radius\",\n    \"-webkit-border-top-right-radius\",\n    \"-webkit-box-align\",\n    \"-webkit-box-direction\",\n    \"-webkit-box-flex\",\n    \"-webkit-box-ordinal-group\",\n    \"-webkit-box-orient\",\n    \"-webkit-box-pack\",\n    \"-webkit-box-shadow\",\n    \"-webkit-box-sizing\",\n    \"-webkit-clip-path\",\n    \"-webkit-filter\",\n    \"-webkit-flex\",\n    \"-webkit-flex-basis\",\n    \"-webkit-flex-direction\",\n    \"-webkit-flex-flow\",\n    \"-webkit-flex-grow\",\n    \"-webkit-flex-shrink\",\n    \"-webkit-flex-wrap\",\n    \"-webkit-font-feature-settings\",\n    \"-webkit-justify-content\",\n    \"-webkit-line-clamp\",\n    \"-webkit-mask\",\n    \"-webkit-mask-clip\",\n    \"-webkit-mask-composite\",\n    \"-webkit-mask-image\",\n    \"-webkit-mask-origin\",\n    \"-webkit-mask-position\",\n    \"-webkit-mask-position-x\",\n    \"-webkit-mask-position-y\",\n    \"-webkit-mask-repeat\",\n    \"-webkit-mask-size\",\n    \"-webkit-order\",\n    \"-webkit-perspective\",\n    \"-webkit-perspective-origin\",\n    \"-webkit-text-fill-color\",\n    \"-webkit-text-security\",\n    \"-webkit-text-size-adjust\",\n    \"-webkit-text-stroke\",\n    \"-webkit-text-stroke-color\",\n    \"-webkit-text-stroke-width\",\n    \"-webkit-transform\",\n    \"-webkit-transform-origin\",\n    \"-webkit-transform-style\",\n    \"-webkit-transition\",\n    \"-webkit-transition-delay\",\n    \"-webkit-transition-duration\",\n    \"-webkit-transition-property\",\n    \"-webkit-transition-timing-function\",\n    \"-webkit-user-select\",\n    \"@@iterator\",\n    \"ABORT_ERR\",\n    \"ACTIVE\",\n    \"ACTIVE_ATTRIBUTES\",\n    \"ACTIVE_TEXTURE\",\n    \"ACTIVE_UNIFORMS\",\n    \"ACTIVE_UNIFORM_BLOCKS\",\n    \"ADDITION\",\n    \"ALIASED_LINE_WIDTH_RANGE\",\n    \"ALIASED_POINT_SIZE_RANGE\",\n    \"ALL\",\n    \"ALLOW_KEYBOARD_INPUT\",\n    \"ALLPASS\",\n    \"ALPHA\",\n    \"ALPHA_BITS\",\n    \"ALREADY_SIGNALED\",\n    \"ALT_MASK\",\n    \"ALWAYS\",\n    \"ANY_SAMPLES_PASSED\",\n    \"ANY_SAMPLES_PASSED_CONSERVATIVE\",\n    \"ANY_TYPE\",\n    \"ANY_UNORDERED_NODE_TYPE\",\n    \"ARRAY_BUFFER\",\n    \"ARRAY_BUFFER_BINDING\",\n    \"ATTACHED_SHADERS\",\n    \"ATTRIBUTE_NODE\",\n    \"AT_TARGET\",\n    \"AbortController\",\n    \"AbortSignal\",\n    \"AbsoluteOrientationSensor\",\n    \"AbstractRange\",\n    \"Accelerometer\",\n    \"AddSearchProvider\",\n    \"AggregateError\",\n    \"AnalyserNode\",\n    \"Animation\",\n    \"AnimationEffect\",\n    \"AnimationEvent\",\n    \"AnimationPlaybackEvent\",\n    \"AnimationTimeline\",\n    \"AnonXMLHttpRequest\",\n    \"Any\",\n    \"AnyPermissions\",\n    \"ApplicationCache\",\n    \"ApplicationCacheErrorEvent\",\n    \"Array\",\n    \"ArrayBuffer\",\n    \"ArrayType\",\n    \"Atomics\",\n    \"Attr\",\n    \"Audio\",\n    \"AudioBuffer\",\n    \"AudioBufferSourceNode\",\n    \"AudioContext\",\n    \"AudioData\",\n    \"AudioDecoder\",\n    \"AudioDestinationNode\",\n    \"AudioEncoder\",\n    \"AudioListener\",\n    \"AudioNode\",\n    \"AudioParam\",\n    \"AudioParamMap\",\n    \"AudioProcessingEvent\",\n    \"AudioScheduledSourceNode\",\n    \"AudioSinkInfo\",\n    \"AudioStreamTrack\",\n    \"AudioWorklet\",\n    \"AudioWorkletNode\",\n    \"AuthenticatorAssertionResponse\",\n    \"AuthenticatorAttestationResponse\",\n    \"AuthenticatorResponse\",\n    \"AutocompleteErrorEvent\",\n    \"BACK\",\n    \"BAD_BOUNDARYPOINTS_ERR\",\n    \"BAD_REQUEST\",\n    \"BANDPASS\",\n    \"BLEND\",\n    \"BLEND_COLOR\",\n    \"BLEND_DST_ALPHA\",\n    \"BLEND_DST_RGB\",\n    \"BLEND_EQUATION\",\n    \"BLEND_EQUATION_ALPHA\",\n    \"BLEND_EQUATION_RGB\",\n    \"BLEND_SRC_ALPHA\",\n    \"BLEND_SRC_RGB\",\n    \"BLUE\",\n    \"BLUE_BITS\",\n    \"BLUR\",\n    \"BOOL\",\n    \"BOOLEAN_TYPE\",\n    \"BOOL_VEC2\",\n    \"BOOL_VEC3\",\n    \"BOOL_VEC4\",\n    \"BOTH\",\n    \"BROWSER_DEFAULT_WEBGL\",\n    \"BUBBLING_PHASE\",\n    \"BUFFER_SIZE\",\n    \"BUFFER_USAGE\",\n    \"BYTE\",\n    \"BYTES_PER_ELEMENT\",\n    \"BackgroundFetchManager\",\n    \"BackgroundFetchRecord\",\n    \"BackgroundFetchRegistration\",\n    \"BarProp\",\n    \"BarcodeDetector\",\n    \"BaseAudioContext\",\n    \"BaseHref\",\n    \"BatteryManager\",\n    \"BeforeInstallPromptEvent\",\n    \"BeforeLoadEvent\",\n    \"BeforeUnloadEvent\",\n    \"BigInt\",\n    \"BigInt64Array\",\n    \"BigUint64Array\",\n    \"BiquadFilterNode\",\n    \"Blob\",\n    \"BlobEvent\",\n    \"Bluetooth\",\n    \"BluetoothCharacteristicProperties\",\n    \"BluetoothDevice\",\n    \"BluetoothRemoteGATTCharacteristic\",\n    \"BluetoothRemoteGATTDescriptor\",\n    \"BluetoothRemoteGATTServer\",\n    \"BluetoothRemoteGATTService\",\n    \"BluetoothUUID\",\n    \"Boolean\",\n    \"BroadcastChannel\",\n    \"BrowserCaptureMediaStreamTrack\",\n    \"BrowserInfo\",\n    \"ByteLengthQueuingStrategy\",\n    \"CAPTURING_PHASE\",\n    \"CCW\",\n    \"CDATASection\",\n    \"CDATA_SECTION_NODE\",\n    \"CHANGE\",\n    \"CHARSET_RULE\",\n    \"CHECKING\",\n    \"CLAMP_TO_EDGE\",\n    \"CLICK\",\n    \"CLOSED\",\n    \"CLOSING\",\n    \"COLOR\",\n    \"COLOR_ATTACHMENT0\",\n    \"COLOR_ATTACHMENT1\",\n    \"COLOR_ATTACHMENT10\",\n    \"COLOR_ATTACHMENT11\",\n    \"COLOR_ATTACHMENT12\",\n    \"COLOR_ATTACHMENT13\",\n    \"COLOR_ATTACHMENT14\",\n    \"COLOR_ATTACHMENT15\",\n    \"COLOR_ATTACHMENT2\",\n    \"COLOR_ATTACHMENT3\",\n    \"COLOR_ATTACHMENT4\",\n    \"COLOR_ATTACHMENT5\",\n    \"COLOR_ATTACHMENT6\",\n    \"COLOR_ATTACHMENT7\",\n    \"COLOR_ATTACHMENT8\",\n    \"COLOR_ATTACHMENT9\",\n    \"COLOR_BUFFER_BIT\",\n    \"COLOR_CLEAR_VALUE\",\n    \"COLOR_WRITEMASK\",\n    \"COMMENT_NODE\",\n    \"COMPARE_REF_TO_TEXTURE\",\n    \"COMPILE_STATUS\",\n    \"COMPLETION_STATUS_KHR\",\n    \"COMPRESSED_RGBA_S3TC_DXT1_EXT\",\n    \"COMPRESSED_RGBA_S3TC_DXT3_EXT\",\n    \"COMPRESSED_RGBA_S3TC_DXT5_EXT\",\n    \"COMPRESSED_RGB_S3TC_DXT1_EXT\",\n    \"COMPRESSED_TEXTURE_FORMATS\",\n    \"COMPUTE\",\n    \"CONDITION_SATISFIED\",\n    \"CONFIGURATION_UNSUPPORTED\",\n    \"CONNECTING\",\n    \"CONSTANT_ALPHA\",\n    \"CONSTANT_COLOR\",\n    \"CONSTRAINT_ERR\",\n    \"CONTEXT_LOST_WEBGL\",\n    \"CONTROL_MASK\",\n    \"COPY_DST\",\n    \"COPY_READ_BUFFER\",\n    \"COPY_READ_BUFFER_BINDING\",\n    \"COPY_SRC\",\n    \"COPY_WRITE_BUFFER\",\n    \"COPY_WRITE_BUFFER_BINDING\",\n    \"COUNTER_STYLE_RULE\",\n    \"CSS\",\n    \"CSS2Properties\",\n    \"CSSAnimation\",\n    \"CSSCharsetRule\",\n    \"CSSConditionRule\",\n    \"CSSContainerRule\",\n    \"CSSCounterStyleRule\",\n    \"CSSFontFaceRule\",\n    \"CSSFontFeatureValuesRule\",\n    \"CSSFontPaletteValuesRule\",\n    \"CSSGroupingRule\",\n    \"CSSImageValue\",\n    \"CSSImportRule\",\n    \"CSSKeyframeRule\",\n    \"CSSKeyframesRule\",\n    \"CSSKeywordValue\",\n    \"CSSLayerBlockRule\",\n    \"CSSLayerStatementRule\",\n    \"CSSMarginRule\",\n    \"CSSMathClamp\",\n    \"CSSMathInvert\",\n    \"CSSMathMax\",\n    \"CSSMathMin\",\n    \"CSSMathNegate\",\n    \"CSSMathProduct\",\n    \"CSSMathSum\",\n    \"CSSMathValue\",\n    \"CSSMatrixComponent\",\n    \"CSSMediaRule\",\n    \"CSSMozDocumentRule\",\n    \"CSSNameSpaceRule\",\n    \"CSSNamespaceRule\",\n    \"CSSNestedDeclarations\",\n    \"CSSNumericArray\",\n    \"CSSNumericValue\",\n    \"CSSPageDescriptors\",\n    \"CSSPageRule\",\n    \"CSSPerspective\",\n    \"CSSPositionTryDescriptors\",\n    \"CSSPositionTryRule\",\n    \"CSSPositionValue\",\n    \"CSSPrimitiveValue\",\n    \"CSSPropertyRule\",\n    \"CSSRotate\",\n    \"CSSRule\",\n    \"CSSRuleList\",\n    \"CSSScale\",\n    \"CSSScopeRule\",\n    \"CSSSkew\",\n    \"CSSSkewX\",\n    \"CSSSkewY\",\n    \"CSSStartingStyleRule\",\n    \"CSSStyleDeclaration\",\n    \"CSSStyleRule\",\n    \"CSSStyleSheet\",\n    \"CSSStyleValue\",\n    \"CSSSupportsRule\",\n    \"CSSTransformComponent\",\n    \"CSSTransformValue\",\n    \"CSSTransition\",\n    \"CSSTranslate\",\n    \"CSSUnitValue\",\n    \"CSSUnknownRule\",\n    \"CSSUnparsedValue\",\n    \"CSSValue\",\n    \"CSSValueList\",\n    \"CSSVariableReferenceValue\",\n    \"CSSVariablesDeclaration\",\n    \"CSSVariablesRule\",\n    \"CSSViewTransitionRule\",\n    \"CSSViewportRule\",\n    \"CSS_ATTR\",\n    \"CSS_CM\",\n    \"CSS_COUNTER\",\n    \"CSS_CUSTOM\",\n    \"CSS_DEG\",\n    \"CSS_DIMENSION\",\n    \"CSS_EMS\",\n    \"CSS_EXS\",\n    \"CSS_FILTER_BLUR\",\n    \"CSS_FILTER_BRIGHTNESS\",\n    \"CSS_FILTER_CONTRAST\",\n    \"CSS_FILTER_CUSTOM\",\n    \"CSS_FILTER_DROP_SHADOW\",\n    \"CSS_FILTER_GRAYSCALE\",\n    \"CSS_FILTER_HUE_ROTATE\",\n    \"CSS_FILTER_INVERT\",\n    \"CSS_FILTER_OPACITY\",\n    \"CSS_FILTER_REFERENCE\",\n    \"CSS_FILTER_SATURATE\",\n    \"CSS_FILTER_SEPIA\",\n    \"CSS_GRAD\",\n    \"CSS_HZ\",\n    \"CSS_IDENT\",\n    \"CSS_IN\",\n    \"CSS_INHERIT\",\n    \"CSS_KHZ\",\n    \"CSS_MATRIX\",\n    \"CSS_MATRIX3D\",\n    \"CSS_MM\",\n    \"CSS_MS\",\n    \"CSS_NUMBER\",\n    \"CSS_PC\",\n    \"CSS_PERCENTAGE\",\n    \"CSS_PERSPECTIVE\",\n    \"CSS_PRIMITIVE_VALUE\",\n    \"CSS_PT\",\n    \"CSS_PX\",\n    \"CSS_RAD\",\n    \"CSS_RECT\",\n    \"CSS_RGBCOLOR\",\n    \"CSS_ROTATE\",\n    \"CSS_ROTATE3D\",\n    \"CSS_ROTATEX\",\n    \"CSS_ROTATEY\",\n    \"CSS_ROTATEZ\",\n    \"CSS_S\",\n    \"CSS_SCALE\",\n    \"CSS_SCALE3D\",\n    \"CSS_SCALEX\",\n    \"CSS_SCALEY\",\n    \"CSS_SCALEZ\",\n    \"CSS_SKEW\",\n    \"CSS_SKEWX\",\n    \"CSS_SKEWY\",\n    \"CSS_STRING\",\n    \"CSS_TRANSLATE\",\n    \"CSS_TRANSLATE3D\",\n    \"CSS_TRANSLATEX\",\n    \"CSS_TRANSLATEY\",\n    \"CSS_TRANSLATEZ\",\n    \"CSS_UNKNOWN\",\n    \"CSS_URI\",\n    \"CSS_VALUE_LIST\",\n    \"CSS_VH\",\n    \"CSS_VMAX\",\n    \"CSS_VMIN\",\n    \"CSS_VW\",\n    \"CULL_FACE\",\n    \"CULL_FACE_MODE\",\n    \"CURRENT_PROGRAM\",\n    \"CURRENT_QUERY\",\n    \"CURRENT_VERTEX_ATTRIB\",\n    \"CUSTOM\",\n    \"CW\",\n    \"Cache\",\n    \"CacheStorage\",\n    \"CanvasCaptureMediaStream\",\n    \"CanvasCaptureMediaStreamTrack\",\n    \"CanvasGradient\",\n    \"CanvasPattern\",\n    \"CanvasRenderingContext2D\",\n    \"CaptureController\",\n    \"CaretPosition\",\n    \"ChannelMergerNode\",\n    \"ChannelSplitterNode\",\n    \"ChapterInformation\",\n    \"CharacterBoundsUpdateEvent\",\n    \"CharacterData\",\n    \"ClientRect\",\n    \"ClientRectList\",\n    \"Clipboard\",\n    \"ClipboardEvent\",\n    \"ClipboardItem\",\n    \"CloseEvent\",\n    \"CloseWatcher\",\n    \"Collator\",\n    \"ColorArray\",\n    \"ColorValue\",\n    \"CommandEvent\",\n    \"Comment\",\n    \"CompileError\",\n    \"CompositionEvent\",\n    \"CompressionStream\",\n    \"Console\",\n    \"ConstantSourceNode\",\n    \"ContentVisibilityAutoStateChangeEvent\",\n    \"ContextFilter\",\n    \"ContextType\",\n    \"Controllers\",\n    \"ConvolverNode\",\n    \"CookieChangeEvent\",\n    \"CookieStore\",\n    \"CookieStoreManager\",\n    \"CountQueuingStrategy\",\n    \"Counter\",\n    \"CreateType\",\n    \"Credential\",\n    \"CredentialsContainer\",\n    \"CropTarget\",\n    \"Crypto\",\n    \"CryptoKey\",\n    \"CustomElementRegistry\",\n    \"CustomEvent\",\n    \"CustomStateSet\",\n    \"DATABASE_ERR\",\n    \"DATA_CLONE_ERR\",\n    \"DATA_ERR\",\n    \"DBLCLICK\",\n    \"DECR\",\n    \"DECR_WRAP\",\n    \"DELETE_STATUS\",\n    \"DEPTH\",\n    \"DEPTH24_STENCIL8\",\n    \"DEPTH32F_STENCIL8\",\n    \"DEPTH_ATTACHMENT\",\n    \"DEPTH_BITS\",\n    \"DEPTH_BUFFER_BIT\",\n    \"DEPTH_CLEAR_VALUE\",\n    \"DEPTH_COMPONENT\",\n    \"DEPTH_COMPONENT16\",\n    \"DEPTH_COMPONENT24\",\n    \"DEPTH_COMPONENT32F\",\n    \"DEPTH_FUNC\",\n    \"DEPTH_RANGE\",\n    \"DEPTH_STENCIL\",\n    \"DEPTH_STENCIL_ATTACHMENT\",\n    \"DEPTH_TEST\",\n    \"DEPTH_WRITEMASK\",\n    \"DEVICE_INELIGIBLE\",\n    \"DIRECTION_DOWN\",\n    \"DIRECTION_LEFT\",\n    \"DIRECTION_RIGHT\",\n    \"DIRECTION_UP\",\n    \"DISABLED\",\n    \"DISPATCH_REQUEST_ERR\",\n    \"DITHER\",\n    \"DOCUMENT_FRAGMENT_NODE\",\n    \"DOCUMENT_NODE\",\n    \"DOCUMENT_POSITION_CONTAINED_BY\",\n    \"DOCUMENT_POSITION_CONTAINS\",\n    \"DOCUMENT_POSITION_DISCONNECTED\",\n    \"DOCUMENT_POSITION_FOLLOWING\",\n    \"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\",\n    \"DOCUMENT_POSITION_PRECEDING\",\n    \"DOCUMENT_TYPE_NODE\",\n    \"DOMCursor\",\n    \"DOMError\",\n    \"DOMException\",\n    \"DOMImplementation\",\n    \"DOMImplementationLS\",\n    \"DOMMatrix\",\n    \"DOMMatrixReadOnly\",\n    \"DOMParser\",\n    \"DOMPoint\",\n    \"DOMPointReadOnly\",\n    \"DOMQuad\",\n    \"DOMRect\",\n    \"DOMRectList\",\n    \"DOMRectReadOnly\",\n    \"DOMRequest\",\n    \"DOMSTRING_SIZE_ERR\",\n    \"DOMSettableTokenList\",\n    \"DOMStringList\",\n    \"DOMStringMap\",\n    \"DOMTokenList\",\n    \"DOMTransactionEvent\",\n    \"DOM_DELTA_LINE\",\n    \"DOM_DELTA_PAGE\",\n    \"DOM_DELTA_PIXEL\",\n    \"DOM_INPUT_METHOD_DROP\",\n    \"DOM_INPUT_METHOD_HANDWRITING\",\n    \"DOM_INPUT_METHOD_IME\",\n    \"DOM_INPUT_METHOD_KEYBOARD\",\n    \"DOM_INPUT_METHOD_MULTIMODAL\",\n    \"DOM_INPUT_METHOD_OPTION\",\n    \"DOM_INPUT_METHOD_PASTE\",\n    \"DOM_INPUT_METHOD_SCRIPT\",\n    \"DOM_INPUT_METHOD_UNKNOWN\",\n    \"DOM_INPUT_METHOD_VOICE\",\n    \"DOM_KEY_LOCATION_JOYSTICK\",\n    \"DOM_KEY_LOCATION_LEFT\",\n    \"DOM_KEY_LOCATION_MOBILE\",\n    \"DOM_KEY_LOCATION_NUMPAD\",\n    \"DOM_KEY_LOCATION_RIGHT\",\n    \"DOM_KEY_LOCATION_STANDARD\",\n    \"DOM_VK_0\",\n    \"DOM_VK_1\",\n    \"DOM_VK_2\",\n    \"DOM_VK_3\",\n    \"DOM_VK_4\",\n    \"DOM_VK_5\",\n    \"DOM_VK_6\",\n    \"DOM_VK_7\",\n    \"DOM_VK_8\",\n    \"DOM_VK_9\",\n    \"DOM_VK_A\",\n    \"DOM_VK_ACCEPT\",\n    \"DOM_VK_ADD\",\n    \"DOM_VK_ALT\",\n    \"DOM_VK_ALTGR\",\n    \"DOM_VK_AMPERSAND\",\n    \"DOM_VK_ASTERISK\",\n    \"DOM_VK_AT\",\n    \"DOM_VK_ATTN\",\n    \"DOM_VK_B\",\n    \"DOM_VK_BACKSPACE\",\n    \"DOM_VK_BACK_QUOTE\",\n    \"DOM_VK_BACK_SLASH\",\n    \"DOM_VK_BACK_SPACE\",\n    \"DOM_VK_C\",\n    \"DOM_VK_CANCEL\",\n    \"DOM_VK_CAPS_LOCK\",\n    \"DOM_VK_CIRCUMFLEX\",\n    \"DOM_VK_CLEAR\",\n    \"DOM_VK_CLOSE_BRACKET\",\n    \"DOM_VK_CLOSE_CURLY_BRACKET\",\n    \"DOM_VK_CLOSE_PAREN\",\n    \"DOM_VK_COLON\",\n    \"DOM_VK_COMMA\",\n    \"DOM_VK_CONTEXT_MENU\",\n    \"DOM_VK_CONTROL\",\n    \"DOM_VK_CONVERT\",\n    \"DOM_VK_CRSEL\",\n    \"DOM_VK_CTRL\",\n    \"DOM_VK_D\",\n    \"DOM_VK_DECIMAL\",\n    \"DOM_VK_DELETE\",\n    \"DOM_VK_DIVIDE\",\n    \"DOM_VK_DOLLAR\",\n    \"DOM_VK_DOUBLE_QUOTE\",\n    \"DOM_VK_DOWN\",\n    \"DOM_VK_E\",\n    \"DOM_VK_EISU\",\n    \"DOM_VK_END\",\n    \"DOM_VK_ENTER\",\n    \"DOM_VK_EQUALS\",\n    \"DOM_VK_EREOF\",\n    \"DOM_VK_ESCAPE\",\n    \"DOM_VK_EXCLAMATION\",\n    \"DOM_VK_EXECUTE\",\n    \"DOM_VK_EXSEL\",\n    \"DOM_VK_F\",\n    \"DOM_VK_F1\",\n    \"DOM_VK_F10\",\n    \"DOM_VK_F11\",\n    \"DOM_VK_F12\",\n    \"DOM_VK_F13\",\n    \"DOM_VK_F14\",\n    \"DOM_VK_F15\",\n    \"DOM_VK_F16\",\n    \"DOM_VK_F17\",\n    \"DOM_VK_F18\",\n    \"DOM_VK_F19\",\n    \"DOM_VK_F2\",\n    \"DOM_VK_F20\",\n    \"DOM_VK_F21\",\n    \"DOM_VK_F22\",\n    \"DOM_VK_F23\",\n    \"DOM_VK_F24\",\n    \"DOM_VK_F25\",\n    \"DOM_VK_F26\",\n    \"DOM_VK_F27\",\n    \"DOM_VK_F28\",\n    \"DOM_VK_F29\",\n    \"DOM_VK_F3\",\n    \"DOM_VK_F30\",\n    \"DOM_VK_F31\",\n    \"DOM_VK_F32\",\n    \"DOM_VK_F33\",\n    \"DOM_VK_F34\",\n    \"DOM_VK_F35\",\n    \"DOM_VK_F36\",\n    \"DOM_VK_F4\",\n    \"DOM_VK_F5\",\n    \"DOM_VK_F6\",\n    \"DOM_VK_F7\",\n    \"DOM_VK_F8\",\n    \"DOM_VK_F9\",\n    \"DOM_VK_FINAL\",\n    \"DOM_VK_FRONT\",\n    \"DOM_VK_G\",\n    \"DOM_VK_GREATER_THAN\",\n    \"DOM_VK_H\",\n    \"DOM_VK_HANGUL\",\n    \"DOM_VK_HANJA\",\n    \"DOM_VK_HASH\",\n    \"DOM_VK_HELP\",\n    \"DOM_VK_HK_TOGGLE\",\n    \"DOM_VK_HOME\",\n    \"DOM_VK_HYPHEN_MINUS\",\n    \"DOM_VK_I\",\n    \"DOM_VK_INSERT\",\n    \"DOM_VK_J\",\n    \"DOM_VK_JUNJA\",\n    \"DOM_VK_K\",\n    \"DOM_VK_KANA\",\n    \"DOM_VK_KANJI\",\n    \"DOM_VK_L\",\n    \"DOM_VK_LEFT\",\n    \"DOM_VK_LEFT_TAB\",\n    \"DOM_VK_LESS_THAN\",\n    \"DOM_VK_M\",\n    \"DOM_VK_META\",\n    \"DOM_VK_MODECHANGE\",\n    \"DOM_VK_MULTIPLY\",\n    \"DOM_VK_N\",\n    \"DOM_VK_NONCONVERT\",\n    \"DOM_VK_NUMPAD0\",\n    \"DOM_VK_NUMPAD1\",\n    \"DOM_VK_NUMPAD2\",\n    \"DOM_VK_NUMPAD3\",\n    \"DOM_VK_NUMPAD4\",\n    \"DOM_VK_NUMPAD5\",\n    \"DOM_VK_NUMPAD6\",\n    \"DOM_VK_NUMPAD7\",\n    \"DOM_VK_NUMPAD8\",\n    \"DOM_VK_NUMPAD9\",\n    \"DOM_VK_NUM_LOCK\",\n    \"DOM_VK_O\",\n    \"DOM_VK_OEM_1\",\n    \"DOM_VK_OEM_102\",\n    \"DOM_VK_OEM_2\",\n    \"DOM_VK_OEM_3\",\n    \"DOM_VK_OEM_4\",\n    \"DOM_VK_OEM_5\",\n    \"DOM_VK_OEM_6\",\n    \"DOM_VK_OEM_7\",\n    \"DOM_VK_OEM_8\",\n    \"DOM_VK_OEM_COMMA\",\n    \"DOM_VK_OEM_MINUS\",\n    \"DOM_VK_OEM_PERIOD\",\n    \"DOM_VK_OEM_PLUS\",\n    \"DOM_VK_OPEN_BRACKET\",\n    \"DOM_VK_OPEN_CURLY_BRACKET\",\n    \"DOM_VK_OPEN_PAREN\",\n    \"DOM_VK_P\",\n    \"DOM_VK_PA1\",\n    \"DOM_VK_PAGEDOWN\",\n    \"DOM_VK_PAGEUP\",\n    \"DOM_VK_PAGE_DOWN\",\n    \"DOM_VK_PAGE_UP\",\n    \"DOM_VK_PAUSE\",\n    \"DOM_VK_PERCENT\",\n    \"DOM_VK_PERIOD\",\n    \"DOM_VK_PIPE\",\n    \"DOM_VK_PLAY\",\n    \"DOM_VK_PLUS\",\n    \"DOM_VK_PRINT\",\n    \"DOM_VK_PRINTSCREEN\",\n    \"DOM_VK_PROCESSKEY\",\n    \"DOM_VK_PROPERITES\",\n    \"DOM_VK_Q\",\n    \"DOM_VK_QUESTION_MARK\",\n    \"DOM_VK_QUOTE\",\n    \"DOM_VK_R\",\n    \"DOM_VK_REDO\",\n    \"DOM_VK_RETURN\",\n    \"DOM_VK_RIGHT\",\n    \"DOM_VK_S\",\n    \"DOM_VK_SCROLL_LOCK\",\n    \"DOM_VK_SELECT\",\n    \"DOM_VK_SEMICOLON\",\n    \"DOM_VK_SEPARATOR\",\n    \"DOM_VK_SHIFT\",\n    \"DOM_VK_SLASH\",\n    \"DOM_VK_SLEEP\",\n    \"DOM_VK_SPACE\",\n    \"DOM_VK_SUBTRACT\",\n    \"DOM_VK_T\",\n    \"DOM_VK_TAB\",\n    \"DOM_VK_TILDE\",\n    \"DOM_VK_U\",\n    \"DOM_VK_UNDERSCORE\",\n    \"DOM_VK_UNDO\",\n    \"DOM_VK_UNICODE\",\n    \"DOM_VK_UP\",\n    \"DOM_VK_V\",\n    \"DOM_VK_VOLUME_DOWN\",\n    \"DOM_VK_VOLUME_MUTE\",\n    \"DOM_VK_VOLUME_UP\",\n    \"DOM_VK_W\",\n    \"DOM_VK_WIN\",\n    \"DOM_VK_WINDOW\",\n    \"DOM_VK_WIN_ICO_00\",\n    \"DOM_VK_WIN_ICO_CLEAR\",\n    \"DOM_VK_WIN_ICO_HELP\",\n    \"DOM_VK_WIN_OEM_ATTN\",\n    \"DOM_VK_WIN_OEM_AUTO\",\n    \"DOM_VK_WIN_OEM_BACKTAB\",\n    \"DOM_VK_WIN_OEM_CLEAR\",\n    \"DOM_VK_WIN_OEM_COPY\",\n    \"DOM_VK_WIN_OEM_CUSEL\",\n    \"DOM_VK_WIN_OEM_ENLW\",\n    \"DOM_VK_WIN_OEM_FINISH\",\n    \"DOM_VK_WIN_OEM_FJ_JISHO\",\n    \"DOM_VK_WIN_OEM_FJ_LOYA\",\n    \"DOM_VK_WIN_OEM_FJ_MASSHOU\",\n    \"DOM_VK_WIN_OEM_FJ_ROYA\",\n    \"DOM_VK_WIN_OEM_FJ_TOUROKU\",\n    \"DOM_VK_WIN_OEM_JUMP\",\n    \"DOM_VK_WIN_OEM_PA1\",\n    \"DOM_VK_WIN_OEM_PA2\",\n    \"DOM_VK_WIN_OEM_PA3\",\n    \"DOM_VK_WIN_OEM_RESET\",\n    \"DOM_VK_WIN_OEM_WSCTRL\",\n    \"DOM_VK_X\",\n    \"DOM_VK_XF86XK_ADD_FAVORITE\",\n    \"DOM_VK_XF86XK_APPLICATION_LEFT\",\n    \"DOM_VK_XF86XK_APPLICATION_RIGHT\",\n    \"DOM_VK_XF86XK_AUDIO_CYCLE_TRACK\",\n    \"DOM_VK_XF86XK_AUDIO_FORWARD\",\n    \"DOM_VK_XF86XK_AUDIO_LOWER_VOLUME\",\n    \"DOM_VK_XF86XK_AUDIO_MEDIA\",\n    \"DOM_VK_XF86XK_AUDIO_MUTE\",\n    \"DOM_VK_XF86XK_AUDIO_NEXT\",\n    \"DOM_VK_XF86XK_AUDIO_PAUSE\",\n    \"DOM_VK_XF86XK_AUDIO_PLAY\",\n    \"DOM_VK_XF86XK_AUDIO_PREV\",\n    \"DOM_VK_XF86XK_AUDIO_RAISE_VOLUME\",\n    \"DOM_VK_XF86XK_AUDIO_RANDOM_PLAY\",\n    \"DOM_VK_XF86XK_AUDIO_RECORD\",\n    \"DOM_VK_XF86XK_AUDIO_REPEAT\",\n    \"DOM_VK_XF86XK_AUDIO_REWIND\",\n    \"DOM_VK_XF86XK_AUDIO_STOP\",\n    \"DOM_VK_XF86XK_AWAY\",\n    \"DOM_VK_XF86XK_BACK\",\n    \"DOM_VK_XF86XK_BACK_FORWARD\",\n    \"DOM_VK_XF86XK_BATTERY\",\n    \"DOM_VK_XF86XK_BLUE\",\n    \"DOM_VK_XF86XK_BLUETOOTH\",\n    \"DOM_VK_XF86XK_BOOK\",\n    \"DOM_VK_XF86XK_BRIGHTNESS_ADJUST\",\n    \"DOM_VK_XF86XK_CALCULATOR\",\n    \"DOM_VK_XF86XK_CALENDAR\",\n    \"DOM_VK_XF86XK_CD\",\n    \"DOM_VK_XF86XK_CLOSE\",\n    \"DOM_VK_XF86XK_COMMUNITY\",\n    \"DOM_VK_XF86XK_CONTRAST_ADJUST\",\n    \"DOM_VK_XF86XK_COPY\",\n    \"DOM_VK_XF86XK_CUT\",\n    \"DOM_VK_XF86XK_CYCLE_ANGLE\",\n    \"DOM_VK_XF86XK_DISPLAY\",\n    \"DOM_VK_XF86XK_DOCUMENTS\",\n    \"DOM_VK_XF86XK_DOS\",\n    \"DOM_VK_XF86XK_EJECT\",\n    \"DOM_VK_XF86XK_EXCEL\",\n    \"DOM_VK_XF86XK_EXPLORER\",\n    \"DOM_VK_XF86XK_FAVORITES\",\n    \"DOM_VK_XF86XK_FINANCE\",\n    \"DOM_VK_XF86XK_FORWARD\",\n    \"DOM_VK_XF86XK_FRAME_BACK\",\n    \"DOM_VK_XF86XK_FRAME_FORWARD\",\n    \"DOM_VK_XF86XK_GAME\",\n    \"DOM_VK_XF86XK_GO\",\n    \"DOM_VK_XF86XK_GREEN\",\n    \"DOM_VK_XF86XK_HIBERNATE\",\n    \"DOM_VK_XF86XK_HISTORY\",\n    \"DOM_VK_XF86XK_HOME_PAGE\",\n    \"DOM_VK_XF86XK_HOT_LINKS\",\n    \"DOM_VK_XF86XK_I_TOUCH\",\n    \"DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN\",\n    \"DOM_VK_XF86XK_KBD_BRIGHTNESS_UP\",\n    \"DOM_VK_XF86XK_KBD_LIGHT_ON_OFF\",\n    \"DOM_VK_XF86XK_LAUNCH0\",\n    \"DOM_VK_XF86XK_LAUNCH1\",\n    \"DOM_VK_XF86XK_LAUNCH2\",\n    \"DOM_VK_XF86XK_LAUNCH3\",\n    \"DOM_VK_XF86XK_LAUNCH4\",\n    \"DOM_VK_XF86XK_LAUNCH5\",\n    \"DOM_VK_XF86XK_LAUNCH6\",\n    \"DOM_VK_XF86XK_LAUNCH7\",\n    \"DOM_VK_XF86XK_LAUNCH8\",\n    \"DOM_VK_XF86XK_LAUNCH9\",\n    \"DOM_VK_XF86XK_LAUNCH_A\",\n    \"DOM_VK_XF86XK_LAUNCH_B\",\n    \"DOM_VK_XF86XK_LAUNCH_C\",\n    \"DOM_VK_XF86XK_LAUNCH_D\",\n    \"DOM_VK_XF86XK_LAUNCH_E\",\n    \"DOM_VK_XF86XK_LAUNCH_F\",\n    \"DOM_VK_XF86XK_LIGHT_BULB\",\n    \"DOM_VK_XF86XK_LOG_OFF\",\n    \"DOM_VK_XF86XK_MAIL\",\n    \"DOM_VK_XF86XK_MAIL_FORWARD\",\n    \"DOM_VK_XF86XK_MARKET\",\n    \"DOM_VK_XF86XK_MEETING\",\n    \"DOM_VK_XF86XK_MEMO\",\n    \"DOM_VK_XF86XK_MENU_KB\",\n    \"DOM_VK_XF86XK_MENU_PB\",\n    \"DOM_VK_XF86XK_MESSENGER\",\n    \"DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN\",\n    \"DOM_VK_XF86XK_MON_BRIGHTNESS_UP\",\n    \"DOM_VK_XF86XK_MUSIC\",\n    \"DOM_VK_XF86XK_MY_COMPUTER\",\n    \"DOM_VK_XF86XK_MY_SITES\",\n    \"DOM_VK_XF86XK_NEW\",\n    \"DOM_VK_XF86XK_NEWS\",\n    \"DOM_VK_XF86XK_OFFICE_HOME\",\n    \"DOM_VK_XF86XK_OPEN\",\n    \"DOM_VK_XF86XK_OPEN_URL\",\n    \"DOM_VK_XF86XK_OPTION\",\n    \"DOM_VK_XF86XK_PASTE\",\n    \"DOM_VK_XF86XK_PHONE\",\n    \"DOM_VK_XF86XK_PICTURES\",\n    \"DOM_VK_XF86XK_POWER_DOWN\",\n    \"DOM_VK_XF86XK_POWER_OFF\",\n    \"DOM_VK_XF86XK_RED\",\n    \"DOM_VK_XF86XK_REFRESH\",\n    \"DOM_VK_XF86XK_RELOAD\",\n    \"DOM_VK_XF86XK_REPLY\",\n    \"DOM_VK_XF86XK_ROCKER_DOWN\",\n    \"DOM_VK_XF86XK_ROCKER_ENTER\",\n    \"DOM_VK_XF86XK_ROCKER_UP\",\n    \"DOM_VK_XF86XK_ROTATE_WINDOWS\",\n    \"DOM_VK_XF86XK_ROTATION_KB\",\n    \"DOM_VK_XF86XK_ROTATION_PB\",\n    \"DOM_VK_XF86XK_SAVE\",\n    \"DOM_VK_XF86XK_SCREEN_SAVER\",\n    \"DOM_VK_XF86XK_SCROLL_CLICK\",\n    \"DOM_VK_XF86XK_SCROLL_DOWN\",\n    \"DOM_VK_XF86XK_SCROLL_UP\",\n    \"DOM_VK_XF86XK_SEARCH\",\n    \"DOM_VK_XF86XK_SEND\",\n    \"DOM_VK_XF86XK_SHOP\",\n    \"DOM_VK_XF86XK_SPELL\",\n    \"DOM_VK_XF86XK_SPLIT_SCREEN\",\n    \"DOM_VK_XF86XK_STANDBY\",\n    \"DOM_VK_XF86XK_START\",\n    \"DOM_VK_XF86XK_STOP\",\n    \"DOM_VK_XF86XK_SUBTITLE\",\n    \"DOM_VK_XF86XK_SUPPORT\",\n    \"DOM_VK_XF86XK_SUSPEND\",\n    \"DOM_VK_XF86XK_TASK_PANE\",\n    \"DOM_VK_XF86XK_TERMINAL\",\n    \"DOM_VK_XF86XK_TIME\",\n    \"DOM_VK_XF86XK_TOOLS\",\n    \"DOM_VK_XF86XK_TOP_MENU\",\n    \"DOM_VK_XF86XK_TO_DO_LIST\",\n    \"DOM_VK_XF86XK_TRAVEL\",\n    \"DOM_VK_XF86XK_USER1KB\",\n    \"DOM_VK_XF86XK_USER2KB\",\n    \"DOM_VK_XF86XK_USER_PB\",\n    \"DOM_VK_XF86XK_UWB\",\n    \"DOM_VK_XF86XK_VENDOR_HOME\",\n    \"DOM_VK_XF86XK_VIDEO\",\n    \"DOM_VK_XF86XK_VIEW\",\n    \"DOM_VK_XF86XK_WAKE_UP\",\n    \"DOM_VK_XF86XK_WEB_CAM\",\n    \"DOM_VK_XF86XK_WHEEL_BUTTON\",\n    \"DOM_VK_XF86XK_WLAN\",\n    \"DOM_VK_XF86XK_WORD\",\n    \"DOM_VK_XF86XK_WWW\",\n    \"DOM_VK_XF86XK_XFER\",\n    \"DOM_VK_XF86XK_YELLOW\",\n    \"DOM_VK_XF86XK_ZOOM_IN\",\n    \"DOM_VK_XF86XK_ZOOM_OUT\",\n    \"DOM_VK_Y\",\n    \"DOM_VK_Z\",\n    \"DOM_VK_ZOOM\",\n    \"DONE\",\n    \"DONT_CARE\",\n    \"DOWNLOADING\",\n    \"DRAGDROP\",\n    \"DRAW_BUFFER0\",\n    \"DRAW_BUFFER1\",\n    \"DRAW_BUFFER10\",\n    \"DRAW_BUFFER11\",\n    \"DRAW_BUFFER12\",\n    \"DRAW_BUFFER13\",\n    \"DRAW_BUFFER14\",\n    \"DRAW_BUFFER15\",\n    \"DRAW_BUFFER2\",\n    \"DRAW_BUFFER3\",\n    \"DRAW_BUFFER4\",\n    \"DRAW_BUFFER5\",\n    \"DRAW_BUFFER6\",\n    \"DRAW_BUFFER7\",\n    \"DRAW_BUFFER8\",\n    \"DRAW_BUFFER9\",\n    \"DRAW_FRAMEBUFFER\",\n    \"DRAW_FRAMEBUFFER_BINDING\",\n    \"DST_ALPHA\",\n    \"DST_COLOR\",\n    \"DYNAMIC_COPY\",\n    \"DYNAMIC_DRAW\",\n    \"DYNAMIC_READ\",\n    \"DataChannel\",\n    \"DataTransfer\",\n    \"DataTransferItem\",\n    \"DataTransferItemList\",\n    \"DataView\",\n    \"Date\",\n    \"DateTimeFormat\",\n    \"DecompressionStream\",\n    \"DelayNode\",\n    \"DelegatedInkTrailPresenter\",\n    \"DeprecationReportBody\",\n    \"DesktopNotification\",\n    \"DesktopNotificationCenter\",\n    \"Details\",\n    \"DeviceLightEvent\",\n    \"DeviceMotionEvent\",\n    \"DeviceMotionEventAcceleration\",\n    \"DeviceMotionEventRotationRate\",\n    \"DeviceOrientationEvent\",\n    \"DeviceProximityEvent\",\n    \"DeviceStorage\",\n    \"DeviceStorageChangeEvent\",\n    \"Directory\",\n    \"DisplayNames\",\n    \"Document\",\n    \"DocumentFragment\",\n    \"DocumentPictureInPicture\",\n    \"DocumentPictureInPictureEvent\",\n    \"DocumentTimeline\",\n    \"DocumentType\",\n    \"DragEvent\",\n    \"DurationFormat\",\n    \"DynamicsCompressorNode\",\n    \"E\",\n    \"ELEMENT_ARRAY_BUFFER\",\n    \"ELEMENT_ARRAY_BUFFER_BINDING\",\n    \"ELEMENT_NODE\",\n    \"EMPTY\",\n    \"ENCODING_ERR\",\n    \"ENDED\",\n    \"END_TO_END\",\n    \"END_TO_START\",\n    \"ENTITY_NODE\",\n    \"ENTITY_REFERENCE_NODE\",\n    \"EPSILON\",\n    \"EQUAL\",\n    \"EQUALPOWER\",\n    \"ERROR\",\n    \"EXPONENTIAL_DISTANCE\",\n    \"EditContext\",\n    \"Element\",\n    \"ElementInternals\",\n    \"ElementQuery\",\n    \"EncodedAudioChunk\",\n    \"EncodedVideoChunk\",\n    \"EnterPictureInPictureEvent\",\n    \"Entity\",\n    \"EntityReference\",\n    \"Error\",\n    \"ErrorEvent\",\n    \"EvalError\",\n    \"Event\",\n    \"EventCounts\",\n    \"EventException\",\n    \"EventSource\",\n    \"EventTarget\",\n    \"Exception\",\n    \"ExtensionContext\",\n    \"ExtensionDisabledReason\",\n    \"ExtensionInfo\",\n    \"ExtensionInstallType\",\n    \"ExtensionType\",\n    \"External\",\n    \"EyeDropper\",\n    \"FASTEST\",\n    \"FIDOSDK\",\n    \"FILTER_ACCEPT\",\n    \"FILTER_INTERRUPT\",\n    \"FILTER_REJECT\",\n    \"FILTER_SKIP\",\n    \"FINISHED_STATE\",\n    \"FIRST_ORDERED_NODE_TYPE\",\n    \"FLOAT\",\n    \"FLOAT_32_UNSIGNED_INT_24_8_REV\",\n    \"FLOAT_MAT2\",\n    \"FLOAT_MAT2x3\",\n    \"FLOAT_MAT2x4\",\n    \"FLOAT_MAT3\",\n    \"FLOAT_MAT3x2\",\n    \"FLOAT_MAT3x4\",\n    \"FLOAT_MAT4\",\n    \"FLOAT_MAT4x2\",\n    \"FLOAT_MAT4x3\",\n    \"FLOAT_VEC2\",\n    \"FLOAT_VEC3\",\n    \"FLOAT_VEC4\",\n    \"FOCUS\",\n    \"FONT_FACE_RULE\",\n    \"FONT_FEATURE_VALUES_RULE\",\n    \"FRAGMENT\",\n    \"FRAGMENT_SHADER\",\n    \"FRAGMENT_SHADER_DERIVATIVE_HINT\",\n    \"FRAGMENT_SHADER_DERIVATIVE_HINT_OES\",\n    \"FRAMEBUFFER\",\n    \"FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_BLUE_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING\",\n    \"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE\",\n    \"FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_GREEN_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME\",\n    \"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE\",\n    \"FRAMEBUFFER_ATTACHMENT_RED_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE\",\n    \"FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER\",\n    \"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL\",\n    \"FRAMEBUFFER_BINDING\",\n    \"FRAMEBUFFER_COMPLETE\",\n    \"FRAMEBUFFER_DEFAULT\",\n    \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\",\n    \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\",\n    \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\",\n    \"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE\",\n    \"FRAMEBUFFER_UNSUPPORTED\",\n    \"FRONT\",\n    \"FRONT_AND_BACK\",\n    \"FRONT_FACE\",\n    \"FUNC_ADD\",\n    \"FUNC_REVERSE_SUBTRACT\",\n    \"FUNC_SUBTRACT\",\n    \"FeaturePolicy\",\n    \"FeaturePolicyViolationReportBody\",\n    \"FederatedCredential\",\n    \"Feed\",\n    \"FeedEntry\",\n    \"Fence\",\n    \"FencedFrameConfig\",\n    \"File\",\n    \"FileError\",\n    \"FileList\",\n    \"FileReader\",\n    \"FileSystem\",\n    \"FileSystemDirectoryEntry\",\n    \"FileSystemDirectoryHandle\",\n    \"FileSystemDirectoryReader\",\n    \"FileSystemEntry\",\n    \"FileSystemFileEntry\",\n    \"FileSystemFileHandle\",\n    \"FileSystemHandle\",\n    \"FileSystemWritableFileStream\",\n    \"FinalizationRegistry\",\n    \"FindInPage\",\n    \"Float16Array\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"FocusEvent\",\n    \"FontData\",\n    \"FontFace\",\n    \"FontFaceSet\",\n    \"FontFaceSetLoadEvent\",\n    \"FormData\",\n    \"FormDataEvent\",\n    \"FragmentDirective\",\n    \"Function\",\n    \"GENERATE_MIPMAP_HINT\",\n    \"GEQUAL\",\n    \"GPU\",\n    \"GPUAdapter\",\n    \"GPUAdapterInfo\",\n    \"GPUBindGroup\",\n    \"GPUBindGroupLayout\",\n    \"GPUBuffer\",\n    \"GPUBufferUsage\",\n    \"GPUCanvasContext\",\n    \"GPUColorWrite\",\n    \"GPUCommandBuffer\",\n    \"GPUCommandEncoder\",\n    \"GPUCompilationInfo\",\n    \"GPUCompilationMessage\",\n    \"GPUComputePassEncoder\",\n    \"GPUComputePipeline\",\n    \"GPUDevice\",\n    \"GPUDeviceLostInfo\",\n    \"GPUError\",\n    \"GPUExternalTexture\",\n    \"GPUInternalError\",\n    \"GPUMapMode\",\n    \"GPUOutOfMemoryError\",\n    \"GPUPipelineError\",\n    \"GPUPipelineLayout\",\n    \"GPUQuerySet\",\n    \"GPUQueue\",\n    \"GPURenderBundle\",\n    \"GPURenderBundleEncoder\",\n    \"GPURenderPassEncoder\",\n    \"GPURenderPipeline\",\n    \"GPUSampler\",\n    \"GPUShaderModule\",\n    \"GPUShaderStage\",\n    \"GPUSupportedFeatures\",\n    \"GPUSupportedLimits\",\n    \"GPUTexture\",\n    \"GPUTextureUsage\",\n    \"GPUTextureView\",\n    \"GPUUncapturedErrorEvent\",\n    \"GPUValidationError\",\n    \"GREATER\",\n    \"GREEN\",\n    \"GREEN_BITS\",\n    \"GainNode\",\n    \"Gamepad\",\n    \"GamepadAxisMoveEvent\",\n    \"GamepadButton\",\n    \"GamepadButtonEvent\",\n    \"GamepadEvent\",\n    \"GamepadHapticActuator\",\n    \"GamepadPose\",\n    \"Geolocation\",\n    \"GeolocationCoordinates\",\n    \"GeolocationPosition\",\n    \"GeolocationPositionError\",\n    \"GestureEvent\",\n    \"GetInfo\",\n    \"Global\",\n    \"GravitySensor\",\n    \"Gyroscope\",\n    \"HALF_FLOAT\",\n    \"HAVE_CURRENT_DATA\",\n    \"HAVE_ENOUGH_DATA\",\n    \"HAVE_FUTURE_DATA\",\n    \"HAVE_METADATA\",\n    \"HAVE_NOTHING\",\n    \"HEADERS_RECEIVED\",\n    \"HID\",\n    \"HIDConnectionEvent\",\n    \"HIDDEN\",\n    \"HIDDevice\",\n    \"HIDInputReportEvent\",\n    \"HIERARCHY_REQUEST_ERR\",\n    \"HIGHPASS\",\n    \"HIGHSHELF\",\n    \"HIGH_FLOAT\",\n    \"HIGH_INT\",\n    \"HORIZONTAL\",\n    \"HORIZONTAL_AXIS\",\n    \"HRTF\",\n    \"HTMLAllCollection\",\n    \"HTMLAnchorElement\",\n    \"HTMLAppletElement\",\n    \"HTMLAreaElement\",\n    \"HTMLAudioElement\",\n    \"HTMLBRElement\",\n    \"HTMLBaseElement\",\n    \"HTMLBaseFontElement\",\n    \"HTMLBlockquoteElement\",\n    \"HTMLBodyElement\",\n    \"HTMLButtonElement\",\n    \"HTMLCanvasElement\",\n    \"HTMLCollection\",\n    \"HTMLCommandElement\",\n    \"HTMLContentElement\",\n    \"HTMLDListElement\",\n    \"HTMLDataElement\",\n    \"HTMLDataListElement\",\n    \"HTMLDetailsElement\",\n    \"HTMLDialogElement\",\n    \"HTMLDirectoryElement\",\n    \"HTMLDivElement\",\n    \"HTMLDocument\",\n    \"HTMLElement\",\n    \"HTMLEmbedElement\",\n    \"HTMLFencedFrameElement\",\n    \"HTMLFieldSetElement\",\n    \"HTMLFontElement\",\n    \"HTMLFormControlsCollection\",\n    \"HTMLFormElement\",\n    \"HTMLFrameElement\",\n    \"HTMLFrameSetElement\",\n    \"HTMLHRElement\",\n    \"HTMLHeadElement\",\n    \"HTMLHeadingElement\",\n    \"HTMLHtmlElement\",\n    \"HTMLIFrameElement\",\n    \"HTMLImageElement\",\n    \"HTMLInputElement\",\n    \"HTMLIsIndexElement\",\n    \"HTMLKeygenElement\",\n    \"HTMLLIElement\",\n    \"HTMLLabelElement\",\n    \"HTMLLegendElement\",\n    \"HTMLLinkElement\",\n    \"HTMLMapElement\",\n    \"HTMLMarqueeElement\",\n    \"HTMLMediaElement\",\n    \"HTMLMenuElement\",\n    \"HTMLMenuItemElement\",\n    \"HTMLMetaElement\",\n    \"HTMLMeterElement\",\n    \"HTMLModElement\",\n    \"HTMLOListElement\",\n    \"HTMLObjectElement\",\n    \"HTMLOptGroupElement\",\n    \"HTMLOptionElement\",\n    \"HTMLOptionsCollection\",\n    \"HTMLOutputElement\",\n    \"HTMLParagraphElement\",\n    \"HTMLParamElement\",\n    \"HTMLPictureElement\",\n    \"HTMLPreElement\",\n    \"HTMLProgressElement\",\n    \"HTMLPropertiesCollection\",\n    \"HTMLQuoteElement\",\n    \"HTMLScriptElement\",\n    \"HTMLSelectElement\",\n    \"HTMLShadowElement\",\n    \"HTMLSlotElement\",\n    \"HTMLSourceElement\",\n    \"HTMLSpanElement\",\n    \"HTMLStyleElement\",\n    \"HTMLTableCaptionElement\",\n    \"HTMLTableCellElement\",\n    \"HTMLTableColElement\",\n    \"HTMLTableElement\",\n    \"HTMLTableRowElement\",\n    \"HTMLTableSectionElement\",\n    \"HTMLTemplateElement\",\n    \"HTMLTextAreaElement\",\n    \"HTMLTimeElement\",\n    \"HTMLTitleElement\",\n    \"HTMLTrackElement\",\n    \"HTMLUListElement\",\n    \"HTMLUnknownElement\",\n    \"HTMLVideoElement\",\n    \"HashChangeEvent\",\n    \"Headers\",\n    \"Highlight\",\n    \"HighlightRegistry\",\n    \"History\",\n    \"Hz\",\n    \"ICE_CHECKING\",\n    \"ICE_CLOSED\",\n    \"ICE_COMPLETED\",\n    \"ICE_CONNECTED\",\n    \"ICE_FAILED\",\n    \"ICE_GATHERING\",\n    \"ICE_WAITING\",\n    \"IDBCursor\",\n    \"IDBCursorWithValue\",\n    \"IDBDatabase\",\n    \"IDBDatabaseException\",\n    \"IDBFactory\",\n    \"IDBFileHandle\",\n    \"IDBFileRequest\",\n    \"IDBIndex\",\n    \"IDBKeyRange\",\n    \"IDBMutableFile\",\n    \"IDBObjectStore\",\n    \"IDBOpenDBRequest\",\n    \"IDBRequest\",\n    \"IDBTransaction\",\n    \"IDBVersionChangeEvent\",\n    \"IDLE\",\n    \"IIRFilterNode\",\n    \"IMPLEMENTATION_COLOR_READ_FORMAT\",\n    \"IMPLEMENTATION_COLOR_READ_TYPE\",\n    \"IMPORT_RULE\",\n    \"INCR\",\n    \"INCR_WRAP\",\n    \"INDEX\",\n    \"INDEX_SIZE_ERR\",\n    \"INDIRECT\",\n    \"INT\",\n    \"INTERLEAVED_ATTRIBS\",\n    \"INT_2_10_10_10_REV\",\n    \"INT_SAMPLER_2D\",\n    \"INT_SAMPLER_2D_ARRAY\",\n    \"INT_SAMPLER_3D\",\n    \"INT_SAMPLER_CUBE\",\n    \"INT_VEC2\",\n    \"INT_VEC3\",\n    \"INT_VEC4\",\n    \"INUSE_ATTRIBUTE_ERR\",\n    \"INVALID_ACCESS_ERR\",\n    \"INVALID_CHARACTER_ERR\",\n    \"INVALID_ENUM\",\n    \"INVALID_EXPRESSION_ERR\",\n    \"INVALID_FRAMEBUFFER_OPERATION\",\n    \"INVALID_INDEX\",\n    \"INVALID_MODIFICATION_ERR\",\n    \"INVALID_NODE_TYPE_ERR\",\n    \"INVALID_OPERATION\",\n    \"INVALID_STATE_ERR\",\n    \"INVALID_VALUE\",\n    \"INVERSE_DISTANCE\",\n    \"INVERT\",\n    \"IceCandidate\",\n    \"IconInfo\",\n    \"IdentityCredential\",\n    \"IdentityCredentialError\",\n    \"IdentityProvider\",\n    \"IdleDeadline\",\n    \"IdleDetector\",\n    \"Image\",\n    \"ImageBitmap\",\n    \"ImageBitmapRenderingContext\",\n    \"ImageCapture\",\n    \"ImageData\",\n    \"ImageDataType\",\n    \"ImageDecoder\",\n    \"ImageTrack\",\n    \"ImageTrackList\",\n    \"Infinity\",\n    \"Ink\",\n    \"InputDeviceCapabilities\",\n    \"InputDeviceInfo\",\n    \"InputEvent\",\n    \"InputMethodContext\",\n    \"InstallTrigger\",\n    \"InstallTriggerImpl\",\n    \"Instance\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Int8Array\",\n    \"Intent\",\n    \"InternalError\",\n    \"IntersectionObserver\",\n    \"IntersectionObserverEntry\",\n    \"Intl\",\n    \"IsSearchProviderInstalled\",\n    \"Iterator\",\n    \"JSON\",\n    \"JSTag\",\n    \"KEEP\",\n    \"KEYDOWN\",\n    \"KEYFRAMES_RULE\",\n    \"KEYFRAME_RULE\",\n    \"KEYPRESS\",\n    \"KEYUP\",\n    \"KeyEvent\",\n    \"Keyboard\",\n    \"KeyboardEvent\",\n    \"KeyboardLayoutMap\",\n    \"KeyframeEffect\",\n    \"LENGTHADJUST_SPACING\",\n    \"LENGTHADJUST_SPACINGANDGLYPHS\",\n    \"LENGTHADJUST_UNKNOWN\",\n    \"LEQUAL\",\n    \"LESS\",\n    \"LINEAR\",\n    \"LINEAR_DISTANCE\",\n    \"LINEAR_MIPMAP_LINEAR\",\n    \"LINEAR_MIPMAP_NEAREST\",\n    \"LINES\",\n    \"LINE_LOOP\",\n    \"LINE_STRIP\",\n    \"LINE_WIDTH\",\n    \"LINK_STATUS\",\n    \"LIVE\",\n    \"LN10\",\n    \"LN2\",\n    \"LOADED\",\n    \"LOADING\",\n    \"LOG10E\",\n    \"LOG2E\",\n    \"LOWPASS\",\n    \"LOWSHELF\",\n    \"LOW_FLOAT\",\n    \"LOW_INT\",\n    \"LSException\",\n    \"LSParserFilter\",\n    \"LUMINANCE\",\n    \"LUMINANCE_ALPHA\",\n    \"LanguageCode\",\n    \"LargestContentfulPaint\",\n    \"LaunchParams\",\n    \"LaunchQueue\",\n    \"LaunchType\",\n    \"LayoutShift\",\n    \"LayoutShiftAttribution\",\n    \"LinearAccelerationSensor\",\n    \"LinkError\",\n    \"ListFormat\",\n    \"LocalMediaStream\",\n    \"Locale\",\n    \"Location\",\n    \"Lock\",\n    \"LockManager\",\n    \"MAP_READ\",\n    \"MAP_WRITE\",\n    \"MARGIN_RULE\",\n    \"MAX\",\n    \"MAX_3D_TEXTURE_SIZE\",\n    \"MAX_ARRAY_TEXTURE_LAYERS\",\n    \"MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND\",\n    \"MAX_CLIENT_WAIT_TIMEOUT_WEBGL\",\n    \"MAX_COLOR_ATTACHMENTS\",\n    \"MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS\",\n    \"MAX_COMBINED_TEXTURE_IMAGE_UNITS\",\n    \"MAX_COMBINED_UNIFORM_BLOCKS\",\n    \"MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS\",\n    \"MAX_CUBE_MAP_TEXTURE_SIZE\",\n    \"MAX_DRAW_BUFFERS\",\n    \"MAX_ELEMENTS_INDICES\",\n    \"MAX_ELEMENTS_VERTICES\",\n    \"MAX_ELEMENT_INDEX\",\n    \"MAX_FRAGMENT_INPUT_COMPONENTS\",\n    \"MAX_FRAGMENT_UNIFORM_BLOCKS\",\n    \"MAX_FRAGMENT_UNIFORM_COMPONENTS\",\n    \"MAX_FRAGMENT_UNIFORM_VECTORS\",\n    \"MAX_PROGRAM_TEXEL_OFFSET\",\n    \"MAX_RENDERBUFFER_SIZE\",\n    \"MAX_SAFE_INTEGER\",\n    \"MAX_SAMPLES\",\n    \"MAX_SERVER_WAIT_TIMEOUT\",\n    \"MAX_TEXTURE_IMAGE_UNITS\",\n    \"MAX_TEXTURE_LOD_BIAS\",\n    \"MAX_TEXTURE_MAX_ANISOTROPY_EXT\",\n    \"MAX_TEXTURE_SIZE\",\n    \"MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS\",\n    \"MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS\",\n    \"MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS\",\n    \"MAX_UNIFORM_BLOCK_SIZE\",\n    \"MAX_UNIFORM_BUFFER_BINDINGS\",\n    \"MAX_VALUE\",\n    \"MAX_VARYING_COMPONENTS\",\n    \"MAX_VARYING_VECTORS\",\n    \"MAX_VERTEX_ATTRIBS\",\n    \"MAX_VERTEX_OUTPUT_COMPONENTS\",\n    \"MAX_VERTEX_TEXTURE_IMAGE_UNITS\",\n    \"MAX_VERTEX_UNIFORM_BLOCKS\",\n    \"MAX_VERTEX_UNIFORM_COMPONENTS\",\n    \"MAX_VERTEX_UNIFORM_VECTORS\",\n    \"MAX_VIEWPORT_DIMS\",\n    \"MEDIA_ERR_ABORTED\",\n    \"MEDIA_ERR_DECODE\",\n    \"MEDIA_ERR_ENCRYPTED\",\n    \"MEDIA_ERR_NETWORK\",\n    \"MEDIA_ERR_SRC_NOT_SUPPORTED\",\n    \"MEDIA_KEYERR_CLIENT\",\n    \"MEDIA_KEYERR_DOMAIN\",\n    \"MEDIA_KEYERR_HARDWARECHANGE\",\n    \"MEDIA_KEYERR_OUTPUT\",\n    \"MEDIA_KEYERR_SERVICE\",\n    \"MEDIA_KEYERR_UNKNOWN\",\n    \"MEDIA_RULE\",\n    \"MEDIUM_FLOAT\",\n    \"MEDIUM_INT\",\n    \"META_MASK\",\n    \"MIDIAccess\",\n    \"MIDIConnectionEvent\",\n    \"MIDIInput\",\n    \"MIDIInputMap\",\n    \"MIDIMessageEvent\",\n    \"MIDIOutput\",\n    \"MIDIOutputMap\",\n    \"MIDIPort\",\n    \"MIN\",\n    \"MIN_PROGRAM_TEXEL_OFFSET\",\n    \"MIN_SAFE_INTEGER\",\n    \"MIN_VALUE\",\n    \"MIRRORED_REPEAT\",\n    \"MODE_ASYNCHRONOUS\",\n    \"MODE_SYNCHRONOUS\",\n    \"MODIFICATION\",\n    \"MOUSEDOWN\",\n    \"MOUSEDRAG\",\n    \"MOUSEMOVE\",\n    \"MOUSEOUT\",\n    \"MOUSEOVER\",\n    \"MOUSEUP\",\n    \"MOZ_KEYFRAMES_RULE\",\n    \"MOZ_KEYFRAME_RULE\",\n    \"MOZ_SOURCE_CURSOR\",\n    \"MOZ_SOURCE_ERASER\",\n    \"MOZ_SOURCE_KEYBOARD\",\n    \"MOZ_SOURCE_MOUSE\",\n    \"MOZ_SOURCE_PEN\",\n    \"MOZ_SOURCE_TOUCH\",\n    \"MOZ_SOURCE_UNKNOWN\",\n    \"MSGESTURE_FLAG_BEGIN\",\n    \"MSGESTURE_FLAG_CANCEL\",\n    \"MSGESTURE_FLAG_END\",\n    \"MSGESTURE_FLAG_INERTIA\",\n    \"MSGESTURE_FLAG_NONE\",\n    \"MSPOINTER_TYPE_MOUSE\",\n    \"MSPOINTER_TYPE_PEN\",\n    \"MSPOINTER_TYPE_TOUCH\",\n    \"MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE\",\n    \"MS_ASYNC_CALLBACK_STATUS_CANCEL\",\n    \"MS_ASYNC_CALLBACK_STATUS_CHOOSEANY\",\n    \"MS_ASYNC_CALLBACK_STATUS_ERROR\",\n    \"MS_ASYNC_CALLBACK_STATUS_JOIN\",\n    \"MS_ASYNC_OP_STATUS_CANCELED\",\n    \"MS_ASYNC_OP_STATUS_ERROR\",\n    \"MS_ASYNC_OP_STATUS_SUCCESS\",\n    \"MS_MANIPULATION_STATE_ACTIVE\",\n    \"MS_MANIPULATION_STATE_CANCELLED\",\n    \"MS_MANIPULATION_STATE_COMMITTED\",\n    \"MS_MANIPULATION_STATE_DRAGGING\",\n    \"MS_MANIPULATION_STATE_INERTIA\",\n    \"MS_MANIPULATION_STATE_PRESELECT\",\n    \"MS_MANIPULATION_STATE_SELECTING\",\n    \"MS_MANIPULATION_STATE_STOPPED\",\n    \"MS_MEDIA_ERR_ENCRYPTED\",\n    \"MS_MEDIA_KEYERR_CLIENT\",\n    \"MS_MEDIA_KEYERR_DOMAIN\",\n    \"MS_MEDIA_KEYERR_HARDWARECHANGE\",\n    \"MS_MEDIA_KEYERR_OUTPUT\",\n    \"MS_MEDIA_KEYERR_SERVICE\",\n    \"MS_MEDIA_KEYERR_UNKNOWN\",\n    \"Map\",\n    \"Math\",\n    \"MathMLElement\",\n    \"MediaCapabilities\",\n    \"MediaCapabilitiesInfo\",\n    \"MediaController\",\n    \"MediaDeviceInfo\",\n    \"MediaDevices\",\n    \"MediaElementAudioSourceNode\",\n    \"MediaEncryptedEvent\",\n    \"MediaError\",\n    \"MediaKeyError\",\n    \"MediaKeyEvent\",\n    \"MediaKeyMessageEvent\",\n    \"MediaKeyNeededEvent\",\n    \"MediaKeySession\",\n    \"MediaKeyStatusMap\",\n    \"MediaKeySystemAccess\",\n    \"MediaKeys\",\n    \"MediaList\",\n    \"MediaMetadata\",\n    \"MediaQueryList\",\n    \"MediaQueryListEvent\",\n    \"MediaRecorder\",\n    \"MediaRecorderErrorEvent\",\n    \"MediaSession\",\n    \"MediaSettingsRange\",\n    \"MediaSource\",\n    \"MediaSourceHandle\",\n    \"MediaStream\",\n    \"MediaStreamAudioDestinationNode\",\n    \"MediaStreamAudioSourceNode\",\n    \"MediaStreamEvent\",\n    \"MediaStreamTrack\",\n    \"MediaStreamTrackAudioSourceNode\",\n    \"MediaStreamTrackAudioStats\",\n    \"MediaStreamTrackEvent\",\n    \"MediaStreamTrackGenerator\",\n    \"MediaStreamTrackProcessor\",\n    \"MediaStreamTrackVideoStats\",\n    \"Memory\",\n    \"MessageChannel\",\n    \"MessageEvent\",\n    \"MessagePort\",\n    \"MessageSender\",\n    \"Methods\",\n    \"MimeType\",\n    \"MimeTypeArray\",\n    \"Module\",\n    \"MouseEvent\",\n    \"MouseScrollEvent\",\n    \"MozAnimation\",\n    \"MozAnimationDelay\",\n    \"MozAnimationDirection\",\n    \"MozAnimationDuration\",\n    \"MozAnimationFillMode\",\n    \"MozAnimationIterationCount\",\n    \"MozAnimationName\",\n    \"MozAnimationPlayState\",\n    \"MozAnimationTimingFunction\",\n    \"MozAppearance\",\n    \"MozBackfaceVisibility\",\n    \"MozBinding\",\n    \"MozBorderBottomColors\",\n    \"MozBorderEnd\",\n    \"MozBorderEndColor\",\n    \"MozBorderEndStyle\",\n    \"MozBorderEndWidth\",\n    \"MozBorderImage\",\n    \"MozBorderLeftColors\",\n    \"MozBorderRightColors\",\n    \"MozBorderStart\",\n    \"MozBorderStartColor\",\n    \"MozBorderStartStyle\",\n    \"MozBorderStartWidth\",\n    \"MozBorderTopColors\",\n    \"MozBoxAlign\",\n    \"MozBoxDirection\",\n    \"MozBoxFlex\",\n    \"MozBoxOrdinalGroup\",\n    \"MozBoxOrient\",\n    \"MozBoxPack\",\n    \"MozBoxSizing\",\n    \"MozCSSKeyframeRule\",\n    \"MozCSSKeyframesRule\",\n    \"MozColumnCount\",\n    \"MozColumnFill\",\n    \"MozColumnGap\",\n    \"MozColumnRule\",\n    \"MozColumnRuleColor\",\n    \"MozColumnRuleStyle\",\n    \"MozColumnRuleWidth\",\n    \"MozColumnWidth\",\n    \"MozColumns\",\n    \"MozContactChangeEvent\",\n    \"MozFloatEdge\",\n    \"MozFontFeatureSettings\",\n    \"MozFontLanguageOverride\",\n    \"MozForceBrokenImageIcon\",\n    \"MozHyphens\",\n    \"MozImageRegion\",\n    \"MozMarginEnd\",\n    \"MozMarginStart\",\n    \"MozMmsEvent\",\n    \"MozMmsMessage\",\n    \"MozMobileMessageThread\",\n    \"MozOSXFontSmoothing\",\n    \"MozOrient\",\n    \"MozOsxFontSmoothing\",\n    \"MozOutlineRadius\",\n    \"MozOutlineRadiusBottomleft\",\n    \"MozOutlineRadiusBottomright\",\n    \"MozOutlineRadiusTopleft\",\n    \"MozOutlineRadiusTopright\",\n    \"MozPaddingEnd\",\n    \"MozPaddingStart\",\n    \"MozPerspective\",\n    \"MozPerspectiveOrigin\",\n    \"MozPowerManager\",\n    \"MozSettingsEvent\",\n    \"MozSmsEvent\",\n    \"MozSmsMessage\",\n    \"MozStackSizing\",\n    \"MozTabSize\",\n    \"MozTextAlignLast\",\n    \"MozTextDecorationColor\",\n    \"MozTextDecorationLine\",\n    \"MozTextDecorationStyle\",\n    \"MozTextSizeAdjust\",\n    \"MozTransform\",\n    \"MozTransformOrigin\",\n    \"MozTransformStyle\",\n    \"MozTransition\",\n    \"MozTransitionDelay\",\n    \"MozTransitionDuration\",\n    \"MozTransitionProperty\",\n    \"MozTransitionTimingFunction\",\n    \"MozUserFocus\",\n    \"MozUserInput\",\n    \"MozUserModify\",\n    \"MozUserSelect\",\n    \"MozWindowDragging\",\n    \"MozWindowShadow\",\n    \"MutationEvent\",\n    \"MutationObserver\",\n    \"MutationRecord\",\n    \"MutedInfo\",\n    \"MutedInfoReason\",\n    \"NAMESPACE_ERR\",\n    \"NAMESPACE_RULE\",\n    \"NEAREST\",\n    \"NEAREST_MIPMAP_LINEAR\",\n    \"NEAREST_MIPMAP_NEAREST\",\n    \"NEGATIVE_INFINITY\",\n    \"NETWORK_EMPTY\",\n    \"NETWORK_ERR\",\n    \"NETWORK_IDLE\",\n    \"NETWORK_LOADED\",\n    \"NETWORK_LOADING\",\n    \"NETWORK_NO_SOURCE\",\n    \"NEVER\",\n    \"NEW\",\n    \"NEXT\",\n    \"NEXT_NO_DUPLICATE\",\n    \"NICEST\",\n    \"NODE_AFTER\",\n    \"NODE_BEFORE\",\n    \"NODE_BEFORE_AND_AFTER\",\n    \"NODE_INSIDE\",\n    \"NONE\",\n    \"NON_TRANSIENT_ERR\",\n    \"NOTATION_NODE\",\n    \"NOTCH\",\n    \"NOTEQUAL\",\n    \"NOT_ALLOWED_ERR\",\n    \"NOT_FOUND_ERR\",\n    \"NOT_READABLE_ERR\",\n    \"NOT_SUPPORTED_ERR\",\n    \"NO_DATA_ALLOWED_ERR\",\n    \"NO_ERR\",\n    \"NO_ERROR\",\n    \"NO_MODIFICATION_ALLOWED_ERR\",\n    \"NUMBER_TYPE\",\n    \"NUM_COMPRESSED_TEXTURE_FORMATS\",\n    \"NaN\",\n    \"NamedNodeMap\",\n    \"NavigateEvent\",\n    \"Navigation\",\n    \"NavigationActivation\",\n    \"NavigationCurrentEntryChangeEvent\",\n    \"NavigationDestination\",\n    \"NavigationHistoryEntry\",\n    \"NavigationPreloadManager\",\n    \"NavigationTransition\",\n    \"Navigator\",\n    \"NavigatorLogin\",\n    \"NavigatorManagedData\",\n    \"NavigatorUAData\",\n    \"NearbyLinks\",\n    \"NetworkInformation\",\n    \"Node\",\n    \"NodeFilter\",\n    \"NodeIterator\",\n    \"NodeList\",\n    \"NotRestoredReasonDetails\",\n    \"NotRestoredReasons\",\n    \"Notation\",\n    \"Notification\",\n    \"NotifyPaintEvent\",\n    \"Number\",\n    \"NumberFormat\",\n    \"OBJECT_TYPE\",\n    \"OBSOLETE\",\n    \"OK\",\n    \"ONE\",\n    \"ONE_MINUS_CONSTANT_ALPHA\",\n    \"ONE_MINUS_CONSTANT_COLOR\",\n    \"ONE_MINUS_DST_ALPHA\",\n    \"ONE_MINUS_DST_COLOR\",\n    \"ONE_MINUS_SRC_ALPHA\",\n    \"ONE_MINUS_SRC_COLOR\",\n    \"OPEN\",\n    \"OPENED\",\n    \"OPENING\",\n    \"ORDERED_NODE_ITERATOR_TYPE\",\n    \"ORDERED_NODE_SNAPSHOT_TYPE\",\n    \"OTHER_ERROR\",\n    \"OTPCredential\",\n    \"OUT_OF_MEMORY\",\n    \"Object\",\n    \"OfflineAudioCompletionEvent\",\n    \"OfflineAudioContext\",\n    \"OfflineResourceList\",\n    \"OffscreenCanvas\",\n    \"OffscreenCanvasRenderingContext2D\",\n    \"OnClickData\",\n    \"OnInstalledReason\",\n    \"OnPerformanceWarningCategory\",\n    \"OnPerformanceWarningSeverity\",\n    \"OnRestartRequiredReason\",\n    \"Option\",\n    \"OrientationSensor\",\n    \"OscillatorNode\",\n    \"OverconstrainedError\",\n    \"OverflowEvent\",\n    \"PACK_ALIGNMENT\",\n    \"PACK_ROW_LENGTH\",\n    \"PACK_SKIP_PIXELS\",\n    \"PACK_SKIP_ROWS\",\n    \"PAGE_RULE\",\n    \"PARSE_ERR\",\n    \"PATHSEG_ARC_ABS\",\n    \"PATHSEG_ARC_REL\",\n    \"PATHSEG_CLOSEPATH\",\n    \"PATHSEG_CURVETO_CUBIC_ABS\",\n    \"PATHSEG_CURVETO_CUBIC_REL\",\n    \"PATHSEG_CURVETO_CUBIC_SMOOTH_ABS\",\n    \"PATHSEG_CURVETO_CUBIC_SMOOTH_REL\",\n    \"PATHSEG_CURVETO_QUADRATIC_ABS\",\n    \"PATHSEG_CURVETO_QUADRATIC_REL\",\n    \"PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS\",\n    \"PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL\",\n    \"PATHSEG_LINETO_ABS\",\n    \"PATHSEG_LINETO_HORIZONTAL_ABS\",\n    \"PATHSEG_LINETO_HORIZONTAL_REL\",\n    \"PATHSEG_LINETO_REL\",\n    \"PATHSEG_LINETO_VERTICAL_ABS\",\n    \"PATHSEG_LINETO_VERTICAL_REL\",\n    \"PATHSEG_MOVETO_ABS\",\n    \"PATHSEG_MOVETO_REL\",\n    \"PATHSEG_UNKNOWN\",\n    \"PATH_EXISTS_ERR\",\n    \"PEAKING\",\n    \"PERMISSION_DENIED\",\n    \"PERSISTENT\",\n    \"PI\",\n    \"PIXEL_PACK_BUFFER\",\n    \"PIXEL_PACK_BUFFER_BINDING\",\n    \"PIXEL_UNPACK_BUFFER\",\n    \"PIXEL_UNPACK_BUFFER_BINDING\",\n    \"PLAYING_STATE\",\n    \"POINTS\",\n    \"POLYGON_OFFSET_FACTOR\",\n    \"POLYGON_OFFSET_FILL\",\n    \"POLYGON_OFFSET_UNITS\",\n    \"POSITION_UNAVAILABLE\",\n    \"POSITIVE_INFINITY\",\n    \"PREV\",\n    \"PREV_NO_DUPLICATE\",\n    \"PROCESSING_INSTRUCTION_NODE\",\n    \"PageChangeEvent\",\n    \"PageRevealEvent\",\n    \"PageSettings\",\n    \"PageSwapEvent\",\n    \"PageTransitionEvent\",\n    \"PaintRequest\",\n    \"PaintRequestList\",\n    \"PannerNode\",\n    \"PasswordCredential\",\n    \"Path2D\",\n    \"PaymentAddress\",\n    \"PaymentInstruments\",\n    \"PaymentManager\",\n    \"PaymentMethodChangeEvent\",\n    \"PaymentRequest\",\n    \"PaymentRequestUpdateEvent\",\n    \"PaymentResponse\",\n    \"Performance\",\n    \"PerformanceElementTiming\",\n    \"PerformanceEntry\",\n    \"PerformanceEventTiming\",\n    \"PerformanceLongAnimationFrameTiming\",\n    \"PerformanceLongTaskTiming\",\n    \"PerformanceMark\",\n    \"PerformanceMeasure\",\n    \"PerformanceNavigation\",\n    \"PerformanceNavigationTiming\",\n    \"PerformanceObserver\",\n    \"PerformanceObserverEntryList\",\n    \"PerformancePaintTiming\",\n    \"PerformanceResourceTiming\",\n    \"PerformanceScriptTiming\",\n    \"PerformanceServerTiming\",\n    \"PerformanceTiming\",\n    \"PeriodicSyncManager\",\n    \"PeriodicWave\",\n    \"PermissionStatus\",\n    \"Permissions\",\n    \"PhotoCapabilities\",\n    \"PictureInPictureEvent\",\n    \"PictureInPictureWindow\",\n    \"PlatformArch\",\n    \"PlatformInfo\",\n    \"PlatformNaclArch\",\n    \"PlatformOs\",\n    \"Plugin\",\n    \"PluginArray\",\n    \"PluralRules\",\n    \"PointerEvent\",\n    \"PopStateEvent\",\n    \"PopupBlockedEvent\",\n    \"Port\",\n    \"Presentation\",\n    \"PresentationAvailability\",\n    \"PresentationConnection\",\n    \"PresentationConnectionAvailableEvent\",\n    \"PresentationConnectionCloseEvent\",\n    \"PresentationConnectionList\",\n    \"PresentationReceiver\",\n    \"PresentationRequest\",\n    \"PressureObserver\",\n    \"PressureRecord\",\n    \"ProcessingInstruction\",\n    \"Profiler\",\n    \"ProgressEvent\",\n    \"Promise\",\n    \"PromiseRejectionEvent\",\n    \"PropertyNodeList\",\n    \"ProtectedAudience\",\n    \"Proxy\",\n    \"PublicKeyCredential\",\n    \"PushManager\",\n    \"PushSubscription\",\n    \"PushSubscriptionOptions\",\n    \"Q\",\n    \"QUERY_RESOLVE\",\n    \"QUERY_RESULT\",\n    \"QUERY_RESULT_AVAILABLE\",\n    \"QUOTA_ERR\",\n    \"QUOTA_EXCEEDED_ERR\",\n    \"QueryInterface\",\n    \"R11F_G11F_B10F\",\n    \"R16F\",\n    \"R16I\",\n    \"R16UI\",\n    \"R32F\",\n    \"R32I\",\n    \"R32UI\",\n    \"R8\",\n    \"R8I\",\n    \"R8UI\",\n    \"R8_SNORM\",\n    \"RASTERIZER_DISCARD\",\n    \"READ\",\n    \"READ_BUFFER\",\n    \"READ_FRAMEBUFFER\",\n    \"READ_FRAMEBUFFER_BINDING\",\n    \"READ_ONLY\",\n    \"READ_ONLY_ERR\",\n    \"READ_WRITE\",\n    \"RED\",\n    \"RED_BITS\",\n    \"RED_INTEGER\",\n    \"REMOVAL\",\n    \"RENDERBUFFER\",\n    \"RENDERBUFFER_ALPHA_SIZE\",\n    \"RENDERBUFFER_BINDING\",\n    \"RENDERBUFFER_BLUE_SIZE\",\n    \"RENDERBUFFER_DEPTH_SIZE\",\n    \"RENDERBUFFER_GREEN_SIZE\",\n    \"RENDERBUFFER_HEIGHT\",\n    \"RENDERBUFFER_INTERNAL_FORMAT\",\n    \"RENDERBUFFER_RED_SIZE\",\n    \"RENDERBUFFER_SAMPLES\",\n    \"RENDERBUFFER_STENCIL_SIZE\",\n    \"RENDERBUFFER_WIDTH\",\n    \"RENDERER\",\n    \"RENDERING_INTENT_ABSOLUTE_COLORIMETRIC\",\n    \"RENDERING_INTENT_AUTO\",\n    \"RENDERING_INTENT_PERCEPTUAL\",\n    \"RENDERING_INTENT_RELATIVE_COLORIMETRIC\",\n    \"RENDERING_INTENT_SATURATION\",\n    \"RENDERING_INTENT_UNKNOWN\",\n    \"RENDER_ATTACHMENT\",\n    \"REPEAT\",\n    \"REPLACE\",\n    \"RG\",\n    \"RG16F\",\n    \"RG16I\",\n    \"RG16UI\",\n    \"RG32F\",\n    \"RG32I\",\n    \"RG32UI\",\n    \"RG8\",\n    \"RG8I\",\n    \"RG8UI\",\n    \"RG8_SNORM\",\n    \"RGB\",\n    \"RGB10_A2\",\n    \"RGB10_A2UI\",\n    \"RGB16F\",\n    \"RGB16I\",\n    \"RGB16UI\",\n    \"RGB32F\",\n    \"RGB32I\",\n    \"RGB32UI\",\n    \"RGB565\",\n    \"RGB5_A1\",\n    \"RGB8\",\n    \"RGB8I\",\n    \"RGB8UI\",\n    \"RGB8_SNORM\",\n    \"RGB9_E5\",\n    \"RGBA\",\n    \"RGBA16F\",\n    \"RGBA16I\",\n    \"RGBA16UI\",\n    \"RGBA32F\",\n    \"RGBA32I\",\n    \"RGBA32UI\",\n    \"RGBA4\",\n    \"RGBA8\",\n    \"RGBA8I\",\n    \"RGBA8UI\",\n    \"RGBA8_SNORM\",\n    \"RGBA_INTEGER\",\n    \"RGBColor\",\n    \"RGB_INTEGER\",\n    \"RG_INTEGER\",\n    \"ROTATION_CLOCKWISE\",\n    \"ROTATION_COUNTERCLOCKWISE\",\n    \"RTCCertificate\",\n    \"RTCDTMFSender\",\n    \"RTCDTMFToneChangeEvent\",\n    \"RTCDataChannel\",\n    \"RTCDataChannelEvent\",\n    \"RTCDtlsTransport\",\n    \"RTCEncodedAudioFrame\",\n    \"RTCEncodedVideoFrame\",\n    \"RTCError\",\n    \"RTCErrorEvent\",\n    \"RTCIceCandidate\",\n    \"RTCIceTransport\",\n    \"RTCPeerConnection\",\n    \"RTCPeerConnectionIceErrorEvent\",\n    \"RTCPeerConnectionIceEvent\",\n    \"RTCRtpReceiver\",\n    \"RTCRtpScriptTransform\",\n    \"RTCRtpSender\",\n    \"RTCRtpTransceiver\",\n    \"RTCSctpTransport\",\n    \"RTCSessionDescription\",\n    \"RTCStatsReport\",\n    \"RTCTrackEvent\",\n    \"RadioNodeList\",\n    \"Range\",\n    \"RangeError\",\n    \"RangeException\",\n    \"ReadableByteStreamController\",\n    \"ReadableStream\",\n    \"ReadableStreamBYOBReader\",\n    \"ReadableStreamBYOBRequest\",\n    \"ReadableStreamDefaultController\",\n    \"ReadableStreamDefaultReader\",\n    \"RecordErrorEvent\",\n    \"Rect\",\n    \"ReferenceError\",\n    \"Reflect\",\n    \"RegExp\",\n    \"RelativeOrientationSensor\",\n    \"RelativeTimeFormat\",\n    \"RemotePlayback\",\n    \"Report\",\n    \"ReportBody\",\n    \"ReportingObserver\",\n    \"Request\",\n    \"RequestUpdateCheckStatus\",\n    \"ResizeObserver\",\n    \"ResizeObserverEntry\",\n    \"ResizeObserverSize\",\n    \"Response\",\n    \"RuntimeError\",\n    \"SAMPLER_2D\",\n    \"SAMPLER_2D_ARRAY\",\n    \"SAMPLER_2D_ARRAY_SHADOW\",\n    \"SAMPLER_2D_SHADOW\",\n    \"SAMPLER_3D\",\n    \"SAMPLER_BINDING\",\n    \"SAMPLER_CUBE\",\n    \"SAMPLER_CUBE_SHADOW\",\n    \"SAMPLES\",\n    \"SAMPLE_ALPHA_TO_COVERAGE\",\n    \"SAMPLE_BUFFERS\",\n    \"SAMPLE_COVERAGE\",\n    \"SAMPLE_COVERAGE_INVERT\",\n    \"SAMPLE_COVERAGE_VALUE\",\n    \"SAWTOOTH\",\n    \"SCHEDULED_STATE\",\n    \"SCISSOR_BOX\",\n    \"SCISSOR_TEST\",\n    \"SCROLL_PAGE_DOWN\",\n    \"SCROLL_PAGE_UP\",\n    \"SDP_ANSWER\",\n    \"SDP_OFFER\",\n    \"SDP_PRANSWER\",\n    \"SECURITY_ERR\",\n    \"SELECT\",\n    \"SEPARATE_ATTRIBS\",\n    \"SERIALIZE_ERR\",\n    \"SEVERITY_ERROR\",\n    \"SEVERITY_FATAL_ERROR\",\n    \"SEVERITY_WARNING\",\n    \"SHADER_COMPILER\",\n    \"SHADER_TYPE\",\n    \"SHADING_LANGUAGE_VERSION\",\n    \"SHIFT_MASK\",\n    \"SHORT\",\n    \"SHOWING\",\n    \"SHOW_ALL\",\n    \"SHOW_ATTRIBUTE\",\n    \"SHOW_CDATA_SECTION\",\n    \"SHOW_COMMENT\",\n    \"SHOW_DOCUMENT\",\n    \"SHOW_DOCUMENT_FRAGMENT\",\n    \"SHOW_DOCUMENT_TYPE\",\n    \"SHOW_ELEMENT\",\n    \"SHOW_ENTITY\",\n    \"SHOW_ENTITY_REFERENCE\",\n    \"SHOW_NOTATION\",\n    \"SHOW_PROCESSING_INSTRUCTION\",\n    \"SHOW_TEXT\",\n    \"SIGNALED\",\n    \"SIGNED_NORMALIZED\",\n    \"SINE\",\n    \"SOUNDFIELD\",\n    \"SQLException\",\n    \"SQRT1_2\",\n    \"SQRT2\",\n    \"SQUARE\",\n    \"SRC_ALPHA\",\n    \"SRC_ALPHA_SATURATE\",\n    \"SRC_COLOR\",\n    \"SRGB\",\n    \"SRGB8\",\n    \"SRGB8_ALPHA8\",\n    \"START_TO_END\",\n    \"START_TO_START\",\n    \"STATIC_COPY\",\n    \"STATIC_DRAW\",\n    \"STATIC_READ\",\n    \"STENCIL\",\n    \"STENCIL_ATTACHMENT\",\n    \"STENCIL_BACK_FAIL\",\n    \"STENCIL_BACK_FUNC\",\n    \"STENCIL_BACK_PASS_DEPTH_FAIL\",\n    \"STENCIL_BACK_PASS_DEPTH_PASS\",\n    \"STENCIL_BACK_REF\",\n    \"STENCIL_BACK_VALUE_MASK\",\n    \"STENCIL_BACK_WRITEMASK\",\n    \"STENCIL_BITS\",\n    \"STENCIL_BUFFER_BIT\",\n    \"STENCIL_CLEAR_VALUE\",\n    \"STENCIL_FAIL\",\n    \"STENCIL_FUNC\",\n    \"STENCIL_INDEX\",\n    \"STENCIL_INDEX8\",\n    \"STENCIL_PASS_DEPTH_FAIL\",\n    \"STENCIL_PASS_DEPTH_PASS\",\n    \"STENCIL_REF\",\n    \"STENCIL_TEST\",\n    \"STENCIL_VALUE_MASK\",\n    \"STENCIL_WRITEMASK\",\n    \"STORAGE\",\n    \"STORAGE_BINDING\",\n    \"STREAM_COPY\",\n    \"STREAM_DRAW\",\n    \"STREAM_READ\",\n    \"STRING_TYPE\",\n    \"STYLE_RULE\",\n    \"SUBPIXEL_BITS\",\n    \"SUPPORTS_RULE\",\n    \"SVGAElement\",\n    \"SVGAltGlyphDefElement\",\n    \"SVGAltGlyphElement\",\n    \"SVGAltGlyphItemElement\",\n    \"SVGAngle\",\n    \"SVGAnimateColorElement\",\n    \"SVGAnimateElement\",\n    \"SVGAnimateMotionElement\",\n    \"SVGAnimateTransformElement\",\n    \"SVGAnimatedAngle\",\n    \"SVGAnimatedBoolean\",\n    \"SVGAnimatedEnumeration\",\n    \"SVGAnimatedInteger\",\n    \"SVGAnimatedLength\",\n    \"SVGAnimatedLengthList\",\n    \"SVGAnimatedNumber\",\n    \"SVGAnimatedNumberList\",\n    \"SVGAnimatedPreserveAspectRatio\",\n    \"SVGAnimatedRect\",\n    \"SVGAnimatedString\",\n    \"SVGAnimatedTransformList\",\n    \"SVGAnimationElement\",\n    \"SVGCircleElement\",\n    \"SVGClipPathElement\",\n    \"SVGColor\",\n    \"SVGComponentTransferFunctionElement\",\n    \"SVGCursorElement\",\n    \"SVGDefsElement\",\n    \"SVGDescElement\",\n    \"SVGDiscardElement\",\n    \"SVGDocument\",\n    \"SVGElement\",\n    \"SVGElementInstance\",\n    \"SVGElementInstanceList\",\n    \"SVGEllipseElement\",\n    \"SVGException\",\n    \"SVGFEBlendElement\",\n    \"SVGFEColorMatrixElement\",\n    \"SVGFEComponentTransferElement\",\n    \"SVGFECompositeElement\",\n    \"SVGFEConvolveMatrixElement\",\n    \"SVGFEDiffuseLightingElement\",\n    \"SVGFEDisplacementMapElement\",\n    \"SVGFEDistantLightElement\",\n    \"SVGFEDropShadowElement\",\n    \"SVGFEFloodElement\",\n    \"SVGFEFuncAElement\",\n    \"SVGFEFuncBElement\",\n    \"SVGFEFuncGElement\",\n    \"SVGFEFuncRElement\",\n    \"SVGFEGaussianBlurElement\",\n    \"SVGFEImageElement\",\n    \"SVGFEMergeElement\",\n    \"SVGFEMergeNodeElement\",\n    \"SVGFEMorphologyElement\",\n    \"SVGFEOffsetElement\",\n    \"SVGFEPointLightElement\",\n    \"SVGFESpecularLightingElement\",\n    \"SVGFESpotLightElement\",\n    \"SVGFETileElement\",\n    \"SVGFETurbulenceElement\",\n    \"SVGFilterElement\",\n    \"SVGFontElement\",\n    \"SVGFontFaceElement\",\n    \"SVGFontFaceFormatElement\",\n    \"SVGFontFaceNameElement\",\n    \"SVGFontFaceSrcElement\",\n    \"SVGFontFaceUriElement\",\n    \"SVGForeignObjectElement\",\n    \"SVGGElement\",\n    \"SVGGeometryElement\",\n    \"SVGGlyphElement\",\n    \"SVGGlyphRefElement\",\n    \"SVGGradientElement\",\n    \"SVGGraphicsElement\",\n    \"SVGHKernElement\",\n    \"SVGImageElement\",\n    \"SVGLength\",\n    \"SVGLengthList\",\n    \"SVGLineElement\",\n    \"SVGLinearGradientElement\",\n    \"SVGMPathElement\",\n    \"SVGMarkerElement\",\n    \"SVGMaskElement\",\n    \"SVGMatrix\",\n    \"SVGMetadataElement\",\n    \"SVGMissingGlyphElement\",\n    \"SVGNumber\",\n    \"SVGNumberList\",\n    \"SVGPaint\",\n    \"SVGPathElement\",\n    \"SVGPathSeg\",\n    \"SVGPathSegArcAbs\",\n    \"SVGPathSegArcRel\",\n    \"SVGPathSegClosePath\",\n    \"SVGPathSegCurvetoCubicAbs\",\n    \"SVGPathSegCurvetoCubicRel\",\n    \"SVGPathSegCurvetoCubicSmoothAbs\",\n    \"SVGPathSegCurvetoCubicSmoothRel\",\n    \"SVGPathSegCurvetoQuadraticAbs\",\n    \"SVGPathSegCurvetoQuadraticRel\",\n    \"SVGPathSegCurvetoQuadraticSmoothAbs\",\n    \"SVGPathSegCurvetoQuadraticSmoothRel\",\n    \"SVGPathSegLinetoAbs\",\n    \"SVGPathSegLinetoHorizontalAbs\",\n    \"SVGPathSegLinetoHorizontalRel\",\n    \"SVGPathSegLinetoRel\",\n    \"SVGPathSegLinetoVerticalAbs\",\n    \"SVGPathSegLinetoVerticalRel\",\n    \"SVGPathSegList\",\n    \"SVGPathSegMovetoAbs\",\n    \"SVGPathSegMovetoRel\",\n    \"SVGPatternElement\",\n    \"SVGPoint\",\n    \"SVGPointList\",\n    \"SVGPolygonElement\",\n    \"SVGPolylineElement\",\n    \"SVGPreserveAspectRatio\",\n    \"SVGRadialGradientElement\",\n    \"SVGRect\",\n    \"SVGRectElement\",\n    \"SVGRenderingIntent\",\n    \"SVGSVGElement\",\n    \"SVGScriptElement\",\n    \"SVGSetElement\",\n    \"SVGStopElement\",\n    \"SVGStringList\",\n    \"SVGStyleElement\",\n    \"SVGSwitchElement\",\n    \"SVGSymbolElement\",\n    \"SVGTRefElement\",\n    \"SVGTSpanElement\",\n    \"SVGTextContentElement\",\n    \"SVGTextElement\",\n    \"SVGTextPathElement\",\n    \"SVGTextPositioningElement\",\n    \"SVGTitleElement\",\n    \"SVGTransform\",\n    \"SVGTransformList\",\n    \"SVGUnitTypes\",\n    \"SVGUseElement\",\n    \"SVGVKernElement\",\n    \"SVGViewElement\",\n    \"SVGViewSpec\",\n    \"SVGZoomAndPan\",\n    \"SVGZoomEvent\",\n    \"SVG_ANGLETYPE_DEG\",\n    \"SVG_ANGLETYPE_GRAD\",\n    \"SVG_ANGLETYPE_RAD\",\n    \"SVG_ANGLETYPE_UNKNOWN\",\n    \"SVG_ANGLETYPE_UNSPECIFIED\",\n    \"SVG_CHANNEL_A\",\n    \"SVG_CHANNEL_B\",\n    \"SVG_CHANNEL_G\",\n    \"SVG_CHANNEL_R\",\n    \"SVG_CHANNEL_UNKNOWN\",\n    \"SVG_COLORTYPE_CURRENTCOLOR\",\n    \"SVG_COLORTYPE_RGBCOLOR\",\n    \"SVG_COLORTYPE_RGBCOLOR_ICCCOLOR\",\n    \"SVG_COLORTYPE_UNKNOWN\",\n    \"SVG_EDGEMODE_DUPLICATE\",\n    \"SVG_EDGEMODE_NONE\",\n    \"SVG_EDGEMODE_UNKNOWN\",\n    \"SVG_EDGEMODE_WRAP\",\n    \"SVG_FEBLEND_MODE_COLOR\",\n    \"SVG_FEBLEND_MODE_COLOR_BURN\",\n    \"SVG_FEBLEND_MODE_COLOR_DODGE\",\n    \"SVG_FEBLEND_MODE_DARKEN\",\n    \"SVG_FEBLEND_MODE_DIFFERENCE\",\n    \"SVG_FEBLEND_MODE_EXCLUSION\",\n    \"SVG_FEBLEND_MODE_HARD_LIGHT\",\n    \"SVG_FEBLEND_MODE_HUE\",\n    \"SVG_FEBLEND_MODE_LIGHTEN\",\n    \"SVG_FEBLEND_MODE_LUMINOSITY\",\n    \"SVG_FEBLEND_MODE_MULTIPLY\",\n    \"SVG_FEBLEND_MODE_NORMAL\",\n    \"SVG_FEBLEND_MODE_OVERLAY\",\n    \"SVG_FEBLEND_MODE_SATURATION\",\n    \"SVG_FEBLEND_MODE_SCREEN\",\n    \"SVG_FEBLEND_MODE_SOFT_LIGHT\",\n    \"SVG_FEBLEND_MODE_UNKNOWN\",\n    \"SVG_FECOLORMATRIX_TYPE_HUEROTATE\",\n    \"SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA\",\n    \"SVG_FECOLORMATRIX_TYPE_MATRIX\",\n    \"SVG_FECOLORMATRIX_TYPE_SATURATE\",\n    \"SVG_FECOLORMATRIX_TYPE_UNKNOWN\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_GAMMA\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_LINEAR\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_TABLE\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN\",\n    \"SVG_FECOMPOSITE_OPERATOR_ARITHMETIC\",\n    \"SVG_FECOMPOSITE_OPERATOR_ATOP\",\n    \"SVG_FECOMPOSITE_OPERATOR_IN\",\n    \"SVG_FECOMPOSITE_OPERATOR_LIGHTER\",\n    \"SVG_FECOMPOSITE_OPERATOR_OUT\",\n    \"SVG_FECOMPOSITE_OPERATOR_OVER\",\n    \"SVG_FECOMPOSITE_OPERATOR_UNKNOWN\",\n    \"SVG_FECOMPOSITE_OPERATOR_XOR\",\n    \"SVG_INVALID_VALUE_ERR\",\n    \"SVG_LENGTHTYPE_CM\",\n    \"SVG_LENGTHTYPE_EMS\",\n    \"SVG_LENGTHTYPE_EXS\",\n    \"SVG_LENGTHTYPE_IN\",\n    \"SVG_LENGTHTYPE_MM\",\n    \"SVG_LENGTHTYPE_NUMBER\",\n    \"SVG_LENGTHTYPE_PC\",\n    \"SVG_LENGTHTYPE_PERCENTAGE\",\n    \"SVG_LENGTHTYPE_PT\",\n    \"SVG_LENGTHTYPE_PX\",\n    \"SVG_LENGTHTYPE_UNKNOWN\",\n    \"SVG_MARKERUNITS_STROKEWIDTH\",\n    \"SVG_MARKERUNITS_UNKNOWN\",\n    \"SVG_MARKERUNITS_USERSPACEONUSE\",\n    \"SVG_MARKER_ORIENT_ANGLE\",\n    \"SVG_MARKER_ORIENT_AUTO\",\n    \"SVG_MARKER_ORIENT_AUTO_START_REVERSE\",\n    \"SVG_MARKER_ORIENT_UNKNOWN\",\n    \"SVG_MASKTYPE_ALPHA\",\n    \"SVG_MASKTYPE_LUMINANCE\",\n    \"SVG_MATRIX_NOT_INVERTABLE\",\n    \"SVG_MEETORSLICE_MEET\",\n    \"SVG_MEETORSLICE_SLICE\",\n    \"SVG_MEETORSLICE_UNKNOWN\",\n    \"SVG_MORPHOLOGY_OPERATOR_DILATE\",\n    \"SVG_MORPHOLOGY_OPERATOR_ERODE\",\n    \"SVG_MORPHOLOGY_OPERATOR_UNKNOWN\",\n    \"SVG_PAINTTYPE_CURRENTCOLOR\",\n    \"SVG_PAINTTYPE_NONE\",\n    \"SVG_PAINTTYPE_RGBCOLOR\",\n    \"SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR\",\n    \"SVG_PAINTTYPE_UNKNOWN\",\n    \"SVG_PAINTTYPE_URI\",\n    \"SVG_PAINTTYPE_URI_CURRENTCOLOR\",\n    \"SVG_PAINTTYPE_URI_NONE\",\n    \"SVG_PAINTTYPE_URI_RGBCOLOR\",\n    \"SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR\",\n    \"SVG_PRESERVEASPECTRATIO_NONE\",\n    \"SVG_PRESERVEASPECTRATIO_UNKNOWN\",\n    \"SVG_PRESERVEASPECTRATIO_XMAXYMAX\",\n    \"SVG_PRESERVEASPECTRATIO_XMAXYMID\",\n    \"SVG_PRESERVEASPECTRATIO_XMAXYMIN\",\n    \"SVG_PRESERVEASPECTRATIO_XMIDYMAX\",\n    \"SVG_PRESERVEASPECTRATIO_XMIDYMID\",\n    \"SVG_PRESERVEASPECTRATIO_XMIDYMIN\",\n    \"SVG_PRESERVEASPECTRATIO_XMINYMAX\",\n    \"SVG_PRESERVEASPECTRATIO_XMINYMID\",\n    \"SVG_PRESERVEASPECTRATIO_XMINYMIN\",\n    \"SVG_SPREADMETHOD_PAD\",\n    \"SVG_SPREADMETHOD_REFLECT\",\n    \"SVG_SPREADMETHOD_REPEAT\",\n    \"SVG_SPREADMETHOD_UNKNOWN\",\n    \"SVG_STITCHTYPE_NOSTITCH\",\n    \"SVG_STITCHTYPE_STITCH\",\n    \"SVG_STITCHTYPE_UNKNOWN\",\n    \"SVG_TRANSFORM_MATRIX\",\n    \"SVG_TRANSFORM_ROTATE\",\n    \"SVG_TRANSFORM_SCALE\",\n    \"SVG_TRANSFORM_SKEWX\",\n    \"SVG_TRANSFORM_SKEWY\",\n    \"SVG_TRANSFORM_TRANSLATE\",\n    \"SVG_TRANSFORM_UNKNOWN\",\n    \"SVG_TURBULENCE_TYPE_FRACTALNOISE\",\n    \"SVG_TURBULENCE_TYPE_TURBULENCE\",\n    \"SVG_TURBULENCE_TYPE_UNKNOWN\",\n    \"SVG_UNIT_TYPE_OBJECTBOUNDINGBOX\",\n    \"SVG_UNIT_TYPE_UNKNOWN\",\n    \"SVG_UNIT_TYPE_USERSPACEONUSE\",\n    \"SVG_WRONG_TYPE_ERR\",\n    \"SVG_ZOOMANDPAN_DISABLE\",\n    \"SVG_ZOOMANDPAN_MAGNIFY\",\n    \"SVG_ZOOMANDPAN_UNKNOWN\",\n    \"SYNC_CONDITION\",\n    \"SYNC_FENCE\",\n    \"SYNC_FLAGS\",\n    \"SYNC_FLUSH_COMMANDS_BIT\",\n    \"SYNC_GPU_COMMANDS_COMPLETE\",\n    \"SYNC_STATUS\",\n    \"SYNTAX_ERR\",\n    \"SavedPages\",\n    \"Scheduler\",\n    \"Scheduling\",\n    \"Screen\",\n    \"ScreenDetailed\",\n    \"ScreenDetails\",\n    \"ScreenOrientation\",\n    \"Script\",\n    \"ScriptProcessorNode\",\n    \"ScrollAreaEvent\",\n    \"ScrollTimeline\",\n    \"SecurityPolicyViolationEvent\",\n    \"Segmenter\",\n    \"Selection\",\n    \"Sensor\",\n    \"SensorErrorEvent\",\n    \"Serial\",\n    \"SerialPort\",\n    \"ServiceWorker\",\n    \"ServiceWorkerContainer\",\n    \"ServiceWorkerRegistration\",\n    \"SessionDescription\",\n    \"Set\",\n    \"ShadowRoot\",\n    \"SharedArrayBuffer\",\n    \"SharedStorage\",\n    \"SharedStorageWorklet\",\n    \"SharedWorker\",\n    \"SharingState\",\n    \"SimpleGestureEvent\",\n    \"SnapEvent\",\n    \"SourceBuffer\",\n    \"SourceBufferList\",\n    \"SpeechSynthesis\",\n    \"SpeechSynthesisErrorEvent\",\n    \"SpeechSynthesisEvent\",\n    \"SpeechSynthesisUtterance\",\n    \"SpeechSynthesisVoice\",\n    \"StaticRange\",\n    \"StereoPannerNode\",\n    \"StopIteration\",\n    \"Storage\",\n    \"StorageBucket\",\n    \"StorageBucketManager\",\n    \"StorageEvent\",\n    \"StorageManager\",\n    \"String\",\n    \"StructType\",\n    \"StylePropertyMap\",\n    \"StylePropertyMapReadOnly\",\n    \"StyleSheet\",\n    \"StyleSheetList\",\n    \"SubmitEvent\",\n    \"SubtleCrypto\",\n    \"Symbol\",\n    \"SyncManager\",\n    \"SyntaxError\",\n    \"TAB_ID_NONE\",\n    \"TAB_INDEX_NONE\",\n    \"TEMPORARY\",\n    \"TEXTPATH_METHODTYPE_ALIGN\",\n    \"TEXTPATH_METHODTYPE_STRETCH\",\n    \"TEXTPATH_METHODTYPE_UNKNOWN\",\n    \"TEXTPATH_SPACINGTYPE_AUTO\",\n    \"TEXTPATH_SPACINGTYPE_EXACT\",\n    \"TEXTPATH_SPACINGTYPE_UNKNOWN\",\n    \"TEXTURE\",\n    \"TEXTURE0\",\n    \"TEXTURE1\",\n    \"TEXTURE10\",\n    \"TEXTURE11\",\n    \"TEXTURE12\",\n    \"TEXTURE13\",\n    \"TEXTURE14\",\n    \"TEXTURE15\",\n    \"TEXTURE16\",\n    \"TEXTURE17\",\n    \"TEXTURE18\",\n    \"TEXTURE19\",\n    \"TEXTURE2\",\n    \"TEXTURE20\",\n    \"TEXTURE21\",\n    \"TEXTURE22\",\n    \"TEXTURE23\",\n    \"TEXTURE24\",\n    \"TEXTURE25\",\n    \"TEXTURE26\",\n    \"TEXTURE27\",\n    \"TEXTURE28\",\n    \"TEXTURE29\",\n    \"TEXTURE3\",\n    \"TEXTURE30\",\n    \"TEXTURE31\",\n    \"TEXTURE4\",\n    \"TEXTURE5\",\n    \"TEXTURE6\",\n    \"TEXTURE7\",\n    \"TEXTURE8\",\n    \"TEXTURE9\",\n    \"TEXTURE_2D\",\n    \"TEXTURE_2D_ARRAY\",\n    \"TEXTURE_3D\",\n    \"TEXTURE_BASE_LEVEL\",\n    \"TEXTURE_BINDING\",\n    \"TEXTURE_BINDING_2D\",\n    \"TEXTURE_BINDING_2D_ARRAY\",\n    \"TEXTURE_BINDING_3D\",\n    \"TEXTURE_BINDING_CUBE_MAP\",\n    \"TEXTURE_COMPARE_FUNC\",\n    \"TEXTURE_COMPARE_MODE\",\n    \"TEXTURE_CUBE_MAP\",\n    \"TEXTURE_CUBE_MAP_NEGATIVE_X\",\n    \"TEXTURE_CUBE_MAP_NEGATIVE_Y\",\n    \"TEXTURE_CUBE_MAP_NEGATIVE_Z\",\n    \"TEXTURE_CUBE_MAP_POSITIVE_X\",\n    \"TEXTURE_CUBE_MAP_POSITIVE_Y\",\n    \"TEXTURE_CUBE_MAP_POSITIVE_Z\",\n    \"TEXTURE_IMMUTABLE_FORMAT\",\n    \"TEXTURE_IMMUTABLE_LEVELS\",\n    \"TEXTURE_MAG_FILTER\",\n    \"TEXTURE_MAX_ANISOTROPY_EXT\",\n    \"TEXTURE_MAX_LEVEL\",\n    \"TEXTURE_MAX_LOD\",\n    \"TEXTURE_MIN_FILTER\",\n    \"TEXTURE_MIN_LOD\",\n    \"TEXTURE_WRAP_R\",\n    \"TEXTURE_WRAP_S\",\n    \"TEXTURE_WRAP_T\",\n    \"TEXT_NODE\",\n    \"TIMEOUT\",\n    \"TIMEOUT_ERR\",\n    \"TIMEOUT_EXPIRED\",\n    \"TIMEOUT_IGNORED\",\n    \"TOO_LARGE_ERR\",\n    \"TRANSACTION_INACTIVE_ERR\",\n    \"TRANSFORM_FEEDBACK\",\n    \"TRANSFORM_FEEDBACK_ACTIVE\",\n    \"TRANSFORM_FEEDBACK_BINDING\",\n    \"TRANSFORM_FEEDBACK_BUFFER\",\n    \"TRANSFORM_FEEDBACK_BUFFER_BINDING\",\n    \"TRANSFORM_FEEDBACK_BUFFER_MODE\",\n    \"TRANSFORM_FEEDBACK_BUFFER_SIZE\",\n    \"TRANSFORM_FEEDBACK_BUFFER_START\",\n    \"TRANSFORM_FEEDBACK_PAUSED\",\n    \"TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN\",\n    \"TRANSFORM_FEEDBACK_VARYINGS\",\n    \"TRIANGLE\",\n    \"TRIANGLES\",\n    \"TRIANGLE_FAN\",\n    \"TRIANGLE_STRIP\",\n    \"TYPE_BACK_FORWARD\",\n    \"TYPE_ERR\",\n    \"TYPE_MISMATCH_ERR\",\n    \"TYPE_NAVIGATE\",\n    \"TYPE_RELOAD\",\n    \"TYPE_RESERVED\",\n    \"Tab\",\n    \"TabStatus\",\n    \"Table\",\n    \"Tag\",\n    \"TaskAttributionTiming\",\n    \"TaskController\",\n    \"TaskPriorityChangeEvent\",\n    \"TaskSignal\",\n    \"Text\",\n    \"TextDecoder\",\n    \"TextDecoderStream\",\n    \"TextEncoder\",\n    \"TextEncoderStream\",\n    \"TextEvent\",\n    \"TextFormat\",\n    \"TextFormatUpdateEvent\",\n    \"TextMetrics\",\n    \"TextTrack\",\n    \"TextTrackCue\",\n    \"TextTrackCueList\",\n    \"TextTrackList\",\n    \"TextUpdateEvent\",\n    \"TimeEvent\",\n    \"TimeRanges\",\n    \"ToggleEvent\",\n    \"Touch\",\n    \"TouchEvent\",\n    \"TouchList\",\n    \"TrackEvent\",\n    \"TransformStream\",\n    \"TransformStreamDefaultController\",\n    \"TransitionEvent\",\n    \"TreeWalker\",\n    \"TrustedHTML\",\n    \"TrustedScript\",\n    \"TrustedScriptURL\",\n    \"TrustedTypePolicy\",\n    \"TrustedTypePolicyFactory\",\n    \"TypeError\",\n    \"TypedObject\",\n    \"U2F\",\n    \"UIEvent\",\n    \"UNCACHED\",\n    \"UNIFORM\",\n    \"UNIFORM_ARRAY_STRIDE\",\n    \"UNIFORM_BLOCK_ACTIVE_UNIFORMS\",\n    \"UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES\",\n    \"UNIFORM_BLOCK_BINDING\",\n    \"UNIFORM_BLOCK_DATA_SIZE\",\n    \"UNIFORM_BLOCK_INDEX\",\n    \"UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER\",\n    \"UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER\",\n    \"UNIFORM_BUFFER\",\n    \"UNIFORM_BUFFER_BINDING\",\n    \"UNIFORM_BUFFER_OFFSET_ALIGNMENT\",\n    \"UNIFORM_BUFFER_SIZE\",\n    \"UNIFORM_BUFFER_START\",\n    \"UNIFORM_IS_ROW_MAJOR\",\n    \"UNIFORM_MATRIX_STRIDE\",\n    \"UNIFORM_OFFSET\",\n    \"UNIFORM_SIZE\",\n    \"UNIFORM_TYPE\",\n    \"UNKNOWN_ERR\",\n    \"UNKNOWN_RULE\",\n    \"UNMASKED_RENDERER_WEBGL\",\n    \"UNMASKED_VENDOR_WEBGL\",\n    \"UNORDERED_NODE_ITERATOR_TYPE\",\n    \"UNORDERED_NODE_SNAPSHOT_TYPE\",\n    \"UNPACK_ALIGNMENT\",\n    \"UNPACK_COLORSPACE_CONVERSION_WEBGL\",\n    \"UNPACK_FLIP_Y_WEBGL\",\n    \"UNPACK_IMAGE_HEIGHT\",\n    \"UNPACK_PREMULTIPLY_ALPHA_WEBGL\",\n    \"UNPACK_ROW_LENGTH\",\n    \"UNPACK_SKIP_IMAGES\",\n    \"UNPACK_SKIP_PIXELS\",\n    \"UNPACK_SKIP_ROWS\",\n    \"UNSCHEDULED_STATE\",\n    \"UNSENT\",\n    \"UNSIGNALED\",\n    \"UNSIGNED_BYTE\",\n    \"UNSIGNED_INT\",\n    \"UNSIGNED_INT_10F_11F_11F_REV\",\n    \"UNSIGNED_INT_24_8\",\n    \"UNSIGNED_INT_2_10_10_10_REV\",\n    \"UNSIGNED_INT_5_9_9_9_REV\",\n    \"UNSIGNED_INT_SAMPLER_2D\",\n    \"UNSIGNED_INT_SAMPLER_2D_ARRAY\",\n    \"UNSIGNED_INT_SAMPLER_3D\",\n    \"UNSIGNED_INT_SAMPLER_CUBE\",\n    \"UNSIGNED_INT_VEC2\",\n    \"UNSIGNED_INT_VEC3\",\n    \"UNSIGNED_INT_VEC4\",\n    \"UNSIGNED_NORMALIZED\",\n    \"UNSIGNED_SHORT\",\n    \"UNSIGNED_SHORT_4_4_4_4\",\n    \"UNSIGNED_SHORT_5_5_5_1\",\n    \"UNSIGNED_SHORT_5_6_5\",\n    \"UNSPECIFIED_EVENT_TYPE_ERR\",\n    \"UPDATEREADY\",\n    \"URIError\",\n    \"URL\",\n    \"URLPattern\",\n    \"URLSearchParams\",\n    \"URLUnencoded\",\n    \"URL_MISMATCH_ERR\",\n    \"USB\",\n    \"USBAlternateInterface\",\n    \"USBConfiguration\",\n    \"USBConnectionEvent\",\n    \"USBDevice\",\n    \"USBEndpoint\",\n    \"USBInTransferResult\",\n    \"USBInterface\",\n    \"USBIsochronousInTransferPacket\",\n    \"USBIsochronousInTransferResult\",\n    \"USBIsochronousOutTransferPacket\",\n    \"USBIsochronousOutTransferResult\",\n    \"USBOutTransferResult\",\n    \"UTC\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"UpdateFilter\",\n    \"UpdatePropertyName\",\n    \"UserActivation\",\n    \"UserMessageHandler\",\n    \"UserMessageHandlersNamespace\",\n    \"UserProximityEvent\",\n    \"VALIDATE_STATUS\",\n    \"VALIDATION_ERR\",\n    \"VARIABLES_RULE\",\n    \"VENDOR\",\n    \"VERSION\",\n    \"VERSION_CHANGE\",\n    \"VERSION_ERR\",\n    \"VERTEX\",\n    \"VERTEX_ARRAY_BINDING\",\n    \"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING\",\n    \"VERTEX_ATTRIB_ARRAY_DIVISOR\",\n    \"VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE\",\n    \"VERTEX_ATTRIB_ARRAY_ENABLED\",\n    \"VERTEX_ATTRIB_ARRAY_INTEGER\",\n    \"VERTEX_ATTRIB_ARRAY_NORMALIZED\",\n    \"VERTEX_ATTRIB_ARRAY_POINTER\",\n    \"VERTEX_ATTRIB_ARRAY_SIZE\",\n    \"VERTEX_ATTRIB_ARRAY_STRIDE\",\n    \"VERTEX_ATTRIB_ARRAY_TYPE\",\n    \"VERTEX_SHADER\",\n    \"VERTICAL\",\n    \"VERTICAL_AXIS\",\n    \"VER_ERR\",\n    \"VIEWPORT\",\n    \"VIEWPORT_RULE\",\n    \"VRDisplay\",\n    \"VRDisplayCapabilities\",\n    \"VRDisplayEvent\",\n    \"VREyeParameters\",\n    \"VRFieldOfView\",\n    \"VRFrameData\",\n    \"VRPose\",\n    \"VRStageParameters\",\n    \"VTTCue\",\n    \"VTTRegion\",\n    \"ValidityState\",\n    \"VideoColorSpace\",\n    \"VideoDecoder\",\n    \"VideoEncoder\",\n    \"VideoFrame\",\n    \"VideoPlaybackQuality\",\n    \"VideoStreamTrack\",\n    \"ViewTimeline\",\n    \"ViewTransition\",\n    \"ViewTransitionTypeSet\",\n    \"ViewType\",\n    \"VirtualKeyboard\",\n    \"VirtualKeyboardGeometryChangeEvent\",\n    \"VisibilityStateEntry\",\n    \"VisualViewport\",\n    \"WAIT_FAILED\",\n    \"WEBKIT_FILTER_RULE\",\n    \"WEBKIT_KEYFRAMES_RULE\",\n    \"WEBKIT_KEYFRAME_RULE\",\n    \"WEBKIT_REGION_RULE\",\n    \"WGSLLanguageFeatures\",\n    \"WINDOW_ID_CURRENT\",\n    \"WINDOW_ID_NONE\",\n    \"WRITE\",\n    \"WRONG_DOCUMENT_ERR\",\n    \"WakeLock\",\n    \"WakeLockSentinel\",\n    \"WasmAnyRef\",\n    \"WaveShaperNode\",\n    \"WeakMap\",\n    \"WeakRef\",\n    \"WeakSet\",\n    \"WebAssembly\",\n    \"WebGL2RenderingContext\",\n    \"WebGLActiveInfo\",\n    \"WebGLBuffer\",\n    \"WebGLContextEvent\",\n    \"WebGLFramebuffer\",\n    \"WebGLObject\",\n    \"WebGLProgram\",\n    \"WebGLQuery\",\n    \"WebGLRenderbuffer\",\n    \"WebGLRenderingContext\",\n    \"WebGLSampler\",\n    \"WebGLShader\",\n    \"WebGLShaderPrecisionFormat\",\n    \"WebGLSync\",\n    \"WebGLTexture\",\n    \"WebGLTransformFeedback\",\n    \"WebGLUniformLocation\",\n    \"WebGLVertexArray\",\n    \"WebGLVertexArrayObject\",\n    \"WebKitAnimationEvent\",\n    \"WebKitBlobBuilder\",\n    \"WebKitCSSFilterRule\",\n    \"WebKitCSSFilterValue\",\n    \"WebKitCSSKeyframeRule\",\n    \"WebKitCSSKeyframesRule\",\n    \"WebKitCSSMatrix\",\n    \"WebKitCSSRegionRule\",\n    \"WebKitCSSTransformValue\",\n    \"WebKitDataCue\",\n    \"WebKitGamepad\",\n    \"WebKitMediaKeyError\",\n    \"WebKitMediaKeyMessageEvent\",\n    \"WebKitMediaKeySession\",\n    \"WebKitMediaKeys\",\n    \"WebKitMediaSource\",\n    \"WebKitMutationObserver\",\n    \"WebKitNamespace\",\n    \"WebKitPlaybackTargetAvailabilityEvent\",\n    \"WebKitPoint\",\n    \"WebKitShadowRoot\",\n    \"WebKitSourceBuffer\",\n    \"WebKitSourceBufferList\",\n    \"WebKitTransitionEvent\",\n    \"WebSocket\",\n    \"WebSocketError\",\n    \"WebSocketStream\",\n    \"WebTransport\",\n    \"WebTransportBidirectionalStream\",\n    \"WebTransportDatagramDuplexStream\",\n    \"WebTransportError\",\n    \"WebTransportReceiveStream\",\n    \"WebTransportSendStream\",\n    \"WebkitAlignContent\",\n    \"WebkitAlignItems\",\n    \"WebkitAlignSelf\",\n    \"WebkitAnimation\",\n    \"WebkitAnimationDelay\",\n    \"WebkitAnimationDirection\",\n    \"WebkitAnimationDuration\",\n    \"WebkitAnimationFillMode\",\n    \"WebkitAnimationIterationCount\",\n    \"WebkitAnimationName\",\n    \"WebkitAnimationPlayState\",\n    \"WebkitAnimationTimingFunction\",\n    \"WebkitAppearance\",\n    \"WebkitBackfaceVisibility\",\n    \"WebkitBackgroundClip\",\n    \"WebkitBackgroundOrigin\",\n    \"WebkitBackgroundSize\",\n    \"WebkitBorderBottomLeftRadius\",\n    \"WebkitBorderBottomRightRadius\",\n    \"WebkitBorderImage\",\n    \"WebkitBorderRadius\",\n    \"WebkitBorderTopLeftRadius\",\n    \"WebkitBorderTopRightRadius\",\n    \"WebkitBoxAlign\",\n    \"WebkitBoxDirection\",\n    \"WebkitBoxFlex\",\n    \"WebkitBoxOrdinalGroup\",\n    \"WebkitBoxOrient\",\n    \"WebkitBoxPack\",\n    \"WebkitBoxShadow\",\n    \"WebkitBoxSizing\",\n    \"WebkitClipPath\",\n    \"WebkitFilter\",\n    \"WebkitFlex\",\n    \"WebkitFlexBasis\",\n    \"WebkitFlexDirection\",\n    \"WebkitFlexFlow\",\n    \"WebkitFlexGrow\",\n    \"WebkitFlexShrink\",\n    \"WebkitFlexWrap\",\n    \"WebkitFontFeatureSettings\",\n    \"WebkitJustifyContent\",\n    \"WebkitLineClamp\",\n    \"WebkitMask\",\n    \"WebkitMaskClip\",\n    \"WebkitMaskComposite\",\n    \"WebkitMaskImage\",\n    \"WebkitMaskOrigin\",\n    \"WebkitMaskPosition\",\n    \"WebkitMaskPositionX\",\n    \"WebkitMaskPositionY\",\n    \"WebkitMaskRepeat\",\n    \"WebkitMaskSize\",\n    \"WebkitOrder\",\n    \"WebkitPerspective\",\n    \"WebkitPerspectiveOrigin\",\n    \"WebkitTextFillColor\",\n    \"WebkitTextSecurity\",\n    \"WebkitTextSizeAdjust\",\n    \"WebkitTextStroke\",\n    \"WebkitTextStrokeColor\",\n    \"WebkitTextStrokeWidth\",\n    \"WebkitTransform\",\n    \"WebkitTransformOrigin\",\n    \"WebkitTransformStyle\",\n    \"WebkitTransition\",\n    \"WebkitTransitionDelay\",\n    \"WebkitTransitionDuration\",\n    \"WebkitTransitionProperty\",\n    \"WebkitTransitionTimingFunction\",\n    \"WebkitUserSelect\",\n    \"WheelEvent\",\n    \"Window\",\n    \"WindowControlsOverlay\",\n    \"WindowControlsOverlayGeometryChangeEvent\",\n    \"WindowState\",\n    \"WindowType\",\n    \"Worker\",\n    \"Worklet\",\n    \"WritableStream\",\n    \"WritableStreamDefaultController\",\n    \"WritableStreamDefaultWriter\",\n    \"XMLDocument\",\n    \"XMLHttpRequest\",\n    \"XMLHttpRequestEventTarget\",\n    \"XMLHttpRequestException\",\n    \"XMLHttpRequestProgressEvent\",\n    \"XMLHttpRequestUpload\",\n    \"XMLSerializer\",\n    \"XMLStylesheetProcessingInstruction\",\n    \"XPathEvaluator\",\n    \"XPathException\",\n    \"XPathExpression\",\n    \"XPathNSResolver\",\n    \"XPathResult\",\n    \"XRAnchor\",\n    \"XRAnchorSet\",\n    \"XRBoundedReferenceSpace\",\n    \"XRCPUDepthInformation\",\n    \"XRCamera\",\n    \"XRDOMOverlayState\",\n    \"XRDepthInformation\",\n    \"XRFrame\",\n    \"XRHand\",\n    \"XRHitTestResult\",\n    \"XRHitTestSource\",\n    \"XRInputSource\",\n    \"XRInputSourceArray\",\n    \"XRInputSourceEvent\",\n    \"XRInputSourcesChangeEvent\",\n    \"XRJointPose\",\n    \"XRJointSpace\",\n    \"XRLayer\",\n    \"XRLightEstimate\",\n    \"XRLightProbe\",\n    \"XRPose\",\n    \"XRRay\",\n    \"XRReferenceSpace\",\n    \"XRReferenceSpaceEvent\",\n    \"XRRenderState\",\n    \"XRRigidTransform\",\n    \"XRSession\",\n    \"XRSessionEvent\",\n    \"XRSpace\",\n    \"XRSystem\",\n    \"XRTransientInputHitTestResult\",\n    \"XRTransientInputHitTestSource\",\n    \"XRView\",\n    \"XRViewerPose\",\n    \"XRViewport\",\n    \"XRWebGLBinding\",\n    \"XRWebGLDepthInformation\",\n    \"XRWebGLLayer\",\n    \"XSLTProcessor\",\n    \"ZERO\",\n    \"ZoomSettings\",\n    \"ZoomSettingsMode\",\n    \"ZoomSettingsScope\",\n    \"_XD0M_\",\n    \"_YD0M_\",\n    \"__REACT_DEVTOOLS_GLOBAL_HOOK__\",\n    \"__brand\",\n    \"__defineGetter__\",\n    \"__defineSetter__\",\n    \"__lookupGetter__\",\n    \"__lookupSetter__\",\n    \"__opera\",\n    \"__proto__\",\n    \"_browserjsran\",\n    \"a\",\n    \"aLink\",\n    \"abbr\",\n    \"abort\",\n    \"aborted\",\n    \"aboutConfigPrefs\",\n    \"abs\",\n    \"absolute\",\n    \"acceleration\",\n    \"accelerationIncludingGravity\",\n    \"accelerator\",\n    \"accent-color\",\n    \"accentColor\",\n    \"accept\",\n    \"acceptCharset\",\n    \"acceptNode\",\n    \"access\",\n    \"accessKey\",\n    \"accessKeyLabel\",\n    \"accuracy\",\n    \"acos\",\n    \"acosh\",\n    \"action\",\n    \"actionURL\",\n    \"actions\",\n    \"activated\",\n    \"activation\",\n    \"activationStart\",\n    \"active\",\n    \"activeCues\",\n    \"activeElement\",\n    \"activeSourceBuffers\",\n    \"activeSourceCount\",\n    \"activeTexture\",\n    \"activeVRDisplays\",\n    \"activityLog\",\n    \"actualBoundingBoxAscent\",\n    \"actualBoundingBoxDescent\",\n    \"actualBoundingBoxLeft\",\n    \"actualBoundingBoxRight\",\n    \"adAuctionComponents\",\n    \"adAuctionHeaders\",\n    \"add\",\n    \"addAll\",\n    \"addBehavior\",\n    \"addCandidate\",\n    \"addColorStop\",\n    \"addCue\",\n    \"addElement\",\n    \"addEventListener\",\n    \"addFilter\",\n    \"addFromString\",\n    \"addFromUri\",\n    \"addIceCandidate\",\n    \"addImport\",\n    \"addListener\",\n    \"addModule\",\n    \"addNamed\",\n    \"addPageRule\",\n    \"addPath\",\n    \"addPointer\",\n    \"addRange\",\n    \"addRegion\",\n    \"addRule\",\n    \"addSearchEngine\",\n    \"addSourceBuffer\",\n    \"addStream\",\n    \"addTextTrack\",\n    \"addTrack\",\n    \"addTransceiver\",\n    \"addWakeLockListener\",\n    \"added\",\n    \"addedNodes\",\n    \"additionalName\",\n    \"additiveSymbols\",\n    \"addons\",\n    \"address\",\n    \"addressLine\",\n    \"addressModeU\",\n    \"addressModeV\",\n    \"addressModeW\",\n    \"adoptNode\",\n    \"adoptedCallback\",\n    \"adoptedStyleSheets\",\n    \"adr\",\n    \"advance\",\n    \"after\",\n    \"alarms\",\n    \"album\",\n    \"alert\",\n    \"algorithm\",\n    \"align\",\n    \"align-content\",\n    \"align-items\",\n    \"align-self\",\n    \"alignContent\",\n    \"alignItems\",\n    \"alignSelf\",\n    \"alignmentBaseline\",\n    \"alinkColor\",\n    \"all\",\n    \"allSettled\",\n    \"allocationSize\",\n    \"allow\",\n    \"allowFullscreen\",\n    \"allowPaymentRequest\",\n    \"allowedDirections\",\n    \"allowedFeatures\",\n    \"allowedToPlay\",\n    \"allowsFeature\",\n    \"alpha\",\n    \"alphaMode\",\n    \"alphaToCoverageEnabled\",\n    \"alphabeticBaseline\",\n    \"alt\",\n    \"altGraphKey\",\n    \"altHtml\",\n    \"altKey\",\n    \"altLeft\",\n    \"alternate\",\n    \"alternateSetting\",\n    \"alternates\",\n    \"altitude\",\n    \"altitudeAccuracy\",\n    \"altitudeAngle\",\n    \"amplitude\",\n    \"ancestorOrigins\",\n    \"anchor\",\n    \"anchorNode\",\n    \"anchorOffset\",\n    \"anchorSpace\",\n    \"anchors\",\n    \"and\",\n    \"angle\",\n    \"angularAcceleration\",\n    \"angularVelocity\",\n    \"animVal\",\n    \"animate\",\n    \"animated\",\n    \"animatedInstanceRoot\",\n    \"animatedNormalizedPathSegList\",\n    \"animatedPathSegList\",\n    \"animatedPoints\",\n    \"animation\",\n    \"animation-composition\",\n    \"animation-delay\",\n    \"animation-direction\",\n    \"animation-duration\",\n    \"animation-fill-mode\",\n    \"animation-iteration-count\",\n    \"animation-name\",\n    \"animation-play-state\",\n    \"animation-timing-function\",\n    \"animationComposition\",\n    \"animationDelay\",\n    \"animationDirection\",\n    \"animationDuration\",\n    \"animationFillMode\",\n    \"animationIterationCount\",\n    \"animationName\",\n    \"animationPlayState\",\n    \"animationStartTime\",\n    \"animationTimingFunction\",\n    \"animationsPaused\",\n    \"anniversary\",\n    \"antialias\",\n    \"anticipatedRemoval\",\n    \"any\",\n    \"app\",\n    \"appCodeName\",\n    \"appMinorVersion\",\n    \"appName\",\n    \"appNotifications\",\n    \"appVersion\",\n    \"appearance\",\n    \"append\",\n    \"appendBuffer\",\n    \"appendChild\",\n    \"appendData\",\n    \"appendItem\",\n    \"appendMedium\",\n    \"appendNamed\",\n    \"appendRule\",\n    \"appendStream\",\n    \"appendWindowEnd\",\n    \"appendWindowStart\",\n    \"applets\",\n    \"applicationCache\",\n    \"applicationServerKey\",\n    \"apply\",\n    \"applyConstraints\",\n    \"applyElement\",\n    \"arc\",\n    \"arcTo\",\n    \"arch\",\n    \"architecture\",\n    \"archive\",\n    \"areas\",\n    \"arguments\",\n    \"ariaAtomic\",\n    \"ariaAutoComplete\",\n    \"ariaBrailleLabel\",\n    \"ariaBrailleRoleDescription\",\n    \"ariaBusy\",\n    \"ariaChecked\",\n    \"ariaColCount\",\n    \"ariaColIndex\",\n    \"ariaColIndexText\",\n    \"ariaColSpan\",\n    \"ariaCurrent\",\n    \"ariaDescription\",\n    \"ariaDisabled\",\n    \"ariaExpanded\",\n    \"ariaHasPopup\",\n    \"ariaHidden\",\n    \"ariaInvalid\",\n    \"ariaKeyShortcuts\",\n    \"ariaLabel\",\n    \"ariaLevel\",\n    \"ariaLive\",\n    \"ariaModal\",\n    \"ariaMultiLine\",\n    \"ariaMultiSelectable\",\n    \"ariaOrientation\",\n    \"ariaPlaceholder\",\n    \"ariaPosInSet\",\n    \"ariaPressed\",\n    \"ariaReadOnly\",\n    \"ariaRelevant\",\n    \"ariaRequired\",\n    \"ariaRoleDescription\",\n    \"ariaRowCount\",\n    \"ariaRowIndex\",\n    \"ariaRowIndexText\",\n    \"ariaRowSpan\",\n    \"ariaSelected\",\n    \"ariaSetSize\",\n    \"ariaSort\",\n    \"ariaValueMax\",\n    \"ariaValueMin\",\n    \"ariaValueNow\",\n    \"ariaValueText\",\n    \"arrayBuffer\",\n    \"arrayLayerCount\",\n    \"arrayStride\",\n    \"artist\",\n    \"artwork\",\n    \"as\",\n    \"asIntN\",\n    \"asUintN\",\n    \"ascentOverride\",\n    \"asin\",\n    \"asinh\",\n    \"aspect\",\n    \"aspect-ratio\",\n    \"aspectRatio\",\n    \"assert\",\n    \"assign\",\n    \"assignedElements\",\n    \"assignedNodes\",\n    \"assignedSlot\",\n    \"async\",\n    \"asyncDispose\",\n    \"asyncIterator\",\n    \"at\",\n    \"atEnd\",\n    \"atan\",\n    \"atan2\",\n    \"atanh\",\n    \"atob\",\n    \"attachEvent\",\n    \"attachInternals\",\n    \"attachShader\",\n    \"attachShadow\",\n    \"attachedElements\",\n    \"attachments\",\n    \"attack\",\n    \"attestationObject\",\n    \"attrChange\",\n    \"attrName\",\n    \"attributeChangedCallback\",\n    \"attributeFilter\",\n    \"attributeName\",\n    \"attributeNamespace\",\n    \"attributeOldValue\",\n    \"attributeStyleMap\",\n    \"attributes\",\n    \"attribution\",\n    \"attributionSrc\",\n    \"audioBitrateMode\",\n    \"audioBitsPerSecond\",\n    \"audioTracks\",\n    \"audioWorklet\",\n    \"authenticatedSignedWrites\",\n    \"authenticatorAttachment\",\n    \"authenticatorData\",\n    \"autoIncrement\",\n    \"autobuffer\",\n    \"autocapitalize\",\n    \"autocomplete\",\n    \"autocorrect\",\n    \"autofocus\",\n    \"automationRate\",\n    \"autoplay\",\n    \"availHeight\",\n    \"availLeft\",\n    \"availTop\",\n    \"availWidth\",\n    \"availability\",\n    \"available\",\n    \"averageLatency\",\n    \"aversion\",\n    \"ax\",\n    \"axes\",\n    \"axis\",\n    \"ay\",\n    \"azimuth\",\n    \"azimuthAngle\",\n    \"b\",\n    \"back\",\n    \"backdrop-filter\",\n    \"backdropFilter\",\n    \"backends\",\n    \"backface-visibility\",\n    \"backfaceVisibility\",\n    \"background\",\n    \"background-attachment\",\n    \"background-blend-mode\",\n    \"background-clip\",\n    \"background-color\",\n    \"background-image\",\n    \"background-origin\",\n    \"background-position\",\n    \"background-position-x\",\n    \"background-position-y\",\n    \"background-repeat\",\n    \"background-size\",\n    \"backgroundAttachment\",\n    \"backgroundBlendMode\",\n    \"backgroundClip\",\n    \"backgroundColor\",\n    \"backgroundFetch\",\n    \"backgroundImage\",\n    \"backgroundOrigin\",\n    \"backgroundPosition\",\n    \"backgroundPositionX\",\n    \"backgroundPositionY\",\n    \"backgroundRepeat\",\n    \"backgroundSize\",\n    \"badInput\",\n    \"badge\",\n    \"balance\",\n    \"baseArrayLayer\",\n    \"baseFrequencyX\",\n    \"baseFrequencyY\",\n    \"baseLatency\",\n    \"baseLayer\",\n    \"baseMipLevel\",\n    \"baseNode\",\n    \"baseOffset\",\n    \"basePalette\",\n    \"baseURI\",\n    \"baseVal\",\n    \"baseline-source\",\n    \"baselineShift\",\n    \"baselineSource\",\n    \"battery\",\n    \"bday\",\n    \"before\",\n    \"beginComputePass\",\n    \"beginElement\",\n    \"beginElementAt\",\n    \"beginOcclusionQuery\",\n    \"beginPath\",\n    \"beginQuery\",\n    \"beginRenderPass\",\n    \"beginTransformFeedback\",\n    \"beginningOfPassWriteIndex\",\n    \"behavior\",\n    \"behaviorCookie\",\n    \"behaviorPart\",\n    \"behaviorUrns\",\n    \"beta\",\n    \"bezierCurveTo\",\n    \"bgColor\",\n    \"bgProperties\",\n    \"bias\",\n    \"big\",\n    \"bigint64\",\n    \"biguint64\",\n    \"binaryType\",\n    \"bind\",\n    \"bindAttribLocation\",\n    \"bindBuffer\",\n    \"bindBufferBase\",\n    \"bindBufferRange\",\n    \"bindFramebuffer\",\n    \"bindGroupLayouts\",\n    \"bindRenderbuffer\",\n    \"bindSampler\",\n    \"bindTexture\",\n    \"bindTransformFeedback\",\n    \"bindVertexArray\",\n    \"binding\",\n    \"bitness\",\n    \"blend\",\n    \"blendColor\",\n    \"blendEquation\",\n    \"blendEquationSeparate\",\n    \"blendFunc\",\n    \"blendFuncSeparate\",\n    \"blink\",\n    \"blitFramebuffer\",\n    \"blob\",\n    \"block-size\",\n    \"blockDirection\",\n    \"blockSize\",\n    \"blockedURI\",\n    \"blocking\",\n    \"blockingDuration\",\n    \"blue\",\n    \"bluetooth\",\n    \"blur\",\n    \"body\",\n    \"bodyUsed\",\n    \"bold\",\n    \"bookmarks\",\n    \"booleanValue\",\n    \"border\",\n    \"border-block\",\n    \"border-block-color\",\n    \"border-block-end\",\n    \"border-block-end-color\",\n    \"border-block-end-style\",\n    \"border-block-end-width\",\n    \"border-block-start\",\n    \"border-block-start-color\",\n    \"border-block-start-style\",\n    \"border-block-start-width\",\n    \"border-block-style\",\n    \"border-block-width\",\n    \"border-bottom\",\n    \"border-bottom-color\",\n    \"border-bottom-left-radius\",\n    \"border-bottom-right-radius\",\n    \"border-bottom-style\",\n    \"border-bottom-width\",\n    \"border-collapse\",\n    \"border-color\",\n    \"border-end-end-radius\",\n    \"border-end-start-radius\",\n    \"border-image\",\n    \"border-image-outset\",\n    \"border-image-repeat\",\n    \"border-image-slice\",\n    \"border-image-source\",\n    \"border-image-width\",\n    \"border-inline\",\n    \"border-inline-color\",\n    \"border-inline-end\",\n    \"border-inline-end-color\",\n    \"border-inline-end-style\",\n    \"border-inline-end-width\",\n    \"border-inline-start\",\n    \"border-inline-start-color\",\n    \"border-inline-start-style\",\n    \"border-inline-start-width\",\n    \"border-inline-style\",\n    \"border-inline-width\",\n    \"border-left\",\n    \"border-left-color\",\n    \"border-left-style\",\n    \"border-left-width\",\n    \"border-radius\",\n    \"border-right\",\n    \"border-right-color\",\n    \"border-right-style\",\n    \"border-right-width\",\n    \"border-spacing\",\n    \"border-start-end-radius\",\n    \"border-start-start-radius\",\n    \"border-style\",\n    \"border-top\",\n    \"border-top-color\",\n    \"border-top-left-radius\",\n    \"border-top-right-radius\",\n    \"border-top-style\",\n    \"border-top-width\",\n    \"border-width\",\n    \"borderBlock\",\n    \"borderBlockColor\",\n    \"borderBlockEnd\",\n    \"borderBlockEndColor\",\n    \"borderBlockEndStyle\",\n    \"borderBlockEndWidth\",\n    \"borderBlockStart\",\n    \"borderBlockStartColor\",\n    \"borderBlockStartStyle\",\n    \"borderBlockStartWidth\",\n    \"borderBlockStyle\",\n    \"borderBlockWidth\",\n    \"borderBottom\",\n    \"borderBottomColor\",\n    \"borderBottomLeftRadius\",\n    \"borderBottomRightRadius\",\n    \"borderBottomStyle\",\n    \"borderBottomWidth\",\n    \"borderBoxSize\",\n    \"borderCollapse\",\n    \"borderColor\",\n    \"borderColorDark\",\n    \"borderColorLight\",\n    \"borderEndEndRadius\",\n    \"borderEndStartRadius\",\n    \"borderImage\",\n    \"borderImageOutset\",\n    \"borderImageRepeat\",\n    \"borderImageSlice\",\n    \"borderImageSource\",\n    \"borderImageWidth\",\n    \"borderInline\",\n    \"borderInlineColor\",\n    \"borderInlineEnd\",\n    \"borderInlineEndColor\",\n    \"borderInlineEndStyle\",\n    \"borderInlineEndWidth\",\n    \"borderInlineStart\",\n    \"borderInlineStartColor\",\n    \"borderInlineStartStyle\",\n    \"borderInlineStartWidth\",\n    \"borderInlineStyle\",\n    \"borderInlineWidth\",\n    \"borderLeft\",\n    \"borderLeftColor\",\n    \"borderLeftStyle\",\n    \"borderLeftWidth\",\n    \"borderRadius\",\n    \"borderRight\",\n    \"borderRightColor\",\n    \"borderRightStyle\",\n    \"borderRightWidth\",\n    \"borderSpacing\",\n    \"borderStartEndRadius\",\n    \"borderStartStartRadius\",\n    \"borderStyle\",\n    \"borderTop\",\n    \"borderTopColor\",\n    \"borderTopLeftRadius\",\n    \"borderTopRightRadius\",\n    \"borderTopStyle\",\n    \"borderTopWidth\",\n    \"borderWidth\",\n    \"bottom\",\n    \"bottomMargin\",\n    \"bound\",\n    \"boundElements\",\n    \"boundingClientRect\",\n    \"boundingHeight\",\n    \"boundingLeft\",\n    \"boundingRect\",\n    \"boundingTop\",\n    \"boundingWidth\",\n    \"bounds\",\n    \"boundsGeometry\",\n    \"box-decoration-break\",\n    \"box-shadow\",\n    \"box-sizing\",\n    \"boxDecorationBreak\",\n    \"boxShadow\",\n    \"boxSizing\",\n    \"brand\",\n    \"brands\",\n    \"break-after\",\n    \"break-before\",\n    \"break-inside\",\n    \"breakAfter\",\n    \"breakBefore\",\n    \"breakInside\",\n    \"broadcast\",\n    \"browser\",\n    \"browserLanguage\",\n    \"browserSettings\",\n    \"browsingData\",\n    \"browsingTopics\",\n    \"btoa\",\n    \"bubbles\",\n    \"buffer\",\n    \"bufferData\",\n    \"bufferDepth\",\n    \"bufferSize\",\n    \"bufferSubData\",\n    \"buffered\",\n    \"bufferedAmount\",\n    \"bufferedAmountLowThreshold\",\n    \"buffers\",\n    \"buildID\",\n    \"buildNumber\",\n    \"button\",\n    \"buttonID\",\n    \"buttons\",\n    \"byobRequest\",\n    \"byteLength\",\n    \"byteOffset\",\n    \"bytes\",\n    \"bytesPerRow\",\n    \"bytesWritten\",\n    \"c\",\n    \"cache\",\n    \"caches\",\n    \"call\",\n    \"caller\",\n    \"camera\",\n    \"canBeFormatted\",\n    \"canBeMounted\",\n    \"canBeShared\",\n    \"canConstructInDedicatedWorker\",\n    \"canGoBack\",\n    \"canGoForward\",\n    \"canHaveChildren\",\n    \"canHaveHTML\",\n    \"canInsertDTMF\",\n    \"canIntercept\",\n    \"canLoadAdAuctionFencedFrame\",\n    \"canLoadOpaqueURL\",\n    \"canMakePayment\",\n    \"canParse\",\n    \"canPlayType\",\n    \"canPresent\",\n    \"canShare\",\n    \"canTransition\",\n    \"canTrickleIceCandidates\",\n    \"cancel\",\n    \"cancelAndHoldAtTime\",\n    \"cancelAnimationFrame\",\n    \"cancelBubble\",\n    \"cancelIdleCallback\",\n    \"cancelScheduledValues\",\n    \"cancelVideoFrameCallback\",\n    \"cancelWatchAvailability\",\n    \"cancelable\",\n    \"candidate\",\n    \"canonicalUUID\",\n    \"canvas\",\n    \"cap\",\n    \"capabilities\",\n    \"caption\",\n    \"caption-side\",\n    \"captionSide\",\n    \"captivePortal\",\n    \"capture\",\n    \"captureEvents\",\n    \"captureStackTrace\",\n    \"captureStream\",\n    \"captureTab\",\n    \"captureVisibleTab\",\n    \"caret-color\",\n    \"caretBidiLevel\",\n    \"caretColor\",\n    \"caretPositionFromPoint\",\n    \"caretRangeFromPoint\",\n    \"cast\",\n    \"catch\",\n    \"category\",\n    \"cbrt\",\n    \"cd\",\n    \"ceil\",\n    \"cellIndex\",\n    \"cellPadding\",\n    \"cellSpacing\",\n    \"cells\",\n    \"ch\",\n    \"chOff\",\n    \"chain\",\n    \"challenge\",\n    \"changeType\",\n    \"changed\",\n    \"changedTouches\",\n    \"channel\",\n    \"channelCount\",\n    \"channelCountMode\",\n    \"channelInterpretation\",\n    \"chapterInfo\",\n    \"char\",\n    \"charAt\",\n    \"charCode\",\n    \"charCodeAt\",\n    \"charIndex\",\n    \"charLength\",\n    \"characterBounds\",\n    \"characterBoundsRangeStart\",\n    \"characterData\",\n    \"characterDataOldValue\",\n    \"characterSet\",\n    \"characteristic\",\n    \"charging\",\n    \"chargingTime\",\n    \"charset\",\n    \"check\",\n    \"checkDCE\",\n    \"checkEnclosure\",\n    \"checkFramebufferStatus\",\n    \"checkIntersection\",\n    \"checkValidity\",\n    \"checkVisibility\",\n    \"checked\",\n    \"childElementCount\",\n    \"childList\",\n    \"childNodes\",\n    \"children\",\n    \"chrome\",\n    \"ciphertext\",\n    \"cite\",\n    \"city\",\n    \"claimInterface\",\n    \"claimed\",\n    \"classList\",\n    \"className\",\n    \"classid\",\n    \"clear\",\n    \"clearAppBadge\",\n    \"clearAttributes\",\n    \"clearBuffer\",\n    \"clearBufferfi\",\n    \"clearBufferfv\",\n    \"clearBufferiv\",\n    \"clearBufferuiv\",\n    \"clearColor\",\n    \"clearData\",\n    \"clearDepth\",\n    \"clearHalt\",\n    \"clearImmediate\",\n    \"clearInterval\",\n    \"clearLiveSeekableRange\",\n    \"clearMarks\",\n    \"clearMaxGCPauseAccumulator\",\n    \"clearMeasures\",\n    \"clearOriginJoinedAdInterestGroups\",\n    \"clearParameters\",\n    \"clearRect\",\n    \"clearResourceTimings\",\n    \"clearShadow\",\n    \"clearStencil\",\n    \"clearTimeout\",\n    \"clearValue\",\n    \"clearWatch\",\n    \"click\",\n    \"clickCount\",\n    \"clientDataJSON\",\n    \"clientHeight\",\n    \"clientInformation\",\n    \"clientLeft\",\n    \"clientRect\",\n    \"clientRects\",\n    \"clientTop\",\n    \"clientWaitSync\",\n    \"clientWidth\",\n    \"clientX\",\n    \"clientY\",\n    \"clip\",\n    \"clip-path\",\n    \"clip-rule\",\n    \"clipBottom\",\n    \"clipLeft\",\n    \"clipPath\",\n    \"clipPathUnits\",\n    \"clipRight\",\n    \"clipRule\",\n    \"clipTop\",\n    \"clipboard\",\n    \"clipboardData\",\n    \"clonable\",\n    \"clone\",\n    \"cloneContents\",\n    \"cloneNode\",\n    \"cloneRange\",\n    \"close\",\n    \"closeCode\",\n    \"closePath\",\n    \"closed\",\n    \"closest\",\n    \"clz\",\n    \"clz32\",\n    \"cm\",\n    \"cmp\",\n    \"code\",\n    \"codeBase\",\n    \"codePointAt\",\n    \"codeType\",\n    \"codedHeight\",\n    \"codedRect\",\n    \"codedWidth\",\n    \"colSpan\",\n    \"collapse\",\n    \"collapseToEnd\",\n    \"collapseToStart\",\n    \"collapsed\",\n    \"collect\",\n    \"collections\",\n    \"colno\",\n    \"color\",\n    \"color-adjust\",\n    \"color-interpolation\",\n    \"color-interpolation-filters\",\n    \"color-scheme\",\n    \"colorAdjust\",\n    \"colorAttachments\",\n    \"colorDepth\",\n    \"colorFormats\",\n    \"colorInterpolation\",\n    \"colorInterpolationFilters\",\n    \"colorMask\",\n    \"colorScheme\",\n    \"colorSpace\",\n    \"colorType\",\n    \"cols\",\n    \"column-count\",\n    \"column-fill\",\n    \"column-gap\",\n    \"column-rule\",\n    \"column-rule-color\",\n    \"column-rule-style\",\n    \"column-rule-width\",\n    \"column-span\",\n    \"column-width\",\n    \"columnCount\",\n    \"columnFill\",\n    \"columnGap\",\n    \"columnNumber\",\n    \"columnRule\",\n    \"columnRuleColor\",\n    \"columnRuleStyle\",\n    \"columnRuleWidth\",\n    \"columnSpan\",\n    \"columnWidth\",\n    \"columns\",\n    \"command\",\n    \"commands\",\n    \"commit\",\n    \"commitLoadTime\",\n    \"commitPreferences\",\n    \"commitStyles\",\n    \"commonAncestorContainer\",\n    \"compact\",\n    \"compare\",\n    \"compareBoundaryPoints\",\n    \"compareDocumentPosition\",\n    \"compareEndPoints\",\n    \"compareExchange\",\n    \"compareNode\",\n    \"comparePoint\",\n    \"compatMode\",\n    \"compatible\",\n    \"compile\",\n    \"compileShader\",\n    \"compileStreaming\",\n    \"complete\",\n    \"completed\",\n    \"component\",\n    \"componentFromPoint\",\n    \"composed\",\n    \"composedPath\",\n    \"composite\",\n    \"compositionEndOffset\",\n    \"compositionStartOffset\",\n    \"compressedTexImage2D\",\n    \"compressedTexImage3D\",\n    \"compressedTexSubImage2D\",\n    \"compressedTexSubImage3D\",\n    \"compute\",\n    \"computedStyleMap\",\n    \"concat\",\n    \"conditionText\",\n    \"coneInnerAngle\",\n    \"coneOuterAngle\",\n    \"coneOuterGain\",\n    \"config\",\n    \"configurable\",\n    \"configuration\",\n    \"configurationName\",\n    \"configurationValue\",\n    \"configurations\",\n    \"configure\",\n    \"confirm\",\n    \"confirmComposition\",\n    \"confirmSiteSpecificTrackingException\",\n    \"confirmWebWideTrackingException\",\n    \"congestionControl\",\n    \"connect\",\n    \"connectEnd\",\n    \"connectNative\",\n    \"connectShark\",\n    \"connectStart\",\n    \"connected\",\n    \"connectedCallback\",\n    \"connection\",\n    \"connectionInfo\",\n    \"connectionList\",\n    \"connectionSpeed\",\n    \"connectionState\",\n    \"connections\",\n    \"console\",\n    \"consolidate\",\n    \"constants\",\n    \"constraint\",\n    \"constrictionActive\",\n    \"construct\",\n    \"constructor\",\n    \"contactID\",\n    \"contain\",\n    \"contain-intrinsic-block-size\",\n    \"contain-intrinsic-height\",\n    \"contain-intrinsic-inline-size\",\n    \"contain-intrinsic-size\",\n    \"contain-intrinsic-width\",\n    \"containIntrinsicBlockSize\",\n    \"containIntrinsicHeight\",\n    \"containIntrinsicInlineSize\",\n    \"containIntrinsicSize\",\n    \"containIntrinsicWidth\",\n    \"container\",\n    \"container-name\",\n    \"container-type\",\n    \"containerId\",\n    \"containerName\",\n    \"containerQuery\",\n    \"containerSrc\",\n    \"containerType\",\n    \"contains\",\n    \"containsNode\",\n    \"content\",\n    \"content-visibility\",\n    \"contentBoxSize\",\n    \"contentDocument\",\n    \"contentEditable\",\n    \"contentHint\",\n    \"contentOverflow\",\n    \"contentRect\",\n    \"contentScriptType\",\n    \"contentStyleType\",\n    \"contentType\",\n    \"contentVisibility\",\n    \"contentWindow\",\n    \"context\",\n    \"contextId\",\n    \"contextIds\",\n    \"contextMenu\",\n    \"contextMenus\",\n    \"contextType\",\n    \"contextTypes\",\n    \"contextmenu\",\n    \"contextualIdentities\",\n    \"continue\",\n    \"continuePrimaryKey\",\n    \"continuous\",\n    \"control\",\n    \"controlTransferIn\",\n    \"controlTransferOut\",\n    \"controller\",\n    \"controls\",\n    \"controlsList\",\n    \"convertPointFromNode\",\n    \"convertQuadFromNode\",\n    \"convertRectFromNode\",\n    \"convertToBlob\",\n    \"convertToSpecifiedUnits\",\n    \"cookie\",\n    \"cookieEnabled\",\n    \"cookieStore\",\n    \"cookies\",\n    \"coords\",\n    \"copyBufferSubData\",\n    \"copyBufferToBuffer\",\n    \"copyBufferToTexture\",\n    \"copyExternalImageToTexture\",\n    \"copyFromChannel\",\n    \"copyTexImage2D\",\n    \"copyTexSubImage2D\",\n    \"copyTexSubImage3D\",\n    \"copyTextureToBuffer\",\n    \"copyTextureToTexture\",\n    \"copyTo\",\n    \"copyToChannel\",\n    \"copyWithin\",\n    \"correspondingElement\",\n    \"correspondingUseElement\",\n    \"corruptedVideoFrames\",\n    \"cos\",\n    \"cosh\",\n    \"count\",\n    \"countReset\",\n    \"counter-increment\",\n    \"counter-reset\",\n    \"counter-set\",\n    \"counterIncrement\",\n    \"counterReset\",\n    \"counterSet\",\n    \"country\",\n    \"cpuClass\",\n    \"cpuSleepAllowed\",\n    \"cqb\",\n    \"cqh\",\n    \"cqi\",\n    \"cqmax\",\n    \"cqmin\",\n    \"cqw\",\n    \"create\",\n    \"createAnalyser\",\n    \"createAnchor\",\n    \"createAnswer\",\n    \"createAttribute\",\n    \"createAttributeNS\",\n    \"createAuctionNonce\",\n    \"createBidirectionalStream\",\n    \"createBindGroup\",\n    \"createBindGroupLayout\",\n    \"createBiquadFilter\",\n    \"createBuffer\",\n    \"createBufferSource\",\n    \"createCDATASection\",\n    \"createCSSStyleSheet\",\n    \"createCaption\",\n    \"createChannelMerger\",\n    \"createChannelSplitter\",\n    \"createCommandEncoder\",\n    \"createComment\",\n    \"createComputePipeline\",\n    \"createComputePipelineAsync\",\n    \"createConicGradient\",\n    \"createConstantSource\",\n    \"createContextualFragment\",\n    \"createControlRange\",\n    \"createConvolver\",\n    \"createDTMFSender\",\n    \"createDataChannel\",\n    \"createDelay\",\n    \"createDelayNode\",\n    \"createDocument\",\n    \"createDocumentFragment\",\n    \"createDocumentType\",\n    \"createDynamicsCompressor\",\n    \"createElement\",\n    \"createElementNS\",\n    \"createEncodedStreams\",\n    \"createEntityReference\",\n    \"createEvent\",\n    \"createEventObject\",\n    \"createExpression\",\n    \"createFramebuffer\",\n    \"createFunction\",\n    \"createGain\",\n    \"createGainNode\",\n    \"createHTML\",\n    \"createHTMLDocument\",\n    \"createIIRFilter\",\n    \"createImageBitmap\",\n    \"createImageData\",\n    \"createIndex\",\n    \"createJavaScriptNode\",\n    \"createLinearGradient\",\n    \"createMediaElementSource\",\n    \"createMediaKeys\",\n    \"createMediaStreamDestination\",\n    \"createMediaStreamSource\",\n    \"createMediaStreamTrackSource\",\n    \"createMutableFile\",\n    \"createNSResolver\",\n    \"createNodeIterator\",\n    \"createNotification\",\n    \"createObjectStore\",\n    \"createObjectURL\",\n    \"createOffer\",\n    \"createOscillator\",\n    \"createPanner\",\n    \"createPattern\",\n    \"createPeriodicWave\",\n    \"createPipelineLayout\",\n    \"createPolicy\",\n    \"createPopup\",\n    \"createProcessingInstruction\",\n    \"createProgram\",\n    \"createQuery\",\n    \"createQuerySet\",\n    \"createRadialGradient\",\n    \"createRange\",\n    \"createRangeCollection\",\n    \"createReader\",\n    \"createRenderBundleEncoder\",\n    \"createRenderPipeline\",\n    \"createRenderPipelineAsync\",\n    \"createRenderbuffer\",\n    \"createSVGAngle\",\n    \"createSVGLength\",\n    \"createSVGMatrix\",\n    \"createSVGNumber\",\n    \"createSVGPathSegArcAbs\",\n    \"createSVGPathSegArcRel\",\n    \"createSVGPathSegClosePath\",\n    \"createSVGPathSegCurvetoCubicAbs\",\n    \"createSVGPathSegCurvetoCubicRel\",\n    \"createSVGPathSegCurvetoCubicSmoothAbs\",\n    \"createSVGPathSegCurvetoCubicSmoothRel\",\n    \"createSVGPathSegCurvetoQuadraticAbs\",\n    \"createSVGPathSegCurvetoQuadraticRel\",\n    \"createSVGPathSegCurvetoQuadraticSmoothAbs\",\n    \"createSVGPathSegCurvetoQuadraticSmoothRel\",\n    \"createSVGPathSegLinetoAbs\",\n    \"createSVGPathSegLinetoHorizontalAbs\",\n    \"createSVGPathSegLinetoHorizontalRel\",\n    \"createSVGPathSegLinetoRel\",\n    \"createSVGPathSegLinetoVerticalAbs\",\n    \"createSVGPathSegLinetoVerticalRel\",\n    \"createSVGPathSegMovetoAbs\",\n    \"createSVGPathSegMovetoRel\",\n    \"createSVGPoint\",\n    \"createSVGRect\",\n    \"createSVGTransform\",\n    \"createSVGTransformFromMatrix\",\n    \"createSampler\",\n    \"createScript\",\n    \"createScriptProcessor\",\n    \"createScriptURL\",\n    \"createSession\",\n    \"createShader\",\n    \"createShaderModule\",\n    \"createShadowRoot\",\n    \"createStereoPanner\",\n    \"createStyleSheet\",\n    \"createTBody\",\n    \"createTFoot\",\n    \"createTHead\",\n    \"createTask\",\n    \"createTextNode\",\n    \"createTextRange\",\n    \"createTexture\",\n    \"createTouch\",\n    \"createTouchList\",\n    \"createTransformFeedback\",\n    \"createTreeWalker\",\n    \"createUnidirectionalStream\",\n    \"createVertexArray\",\n    \"createView\",\n    \"createWaveShaper\",\n    \"createWorklet\",\n    \"createWritable\",\n    \"creationTime\",\n    \"credentialless\",\n    \"credentials\",\n    \"criticalCHRestart\",\n    \"cropTo\",\n    \"crossOrigin\",\n    \"crossOriginIsolated\",\n    \"crypto\",\n    \"csi\",\n    \"csp\",\n    \"cssFloat\",\n    \"cssRules\",\n    \"cssText\",\n    \"cssValueType\",\n    \"ctrlKey\",\n    \"ctrlLeft\",\n    \"cues\",\n    \"cullFace\",\n    \"cullMode\",\n    \"currentCSSZoom\",\n    \"currentDirection\",\n    \"currentEntry\",\n    \"currentLocalDescription\",\n    \"currentNode\",\n    \"currentPage\",\n    \"currentRect\",\n    \"currentRemoteDescription\",\n    \"currentScale\",\n    \"currentScreen\",\n    \"currentScript\",\n    \"currentSrc\",\n    \"currentState\",\n    \"currentStyle\",\n    \"currentTarget\",\n    \"currentTime\",\n    \"currentTranslate\",\n    \"currentView\",\n    \"cursor\",\n    \"curve\",\n    \"customElements\",\n    \"customError\",\n    \"cx\",\n    \"cy\",\n    \"d\",\n    \"data\",\n    \"dataFld\",\n    \"dataFormatAs\",\n    \"dataLoss\",\n    \"dataLossMessage\",\n    \"dataPageSize\",\n    \"dataSrc\",\n    \"dataTransfer\",\n    \"database\",\n    \"databases\",\n    \"datagrams\",\n    \"dataset\",\n    \"dateTime\",\n    \"db\",\n    \"debug\",\n    \"debuggerEnabled\",\n    \"declarativeNetRequest\",\n    \"declare\",\n    \"decode\",\n    \"decodeAudioData\",\n    \"decodeQueueSize\",\n    \"decodeURI\",\n    \"decodeURIComponent\",\n    \"decodedBodySize\",\n    \"decoding\",\n    \"decodingInfo\",\n    \"decrypt\",\n    \"default\",\n    \"defaultCharset\",\n    \"defaultChecked\",\n    \"defaultMuted\",\n    \"defaultPlaybackRate\",\n    \"defaultPolicy\",\n    \"defaultPrevented\",\n    \"defaultQueue\",\n    \"defaultRequest\",\n    \"defaultSelected\",\n    \"defaultStatus\",\n    \"defaultURL\",\n    \"defaultValue\",\n    \"defaultView\",\n    \"defaultstatus\",\n    \"defer\",\n    \"define\",\n    \"defineMagicFunction\",\n    \"defineMagicVariable\",\n    \"defineProperties\",\n    \"defineProperty\",\n    \"deg\",\n    \"delay\",\n    \"delayTime\",\n    \"delegatesFocus\",\n    \"delete\",\n    \"deleteBuffer\",\n    \"deleteCaption\",\n    \"deleteCell\",\n    \"deleteContents\",\n    \"deleteData\",\n    \"deleteDatabase\",\n    \"deleteFramebuffer\",\n    \"deleteFromDocument\",\n    \"deleteIndex\",\n    \"deleteMedium\",\n    \"deleteObjectStore\",\n    \"deleteProgram\",\n    \"deleteProperty\",\n    \"deleteQuery\",\n    \"deleteRenderbuffer\",\n    \"deleteRow\",\n    \"deleteRule\",\n    \"deleteSampler\",\n    \"deleteShader\",\n    \"deleteSync\",\n    \"deleteTFoot\",\n    \"deleteTHead\",\n    \"deleteTexture\",\n    \"deleteTransformFeedback\",\n    \"deleteVertexArray\",\n    \"deleted\",\n    \"deliverChangeRecords\",\n    \"deliveredFrames\",\n    \"deliveredFramesDuration\",\n    \"delivery\",\n    \"deliveryInfo\",\n    \"deliveryStatus\",\n    \"deliveryTimestamp\",\n    \"deliveryType\",\n    \"delta\",\n    \"deltaMode\",\n    \"deltaX\",\n    \"deltaY\",\n    \"deltaZ\",\n    \"dependentLocality\",\n    \"deprecatedReplaceInURN\",\n    \"deprecatedRunAdAuctionEnforcesKAnonymity\",\n    \"deprecatedURNToURL\",\n    \"depthBias\",\n    \"depthBiasClamp\",\n    \"depthBiasSlopeScale\",\n    \"depthClearValue\",\n    \"depthCompare\",\n    \"depthDataFormat\",\n    \"depthFailOp\",\n    \"depthFar\",\n    \"depthFunc\",\n    \"depthLoadOp\",\n    \"depthMask\",\n    \"depthNear\",\n    \"depthOrArrayLayers\",\n    \"depthRange\",\n    \"depthReadOnly\",\n    \"depthStencil\",\n    \"depthStencilAttachment\",\n    \"depthStencilFormat\",\n    \"depthStoreOp\",\n    \"depthUsage\",\n    \"depthWriteEnabled\",\n    \"deref\",\n    \"deriveBits\",\n    \"deriveKey\",\n    \"descentOverride\",\n    \"description\",\n    \"deselectAll\",\n    \"designMode\",\n    \"desiredSize\",\n    \"destination\",\n    \"destinationURL\",\n    \"destroy\",\n    \"detach\",\n    \"detachEvent\",\n    \"detachShader\",\n    \"detached\",\n    \"detail\",\n    \"details\",\n    \"detect\",\n    \"detectLanguage\",\n    \"detune\",\n    \"device\",\n    \"deviceClass\",\n    \"deviceId\",\n    \"deviceMemory\",\n    \"devicePixelContentBoxSize\",\n    \"devicePixelRatio\",\n    \"deviceProtocol\",\n    \"deviceSubclass\",\n    \"deviceVersionMajor\",\n    \"deviceVersionMinor\",\n    \"deviceVersionSubminor\",\n    \"deviceXDPI\",\n    \"deviceYDPI\",\n    \"devtools\",\n    \"devtools_panels\",\n    \"didTimeout\",\n    \"difference\",\n    \"diffuseConstant\",\n    \"digest\",\n    \"dimension\",\n    \"dimensions\",\n    \"dir\",\n    \"dirName\",\n    \"direction\",\n    \"dirxml\",\n    \"disable\",\n    \"disablePictureInPicture\",\n    \"disableRemotePlayback\",\n    \"disableVertexAttribArray\",\n    \"disabled\",\n    \"discard\",\n    \"discardedFrames\",\n    \"dischargingTime\",\n    \"disconnect\",\n    \"disconnectShark\",\n    \"disconnectedCallback\",\n    \"dispatchEvent\",\n    \"dispatchWorkgroups\",\n    \"dispatchWorkgroupsIndirect\",\n    \"display\",\n    \"displayHeight\",\n    \"displayId\",\n    \"displayName\",\n    \"displayWidth\",\n    \"dispose\",\n    \"disposition\",\n    \"distanceModel\",\n    \"div\",\n    \"divisor\",\n    \"djsapi\",\n    \"djsproxy\",\n    \"dns\",\n    \"doImport\",\n    \"doNotTrack\",\n    \"doScroll\",\n    \"doctype\",\n    \"document\",\n    \"documentElement\",\n    \"documentId\",\n    \"documentIds\",\n    \"documentLifecycle\",\n    \"documentMode\",\n    \"documentOrigin\",\n    \"documentOrigins\",\n    \"documentPictureInPicture\",\n    \"documentURI\",\n    \"documentUrl\",\n    \"documentUrls\",\n    \"dolphin\",\n    \"dolphinGameCenter\",\n    \"dolphininfo\",\n    \"dolphinmeta\",\n    \"dom\",\n    \"domComplete\",\n    \"domContentLoadedEventEnd\",\n    \"domContentLoadedEventStart\",\n    \"domInteractive\",\n    \"domLoading\",\n    \"domOverlayState\",\n    \"domain\",\n    \"domainLookupEnd\",\n    \"domainLookupStart\",\n    \"dominant-baseline\",\n    \"dominantBaseline\",\n    \"done\",\n    \"dopplerFactor\",\n    \"dotAll\",\n    \"downDegrees\",\n    \"downlink\",\n    \"download\",\n    \"downloadRequest\",\n    \"downloadTotal\",\n    \"downloaded\",\n    \"downloads\",\n    \"dpcm\",\n    \"dpi\",\n    \"dppx\",\n    \"dragDrop\",\n    \"draggable\",\n    \"draw\",\n    \"drawArrays\",\n    \"drawArraysInstanced\",\n    \"drawArraysInstancedANGLE\",\n    \"drawBuffers\",\n    \"drawCustomFocusRing\",\n    \"drawElements\",\n    \"drawElementsInstanced\",\n    \"drawElementsInstancedANGLE\",\n    \"drawFocusIfNeeded\",\n    \"drawImage\",\n    \"drawImageFromRect\",\n    \"drawIndexed\",\n    \"drawIndexedIndirect\",\n    \"drawIndirect\",\n    \"drawRangeElements\",\n    \"drawSystemFocusRing\",\n    \"drawingBufferColorSpace\",\n    \"drawingBufferFormat\",\n    \"drawingBufferHeight\",\n    \"drawingBufferStorage\",\n    \"drawingBufferWidth\",\n    \"drop\",\n    \"dropEffect\",\n    \"droppedVideoFrames\",\n    \"dropzone\",\n    \"dstFactor\",\n    \"dtmf\",\n    \"dump\",\n    \"dumpProfile\",\n    \"duplex\",\n    \"duplicate\",\n    \"durability\",\n    \"duration\",\n    \"dvb\",\n    \"dvh\",\n    \"dvi\",\n    \"dvmax\",\n    \"dvmin\",\n    \"dvname\",\n    \"dvnum\",\n    \"dvw\",\n    \"dx\",\n    \"dy\",\n    \"dynamicId\",\n    \"dynsrc\",\n    \"e\",\n    \"edgeMode\",\n    \"editContext\",\n    \"effect\",\n    \"effectAllowed\",\n    \"effectiveDirective\",\n    \"effectiveType\",\n    \"effects\",\n    \"elapsedTime\",\n    \"element\",\n    \"elementFromPoint\",\n    \"elementTiming\",\n    \"elements\",\n    \"elementsFromPoint\",\n    \"elevation\",\n    \"ellipse\",\n    \"em\",\n    \"emHeightAscent\",\n    \"emHeightDescent\",\n    \"email\",\n    \"embeds\",\n    \"emit\",\n    \"emma\",\n    \"empty\",\n    \"empty-cells\",\n    \"emptyCells\",\n    \"emptyHTML\",\n    \"emptyScript\",\n    \"emulatedPosition\",\n    \"enable\",\n    \"enableBackground\",\n    \"enableDelegations\",\n    \"enableStyleSheetsForSet\",\n    \"enableVertexAttribArray\",\n    \"enabled\",\n    \"enabledFeatures\",\n    \"enabledPlugin\",\n    \"encode\",\n    \"encodeInto\",\n    \"encodeQueueSize\",\n    \"encodeURI\",\n    \"encodeURIComponent\",\n    \"encodedBodySize\",\n    \"encoding\",\n    \"encodingInfo\",\n    \"encrypt\",\n    \"enctype\",\n    \"end\",\n    \"endContainer\",\n    \"endElement\",\n    \"endElementAt\",\n    \"endOcclusionQuery\",\n    \"endOfPassWriteIndex\",\n    \"endOfStream\",\n    \"endOffset\",\n    \"endQuery\",\n    \"endTime\",\n    \"endTransformFeedback\",\n    \"ended\",\n    \"endpoint\",\n    \"endpointNumber\",\n    \"endpoints\",\n    \"endsWith\",\n    \"enqueue\",\n    \"enterKeyHint\",\n    \"entities\",\n    \"entries\",\n    \"entry\",\n    \"entryPoint\",\n    \"entryType\",\n    \"enumerable\",\n    \"enumerate\",\n    \"enumerateDevices\",\n    \"enumerateEditable\",\n    \"environmentBlendMode\",\n    \"equals\",\n    \"error\",\n    \"errorCode\",\n    \"errorDetail\",\n    \"errorText\",\n    \"escape\",\n    \"estimate\",\n    \"eval\",\n    \"evaluate\",\n    \"event\",\n    \"eventCounts\",\n    \"eventPhase\",\n    \"events\",\n    \"every\",\n    \"ex\",\n    \"exception\",\n    \"exchange\",\n    \"exec\",\n    \"execCommand\",\n    \"execCommandShowHelp\",\n    \"execScript\",\n    \"executeBundles\",\n    \"executionStart\",\n    \"exitFullscreen\",\n    \"exitPictureInPicture\",\n    \"exitPointerLock\",\n    \"exitPresent\",\n    \"exp\",\n    \"expand\",\n    \"expandEntityReferences\",\n    \"expando\",\n    \"expansion\",\n    \"expectedImprovement\",\n    \"experiments\",\n    \"expiration\",\n    \"expirationTime\",\n    \"expires\",\n    \"expiryDate\",\n    \"explicitOriginalTarget\",\n    \"expm1\",\n    \"exponent\",\n    \"exponentialRampToValueAtTime\",\n    \"exportKey\",\n    \"exports\",\n    \"extend\",\n    \"extension\",\n    \"extensionTypes\",\n    \"extensions\",\n    \"extentNode\",\n    \"extentOffset\",\n    \"external\",\n    \"externalResourcesRequired\",\n    \"externalTexture\",\n    \"extractContents\",\n    \"extractable\",\n    \"eye\",\n    \"f\",\n    \"f16round\",\n    \"face\",\n    \"factoryReset\",\n    \"failOp\",\n    \"failureReason\",\n    \"fallback\",\n    \"family\",\n    \"familyName\",\n    \"farthestViewportElement\",\n    \"fastSeek\",\n    \"fatal\",\n    \"featureId\",\n    \"featurePolicy\",\n    \"featureSettings\",\n    \"features\",\n    \"fence\",\n    \"fenceSync\",\n    \"fetch\",\n    \"fetchPriority\",\n    \"fetchStart\",\n    \"fftSize\",\n    \"fgColor\",\n    \"fieldOfView\",\n    \"file\",\n    \"fileCreatedDate\",\n    \"fileHandle\",\n    \"fileModifiedDate\",\n    \"fileName\",\n    \"fileSize\",\n    \"fileUpdatedDate\",\n    \"filename\",\n    \"files\",\n    \"filesystem\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"fillJointRadii\",\n    \"fillLightMode\",\n    \"fillOpacity\",\n    \"fillPoses\",\n    \"fillRect\",\n    \"fillRule\",\n    \"fillStyle\",\n    \"fillText\",\n    \"filter\",\n    \"filterResX\",\n    \"filterResY\",\n    \"filterUnits\",\n    \"filters\",\n    \"finally\",\n    \"find\",\n    \"findIndex\",\n    \"findLast\",\n    \"findLastIndex\",\n    \"findRule\",\n    \"findText\",\n    \"finish\",\n    \"finishDocumentLoadTime\",\n    \"finishLoadTime\",\n    \"finished\",\n    \"fireEvent\",\n    \"firesTouchEvents\",\n    \"firstChild\",\n    \"firstElementChild\",\n    \"firstInterimResponseStart\",\n    \"firstPage\",\n    \"firstPaintAfterLoadTime\",\n    \"firstPaintTime\",\n    \"firstUIEventTimestamp\",\n    \"fixed\",\n    \"flags\",\n    \"flat\",\n    \"flatMap\",\n    \"flex\",\n    \"flex-basis\",\n    \"flex-direction\",\n    \"flex-flow\",\n    \"flex-grow\",\n    \"flex-shrink\",\n    \"flex-wrap\",\n    \"flexBasis\",\n    \"flexDirection\",\n    \"flexFlow\",\n    \"flexGrow\",\n    \"flexShrink\",\n    \"flexWrap\",\n    \"flipX\",\n    \"flipY\",\n    \"float\",\n    \"float32\",\n    \"float64\",\n    \"flood-color\",\n    \"flood-opacity\",\n    \"floodColor\",\n    \"floodOpacity\",\n    \"floor\",\n    \"flush\",\n    \"focus\",\n    \"focusNode\",\n    \"focusOffset\",\n    \"font\",\n    \"font-family\",\n    \"font-feature-settings\",\n    \"font-kerning\",\n    \"font-language-override\",\n    \"font-optical-sizing\",\n    \"font-palette\",\n    \"font-size\",\n    \"font-size-adjust\",\n    \"font-stretch\",\n    \"font-style\",\n    \"font-synthesis\",\n    \"font-synthesis-position\",\n    \"font-synthesis-small-caps\",\n    \"font-synthesis-style\",\n    \"font-synthesis-weight\",\n    \"font-variant\",\n    \"font-variant-alternates\",\n    \"font-variant-caps\",\n    \"font-variant-east-asian\",\n    \"font-variant-ligatures\",\n    \"font-variant-numeric\",\n    \"font-variant-position\",\n    \"font-variation-settings\",\n    \"font-weight\",\n    \"fontBoundingBoxAscent\",\n    \"fontBoundingBoxDescent\",\n    \"fontFamily\",\n    \"fontFeatureSettings\",\n    \"fontKerning\",\n    \"fontLanguageOverride\",\n    \"fontOpticalSizing\",\n    \"fontPalette\",\n    \"fontSize\",\n    \"fontSizeAdjust\",\n    \"fontSmoothingEnabled\",\n    \"fontStretch\",\n    \"fontStyle\",\n    \"fontSynthesis\",\n    \"fontSynthesisPosition\",\n    \"fontSynthesisSmallCaps\",\n    \"fontSynthesisStyle\",\n    \"fontSynthesisWeight\",\n    \"fontVariant\",\n    \"fontVariantAlternates\",\n    \"fontVariantCaps\",\n    \"fontVariantEastAsian\",\n    \"fontVariantLigatures\",\n    \"fontVariantNumeric\",\n    \"fontVariantPosition\",\n    \"fontVariationSettings\",\n    \"fontWeight\",\n    \"fontcolor\",\n    \"fontfaces\",\n    \"fonts\",\n    \"fontsize\",\n    \"for\",\n    \"forEach\",\n    \"force\",\n    \"forceFallbackAdapter\",\n    \"forceRedraw\",\n    \"forced-color-adjust\",\n    \"forcedColorAdjust\",\n    \"forcedStyleAndLayoutDuration\",\n    \"forget\",\n    \"form\",\n    \"formAction\",\n    \"formData\",\n    \"formEnctype\",\n    \"formMethod\",\n    \"formNoValidate\",\n    \"formTarget\",\n    \"format\",\n    \"formatToParts\",\n    \"forms\",\n    \"forward\",\n    \"forwardX\",\n    \"forwardY\",\n    \"forwardZ\",\n    \"foundation\",\n    \"fr\",\n    \"fragment\",\n    \"fragmentDirective\",\n    \"frame\",\n    \"frameBorder\",\n    \"frameCount\",\n    \"frameElement\",\n    \"frameId\",\n    \"frameIds\",\n    \"frameSpacing\",\n    \"framebuffer\",\n    \"framebufferHeight\",\n    \"framebufferRenderbuffer\",\n    \"framebufferTexture2D\",\n    \"framebufferTextureLayer\",\n    \"framebufferWidth\",\n    \"frames\",\n    \"freeSpace\",\n    \"freeze\",\n    \"frequency\",\n    \"frequencyBinCount\",\n    \"from\",\n    \"fromAsync\",\n    \"fromBase64\",\n    \"fromCharCode\",\n    \"fromCodePoint\",\n    \"fromElement\",\n    \"fromEntries\",\n    \"fromFloat32Array\",\n    \"fromFloat64Array\",\n    \"fromHex\",\n    \"fromMatrix\",\n    \"fromPoint\",\n    \"fromQuad\",\n    \"fromRect\",\n    \"frontFace\",\n    \"fround\",\n    \"fullName\",\n    \"fullPath\",\n    \"fullRange\",\n    \"fullScreen\",\n    \"fullVersionList\",\n    \"fullscreen\",\n    \"fullscreenElement\",\n    \"fullscreenEnabled\",\n    \"fx\",\n    \"fy\",\n    \"g\",\n    \"gain\",\n    \"gamepad\",\n    \"gamma\",\n    \"gap\",\n    \"gatheringState\",\n    \"gatt\",\n    \"geckoProfiler\",\n    \"genderIdentity\",\n    \"generateCertificate\",\n    \"generateKey\",\n    \"generateMipmap\",\n    \"generateRequest\",\n    \"geolocation\",\n    \"gestureObject\",\n    \"get\",\n    \"getAcceptLanguages\",\n    \"getActiveAttrib\",\n    \"getActiveUniform\",\n    \"getActiveUniformBlockName\",\n    \"getActiveUniformBlockParameter\",\n    \"getActiveUniforms\",\n    \"getAdjacentText\",\n    \"getAll\",\n    \"getAllKeys\",\n    \"getAllResponseHeaders\",\n    \"getAllowlistForFeature\",\n    \"getAnimations\",\n    \"getAsFile\",\n    \"getAsFileSystemHandle\",\n    \"getAsString\",\n    \"getAttachedShaders\",\n    \"getAttribLocation\",\n    \"getAttribute\",\n    \"getAttributeNS\",\n    \"getAttributeNames\",\n    \"getAttributeNode\",\n    \"getAttributeNodeNS\",\n    \"getAttributeType\",\n    \"getAudioTracks\",\n    \"getAuthenticatorData\",\n    \"getAutoplayPolicy\",\n    \"getAvailability\",\n    \"getBBox\",\n    \"getBackgroundPage\",\n    \"getBadgeBackgroundColor\",\n    \"getBadgeText\",\n    \"getBadgeTextColor\",\n    \"getBattery\",\n    \"getBigInt64\",\n    \"getBigUint64\",\n    \"getBindGroupLayout\",\n    \"getBlob\",\n    \"getBookmark\",\n    \"getBoundingClientRect\",\n    \"getBounds\",\n    \"getBoxQuads\",\n    \"getBrowserInfo\",\n    \"getBufferParameter\",\n    \"getBufferSubData\",\n    \"getByteFrequencyData\",\n    \"getByteTimeDomainData\",\n    \"getCSSCanvasContext\",\n    \"getCTM\",\n    \"getCameraImage\",\n    \"getCandidateWindowClientRect\",\n    \"getCanonicalLocales\",\n    \"getCapabilities\",\n    \"getCaptureHandle\",\n    \"getChannelData\",\n    \"getCharNumAtPosition\",\n    \"getCharacteristic\",\n    \"getCharacteristics\",\n    \"getClientExtensionResults\",\n    \"getClientRect\",\n    \"getClientRects\",\n    \"getCoalescedEvents\",\n    \"getCompilationInfo\",\n    \"getCompositionAlternatives\",\n    \"getComputedStyle\",\n    \"getComputedTextLength\",\n    \"getComputedTiming\",\n    \"getConfiguration\",\n    \"getConstraints\",\n    \"getContext\",\n    \"getContextAttributes\",\n    \"getContexts\",\n    \"getContributingSources\",\n    \"getCounterValue\",\n    \"getCueAsHTML\",\n    \"getCueById\",\n    \"getCurrent\",\n    \"getCurrentPosition\",\n    \"getCurrentTexture\",\n    \"getCurrentTime\",\n    \"getData\",\n    \"getDatabaseNames\",\n    \"getDate\",\n    \"getDay\",\n    \"getDefaultComputedStyle\",\n    \"getDepthInMeters\",\n    \"getDepthInformation\",\n    \"getDescriptor\",\n    \"getDescriptors\",\n    \"getDestinationInsertionPoints\",\n    \"getDevices\",\n    \"getDirectory\",\n    \"getDirectoryHandle\",\n    \"getDisplayMedia\",\n    \"getDistributedNodes\",\n    \"getEditable\",\n    \"getElementById\",\n    \"getElementsByClassName\",\n    \"getElementsByName\",\n    \"getElementsByTagName\",\n    \"getElementsByTagNameNS\",\n    \"getEnclosureList\",\n    \"getEndPositionOfChar\",\n    \"getEntries\",\n    \"getEntriesByName\",\n    \"getEntriesByType\",\n    \"getError\",\n    \"getExtension\",\n    \"getExtentOfChar\",\n    \"getEyeParameters\",\n    \"getFeature\",\n    \"getFiberRoots\",\n    \"getFile\",\n    \"getFileHandle\",\n    \"getFiles\",\n    \"getFilesAndDirectories\",\n    \"getFingerprints\",\n    \"getFloat16\",\n    \"getFloat32\",\n    \"getFloat64\",\n    \"getFloatFrequencyData\",\n    \"getFloatTimeDomainData\",\n    \"getFloatValue\",\n    \"getFragDataLocation\",\n    \"getFrameData\",\n    \"getFrameId\",\n    \"getFramebufferAttachmentParameter\",\n    \"getFrequencyResponse\",\n    \"getFullYear\",\n    \"getGamepads\",\n    \"getHTML\",\n    \"getHeaderExtensionsToNegotiate\",\n    \"getHighEntropyValues\",\n    \"getHitTestResults\",\n    \"getHitTestResultsForTransientInput\",\n    \"getHours\",\n    \"getIdentityAssertion\",\n    \"getIds\",\n    \"getImageData\",\n    \"getIndexedParameter\",\n    \"getInfo\",\n    \"getInnerHTML\",\n    \"getInstalledRelatedApps\",\n    \"getInt16\",\n    \"getInt32\",\n    \"getInt8\",\n    \"getInterestGroupAdAuctionData\",\n    \"getInternalModuleRanges\",\n    \"getInternalformatParameter\",\n    \"getIntersectionList\",\n    \"getItem\",\n    \"getItems\",\n    \"getJointPose\",\n    \"getKey\",\n    \"getKeyframes\",\n    \"getLastFocused\",\n    \"getLayers\",\n    \"getLayoutMap\",\n    \"getLightEstimate\",\n    \"getLineDash\",\n    \"getLocalCandidates\",\n    \"getLocalParameters\",\n    \"getLocalStreams\",\n    \"getManagedConfiguration\",\n    \"getManifest\",\n    \"getMappedRange\",\n    \"getMarks\",\n    \"getMatchedCSSRules\",\n    \"getMaxGCPauseSinceClear\",\n    \"getMeasures\",\n    \"getMessage\",\n    \"getMetadata\",\n    \"getMilliseconds\",\n    \"getMinutes\",\n    \"getModifierState\",\n    \"getMonth\",\n    \"getName\",\n    \"getNamedItem\",\n    \"getNamedItemNS\",\n    \"getNativeFramebufferScaleFactor\",\n    \"getNegotiatedHeaderExtensions\",\n    \"getNestedConfigs\",\n    \"getNotifications\",\n    \"getNotifier\",\n    \"getNumberOfChars\",\n    \"getOffsetReferenceSpace\",\n    \"getOutputTimestamp\",\n    \"getOverrideHistoryNavigationMode\",\n    \"getOverrideStyle\",\n    \"getOwnPropertyDescriptor\",\n    \"getOwnPropertyDescriptors\",\n    \"getOwnPropertyNames\",\n    \"getOwnPropertySymbols\",\n    \"getPackageDirectoryEntry\",\n    \"getParameter\",\n    \"getParameters\",\n    \"getParent\",\n    \"getPathSegAtLength\",\n    \"getPermissionWarningsByManifest\",\n    \"getPhotoCapabilities\",\n    \"getPhotoSettings\",\n    \"getPlatformInfo\",\n    \"getPointAtLength\",\n    \"getPopup\",\n    \"getPorts\",\n    \"getPose\",\n    \"getPredictedEvents\",\n    \"getPreference\",\n    \"getPreferenceDefault\",\n    \"getPreferredCanvasFormat\",\n    \"getPresentationAttribute\",\n    \"getPreventDefault\",\n    \"getPrimaryService\",\n    \"getPrimaryServices\",\n    \"getProgramInfoLog\",\n    \"getProgramParameter\",\n    \"getPropertyCSSValue\",\n    \"getPropertyPriority\",\n    \"getPropertyShorthand\",\n    \"getPropertyType\",\n    \"getPropertyValue\",\n    \"getPrototypeOf\",\n    \"getPublicKey\",\n    \"getPublicKeyAlgorithm\",\n    \"getQuery\",\n    \"getQueryParameter\",\n    \"getRGBColorValue\",\n    \"getRandomValues\",\n    \"getRangeAt\",\n    \"getReader\",\n    \"getReceivers\",\n    \"getRectValue\",\n    \"getReflectionCubeMap\",\n    \"getRegistration\",\n    \"getRegistrations\",\n    \"getRemoteCandidates\",\n    \"getRemoteCertificates\",\n    \"getRemoteParameters\",\n    \"getRemoteStreams\",\n    \"getRenderbufferParameter\",\n    \"getResponseHeader\",\n    \"getRoot\",\n    \"getRootNode\",\n    \"getRotationOfChar\",\n    \"getSVGDocument\",\n    \"getSamplerParameter\",\n    \"getScreenCTM\",\n    \"getScreenDetails\",\n    \"getSeconds\",\n    \"getSelectedCandidatePair\",\n    \"getSelection\",\n    \"getSelf\",\n    \"getSenders\",\n    \"getService\",\n    \"getSetCookie\",\n    \"getSettings\",\n    \"getShaderInfoLog\",\n    \"getShaderParameter\",\n    \"getShaderPrecisionFormat\",\n    \"getShaderSource\",\n    \"getSignals\",\n    \"getSimpleDuration\",\n    \"getSiteIcons\",\n    \"getSources\",\n    \"getSpeculativeParserUrls\",\n    \"getStartPositionOfChar\",\n    \"getStartTime\",\n    \"getState\",\n    \"getStats\",\n    \"getStatusForPolicy\",\n    \"getStorageUpdates\",\n    \"getStreamById\",\n    \"getStringValue\",\n    \"getSubStringLength\",\n    \"getSubscription\",\n    \"getSubscriptions\",\n    \"getSupportedConstraints\",\n    \"getSupportedExtensions\",\n    \"getSupportedFormats\",\n    \"getSyncParameter\",\n    \"getSynchronizationSources\",\n    \"getTags\",\n    \"getTargetRanges\",\n    \"getTexParameter\",\n    \"getTextFormats\",\n    \"getTime\",\n    \"getTimezoneOffset\",\n    \"getTiming\",\n    \"getTitle\",\n    \"getTitlebarAreaRect\",\n    \"getTotalLength\",\n    \"getTrackById\",\n    \"getTracks\",\n    \"getTransceivers\",\n    \"getTransform\",\n    \"getTransformFeedbackVarying\",\n    \"getTransformToElement\",\n    \"getTransports\",\n    \"getType\",\n    \"getTypeMapping\",\n    \"getUILanguage\",\n    \"getURL\",\n    \"getUTCDate\",\n    \"getUTCDay\",\n    \"getUTCFullYear\",\n    \"getUTCHours\",\n    \"getUTCMilliseconds\",\n    \"getUTCMinutes\",\n    \"getUTCMonth\",\n    \"getUTCSeconds\",\n    \"getUint16\",\n    \"getUint32\",\n    \"getUint8\",\n    \"getUniform\",\n    \"getUniformBlockIndex\",\n    \"getUniformIndices\",\n    \"getUniformLocation\",\n    \"getUserInfo\",\n    \"getUserMedia\",\n    \"getUserSettings\",\n    \"getVRDisplays\",\n    \"getValues\",\n    \"getVarDate\",\n    \"getVariableValue\",\n    \"getVertexAttrib\",\n    \"getVertexAttribOffset\",\n    \"getVideoPlaybackQuality\",\n    \"getVideoTracks\",\n    \"getViewerPose\",\n    \"getViewport\",\n    \"getViews\",\n    \"getVoices\",\n    \"getWakeLockState\",\n    \"getWriter\",\n    \"getYear\",\n    \"getZoom\",\n    \"getZoomSettings\",\n    \"givenName\",\n    \"global\",\n    \"globalAlpha\",\n    \"globalCompositeOperation\",\n    \"globalPrivacyControl\",\n    \"globalThis\",\n    \"glyphOrientationHorizontal\",\n    \"glyphOrientationVertical\",\n    \"glyphRef\",\n    \"go\",\n    \"goBack\",\n    \"goForward\",\n    \"gpu\",\n    \"grabFrame\",\n    \"grad\",\n    \"gradientTransform\",\n    \"gradientUnits\",\n    \"grammars\",\n    \"green\",\n    \"grid\",\n    \"grid-area\",\n    \"grid-auto-columns\",\n    \"grid-auto-flow\",\n    \"grid-auto-rows\",\n    \"grid-column\",\n    \"grid-column-end\",\n    \"grid-column-gap\",\n    \"grid-column-start\",\n    \"grid-gap\",\n    \"grid-row\",\n    \"grid-row-end\",\n    \"grid-row-gap\",\n    \"grid-row-start\",\n    \"grid-template\",\n    \"grid-template-areas\",\n    \"grid-template-columns\",\n    \"grid-template-rows\",\n    \"gridArea\",\n    \"gridAutoColumns\",\n    \"gridAutoFlow\",\n    \"gridAutoRows\",\n    \"gridColumn\",\n    \"gridColumnEnd\",\n    \"gridColumnGap\",\n    \"gridColumnStart\",\n    \"gridGap\",\n    \"gridRow\",\n    \"gridRowEnd\",\n    \"gridRowGap\",\n    \"gridRowStart\",\n    \"gridTemplate\",\n    \"gridTemplateAreas\",\n    \"gridTemplateColumns\",\n    \"gridTemplateRows\",\n    \"gripSpace\",\n    \"group\",\n    \"groupBy\",\n    \"groupCollapsed\",\n    \"groupEnd\",\n    \"groupId\",\n    \"groups\",\n    \"grow\",\n    \"growable\",\n    \"guestProcessId\",\n    \"guestRenderFrameRoutingId\",\n    \"hadRecentInput\",\n    \"hand\",\n    \"handedness\",\n    \"hangingBaseline\",\n    \"hapticActuators\",\n    \"hardwareConcurrency\",\n    \"has\",\n    \"hasAttribute\",\n    \"hasAttributeNS\",\n    \"hasAttributes\",\n    \"hasBeenActive\",\n    \"hasChildNodes\",\n    \"hasComposition\",\n    \"hasDynamicOffset\",\n    \"hasEnrolledInstrument\",\n    \"hasExtension\",\n    \"hasExternalDisplay\",\n    \"hasFeature\",\n    \"hasFocus\",\n    \"hasIndices\",\n    \"hasInstance\",\n    \"hasLayout\",\n    \"hasOrientation\",\n    \"hasOwn\",\n    \"hasOwnProperty\",\n    \"hasPointerCapture\",\n    \"hasPosition\",\n    \"hasPrivateToken\",\n    \"hasReading\",\n    \"hasRedemptionRecord\",\n    \"hasRegExpGroups\",\n    \"hasStorageAccess\",\n    \"hasUAVisualTransition\",\n    \"hasUnpartitionedCookieAccess\",\n    \"hash\",\n    \"hashChange\",\n    \"head\",\n    \"headers\",\n    \"heading\",\n    \"height\",\n    \"hid\",\n    \"hidden\",\n    \"hide\",\n    \"hideFocus\",\n    \"hidePopover\",\n    \"high\",\n    \"highWaterMark\",\n    \"highlight\",\n    \"highlights\",\n    \"hint\",\n    \"hints\",\n    \"history\",\n    \"honorificPrefix\",\n    \"honorificSuffix\",\n    \"horizontalOverflow\",\n    \"host\",\n    \"hostCandidate\",\n    \"hostname\",\n    \"href\",\n    \"hrefTranslate\",\n    \"hreflang\",\n    \"hspace\",\n    \"html5TagCheckInerface\",\n    \"htmlFor\",\n    \"htmlText\",\n    \"httpEquiv\",\n    \"httpRequestStatusCode\",\n    \"hwTimestamp\",\n    \"hyphenate-character\",\n    \"hyphenateCharacter\",\n    \"hyphens\",\n    \"hypot\",\n    \"i18n\",\n    \"ic\",\n    \"iccId\",\n    \"iceConnectionState\",\n    \"iceGatheringState\",\n    \"iceTransport\",\n    \"icon\",\n    \"iconURL\",\n    \"id\",\n    \"identifier\",\n    \"identity\",\n    \"ideographicBaseline\",\n    \"idle\",\n    \"idpLoginUrl\",\n    \"ignoreBOM\",\n    \"ignoreCase\",\n    \"ignoreDepthValues\",\n    \"image\",\n    \"image-orientation\",\n    \"image-rendering\",\n    \"imageHeight\",\n    \"imageOrientation\",\n    \"imageRendering\",\n    \"imageSizes\",\n    \"imageSmoothingEnabled\",\n    \"imageSmoothingQuality\",\n    \"imageSrcset\",\n    \"imageWidth\",\n    \"images\",\n    \"ime-mode\",\n    \"imeMode\",\n    \"implementation\",\n    \"importExternalTexture\",\n    \"importKey\",\n    \"importNode\",\n    \"importStylesheet\",\n    \"imports\",\n    \"impp\",\n    \"imul\",\n    \"in\",\n    \"in1\",\n    \"in2\",\n    \"inBandMetadataTrackDispatchType\",\n    \"inIncognitoContext\",\n    \"inRange\",\n    \"includes\",\n    \"incognito\",\n    \"incomingBidirectionalStreams\",\n    \"incomingHighWaterMark\",\n    \"incomingMaxAge\",\n    \"incomingUnidirectionalStreams\",\n    \"incremental\",\n    \"indeterminate\",\n    \"index\",\n    \"indexNames\",\n    \"indexOf\",\n    \"indexedDB\",\n    \"indicate\",\n    \"indices\",\n    \"inert\",\n    \"inertiaDestinationX\",\n    \"inertiaDestinationY\",\n    \"info\",\n    \"inherits\",\n    \"init\",\n    \"initAnimationEvent\",\n    \"initBeforeLoadEvent\",\n    \"initClipboardEvent\",\n    \"initCloseEvent\",\n    \"initCommandEvent\",\n    \"initCompositionEvent\",\n    \"initCustomEvent\",\n    \"initData\",\n    \"initDataType\",\n    \"initDeviceMotionEvent\",\n    \"initDeviceOrientationEvent\",\n    \"initDragEvent\",\n    \"initErrorEvent\",\n    \"initEvent\",\n    \"initFocusEvent\",\n    \"initGestureEvent\",\n    \"initHashChangeEvent\",\n    \"initKeyEvent\",\n    \"initKeyboardEvent\",\n    \"initMSManipulationEvent\",\n    \"initMessageEvent\",\n    \"initMouseEvent\",\n    \"initMouseScrollEvent\",\n    \"initMouseWheelEvent\",\n    \"initMutationEvent\",\n    \"initNSMouseEvent\",\n    \"initOverflowEvent\",\n    \"initPageEvent\",\n    \"initPageTransitionEvent\",\n    \"initPointerEvent\",\n    \"initPopStateEvent\",\n    \"initProgressEvent\",\n    \"initScrollAreaEvent\",\n    \"initSimpleGestureEvent\",\n    \"initStorageEvent\",\n    \"initTextEvent\",\n    \"initTimeEvent\",\n    \"initTouchEvent\",\n    \"initTransitionEvent\",\n    \"initUIEvent\",\n    \"initWebKitAnimationEvent\",\n    \"initWebKitTransitionEvent\",\n    \"initWebKitWheelEvent\",\n    \"initWheelEvent\",\n    \"initialTime\",\n    \"initialValue\",\n    \"initialize\",\n    \"initiatorType\",\n    \"inject\",\n    \"ink\",\n    \"inline-size\",\n    \"inlineSize\",\n    \"inlineVerticalFieldOfView\",\n    \"inner\",\n    \"innerHTML\",\n    \"innerHeight\",\n    \"innerText\",\n    \"innerWidth\",\n    \"input\",\n    \"inputBuffer\",\n    \"inputEncoding\",\n    \"inputMethod\",\n    \"inputMode\",\n    \"inputSource\",\n    \"inputSources\",\n    \"inputType\",\n    \"inputs\",\n    \"insertAdjacentElement\",\n    \"insertAdjacentHTML\",\n    \"insertAdjacentText\",\n    \"insertBefore\",\n    \"insertCell\",\n    \"insertDTMF\",\n    \"insertData\",\n    \"insertDebugMarker\",\n    \"insertItemBefore\",\n    \"insertNode\",\n    \"insertRow\",\n    \"insertRule\",\n    \"inset\",\n    \"inset-block\",\n    \"inset-block-end\",\n    \"inset-block-start\",\n    \"inset-inline\",\n    \"inset-inline-end\",\n    \"inset-inline-start\",\n    \"insetBlock\",\n    \"insetBlockEnd\",\n    \"insetBlockStart\",\n    \"insetInline\",\n    \"insetInlineEnd\",\n    \"insetInlineStart\",\n    \"install\",\n    \"installing\",\n    \"instanceRoot\",\n    \"instantiate\",\n    \"instantiateStreaming\",\n    \"instruments\",\n    \"int16\",\n    \"int32\",\n    \"int8\",\n    \"integrity\",\n    \"interactionId\",\n    \"interactionMode\",\n    \"intercept\",\n    \"interfaceClass\",\n    \"interfaceName\",\n    \"interfaceNumber\",\n    \"interfaceProtocol\",\n    \"interfaceSubclass\",\n    \"interfaces\",\n    \"interimResults\",\n    \"internalSubset\",\n    \"interpretation\",\n    \"intersection\",\n    \"intersectionRatio\",\n    \"intersectionRect\",\n    \"intersectsNode\",\n    \"interval\",\n    \"invalidIteratorState\",\n    \"invalidateFramebuffer\",\n    \"invalidateSubFramebuffer\",\n    \"inverse\",\n    \"invertSelf\",\n    \"invoker\",\n    \"invokerType\",\n    \"is\",\n    \"is2D\",\n    \"isActive\",\n    \"isAllowedFileSchemeAccess\",\n    \"isAllowedIncognitoAccess\",\n    \"isAlternate\",\n    \"isArray\",\n    \"isAutoSelected\",\n    \"isBingCurrentSearchDefault\",\n    \"isBuffer\",\n    \"isCandidateWindowVisible\",\n    \"isChar\",\n    \"isCollapsed\",\n    \"isComposing\",\n    \"isConcatSpreadable\",\n    \"isConditionalMediationAvailable\",\n    \"isConfigSupported\",\n    \"isConnected\",\n    \"isContentEditable\",\n    \"isContentHandlerRegistered\",\n    \"isContextLost\",\n    \"isDefaultNamespace\",\n    \"isDirectory\",\n    \"isDisabled\",\n    \"isDisjointFrom\",\n    \"isEnabled\",\n    \"isEqual\",\n    \"isEqualNode\",\n    \"isExtended\",\n    \"isExtensible\",\n    \"isExternalCTAP2SecurityKeySupported\",\n    \"isFallbackAdapter\",\n    \"isFile\",\n    \"isFinite\",\n    \"isFirstPersonObserver\",\n    \"isFramebuffer\",\n    \"isFrozen\",\n    \"isGenerator\",\n    \"isHTML\",\n    \"isHistoryNavigation\",\n    \"isId\",\n    \"isIdentity\",\n    \"isInjected\",\n    \"isInputPending\",\n    \"isInteger\",\n    \"isInternal\",\n    \"isIntersecting\",\n    \"isLockFree\",\n    \"isMap\",\n    \"isMultiLine\",\n    \"isNaN\",\n    \"isOpen\",\n    \"isPointInFill\",\n    \"isPointInPath\",\n    \"isPointInRange\",\n    \"isPointInStroke\",\n    \"isPrefAlternate\",\n    \"isPresenting\",\n    \"isPrimary\",\n    \"isProgram\",\n    \"isPropertyImplicit\",\n    \"isProtocolHandlerRegistered\",\n    \"isPrototypeOf\",\n    \"isQuery\",\n    \"isRawJSON\",\n    \"isRenderbuffer\",\n    \"isSafeInteger\",\n    \"isSameEntry\",\n    \"isSameNode\",\n    \"isSampler\",\n    \"isScript\",\n    \"isScriptURL\",\n    \"isSealed\",\n    \"isSecureContext\",\n    \"isSessionSupported\",\n    \"isShader\",\n    \"isSubsetOf\",\n    \"isSupersetOf\",\n    \"isSupported\",\n    \"isSync\",\n    \"isTextEdit\",\n    \"isTexture\",\n    \"isTransformFeedback\",\n    \"isTrusted\",\n    \"isTypeSupported\",\n    \"isUserVerifyingPlatformAuthenticatorAvailable\",\n    \"isVertexArray\",\n    \"isView\",\n    \"isVisible\",\n    \"isWellFormed\",\n    \"isochronousTransferIn\",\n    \"isochronousTransferOut\",\n    \"isolation\",\n    \"italics\",\n    \"item\",\n    \"itemId\",\n    \"itemProp\",\n    \"itemRef\",\n    \"itemScope\",\n    \"itemType\",\n    \"itemValue\",\n    \"items\",\n    \"iterateNext\",\n    \"iterationComposite\",\n    \"iterator\",\n    \"javaEnabled\",\n    \"jitterBufferTarget\",\n    \"jobTitle\",\n    \"join\",\n    \"joinAdInterestGroup\",\n    \"jointName\",\n    \"json\",\n    \"justify-content\",\n    \"justify-items\",\n    \"justify-self\",\n    \"justifyContent\",\n    \"justifyItems\",\n    \"justifySelf\",\n    \"k1\",\n    \"k2\",\n    \"k3\",\n    \"k4\",\n    \"kHz\",\n    \"keepalive\",\n    \"kernelMatrix\",\n    \"kernelUnitLengthX\",\n    \"kernelUnitLengthY\",\n    \"kerning\",\n    \"key\",\n    \"keyCode\",\n    \"keyFor\",\n    \"keyIdentifier\",\n    \"keyLightEnabled\",\n    \"keyLocation\",\n    \"keyPath\",\n    \"keyStatuses\",\n    \"keySystem\",\n    \"keyText\",\n    \"keyUsage\",\n    \"keyboard\",\n    \"keys\",\n    \"keytype\",\n    \"kind\",\n    \"knee\",\n    \"knownSources\",\n    \"label\",\n    \"labels\",\n    \"lang\",\n    \"language\",\n    \"languages\",\n    \"largeArcFlag\",\n    \"lastChild\",\n    \"lastElementChild\",\n    \"lastError\",\n    \"lastEventId\",\n    \"lastIndex\",\n    \"lastIndexOf\",\n    \"lastInputTime\",\n    \"lastMatch\",\n    \"lastMessageSubject\",\n    \"lastMessageType\",\n    \"lastModified\",\n    \"lastModifiedDate\",\n    \"lastPage\",\n    \"lastParen\",\n    \"lastState\",\n    \"lastStyleSheetSet\",\n    \"latency\",\n    \"latitude\",\n    \"launchQueue\",\n    \"layerName\",\n    \"layerX\",\n    \"layerY\",\n    \"layout\",\n    \"layoutFlow\",\n    \"layoutGrid\",\n    \"layoutGridChar\",\n    \"layoutGridLine\",\n    \"layoutGridMode\",\n    \"layoutGridType\",\n    \"lbound\",\n    \"leaveAdInterestGroup\",\n    \"left\",\n    \"leftContext\",\n    \"leftDegrees\",\n    \"leftMargin\",\n    \"leftProjectionMatrix\",\n    \"leftViewMatrix\",\n    \"length\",\n    \"lengthAdjust\",\n    \"lengthComputable\",\n    \"letter-spacing\",\n    \"letterSpacing\",\n    \"level\",\n    \"lh\",\n    \"lighting-color\",\n    \"lightingColor\",\n    \"limitingConeAngle\",\n    \"limits\",\n    \"line\",\n    \"line-break\",\n    \"line-height\",\n    \"lineAlign\",\n    \"lineBreak\",\n    \"lineCap\",\n    \"lineDashOffset\",\n    \"lineGapOverride\",\n    \"lineHeight\",\n    \"lineJoin\",\n    \"lineNum\",\n    \"lineNumber\",\n    \"linePos\",\n    \"lineTo\",\n    \"lineWidth\",\n    \"linearAcceleration\",\n    \"linearRampToValueAtTime\",\n    \"linearVelocity\",\n    \"lineno\",\n    \"lines\",\n    \"link\",\n    \"linkColor\",\n    \"linkProgram\",\n    \"links\",\n    \"list\",\n    \"list-style\",\n    \"list-style-image\",\n    \"list-style-position\",\n    \"list-style-type\",\n    \"listStyle\",\n    \"listStyleImage\",\n    \"listStylePosition\",\n    \"listStyleType\",\n    \"listener\",\n    \"listeners\",\n    \"load\",\n    \"loadEventEnd\",\n    \"loadEventStart\",\n    \"loadOp\",\n    \"loadTime\",\n    \"loadTimes\",\n    \"loaded\",\n    \"loading\",\n    \"localDescription\",\n    \"localName\",\n    \"localService\",\n    \"localStorage\",\n    \"locale\",\n    \"localeCompare\",\n    \"location\",\n    \"locationbar\",\n    \"lock\",\n    \"locked\",\n    \"lockedFile\",\n    \"locks\",\n    \"lodMaxClamp\",\n    \"lodMinClamp\",\n    \"log\",\n    \"log10\",\n    \"log1p\",\n    \"log2\",\n    \"logicalXDPI\",\n    \"logicalYDPI\",\n    \"login\",\n    \"loglevel\",\n    \"longDesc\",\n    \"longitude\",\n    \"lookupNamespaceURI\",\n    \"lookupPrefix\",\n    \"loop\",\n    \"loopEnd\",\n    \"loopStart\",\n    \"looping\",\n    \"lost\",\n    \"low\",\n    \"lower\",\n    \"lowerBound\",\n    \"lowerOpen\",\n    \"lowsrc\",\n    \"lvb\",\n    \"lvh\",\n    \"lvi\",\n    \"lvmax\",\n    \"lvmin\",\n    \"lvw\",\n    \"m11\",\n    \"m12\",\n    \"m13\",\n    \"m14\",\n    \"m21\",\n    \"m22\",\n    \"m23\",\n    \"m24\",\n    \"m31\",\n    \"m32\",\n    \"m33\",\n    \"m34\",\n    \"m41\",\n    \"m42\",\n    \"m43\",\n    \"m44\",\n    \"magFilter\",\n    \"makeXRCompatible\",\n    \"managed\",\n    \"management\",\n    \"manifest\",\n    \"manufacturer\",\n    \"manufacturerName\",\n    \"map\",\n    \"mapAsync\",\n    \"mapState\",\n    \"mappedAtCreation\",\n    \"mapping\",\n    \"margin\",\n    \"margin-block\",\n    \"margin-block-end\",\n    \"margin-block-start\",\n    \"margin-bottom\",\n    \"margin-inline\",\n    \"margin-inline-end\",\n    \"margin-inline-start\",\n    \"margin-left\",\n    \"margin-right\",\n    \"margin-top\",\n    \"marginBlock\",\n    \"marginBlockEnd\",\n    \"marginBlockStart\",\n    \"marginBottom\",\n    \"marginHeight\",\n    \"marginInline\",\n    \"marginInlineEnd\",\n    \"marginInlineStart\",\n    \"marginLeft\",\n    \"marginRight\",\n    \"marginTop\",\n    \"marginWidth\",\n    \"mark\",\n    \"marker\",\n    \"marker-end\",\n    \"marker-mid\",\n    \"marker-offset\",\n    \"marker-start\",\n    \"markerEnd\",\n    \"markerHeight\",\n    \"markerMid\",\n    \"markerOffset\",\n    \"markerStart\",\n    \"markerUnits\",\n    \"markerWidth\",\n    \"marks\",\n    \"mask\",\n    \"mask-clip\",\n    \"mask-composite\",\n    \"mask-image\",\n    \"mask-mode\",\n    \"mask-origin\",\n    \"mask-position\",\n    \"mask-position-x\",\n    \"mask-position-y\",\n    \"mask-repeat\",\n    \"mask-size\",\n    \"mask-type\",\n    \"maskClip\",\n    \"maskComposite\",\n    \"maskContentUnits\",\n    \"maskImage\",\n    \"maskMode\",\n    \"maskOrigin\",\n    \"maskPosition\",\n    \"maskPositionX\",\n    \"maskPositionY\",\n    \"maskRepeat\",\n    \"maskSize\",\n    \"maskType\",\n    \"maskUnits\",\n    \"match\",\n    \"matchAll\",\n    \"matchMedia\",\n    \"matchMedium\",\n    \"matchPatterns\",\n    \"matches\",\n    \"math-depth\",\n    \"math-style\",\n    \"mathDepth\",\n    \"mathStyle\",\n    \"matrix\",\n    \"matrixTransform\",\n    \"max\",\n    \"max-block-size\",\n    \"max-height\",\n    \"max-inline-size\",\n    \"max-width\",\n    \"maxActions\",\n    \"maxAlternatives\",\n    \"maxAnisotropy\",\n    \"maxBindGroups\",\n    \"maxBindGroupsPlusVertexBuffers\",\n    \"maxBindingsPerBindGroup\",\n    \"maxBlockSize\",\n    \"maxBufferSize\",\n    \"maxByteLength\",\n    \"maxChannelCount\",\n    \"maxChannels\",\n    \"maxColorAttachmentBytesPerSample\",\n    \"maxColorAttachments\",\n    \"maxComputeInvocationsPerWorkgroup\",\n    \"maxComputeWorkgroupSizeX\",\n    \"maxComputeWorkgroupSizeY\",\n    \"maxComputeWorkgroupSizeZ\",\n    \"maxComputeWorkgroupStorageSize\",\n    \"maxComputeWorkgroupsPerDimension\",\n    \"maxConnectionsPerServer\",\n    \"maxDatagramSize\",\n    \"maxDecibels\",\n    \"maxDistance\",\n    \"maxDrawCount\",\n    \"maxDynamicStorageBuffersPerPipelineLayout\",\n    \"maxDynamicUniformBuffersPerPipelineLayout\",\n    \"maxHeight\",\n    \"maxInlineSize\",\n    \"maxInterStageShaderComponents\",\n    \"maxInterStageShaderVariables\",\n    \"maxLayers\",\n    \"maxLength\",\n    \"maxMessageSize\",\n    \"maxPacketLifeTime\",\n    \"maxRetransmits\",\n    \"maxSampledTexturesPerShaderStage\",\n    \"maxSamplersPerShaderStage\",\n    \"maxStorageBufferBindingSize\",\n    \"maxStorageBuffersPerShaderStage\",\n    \"maxStorageTexturesPerShaderStage\",\n    \"maxTextureArrayLayers\",\n    \"maxTextureDimension1D\",\n    \"maxTextureDimension2D\",\n    \"maxTextureDimension3D\",\n    \"maxTouchPoints\",\n    \"maxUniformBufferBindingSize\",\n    \"maxUniformBuffersPerShaderStage\",\n    \"maxValue\",\n    \"maxVertexAttributes\",\n    \"maxVertexBufferArrayStride\",\n    \"maxVertexBuffers\",\n    \"maxWidth\",\n    \"maximumLatency\",\n    \"measure\",\n    \"measureText\",\n    \"media\",\n    \"mediaCapabilities\",\n    \"mediaDevices\",\n    \"mediaElement\",\n    \"mediaGroup\",\n    \"mediaKeys\",\n    \"mediaSession\",\n    \"mediaStream\",\n    \"mediaText\",\n    \"meetOrSlice\",\n    \"memory\",\n    \"menubar\",\n    \"menus\",\n    \"menusChild\",\n    \"menusInternal\",\n    \"mergeAttributes\",\n    \"message\",\n    \"messageClass\",\n    \"messageHandlers\",\n    \"messageType\",\n    \"messages\",\n    \"metaKey\",\n    \"metadata\",\n    \"method\",\n    \"methodDetails\",\n    \"methodName\",\n    \"mid\",\n    \"mimeType\",\n    \"mimeTypes\",\n    \"min\",\n    \"min-block-size\",\n    \"min-height\",\n    \"min-inline-size\",\n    \"min-width\",\n    \"minBindingSize\",\n    \"minBlockSize\",\n    \"minDecibels\",\n    \"minFilter\",\n    \"minHeight\",\n    \"minInlineSize\",\n    \"minLength\",\n    \"minStorageBufferOffsetAlignment\",\n    \"minUniformBufferOffsetAlignment\",\n    \"minValue\",\n    \"minWidth\",\n    \"minimumLatency\",\n    \"mipLevel\",\n    \"mipLevelCount\",\n    \"mipmapFilter\",\n    \"miterLimit\",\n    \"mix-blend-mode\",\n    \"mixBlendMode\",\n    \"mm\",\n    \"mobile\",\n    \"mode\",\n    \"model\",\n    \"modify\",\n    \"module\",\n    \"mount\",\n    \"move\",\n    \"moveBy\",\n    \"moveEnd\",\n    \"moveFirst\",\n    \"moveFocusDown\",\n    \"moveFocusLeft\",\n    \"moveFocusRight\",\n    \"moveFocusUp\",\n    \"moveInSuccession\",\n    \"moveNext\",\n    \"moveRow\",\n    \"moveStart\",\n    \"moveTo\",\n    \"moveToBookmark\",\n    \"moveToElementText\",\n    \"moveToPoint\",\n    \"movementX\",\n    \"movementY\",\n    \"mozAdd\",\n    \"mozAnimationStartTime\",\n    \"mozAnon\",\n    \"mozApps\",\n    \"mozAudioCaptured\",\n    \"mozAudioChannelType\",\n    \"mozAutoplayEnabled\",\n    \"mozCancelAnimationFrame\",\n    \"mozCancelFullScreen\",\n    \"mozCancelRequestAnimationFrame\",\n    \"mozCaptureStream\",\n    \"mozCaptureStreamUntilEnded\",\n    \"mozClearDataAt\",\n    \"mozContact\",\n    \"mozContacts\",\n    \"mozCreateFileHandle\",\n    \"mozCurrentTransform\",\n    \"mozCurrentTransformInverse\",\n    \"mozCursor\",\n    \"mozDash\",\n    \"mozDashOffset\",\n    \"mozDecodedFrames\",\n    \"mozExitPointerLock\",\n    \"mozFillRule\",\n    \"mozFragmentEnd\",\n    \"mozFrameDelay\",\n    \"mozFullScreen\",\n    \"mozFullScreenElement\",\n    \"mozFullScreenEnabled\",\n    \"mozGetAll\",\n    \"mozGetAllKeys\",\n    \"mozGetAsFile\",\n    \"mozGetDataAt\",\n    \"mozGetMetadata\",\n    \"mozGetUserMedia\",\n    \"mozHasAudio\",\n    \"mozHasItem\",\n    \"mozHidden\",\n    \"mozImageSmoothingEnabled\",\n    \"mozIndexedDB\",\n    \"mozInnerScreenX\",\n    \"mozInnerScreenY\",\n    \"mozInputSource\",\n    \"mozIsTextField\",\n    \"mozItem\",\n    \"mozItemCount\",\n    \"mozItems\",\n    \"mozLength\",\n    \"mozLockOrientation\",\n    \"mozMatchesSelector\",\n    \"mozMovementX\",\n    \"mozMovementY\",\n    \"mozOpaque\",\n    \"mozOrientation\",\n    \"mozPaintCount\",\n    \"mozPaintedFrames\",\n    \"mozParsedFrames\",\n    \"mozPay\",\n    \"mozPointerLockElement\",\n    \"mozPresentedFrames\",\n    \"mozPreservesPitch\",\n    \"mozPressure\",\n    \"mozPrintCallback\",\n    \"mozRTCIceCandidate\",\n    \"mozRTCPeerConnection\",\n    \"mozRTCSessionDescription\",\n    \"mozRemove\",\n    \"mozRequestAnimationFrame\",\n    \"mozRequestFullScreen\",\n    \"mozRequestPointerLock\",\n    \"mozSetDataAt\",\n    \"mozSetImageElement\",\n    \"mozSourceNode\",\n    \"mozSrcObject\",\n    \"mozSystem\",\n    \"mozTCPSocket\",\n    \"mozTextStyle\",\n    \"mozTypesAt\",\n    \"mozUnlockOrientation\",\n    \"mozUserCancelled\",\n    \"mozVisibilityState\",\n    \"ms\",\n    \"msAnimation\",\n    \"msAnimationDelay\",\n    \"msAnimationDirection\",\n    \"msAnimationDuration\",\n    \"msAnimationFillMode\",\n    \"msAnimationIterationCount\",\n    \"msAnimationName\",\n    \"msAnimationPlayState\",\n    \"msAnimationStartTime\",\n    \"msAnimationTimingFunction\",\n    \"msBackfaceVisibility\",\n    \"msBlockProgression\",\n    \"msCSSOMElementFloatMetrics\",\n    \"msCaching\",\n    \"msCachingEnabled\",\n    \"msCancelRequestAnimationFrame\",\n    \"msCapsLockWarningOff\",\n    \"msClearImmediate\",\n    \"msClose\",\n    \"msContentZoomChaining\",\n    \"msContentZoomFactor\",\n    \"msContentZoomLimit\",\n    \"msContentZoomLimitMax\",\n    \"msContentZoomLimitMin\",\n    \"msContentZoomSnap\",\n    \"msContentZoomSnapPoints\",\n    \"msContentZoomSnapType\",\n    \"msContentZooming\",\n    \"msConvertURL\",\n    \"msCrypto\",\n    \"msDoNotTrack\",\n    \"msElementsFromPoint\",\n    \"msElementsFromRect\",\n    \"msExitFullscreen\",\n    \"msExtendedCode\",\n    \"msFillRule\",\n    \"msFirstPaint\",\n    \"msFlex\",\n    \"msFlexAlign\",\n    \"msFlexDirection\",\n    \"msFlexFlow\",\n    \"msFlexItemAlign\",\n    \"msFlexLinePack\",\n    \"msFlexNegative\",\n    \"msFlexOrder\",\n    \"msFlexPack\",\n    \"msFlexPositive\",\n    \"msFlexPreferredSize\",\n    \"msFlexWrap\",\n    \"msFlowFrom\",\n    \"msFlowInto\",\n    \"msFontFeatureSettings\",\n    \"msFullscreenElement\",\n    \"msFullscreenEnabled\",\n    \"msGetInputContext\",\n    \"msGetRegionContent\",\n    \"msGetUntransformedBounds\",\n    \"msGraphicsTrustStatus\",\n    \"msGridColumn\",\n    \"msGridColumnAlign\",\n    \"msGridColumnSpan\",\n    \"msGridColumns\",\n    \"msGridRow\",\n    \"msGridRowAlign\",\n    \"msGridRowSpan\",\n    \"msGridRows\",\n    \"msHidden\",\n    \"msHighContrastAdjust\",\n    \"msHyphenateLimitChars\",\n    \"msHyphenateLimitLines\",\n    \"msHyphenateLimitZone\",\n    \"msHyphens\",\n    \"msImageSmoothingEnabled\",\n    \"msImeAlign\",\n    \"msIndexedDB\",\n    \"msInterpolationMode\",\n    \"msIsStaticHTML\",\n    \"msKeySystem\",\n    \"msKeys\",\n    \"msLaunchUri\",\n    \"msLockOrientation\",\n    \"msManipulationViewsEnabled\",\n    \"msMatchMedia\",\n    \"msMatchesSelector\",\n    \"msMaxTouchPoints\",\n    \"msOrientation\",\n    \"msOverflowStyle\",\n    \"msPerspective\",\n    \"msPerspectiveOrigin\",\n    \"msPlayToDisabled\",\n    \"msPlayToPreferredSourceUri\",\n    \"msPlayToPrimary\",\n    \"msPointerEnabled\",\n    \"msRegionOverflow\",\n    \"msReleasePointerCapture\",\n    \"msRequestAnimationFrame\",\n    \"msRequestFullscreen\",\n    \"msSaveBlob\",\n    \"msSaveOrOpenBlob\",\n    \"msScrollChaining\",\n    \"msScrollLimit\",\n    \"msScrollLimitXMax\",\n    \"msScrollLimitXMin\",\n    \"msScrollLimitYMax\",\n    \"msScrollLimitYMin\",\n    \"msScrollRails\",\n    \"msScrollSnapPointsX\",\n    \"msScrollSnapPointsY\",\n    \"msScrollSnapType\",\n    \"msScrollSnapX\",\n    \"msScrollSnapY\",\n    \"msScrollTranslation\",\n    \"msSetImmediate\",\n    \"msSetMediaKeys\",\n    \"msSetPointerCapture\",\n    \"msTextCombineHorizontal\",\n    \"msTextSizeAdjust\",\n    \"msToBlob\",\n    \"msTouchAction\",\n    \"msTouchSelect\",\n    \"msTraceAsyncCallbackCompleted\",\n    \"msTraceAsyncCallbackStarting\",\n    \"msTraceAsyncOperationCompleted\",\n    \"msTraceAsyncOperationStarting\",\n    \"msTransform\",\n    \"msTransformOrigin\",\n    \"msTransformStyle\",\n    \"msTransition\",\n    \"msTransitionDelay\",\n    \"msTransitionDuration\",\n    \"msTransitionProperty\",\n    \"msTransitionTimingFunction\",\n    \"msUnlockOrientation\",\n    \"msUpdateAsyncCallbackRelation\",\n    \"msUserSelect\",\n    \"msVisibilityState\",\n    \"msWrapFlow\",\n    \"msWrapMargin\",\n    \"msWrapThrough\",\n    \"msWriteProfilerMark\",\n    \"msZoom\",\n    \"msZoomTo\",\n    \"mt\",\n    \"mul\",\n    \"multiEntry\",\n    \"multiSelectionObj\",\n    \"multiline\",\n    \"multiple\",\n    \"multiply\",\n    \"multiplySelf\",\n    \"multisample\",\n    \"multisampled\",\n    \"mutableFile\",\n    \"muted\",\n    \"n\",\n    \"nacl_arch\",\n    \"name\",\n    \"nameList\",\n    \"nameProp\",\n    \"namedItem\",\n    \"namedRecordset\",\n    \"names\",\n    \"namespaceURI\",\n    \"namespaces\",\n    \"nativeApplication\",\n    \"nativeMap\",\n    \"nativeObjectCreate\",\n    \"nativeSet\",\n    \"nativeWeakMap\",\n    \"naturalHeight\",\n    \"naturalWidth\",\n    \"navigate\",\n    \"navigation\",\n    \"navigationMode\",\n    \"navigationPreload\",\n    \"navigationStart\",\n    \"navigationType\",\n    \"navigator\",\n    \"near\",\n    \"nearestViewportElement\",\n    \"negative\",\n    \"negotiated\",\n    \"netscape\",\n    \"networkState\",\n    \"networkStatus\",\n    \"newScale\",\n    \"newState\",\n    \"newTranslate\",\n    \"newURL\",\n    \"newValue\",\n    \"newValueSpecifiedUnits\",\n    \"newVersion\",\n    \"newhome\",\n    \"next\",\n    \"nextElementSibling\",\n    \"nextHopProtocol\",\n    \"nextNode\",\n    \"nextPage\",\n    \"nextSibling\",\n    \"nickname\",\n    \"noHref\",\n    \"noModule\",\n    \"noResize\",\n    \"noShade\",\n    \"noValidate\",\n    \"noWrap\",\n    \"node\",\n    \"nodeName\",\n    \"nodeType\",\n    \"nodeValue\",\n    \"nonce\",\n    \"normDepthBufferFromNormView\",\n    \"normalize\",\n    \"normalizedPathSegList\",\n    \"normandyAddonStudy\",\n    \"notRestoredReasons\",\n    \"notationName\",\n    \"notations\",\n    \"note\",\n    \"noteGrainOn\",\n    \"noteOff\",\n    \"noteOn\",\n    \"notifications\",\n    \"notify\",\n    \"now\",\n    \"npnNegotiatedProtocol\",\n    \"numOctaves\",\n    \"number\",\n    \"numberOfChannels\",\n    \"numberOfFrames\",\n    \"numberOfInputs\",\n    \"numberOfItems\",\n    \"numberOfOutputs\",\n    \"numberValue\",\n    \"oMatchesSelector\",\n    \"object\",\n    \"object-fit\",\n    \"object-position\",\n    \"objectFit\",\n    \"objectPosition\",\n    \"objectStore\",\n    \"objectStoreNames\",\n    \"objectType\",\n    \"observe\",\n    \"occlusionQuerySet\",\n    \"of\",\n    \"off\",\n    \"offscreenBuffering\",\n    \"offset\",\n    \"offset-anchor\",\n    \"offset-distance\",\n    \"offset-path\",\n    \"offset-position\",\n    \"offset-rotate\",\n    \"offsetAnchor\",\n    \"offsetDistance\",\n    \"offsetHeight\",\n    \"offsetLeft\",\n    \"offsetNode\",\n    \"offsetParent\",\n    \"offsetPath\",\n    \"offsetPosition\",\n    \"offsetRotate\",\n    \"offsetTop\",\n    \"offsetWidth\",\n    \"offsetX\",\n    \"offsetY\",\n    \"ok\",\n    \"oldState\",\n    \"oldURL\",\n    \"oldValue\",\n    \"oldVersion\",\n    \"olderShadowRoot\",\n    \"omnibox\",\n    \"on\",\n    \"onActivated\",\n    \"onAdded\",\n    \"onAttached\",\n    \"onBoundsChanged\",\n    \"onBrowserUpdateAvailable\",\n    \"onClicked\",\n    \"onCommitFiberRoot\",\n    \"onCommitFiberUnmount\",\n    \"onConnect\",\n    \"onConnectExternal\",\n    \"onConnectNative\",\n    \"onCreated\",\n    \"onDetached\",\n    \"onDisabled\",\n    \"onEnabled\",\n    \"onFocusChanged\",\n    \"onHighlighted\",\n    \"onInstalled\",\n    \"onLine\",\n    \"onMessage\",\n    \"onMessageExternal\",\n    \"onMoved\",\n    \"onPerformanceWarning\",\n    \"onPostCommitFiberRoot\",\n    \"onRemoved\",\n    \"onReplaced\",\n    \"onRestartRequired\",\n    \"onStartup\",\n    \"onSubmittedWorkDone\",\n    \"onSuspend\",\n    \"onSuspendCanceled\",\n    \"onUninstalled\",\n    \"onUpdateAvailable\",\n    \"onUpdated\",\n    \"onUserScriptConnect\",\n    \"onUserScriptMessage\",\n    \"onUserSettingsChanged\",\n    \"onZoomChange\",\n    \"onabort\",\n    \"onabsolutedeviceorientation\",\n    \"onactivate\",\n    \"onactive\",\n    \"onaddsourcebuffer\",\n    \"onaddstream\",\n    \"onaddtrack\",\n    \"onafterprint\",\n    \"onafterscriptexecute\",\n    \"onafterupdate\",\n    \"onanimationcancel\",\n    \"onanimationend\",\n    \"onanimationiteration\",\n    \"onanimationstart\",\n    \"onappinstalled\",\n    \"onaudioend\",\n    \"onaudioprocess\",\n    \"onaudiostart\",\n    \"onautocomplete\",\n    \"onautocompleteerror\",\n    \"onauxclick\",\n    \"onbeforeactivate\",\n    \"onbeforecopy\",\n    \"onbeforecut\",\n    \"onbeforedeactivate\",\n    \"onbeforeeditfocus\",\n    \"onbeforeinput\",\n    \"onbeforeinstallprompt\",\n    \"onbeforematch\",\n    \"onbeforepaste\",\n    \"onbeforeprint\",\n    \"onbeforescriptexecute\",\n    \"onbeforetoggle\",\n    \"onbeforeunload\",\n    \"onbeforeupdate\",\n    \"onbeforexrselect\",\n    \"onbegin\",\n    \"onblocked\",\n    \"onblur\",\n    \"onbounce\",\n    \"onboundary\",\n    \"onbufferedamountlow\",\n    \"oncached\",\n    \"oncancel\",\n    \"oncandidatewindowhide\",\n    \"oncandidatewindowshow\",\n    \"oncandidatewindowupdate\",\n    \"oncanplay\",\n    \"oncanplaythrough\",\n    \"oncapturehandlechange\",\n    \"once\",\n    \"oncellchange\",\n    \"onchange\",\n    \"oncharacterboundsupdate\",\n    \"oncharacteristicvaluechanged\",\n    \"onchargingchange\",\n    \"onchargingtimechange\",\n    \"onchecking\",\n    \"onclick\",\n    \"onclose\",\n    \"onclosing\",\n    \"oncompassneedscalibration\",\n    \"oncomplete\",\n    \"oncompositionend\",\n    \"oncompositionstart\",\n    \"onconnect\",\n    \"onconnecting\",\n    \"onconnectionavailable\",\n    \"onconnectionstatechange\",\n    \"oncontentvisibilityautostatechange\",\n    \"oncontextlost\",\n    \"oncontextmenu\",\n    \"oncontextrestored\",\n    \"oncontrollerchange\",\n    \"oncontrolselect\",\n    \"oncopy\",\n    \"oncuechange\",\n    \"oncurrententrychange\",\n    \"oncurrentscreenchange\",\n    \"oncut\",\n    \"ondataavailable\",\n    \"ondatachannel\",\n    \"ondatasetchanged\",\n    \"ondatasetcomplete\",\n    \"ondblclick\",\n    \"ondeactivate\",\n    \"ondequeue\",\n    \"ondevicechange\",\n    \"ondevicelight\",\n    \"ondevicemotion\",\n    \"ondeviceorientation\",\n    \"ondeviceorientationabsolute\",\n    \"ondeviceproximity\",\n    \"ondischargingtimechange\",\n    \"ondisconnect\",\n    \"ondisplay\",\n    \"ondispose\",\n    \"ondownloading\",\n    \"ondrag\",\n    \"ondragend\",\n    \"ondragenter\",\n    \"ondragexit\",\n    \"ondragleave\",\n    \"ondragover\",\n    \"ondragstart\",\n    \"ondrop\",\n    \"ondurationchange\",\n    \"onemptied\",\n    \"onencrypted\",\n    \"onend\",\n    \"onended\",\n    \"onenter\",\n    \"onenterpictureinpicture\",\n    \"onerror\",\n    \"onerrorupdate\",\n    \"onexit\",\n    \"onfencedtreeclick\",\n    \"onfilterchange\",\n    \"onfinish\",\n    \"onfocus\",\n    \"onfocusin\",\n    \"onfocusout\",\n    \"onformdata\",\n    \"onfreeze\",\n    \"onfullscreenchange\",\n    \"onfullscreenerror\",\n    \"ongamepadconnected\",\n    \"ongamepaddisconnected\",\n    \"ongatheringstatechange\",\n    \"ongattserverdisconnected\",\n    \"ongeometrychange\",\n    \"ongesturechange\",\n    \"ongestureend\",\n    \"ongesturestart\",\n    \"ongotpointercapture\",\n    \"onhashchange\",\n    \"onhelp\",\n    \"onicecandidate\",\n    \"onicecandidateerror\",\n    \"oniceconnectionstatechange\",\n    \"onicegatheringstatechange\",\n    \"oninactive\",\n    \"oninput\",\n    \"oninputreport\",\n    \"oninputsourceschange\",\n    \"oninvalid\",\n    \"onkeydown\",\n    \"onkeypress\",\n    \"onkeystatuseschange\",\n    \"onkeyup\",\n    \"onlanguagechange\",\n    \"onlayoutcomplete\",\n    \"onleavepictureinpicture\",\n    \"onlevelchange\",\n    \"onload\",\n    \"onloadT\",\n    \"onloadeddata\",\n    \"onloadedmetadata\",\n    \"onloadend\",\n    \"onloading\",\n    \"onloadingdone\",\n    \"onloadingerror\",\n    \"onloadstart\",\n    \"onlosecapture\",\n    \"onlostpointercapture\",\n    \"only\",\n    \"onmanagedconfigurationchange\",\n    \"onmark\",\n    \"onmessage\",\n    \"onmessageerror\",\n    \"onmidimessage\",\n    \"onmousedown\",\n    \"onmouseenter\",\n    \"onmouseleave\",\n    \"onmousemove\",\n    \"onmouseout\",\n    \"onmouseover\",\n    \"onmouseup\",\n    \"onmousewheel\",\n    \"onmove\",\n    \"onmoveend\",\n    \"onmovestart\",\n    \"onmozfullscreenchange\",\n    \"onmozfullscreenerror\",\n    \"onmozorientationchange\",\n    \"onmozpointerlockchange\",\n    \"onmozpointerlockerror\",\n    \"onmscontentzoom\",\n    \"onmsfullscreenchange\",\n    \"onmsfullscreenerror\",\n    \"onmsgesturechange\",\n    \"onmsgesturedoubletap\",\n    \"onmsgestureend\",\n    \"onmsgesturehold\",\n    \"onmsgesturestart\",\n    \"onmsgesturetap\",\n    \"onmsgotpointercapture\",\n    \"onmsinertiastart\",\n    \"onmslostpointercapture\",\n    \"onmsmanipulationstatechanged\",\n    \"onmsneedkey\",\n    \"onmsorientationchange\",\n    \"onmspointercancel\",\n    \"onmspointerdown\",\n    \"onmspointerenter\",\n    \"onmspointerhover\",\n    \"onmspointerleave\",\n    \"onmspointermove\",\n    \"onmspointerout\",\n    \"onmspointerover\",\n    \"onmspointerup\",\n    \"onmssitemodejumplistitemremoved\",\n    \"onmsthumbnailclick\",\n    \"onmute\",\n    \"onnavigate\",\n    \"onnavigateerror\",\n    \"onnavigatesuccess\",\n    \"onnegotiationneeded\",\n    \"onnomatch\",\n    \"onnoupdate\",\n    \"onobsolete\",\n    \"onoffline\",\n    \"ononline\",\n    \"onopen\",\n    \"onorientationchange\",\n    \"onpagechange\",\n    \"onpagehide\",\n    \"onpagereveal\",\n    \"onpageshow\",\n    \"onpageswap\",\n    \"onpaste\",\n    \"onpause\",\n    \"onpayerdetailchange\",\n    \"onpaymentmethodchange\",\n    \"onplay\",\n    \"onplaying\",\n    \"onpluginstreamstart\",\n    \"onpointercancel\",\n    \"onpointerdown\",\n    \"onpointerenter\",\n    \"onpointerleave\",\n    \"onpointerlockchange\",\n    \"onpointerlockerror\",\n    \"onpointermove\",\n    \"onpointerout\",\n    \"onpointerover\",\n    \"onpointerrawupdate\",\n    \"onpointerup\",\n    \"onpopstate\",\n    \"onprerenderingchange\",\n    \"onprioritychange\",\n    \"onprocessorerror\",\n    \"onprogress\",\n    \"onpropertychange\",\n    \"onratechange\",\n    \"onreading\",\n    \"onreadystatechange\",\n    \"onreflectionchange\",\n    \"onrejectionhandled\",\n    \"onrelease\",\n    \"onremove\",\n    \"onremovesourcebuffer\",\n    \"onremovestream\",\n    \"onremovetrack\",\n    \"onrepeat\",\n    \"onreset\",\n    \"onresize\",\n    \"onresizeend\",\n    \"onresizestart\",\n    \"onresourcetimingbufferfull\",\n    \"onresult\",\n    \"onresume\",\n    \"onrowenter\",\n    \"onrowexit\",\n    \"onrowsdelete\",\n    \"onrowsinserted\",\n    \"onscreenschange\",\n    \"onscroll\",\n    \"onscrollend\",\n    \"onscrollsnapchange\",\n    \"onscrollsnapchanging\",\n    \"onsearch\",\n    \"onsecuritypolicyviolation\",\n    \"onseeked\",\n    \"onseeking\",\n    \"onselect\",\n    \"onselectedcandidatepairchange\",\n    \"onselectend\",\n    \"onselectionchange\",\n    \"onselectstart\",\n    \"onshippingaddresschange\",\n    \"onshippingoptionchange\",\n    \"onshow\",\n    \"onsignalingstatechange\",\n    \"onsinkchange\",\n    \"onslotchange\",\n    \"onsoundend\",\n    \"onsoundstart\",\n    \"onsourceclose\",\n    \"onsourceclosed\",\n    \"onsourceended\",\n    \"onsourceopen\",\n    \"onspeechend\",\n    \"onspeechstart\",\n    \"onsqueeze\",\n    \"onsqueezeend\",\n    \"onsqueezestart\",\n    \"onstalled\",\n    \"onstart\",\n    \"onstatechange\",\n    \"onstop\",\n    \"onstorage\",\n    \"onstoragecommit\",\n    \"onsubmit\",\n    \"onsuccess\",\n    \"onsuspend\",\n    \"onterminate\",\n    \"ontextformatupdate\",\n    \"ontextinput\",\n    \"ontextupdate\",\n    \"ontimeout\",\n    \"ontimeupdate\",\n    \"ontoggle\",\n    \"ontonechange\",\n    \"ontouchcancel\",\n    \"ontouchend\",\n    \"ontouchmove\",\n    \"ontouchstart\",\n    \"ontrack\",\n    \"ontransitioncancel\",\n    \"ontransitionend\",\n    \"ontransitionrun\",\n    \"ontransitionstart\",\n    \"onuncapturederror\",\n    \"onunhandledrejection\",\n    \"onunload\",\n    \"onunmute\",\n    \"onupdate\",\n    \"onupdateend\",\n    \"onupdatefound\",\n    \"onupdateready\",\n    \"onupdatestart\",\n    \"onupgradeneeded\",\n    \"onuserproximity\",\n    \"onversionchange\",\n    \"onvisibilitychange\",\n    \"onvoiceschanged\",\n    \"onvolumechange\",\n    \"onvrdisplayactivate\",\n    \"onvrdisplayconnect\",\n    \"onvrdisplaydeactivate\",\n    \"onvrdisplaydisconnect\",\n    \"onvrdisplaypresentchange\",\n    \"onwaiting\",\n    \"onwaitingforkey\",\n    \"onwarning\",\n    \"onwebkitanimationend\",\n    \"onwebkitanimationiteration\",\n    \"onwebkitanimationstart\",\n    \"onwebkitcurrentplaybacktargetiswirelesschanged\",\n    \"onwebkitfullscreenchange\",\n    \"onwebkitfullscreenerror\",\n    \"onwebkitkeyadded\",\n    \"onwebkitkeyerror\",\n    \"onwebkitkeymessage\",\n    \"onwebkitneedkey\",\n    \"onwebkitorientationchange\",\n    \"onwebkitplaybacktargetavailabilitychanged\",\n    \"onwebkitpointerlockchange\",\n    \"onwebkitpointerlockerror\",\n    \"onwebkitresourcetimingbufferfull\",\n    \"onwebkittransitionend\",\n    \"onwheel\",\n    \"onzoom\",\n    \"opacity\",\n    \"open\",\n    \"openCursor\",\n    \"openDatabase\",\n    \"openKeyCursor\",\n    \"openOptionsPage\",\n    \"openOrClosedShadowRoot\",\n    \"openPopup\",\n    \"opened\",\n    \"opener\",\n    \"opera\",\n    \"operation\",\n    \"operationType\",\n    \"operator\",\n    \"opr\",\n    \"optimum\",\n    \"options\",\n    \"or\",\n    \"order\",\n    \"orderX\",\n    \"orderY\",\n    \"ordered\",\n    \"org\",\n    \"organization\",\n    \"orient\",\n    \"orientAngle\",\n    \"orientType\",\n    \"orientation\",\n    \"orientationX\",\n    \"orientationY\",\n    \"orientationZ\",\n    \"origin\",\n    \"originAgentCluster\",\n    \"originalPolicy\",\n    \"originalTarget\",\n    \"orphans\",\n    \"os\",\n    \"oscpu\",\n    \"outerHTML\",\n    \"outerHeight\",\n    \"outerText\",\n    \"outerWidth\",\n    \"outgoingHighWaterMark\",\n    \"outgoingMaxAge\",\n    \"outline\",\n    \"outline-color\",\n    \"outline-offset\",\n    \"outline-style\",\n    \"outline-width\",\n    \"outlineColor\",\n    \"outlineOffset\",\n    \"outlineStyle\",\n    \"outlineWidth\",\n    \"outputBuffer\",\n    \"outputChannelCount\",\n    \"outputLatency\",\n    \"outputs\",\n    \"overflow\",\n    \"overflow-anchor\",\n    \"overflow-block\",\n    \"overflow-clip-margin\",\n    \"overflow-inline\",\n    \"overflow-wrap\",\n    \"overflow-x\",\n    \"overflow-y\",\n    \"overflowAnchor\",\n    \"overflowBlock\",\n    \"overflowClipMargin\",\n    \"overflowInline\",\n    \"overflowWrap\",\n    \"overflowX\",\n    \"overflowY\",\n    \"overlaysContent\",\n    \"overrideColors\",\n    \"overrideMimeType\",\n    \"oversample\",\n    \"overscroll-behavior\",\n    \"overscroll-behavior-block\",\n    \"overscroll-behavior-inline\",\n    \"overscroll-behavior-x\",\n    \"overscroll-behavior-y\",\n    \"overscrollBehavior\",\n    \"overscrollBehaviorBlock\",\n    \"overscrollBehaviorInline\",\n    \"overscrollBehaviorX\",\n    \"overscrollBehaviorY\",\n    \"ownKeys\",\n    \"ownerDocument\",\n    \"ownerElement\",\n    \"ownerNode\",\n    \"ownerRule\",\n    \"ownerSVGElement\",\n    \"owningElement\",\n    \"p1\",\n    \"p2\",\n    \"p3\",\n    \"p4\",\n    \"packetSize\",\n    \"packets\",\n    \"pad\",\n    \"padEnd\",\n    \"padStart\",\n    \"padding\",\n    \"padding-block\",\n    \"padding-block-end\",\n    \"padding-block-start\",\n    \"padding-bottom\",\n    \"padding-inline\",\n    \"padding-inline-end\",\n    \"padding-inline-start\",\n    \"padding-left\",\n    \"padding-right\",\n    \"padding-top\",\n    \"paddingBlock\",\n    \"paddingBlockEnd\",\n    \"paddingBlockStart\",\n    \"paddingBottom\",\n    \"paddingInline\",\n    \"paddingInlineEnd\",\n    \"paddingInlineStart\",\n    \"paddingLeft\",\n    \"paddingRight\",\n    \"paddingTop\",\n    \"page\",\n    \"page-break-after\",\n    \"page-break-before\",\n    \"page-break-inside\",\n    \"page-orientation\",\n    \"pageAction\",\n    \"pageBreakAfter\",\n    \"pageBreakBefore\",\n    \"pageBreakInside\",\n    \"pageCount\",\n    \"pageLeft\",\n    \"pageOrientation\",\n    \"pageT\",\n    \"pageTop\",\n    \"pageX\",\n    \"pageXOffset\",\n    \"pageY\",\n    \"pageYOffset\",\n    \"pages\",\n    \"paint-order\",\n    \"paintOrder\",\n    \"paintRequests\",\n    \"paintType\",\n    \"paintWorklet\",\n    \"palette\",\n    \"pan\",\n    \"panningModel\",\n    \"parameterData\",\n    \"parameters\",\n    \"parent\",\n    \"parentElement\",\n    \"parentNode\",\n    \"parentRule\",\n    \"parentStyleSheet\",\n    \"parentTextEdit\",\n    \"parentWindow\",\n    \"parse\",\n    \"parseAll\",\n    \"parseCreationOptionsFromJSON\",\n    \"parseFloat\",\n    \"parseFromString\",\n    \"parseHTMLUnsafe\",\n    \"parseInt\",\n    \"parseRequestOptionsFromJSON\",\n    \"part\",\n    \"participants\",\n    \"passOp\",\n    \"passive\",\n    \"password\",\n    \"pasteHTML\",\n    \"path\",\n    \"pathLength\",\n    \"pathSegList\",\n    \"pathSegType\",\n    \"pathSegTypeAsLetter\",\n    \"pathname\",\n    \"pattern\",\n    \"patternContentUnits\",\n    \"patternMismatch\",\n    \"patternTransform\",\n    \"patternUnits\",\n    \"pause\",\n    \"pauseAnimations\",\n    \"pauseDuration\",\n    \"pauseOnExit\",\n    \"pauseProfilers\",\n    \"pauseTransformFeedback\",\n    \"paused\",\n    \"payerEmail\",\n    \"payerName\",\n    \"payerPhone\",\n    \"paymentManager\",\n    \"pc\",\n    \"pdfViewerEnabled\",\n    \"peerIdentity\",\n    \"pending\",\n    \"pendingLocalDescription\",\n    \"pendingRemoteDescription\",\n    \"percent\",\n    \"performance\",\n    \"periodicSync\",\n    \"permission\",\n    \"permissionState\",\n    \"permissions\",\n    \"persist\",\n    \"persisted\",\n    \"persistentDeviceId\",\n    \"personalbar\",\n    \"perspective\",\n    \"perspective-origin\",\n    \"perspectiveOrigin\",\n    \"phone\",\n    \"phoneticFamilyName\",\n    \"phoneticGivenName\",\n    \"photo\",\n    \"pictureInPictureChild\",\n    \"pictureInPictureElement\",\n    \"pictureInPictureEnabled\",\n    \"pictureInPictureWindow\",\n    \"ping\",\n    \"pipeThrough\",\n    \"pipeTo\",\n    \"pitch\",\n    \"pixelBottom\",\n    \"pixelDepth\",\n    \"pixelHeight\",\n    \"pixelLeft\",\n    \"pixelRight\",\n    \"pixelStorei\",\n    \"pixelTop\",\n    \"pixelUnitToMillimeterX\",\n    \"pixelUnitToMillimeterY\",\n    \"pixelWidth\",\n    \"pkcs11\",\n    \"place-content\",\n    \"place-items\",\n    \"place-self\",\n    \"placeContent\",\n    \"placeItems\",\n    \"placeSelf\",\n    \"placeholder\",\n    \"platform\",\n    \"platformVersion\",\n    \"platforms\",\n    \"play\",\n    \"playEffect\",\n    \"playState\",\n    \"playbackRate\",\n    \"playbackState\",\n    \"playbackTime\",\n    \"played\",\n    \"playoutDelayHint\",\n    \"playsInline\",\n    \"plugins\",\n    \"pluginspage\",\n    \"pname\",\n    \"pointer-events\",\n    \"pointerBeforeReferenceNode\",\n    \"pointerEnabled\",\n    \"pointerEvents\",\n    \"pointerId\",\n    \"pointerLockElement\",\n    \"pointerType\",\n    \"points\",\n    \"pointsAtX\",\n    \"pointsAtY\",\n    \"pointsAtZ\",\n    \"polygonOffset\",\n    \"pop\",\n    \"popDebugGroup\",\n    \"popErrorScope\",\n    \"popover\",\n    \"popoverTargetAction\",\n    \"popoverTargetElement\",\n    \"populateMatrix\",\n    \"popupWindowFeatures\",\n    \"popupWindowName\",\n    \"popupWindowURI\",\n    \"port\",\n    \"port1\",\n    \"port2\",\n    \"ports\",\n    \"posBottom\",\n    \"posHeight\",\n    \"posLeft\",\n    \"posRight\",\n    \"posTop\",\n    \"posWidth\",\n    \"pose\",\n    \"position\",\n    \"position-anchor\",\n    \"position-area\",\n    \"positionAlign\",\n    \"positionAnchor\",\n    \"positionArea\",\n    \"positionX\",\n    \"positionY\",\n    \"positionZ\",\n    \"postError\",\n    \"postMessage\",\n    \"postTask\",\n    \"postalCode\",\n    \"poster\",\n    \"postscriptName\",\n    \"pow\",\n    \"powerEfficient\",\n    \"powerOff\",\n    \"powerPreference\",\n    \"preMultiplySelf\",\n    \"precision\",\n    \"preferredReflectionFormat\",\n    \"preferredStyleSheetSet\",\n    \"preferredStylesheetSet\",\n    \"prefix\",\n    \"preload\",\n    \"premultipliedAlpha\",\n    \"prepend\",\n    \"prerendering\",\n    \"presentation\",\n    \"presentationArea\",\n    \"presentationStyle\",\n    \"preserveAlpha\",\n    \"preserveAspectRatio\",\n    \"preserveAspectRatioString\",\n    \"preservesPitch\",\n    \"pressed\",\n    \"pressure\",\n    \"prevValue\",\n    \"preventDefault\",\n    \"preventExtensions\",\n    \"preventSilentAccess\",\n    \"previousElementSibling\",\n    \"previousNode\",\n    \"previousPage\",\n    \"previousPriority\",\n    \"previousRect\",\n    \"previousScale\",\n    \"previousSibling\",\n    \"previousTranslate\",\n    \"primaries\",\n    \"primaryKey\",\n    \"primaryLightDirection\",\n    \"primaryLightIntensity\",\n    \"primitive\",\n    \"primitiveType\",\n    \"primitiveUnits\",\n    \"principals\",\n    \"print\",\n    \"print-color-adjust\",\n    \"printColorAdjust\",\n    \"printPreview\",\n    \"priority\",\n    \"privacy\",\n    \"privateKey\",\n    \"privateToken\",\n    \"probablySupportsContext\",\n    \"probeSpace\",\n    \"process\",\n    \"processIceMessage\",\n    \"processingEnd\",\n    \"processingStart\",\n    \"processorOptions\",\n    \"product\",\n    \"productId\",\n    \"productName\",\n    \"productSub\",\n    \"profile\",\n    \"profileEnd\",\n    \"profiles\",\n    \"projectionMatrix\",\n    \"promise\",\n    \"prompt\",\n    \"properties\",\n    \"propertyIsEnumerable\",\n    \"propertyName\",\n    \"protectedAudience\",\n    \"protocol\",\n    \"protocolLong\",\n    \"prototype\",\n    \"provider\",\n    \"proxy\",\n    \"pseudoClass\",\n    \"pseudoElement\",\n    \"pt\",\n    \"publicId\",\n    \"publicKey\",\n    \"published\",\n    \"pulse\",\n    \"push\",\n    \"pushDebugGroup\",\n    \"pushErrorScope\",\n    \"pushManager\",\n    \"pushNotification\",\n    \"pushState\",\n    \"put\",\n    \"putImageData\",\n    \"px\",\n    \"quadraticCurveTo\",\n    \"qualifier\",\n    \"quaternion\",\n    \"query\",\n    \"queryCommandEnabled\",\n    \"queryCommandIndeterm\",\n    \"queryCommandState\",\n    \"queryCommandSupported\",\n    \"queryCommandText\",\n    \"queryCommandValue\",\n    \"queryFeatureSupport\",\n    \"queryLocalFonts\",\n    \"queryPermission\",\n    \"querySelector\",\n    \"querySelectorAll\",\n    \"querySet\",\n    \"queue\",\n    \"queueMicrotask\",\n    \"quote\",\n    \"quotes\",\n    \"r\",\n    \"r1\",\n    \"r2\",\n    \"race\",\n    \"rad\",\n    \"radiogroup\",\n    \"radius\",\n    \"radiusX\",\n    \"radiusY\",\n    \"random\",\n    \"randomUUID\",\n    \"range\",\n    \"rangeCount\",\n    \"rangeEnd\",\n    \"rangeMax\",\n    \"rangeMin\",\n    \"rangeOffset\",\n    \"rangeOverflow\",\n    \"rangeParent\",\n    \"rangeStart\",\n    \"rangeUnderflow\",\n    \"rate\",\n    \"ratio\",\n    \"raw\",\n    \"rawId\",\n    \"rawJSON\",\n    \"rawValueToMeters\",\n    \"rcap\",\n    \"rch\",\n    \"read\",\n    \"readAsArrayBuffer\",\n    \"readAsBinaryString\",\n    \"readAsBlob\",\n    \"readAsDataURL\",\n    \"readAsText\",\n    \"readBuffer\",\n    \"readEntries\",\n    \"readOnly\",\n    \"readPixels\",\n    \"readReportRequested\",\n    \"readText\",\n    \"readValue\",\n    \"readable\",\n    \"ready\",\n    \"readyState\",\n    \"reason\",\n    \"reasons\",\n    \"reboot\",\n    \"receiveFeatureReport\",\n    \"receivedAlert\",\n    \"receiver\",\n    \"receivers\",\n    \"recipient\",\n    \"recommendedViewportScale\",\n    \"reconnect\",\n    \"recordNumber\",\n    \"recordsAvailable\",\n    \"recordset\",\n    \"rect\",\n    \"red\",\n    \"redEyeReduction\",\n    \"redirect\",\n    \"redirectCount\",\n    \"redirectEnd\",\n    \"redirectStart\",\n    \"redirected\",\n    \"reduce\",\n    \"reduceRight\",\n    \"reduction\",\n    \"refDistance\",\n    \"refX\",\n    \"refY\",\n    \"referenceNode\",\n    \"referenceSpace\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"refresh\",\n    \"region\",\n    \"regionAnchorX\",\n    \"regionAnchorY\",\n    \"regionId\",\n    \"regions\",\n    \"register\",\n    \"registerContentHandler\",\n    \"registerElement\",\n    \"registerInternalModuleStart\",\n    \"registerInternalModuleStop\",\n    \"registerProperty\",\n    \"registerProtocolHandler\",\n    \"reject\",\n    \"rel\",\n    \"relList\",\n    \"relatedAddress\",\n    \"relatedNode\",\n    \"relatedPort\",\n    \"relatedTarget\",\n    \"relayProtocol\",\n    \"release\",\n    \"releaseCapture\",\n    \"releaseEvents\",\n    \"releaseInterface\",\n    \"releaseLock\",\n    \"releasePointerCapture\",\n    \"releaseShaderCompiler\",\n    \"released\",\n    \"reliability\",\n    \"reliable\",\n    \"reliableWrite\",\n    \"reload\",\n    \"rem\",\n    \"remainingSpace\",\n    \"remote\",\n    \"remoteDescription\",\n    \"remove\",\n    \"removeAllRanges\",\n    \"removeAttribute\",\n    \"removeAttributeNS\",\n    \"removeAttributeNode\",\n    \"removeBehavior\",\n    \"removeChild\",\n    \"removeCue\",\n    \"removeEntry\",\n    \"removeEventListener\",\n    \"removeFilter\",\n    \"removeImport\",\n    \"removeItem\",\n    \"removeListener\",\n    \"removeNamedItem\",\n    \"removeNamedItemNS\",\n    \"removeNode\",\n    \"removeParameter\",\n    \"removeProperty\",\n    \"removeRange\",\n    \"removeRegion\",\n    \"removeRule\",\n    \"removeSiteSpecificTrackingException\",\n    \"removeSourceBuffer\",\n    \"removeStream\",\n    \"removeTrack\",\n    \"removeVariable\",\n    \"removeWakeLockListener\",\n    \"removeWebWideTrackingException\",\n    \"removed\",\n    \"removedNodes\",\n    \"renderBlockingStatus\",\n    \"renderHeight\",\n    \"renderStart\",\n    \"renderState\",\n    \"renderTime\",\n    \"renderWidth\",\n    \"renderbufferStorage\",\n    \"renderbufferStorageMultisample\",\n    \"renderedBuffer\",\n    \"rendererInterfaces\",\n    \"renderers\",\n    \"renderingMode\",\n    \"renotify\",\n    \"repeat\",\n    \"repetitionCount\",\n    \"replace\",\n    \"replaceAdjacentText\",\n    \"replaceAll\",\n    \"replaceChild\",\n    \"replaceChildren\",\n    \"replaceData\",\n    \"replaceId\",\n    \"replaceItem\",\n    \"replaceNode\",\n    \"replaceState\",\n    \"replaceSync\",\n    \"replaceTrack\",\n    \"replaceWholeText\",\n    \"replaceWith\",\n    \"reportError\",\n    \"reportEvent\",\n    \"reportId\",\n    \"reportValidity\",\n    \"request\",\n    \"requestAdapter\",\n    \"requestAdapterInfo\",\n    \"requestAnimationFrame\",\n    \"requestAutocomplete\",\n    \"requestClose\",\n    \"requestData\",\n    \"requestDevice\",\n    \"requestFrame\",\n    \"requestFullscreen\",\n    \"requestHitTestSource\",\n    \"requestHitTestSourceForTransientInput\",\n    \"requestId\",\n    \"requestIdleCallback\",\n    \"requestLightProbe\",\n    \"requestMIDIAccess\",\n    \"requestMediaKeySystemAccess\",\n    \"requestPermission\",\n    \"requestPictureInPicture\",\n    \"requestPointerLock\",\n    \"requestPort\",\n    \"requestPresent\",\n    \"requestPresenter\",\n    \"requestReferenceSpace\",\n    \"requestSession\",\n    \"requestStart\",\n    \"requestStorageAccess\",\n    \"requestStorageAccessFor\",\n    \"requestSubmit\",\n    \"requestTime\",\n    \"requestUpdateCheck\",\n    \"requestVideoFrameCallback\",\n    \"requestViewportScale\",\n    \"requestWindow\",\n    \"requestingWindow\",\n    \"requireInteraction\",\n    \"required\",\n    \"requiredExtensions\",\n    \"requiredFeatures\",\n    \"requiredLimits\",\n    \"reset\",\n    \"resetLatency\",\n    \"resetPose\",\n    \"resetTransform\",\n    \"resizable\",\n    \"resize\",\n    \"resizeBy\",\n    \"resizeTo\",\n    \"resolve\",\n    \"resolveQuerySet\",\n    \"resolveTarget\",\n    \"resource\",\n    \"respond\",\n    \"respondWithNewView\",\n    \"response\",\n    \"responseBody\",\n    \"responseEnd\",\n    \"responseReady\",\n    \"responseStart\",\n    \"responseStatus\",\n    \"responseText\",\n    \"responseType\",\n    \"responseURL\",\n    \"responseXML\",\n    \"restart\",\n    \"restartAfterDelay\",\n    \"restartIce\",\n    \"restore\",\n    \"result\",\n    \"resultIndex\",\n    \"resultType\",\n    \"results\",\n    \"resume\",\n    \"resumeProfilers\",\n    \"resumeTransformFeedback\",\n    \"retry\",\n    \"returnValue\",\n    \"rev\",\n    \"reverse\",\n    \"reversed\",\n    \"revocable\",\n    \"revokeObjectURL\",\n    \"rex\",\n    \"rgbColor\",\n    \"ric\",\n    \"right\",\n    \"rightContext\",\n    \"rightDegrees\",\n    \"rightMargin\",\n    \"rightProjectionMatrix\",\n    \"rightViewMatrix\",\n    \"rlh\",\n    \"role\",\n    \"rolloffFactor\",\n    \"root\",\n    \"rootBounds\",\n    \"rootElement\",\n    \"rootMargin\",\n    \"rotate\",\n    \"rotateAxisAngle\",\n    \"rotateAxisAngleSelf\",\n    \"rotateFromVector\",\n    \"rotateFromVectorSelf\",\n    \"rotateSelf\",\n    \"rotation\",\n    \"rotationAngle\",\n    \"rotationRate\",\n    \"round\",\n    \"roundRect\",\n    \"row-gap\",\n    \"rowGap\",\n    \"rowIndex\",\n    \"rowSpan\",\n    \"rows\",\n    \"rowsPerImage\",\n    \"rtcpTransport\",\n    \"rtt\",\n    \"ruby-align\",\n    \"ruby-position\",\n    \"rubyAlign\",\n    \"rubyOverhang\",\n    \"rubyPosition\",\n    \"rules\",\n    \"run\",\n    \"runAdAuction\",\n    \"runtime\",\n    \"runtimeStyle\",\n    \"rx\",\n    \"ry\",\n    \"s\",\n    \"safari\",\n    \"sameDocument\",\n    \"sample\",\n    \"sampleCount\",\n    \"sampleCoverage\",\n    \"sampleInterval\",\n    \"sampleRate\",\n    \"sampleType\",\n    \"sampler\",\n    \"samplerParameterf\",\n    \"samplerParameteri\",\n    \"sandbox\",\n    \"save\",\n    \"saveAsPDF\",\n    \"saveData\",\n    \"scale\",\n    \"scale3d\",\n    \"scale3dSelf\",\n    \"scaleNonUniform\",\n    \"scaleNonUniformSelf\",\n    \"scaleSelf\",\n    \"scheduler\",\n    \"scheduling\",\n    \"scheme\",\n    \"scissor\",\n    \"scope\",\n    \"scopeName\",\n    \"scoped\",\n    \"screen\",\n    \"screenBrightness\",\n    \"screenEnabled\",\n    \"screenLeft\",\n    \"screenPixelToMillimeterX\",\n    \"screenPixelToMillimeterY\",\n    \"screenState\",\n    \"screenTop\",\n    \"screenX\",\n    \"screenY\",\n    \"screens\",\n    \"scriptURL\",\n    \"scripting\",\n    \"scripts\",\n    \"scroll\",\n    \"scroll-behavior\",\n    \"scroll-margin\",\n    \"scroll-margin-block\",\n    \"scroll-margin-block-end\",\n    \"scroll-margin-block-start\",\n    \"scroll-margin-bottom\",\n    \"scroll-margin-inline\",\n    \"scroll-margin-inline-end\",\n    \"scroll-margin-inline-start\",\n    \"scroll-margin-left\",\n    \"scroll-margin-right\",\n    \"scroll-margin-top\",\n    \"scroll-padding\",\n    \"scroll-padding-block\",\n    \"scroll-padding-block-end\",\n    \"scroll-padding-block-start\",\n    \"scroll-padding-bottom\",\n    \"scroll-padding-inline\",\n    \"scroll-padding-inline-end\",\n    \"scroll-padding-inline-start\",\n    \"scroll-padding-left\",\n    \"scroll-padding-right\",\n    \"scroll-padding-top\",\n    \"scroll-snap-align\",\n    \"scroll-snap-stop\",\n    \"scroll-snap-type\",\n    \"scrollAmount\",\n    \"scrollBehavior\",\n    \"scrollBy\",\n    \"scrollByLines\",\n    \"scrollByPages\",\n    \"scrollDelay\",\n    \"scrollHeight\",\n    \"scrollIntoView\",\n    \"scrollIntoViewIfNeeded\",\n    \"scrollLeft\",\n    \"scrollLeftMax\",\n    \"scrollMargin\",\n    \"scrollMarginBlock\",\n    \"scrollMarginBlockEnd\",\n    \"scrollMarginBlockStart\",\n    \"scrollMarginBottom\",\n    \"scrollMarginInline\",\n    \"scrollMarginInlineEnd\",\n    \"scrollMarginInlineStart\",\n    \"scrollMarginLeft\",\n    \"scrollMarginRight\",\n    \"scrollMarginTop\",\n    \"scrollMaxX\",\n    \"scrollMaxY\",\n    \"scrollPadding\",\n    \"scrollPaddingBlock\",\n    \"scrollPaddingBlockEnd\",\n    \"scrollPaddingBlockStart\",\n    \"scrollPaddingBottom\",\n    \"scrollPaddingInline\",\n    \"scrollPaddingInlineEnd\",\n    \"scrollPaddingInlineStart\",\n    \"scrollPaddingLeft\",\n    \"scrollPaddingRight\",\n    \"scrollPaddingTop\",\n    \"scrollRestoration\",\n    \"scrollSnapAlign\",\n    \"scrollSnapStop\",\n    \"scrollSnapType\",\n    \"scrollTo\",\n    \"scrollTop\",\n    \"scrollTopMax\",\n    \"scrollWidth\",\n    \"scrollX\",\n    \"scrollY\",\n    \"scrollbar-color\",\n    \"scrollbar-gutter\",\n    \"scrollbar-width\",\n    \"scrollbar3dLightColor\",\n    \"scrollbarArrowColor\",\n    \"scrollbarBaseColor\",\n    \"scrollbarColor\",\n    \"scrollbarDarkShadowColor\",\n    \"scrollbarFaceColor\",\n    \"scrollbarGutter\",\n    \"scrollbarHighlightColor\",\n    \"scrollbarShadowColor\",\n    \"scrollbarTrackColor\",\n    \"scrollbarWidth\",\n    \"scrollbars\",\n    \"scrolling\",\n    \"scrollingElement\",\n    \"sctp\",\n    \"sctpCauseCode\",\n    \"sdp\",\n    \"sdpLineNumber\",\n    \"sdpMLineIndex\",\n    \"sdpMid\",\n    \"seal\",\n    \"search\",\n    \"searchBox\",\n    \"searchBoxJavaBridge_\",\n    \"searchParams\",\n    \"sectionRowIndex\",\n    \"secureConnectionStart\",\n    \"security\",\n    \"seed\",\n    \"seek\",\n    \"seekToNextFrame\",\n    \"seekable\",\n    \"seeking\",\n    \"select\",\n    \"selectAllChildren\",\n    \"selectAlternateInterface\",\n    \"selectAudioOutput\",\n    \"selectConfiguration\",\n    \"selectNode\",\n    \"selectNodeContents\",\n    \"selectNodes\",\n    \"selectSingleNode\",\n    \"selectSubString\",\n    \"selectURL\",\n    \"selected\",\n    \"selectedIndex\",\n    \"selectedOptions\",\n    \"selectedStyleSheetSet\",\n    \"selectedStylesheetSet\",\n    \"selectedTrack\",\n    \"selection\",\n    \"selectionDirection\",\n    \"selectionEnd\",\n    \"selectionStart\",\n    \"selector\",\n    \"selectorText\",\n    \"self\",\n    \"send\",\n    \"sendAsBinary\",\n    \"sendBeacon\",\n    \"sendFeatureReport\",\n    \"sendMessage\",\n    \"sendNativeMessage\",\n    \"sendOrder\",\n    \"sendReport\",\n    \"sender\",\n    \"sentAlert\",\n    \"sentTimestamp\",\n    \"separator\",\n    \"serial\",\n    \"serialNumber\",\n    \"serializable\",\n    \"serializeToString\",\n    \"serverTiming\",\n    \"service\",\n    \"serviceWorker\",\n    \"session\",\n    \"sessionId\",\n    \"sessionStorage\",\n    \"sessions\",\n    \"set\",\n    \"setActionHandler\",\n    \"setActive\",\n    \"setAlpha\",\n    \"setAppBadge\",\n    \"setAttribute\",\n    \"setAttributeNS\",\n    \"setAttributeNode\",\n    \"setAttributeNodeNS\",\n    \"setAttributionReporting\",\n    \"setBadgeBackgroundColor\",\n    \"setBadgeText\",\n    \"setBadgeTextColor\",\n    \"setBaseAndExtent\",\n    \"setBigInt64\",\n    \"setBigUint64\",\n    \"setBindGroup\",\n    \"setBingCurrentSearchDefault\",\n    \"setBlendConstant\",\n    \"setCameraActive\",\n    \"setCapture\",\n    \"setCaptureHandleConfig\",\n    \"setCodecPreferences\",\n    \"setColor\",\n    \"setCompositeOperation\",\n    \"setConfiguration\",\n    \"setConsumer\",\n    \"setCurrentTime\",\n    \"setCustomValidity\",\n    \"setData\",\n    \"setDate\",\n    \"setDragImage\",\n    \"setEnabled\",\n    \"setEnd\",\n    \"setEndAfter\",\n    \"setEndBefore\",\n    \"setEndPoint\",\n    \"setExpires\",\n    \"setFillColor\",\n    \"setFilterRes\",\n    \"setFloat16\",\n    \"setFloat32\",\n    \"setFloat64\",\n    \"setFloatValue\",\n    \"setFocusBehavior\",\n    \"setFormValue\",\n    \"setFromBase64\",\n    \"setFromHex\",\n    \"setFullYear\",\n    \"setHTMLUnsafe\",\n    \"setHeaderExtensionsToNegotiate\",\n    \"setHeaderValue\",\n    \"setHours\",\n    \"setIcon\",\n    \"setIdentityProvider\",\n    \"setImmediate\",\n    \"setIndexBuffer\",\n    \"setInt16\",\n    \"setInt32\",\n    \"setInt8\",\n    \"setInterval\",\n    \"setItem\",\n    \"setKeyframes\",\n    \"setLineCap\",\n    \"setLineDash\",\n    \"setLineJoin\",\n    \"setLineWidth\",\n    \"setLiveSeekableRange\",\n    \"setLocalDescription\",\n    \"setMatrix\",\n    \"setMatrixValue\",\n    \"setMediaKeys\",\n    \"setMicrophoneActive\",\n    \"setMilliseconds\",\n    \"setMinutes\",\n    \"setMiterLimit\",\n    \"setMonth\",\n    \"setNamedItem\",\n    \"setNamedItemNS\",\n    \"setNonUserCodeExceptions\",\n    \"setOrientToAngle\",\n    \"setOrientToAuto\",\n    \"setOrientation\",\n    \"setOverrideHistoryNavigationMode\",\n    \"setPaint\",\n    \"setParameter\",\n    \"setParameters\",\n    \"setPeriodicWave\",\n    \"setPipeline\",\n    \"setPointerCapture\",\n    \"setPopup\",\n    \"setPosition\",\n    \"setPositionState\",\n    \"setPreference\",\n    \"setPriority\",\n    \"setPrivateToken\",\n    \"setProperty\",\n    \"setPrototypeOf\",\n    \"setRGBColor\",\n    \"setRGBColorICCColor\",\n    \"setRadius\",\n    \"setRangeText\",\n    \"setRemoteDescription\",\n    \"setReportEventDataForAutomaticBeacons\",\n    \"setRequestHeader\",\n    \"setResizable\",\n    \"setResourceTimingBufferSize\",\n    \"setRotate\",\n    \"setScale\",\n    \"setScissorRect\",\n    \"setSeconds\",\n    \"setSelectionRange\",\n    \"setServerCertificate\",\n    \"setShadow\",\n    \"setSharedStorageContext\",\n    \"setSignals\",\n    \"setSinkId\",\n    \"setSkewX\",\n    \"setSkewY\",\n    \"setStart\",\n    \"setStartAfter\",\n    \"setStartBefore\",\n    \"setStatus\",\n    \"setStdDeviation\",\n    \"setStencilReference\",\n    \"setStreams\",\n    \"setStrictMode\",\n    \"setStringValue\",\n    \"setStrokeColor\",\n    \"setSuggestResult\",\n    \"setTargetAtTime\",\n    \"setTargetValueAtTime\",\n    \"setTime\",\n    \"setTimeout\",\n    \"setTitle\",\n    \"setTransform\",\n    \"setTranslate\",\n    \"setUTCDate\",\n    \"setUTCFullYear\",\n    \"setUTCHours\",\n    \"setUTCMilliseconds\",\n    \"setUTCMinutes\",\n    \"setUTCMonth\",\n    \"setUTCSeconds\",\n    \"setUint16\",\n    \"setUint32\",\n    \"setUint8\",\n    \"setUninstallURL\",\n    \"setUpdateUrlData\",\n    \"setUri\",\n    \"setValidity\",\n    \"setValueAtTime\",\n    \"setValueCurveAtTime\",\n    \"setVariable\",\n    \"setVelocity\",\n    \"setVersion\",\n    \"setVertexBuffer\",\n    \"setViewport\",\n    \"setYear\",\n    \"setZoom\",\n    \"setZoomSettings\",\n    \"settingName\",\n    \"settingValue\",\n    \"sex\",\n    \"shaderLocation\",\n    \"shaderSource\",\n    \"shadowBlur\",\n    \"shadowColor\",\n    \"shadowOffsetX\",\n    \"shadowOffsetY\",\n    \"shadowRoot\",\n    \"shadowRootClonable\",\n    \"shadowRootDelegatesFocus\",\n    \"shadowRootMode\",\n    \"shadowRootSerializable\",\n    \"shape\",\n    \"shape-image-threshold\",\n    \"shape-margin\",\n    \"shape-outside\",\n    \"shape-rendering\",\n    \"shapeImageThreshold\",\n    \"shapeMargin\",\n    \"shapeOutside\",\n    \"shapeRendering\",\n    \"share\",\n    \"sharedStorage\",\n    \"sharedStorageWritable\",\n    \"sheet\",\n    \"shift\",\n    \"shiftKey\",\n    \"shiftLeft\",\n    \"shippingAddress\",\n    \"shippingOption\",\n    \"shippingType\",\n    \"show\",\n    \"showDirectoryPicker\",\n    \"showHelp\",\n    \"showModal\",\n    \"showModalDialog\",\n    \"showModelessDialog\",\n    \"showNotification\",\n    \"showOpenFilePicker\",\n    \"showPicker\",\n    \"showPopover\",\n    \"showSaveFilePicker\",\n    \"sidebar\",\n    \"sidebarAction\",\n    \"sign\",\n    \"signal\",\n    \"signalingState\",\n    \"signature\",\n    \"silent\",\n    \"sin\",\n    \"singleNodeValue\",\n    \"sinh\",\n    \"sinkId\",\n    \"sittingToStandingTransform\",\n    \"size\",\n    \"sizeAdjust\",\n    \"sizeToContent\",\n    \"sizeX\",\n    \"sizeZ\",\n    \"sizes\",\n    \"skewX\",\n    \"skewXSelf\",\n    \"skewY\",\n    \"skewYSelf\",\n    \"skipTransition\",\n    \"skipped\",\n    \"slice\",\n    \"slope\",\n    \"slot\",\n    \"slotAssignment\",\n    \"small\",\n    \"smil\",\n    \"smooth\",\n    \"smoothingTimeConstant\",\n    \"snapTargetBlock\",\n    \"snapTargetInline\",\n    \"snapToLines\",\n    \"snapshotItem\",\n    \"snapshotLength\",\n    \"some\",\n    \"sort\",\n    \"sortingCode\",\n    \"source\",\n    \"sourceBuffer\",\n    \"sourceBuffers\",\n    \"sourceCapabilities\",\n    \"sourceCharPosition\",\n    \"sourceFile\",\n    \"sourceFunctionName\",\n    \"sourceIndex\",\n    \"sourceMap\",\n    \"sourceURL\",\n    \"sources\",\n    \"spacing\",\n    \"span\",\n    \"speak\",\n    \"speakAs\",\n    \"speaking\",\n    \"species\",\n    \"specified\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"speechSynthesis\",\n    \"speed\",\n    \"speedOfSound\",\n    \"spellcheck\",\n    \"sphericalHarmonicsCoefficients\",\n    \"splice\",\n    \"split\",\n    \"splitText\",\n    \"spreadMethod\",\n    \"sqrt\",\n    \"src\",\n    \"srcElement\",\n    \"srcFactor\",\n    \"srcFilter\",\n    \"srcObject\",\n    \"srcUrn\",\n    \"srcdoc\",\n    \"srclang\",\n    \"srcset\",\n    \"stack\",\n    \"stackTraceLimit\",\n    \"stacktrace\",\n    \"stageParameters\",\n    \"standalone\",\n    \"standby\",\n    \"start\",\n    \"startContainer\",\n    \"startE\",\n    \"startIce\",\n    \"startLoadTime\",\n    \"startMessages\",\n    \"startNotifications\",\n    \"startOffset\",\n    \"startProfiling\",\n    \"startRendering\",\n    \"startShark\",\n    \"startTime\",\n    \"startViewTransition\",\n    \"startsWith\",\n    \"state\",\n    \"states\",\n    \"stats\",\n    \"status\",\n    \"statusCode\",\n    \"statusMessage\",\n    \"statusText\",\n    \"statusbar\",\n    \"stdDeviationX\",\n    \"stdDeviationY\",\n    \"stencilBack\",\n    \"stencilClearValue\",\n    \"stencilFront\",\n    \"stencilFunc\",\n    \"stencilFuncSeparate\",\n    \"stencilLoadOp\",\n    \"stencilMask\",\n    \"stencilMaskSeparate\",\n    \"stencilOp\",\n    \"stencilOpSeparate\",\n    \"stencilReadMask\",\n    \"stencilReadOnly\",\n    \"stencilStoreOp\",\n    \"stencilWriteMask\",\n    \"step\",\n    \"stepDown\",\n    \"stepMismatch\",\n    \"stepMode\",\n    \"stepUp\",\n    \"sticky\",\n    \"stitchTiles\",\n    \"stop\",\n    \"stop-color\",\n    \"stop-opacity\",\n    \"stopColor\",\n    \"stopImmediatePropagation\",\n    \"stopNotifications\",\n    \"stopOpacity\",\n    \"stopProfiling\",\n    \"stopPropagation\",\n    \"stopShark\",\n    \"stopped\",\n    \"storage\",\n    \"storageArea\",\n    \"storageBuckets\",\n    \"storageName\",\n    \"storageStatus\",\n    \"storageTexture\",\n    \"store\",\n    \"storeOp\",\n    \"storeSiteSpecificTrackingException\",\n    \"storeWebWideTrackingException\",\n    \"stpVersion\",\n    \"stream\",\n    \"streamErrorCode\",\n    \"streams\",\n    \"stretch\",\n    \"strike\",\n    \"string\",\n    \"stringValue\",\n    \"stringify\",\n    \"stripIndexFormat\",\n    \"stroke\",\n    \"stroke-dasharray\",\n    \"stroke-dashoffset\",\n    \"stroke-linecap\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke-width\",\n    \"strokeDasharray\",\n    \"strokeDashoffset\",\n    \"strokeLinecap\",\n    \"strokeLinejoin\",\n    \"strokeMiterlimit\",\n    \"strokeOpacity\",\n    \"strokeRect\",\n    \"strokeStyle\",\n    \"strokeText\",\n    \"strokeWidth\",\n    \"structuredClone\",\n    \"style\",\n    \"styleAndLayoutStart\",\n    \"styleFloat\",\n    \"styleMap\",\n    \"styleMedia\",\n    \"styleSheet\",\n    \"styleSheetSets\",\n    \"styleSheets\",\n    \"sub\",\n    \"subarray\",\n    \"subject\",\n    \"submit\",\n    \"submitFrame\",\n    \"submitter\",\n    \"subscribe\",\n    \"substr\",\n    \"substring\",\n    \"substringData\",\n    \"subtle\",\n    \"subtree\",\n    \"suffix\",\n    \"suffixes\",\n    \"summary\",\n    \"sup\",\n    \"supported\",\n    \"supportedContentEncodings\",\n    \"supportedEntryTypes\",\n    \"supportedValuesOf\",\n    \"supports\",\n    \"supportsFiber\",\n    \"supportsSession\",\n    \"supportsText\",\n    \"surfaceScale\",\n    \"surroundContents\",\n    \"suspend\",\n    \"suspendRedraw\",\n    \"svb\",\n    \"svh\",\n    \"svi\",\n    \"svmax\",\n    \"svmin\",\n    \"svw\",\n    \"swapCache\",\n    \"swapNode\",\n    \"sweepFlag\",\n    \"symbols\",\n    \"symmetricDifference\",\n    \"sync\",\n    \"syntax\",\n    \"sysexEnabled\",\n    \"system\",\n    \"systemCode\",\n    \"systemId\",\n    \"systemLanguage\",\n    \"systemXDPI\",\n    \"systemYDPI\",\n    \"tBodies\",\n    \"tFoot\",\n    \"tHead\",\n    \"tab\",\n    \"tab-size\",\n    \"tabId\",\n    \"tabIds\",\n    \"tabIndex\",\n    \"tabSize\",\n    \"table\",\n    \"table-layout\",\n    \"tableLayout\",\n    \"tableValues\",\n    \"tabs\",\n    \"tag\",\n    \"tagName\",\n    \"tagUrn\",\n    \"tags\",\n    \"taintEnabled\",\n    \"take\",\n    \"takePhoto\",\n    \"takeRecords\",\n    \"tan\",\n    \"tangentialPressure\",\n    \"tanh\",\n    \"target\",\n    \"targetAddressSpace\",\n    \"targetElement\",\n    \"targetRayMode\",\n    \"targetRaySpace\",\n    \"targetTouches\",\n    \"targetURL\",\n    \"targetX\",\n    \"targetY\",\n    \"targets\",\n    \"tcpType\",\n    \"tee\",\n    \"tel\",\n    \"telemetry\",\n    \"terminate\",\n    \"test\",\n    \"texImage2D\",\n    \"texImage3D\",\n    \"texParameterf\",\n    \"texParameteri\",\n    \"texStorage2D\",\n    \"texStorage3D\",\n    \"texSubImage2D\",\n    \"texSubImage3D\",\n    \"text\",\n    \"text-align\",\n    \"text-align-last\",\n    \"text-anchor\",\n    \"text-combine-upright\",\n    \"text-decoration\",\n    \"text-decoration-color\",\n    \"text-decoration-line\",\n    \"text-decoration-skip-ink\",\n    \"text-decoration-style\",\n    \"text-decoration-thickness\",\n    \"text-emphasis\",\n    \"text-emphasis-color\",\n    \"text-emphasis-position\",\n    \"text-emphasis-style\",\n    \"text-indent\",\n    \"text-justify\",\n    \"text-orientation\",\n    \"text-overflow\",\n    \"text-rendering\",\n    \"text-shadow\",\n    \"text-transform\",\n    \"text-underline-offset\",\n    \"text-underline-position\",\n    \"text-wrap\",\n    \"text-wrap-mode\",\n    \"text-wrap-style\",\n    \"textAlign\",\n    \"textAlignLast\",\n    \"textAnchor\",\n    \"textAutospace\",\n    \"textBaseline\",\n    \"textCombineUpright\",\n    \"textContent\",\n    \"textDecoration\",\n    \"textDecorationBlink\",\n    \"textDecorationColor\",\n    \"textDecorationLine\",\n    \"textDecorationLineThrough\",\n    \"textDecorationNone\",\n    \"textDecorationOverline\",\n    \"textDecorationSkipInk\",\n    \"textDecorationStyle\",\n    \"textDecorationThickness\",\n    \"textDecorationUnderline\",\n    \"textEmphasis\",\n    \"textEmphasisColor\",\n    \"textEmphasisPosition\",\n    \"textEmphasisStyle\",\n    \"textIndent\",\n    \"textJustify\",\n    \"textJustifyTrim\",\n    \"textKashida\",\n    \"textKashidaSpace\",\n    \"textLength\",\n    \"textOrientation\",\n    \"textOverflow\",\n    \"textRendering\",\n    \"textShadow\",\n    \"textTracks\",\n    \"textTransform\",\n    \"textUnderlineOffset\",\n    \"textUnderlinePosition\",\n    \"textWrap\",\n    \"textWrapMode\",\n    \"textWrapStyle\",\n    \"texture\",\n    \"theme\",\n    \"then\",\n    \"threadId\",\n    \"threshold\",\n    \"thresholds\",\n    \"throwIfAborted\",\n    \"tiltX\",\n    \"tiltY\",\n    \"time\",\n    \"timeEnd\",\n    \"timeLog\",\n    \"timeOrigin\",\n    \"timeRemaining\",\n    \"timeStamp\",\n    \"timecode\",\n    \"timeline\",\n    \"timelineTime\",\n    \"timeout\",\n    \"timestamp\",\n    \"timestampOffset\",\n    \"timestampWrites\",\n    \"timing\",\n    \"title\",\n    \"titlebarAreaRect\",\n    \"tlsChannelId\",\n    \"to\",\n    \"toArray\",\n    \"toBase64\",\n    \"toBlob\",\n    \"toDataURL\",\n    \"toDateString\",\n    \"toElement\",\n    \"toExponential\",\n    \"toFixed\",\n    \"toFloat32Array\",\n    \"toFloat64Array\",\n    \"toGMTString\",\n    \"toHex\",\n    \"toISOString\",\n    \"toJSON\",\n    \"toLocaleDateString\",\n    \"toLocaleFormat\",\n    \"toLocaleLowerCase\",\n    \"toLocaleString\",\n    \"toLocaleTimeString\",\n    \"toLocaleUpperCase\",\n    \"toLowerCase\",\n    \"toMatrix\",\n    \"toMethod\",\n    \"toPrecision\",\n    \"toPrimitive\",\n    \"toReversed\",\n    \"toSdp\",\n    \"toSorted\",\n    \"toSource\",\n    \"toSpliced\",\n    \"toStaticHTML\",\n    \"toString\",\n    \"toStringTag\",\n    \"toSum\",\n    \"toTimeString\",\n    \"toUTCString\",\n    \"toUpperCase\",\n    \"toWellFormed\",\n    \"toggle\",\n    \"toggleAttribute\",\n    \"toggleLongPressEnabled\",\n    \"togglePopover\",\n    \"toggleReaderMode\",\n    \"token\",\n    \"tone\",\n    \"toneBuffer\",\n    \"tooLong\",\n    \"tooShort\",\n    \"toolbar\",\n    \"top\",\n    \"topMargin\",\n    \"topSites\",\n    \"topology\",\n    \"total\",\n    \"totalFrameDelay\",\n    \"totalFrames\",\n    \"totalFramesDuration\",\n    \"totalVideoFrames\",\n    \"touch-action\",\n    \"touchAction\",\n    \"touched\",\n    \"touches\",\n    \"trace\",\n    \"track\",\n    \"trackVisibility\",\n    \"trackedAnchors\",\n    \"tracks\",\n    \"tran\",\n    \"transaction\",\n    \"transactions\",\n    \"transceiver\",\n    \"transfer\",\n    \"transferControlToOffscreen\",\n    \"transferFromImageBitmap\",\n    \"transferImageBitmap\",\n    \"transferIn\",\n    \"transferOut\",\n    \"transferSize\",\n    \"transferToFixedLength\",\n    \"transferToImageBitmap\",\n    \"transform\",\n    \"transform-box\",\n    \"transform-origin\",\n    \"transform-style\",\n    \"transformBox\",\n    \"transformFeedbackVaryings\",\n    \"transformOrigin\",\n    \"transformPoint\",\n    \"transformString\",\n    \"transformStyle\",\n    \"transformToDocument\",\n    \"transformToFragment\",\n    \"transition\",\n    \"transition-behavior\",\n    \"transition-delay\",\n    \"transition-duration\",\n    \"transition-property\",\n    \"transition-timing-function\",\n    \"transitionBehavior\",\n    \"transitionDelay\",\n    \"transitionDuration\",\n    \"transitionProperty\",\n    \"transitionTimingFunction\",\n    \"translate\",\n    \"translateSelf\",\n    \"translationX\",\n    \"translationY\",\n    \"transport\",\n    \"traverseTo\",\n    \"trim\",\n    \"trimEnd\",\n    \"trimLeft\",\n    \"trimRight\",\n    \"trimStart\",\n    \"trueSpeed\",\n    \"trunc\",\n    \"truncate\",\n    \"trustedTypes\",\n    \"try\",\n    \"turn\",\n    \"twist\",\n    \"type\",\n    \"typeDetail\",\n    \"typeMismatch\",\n    \"typeMustMatch\",\n    \"types\",\n    \"u2f\",\n    \"ubound\",\n    \"uint16\",\n    \"uint32\",\n    \"uint8\",\n    \"uint8Clamped\",\n    \"unadjustedMovement\",\n    \"unclippedDepth\",\n    \"unconfigure\",\n    \"undefined\",\n    \"underlineStyle\",\n    \"underlineThickness\",\n    \"unescape\",\n    \"uneval\",\n    \"ungroup\",\n    \"unicode\",\n    \"unicode-bidi\",\n    \"unicodeBidi\",\n    \"unicodeRange\",\n    \"unicodeSets\",\n    \"uniform1f\",\n    \"uniform1fv\",\n    \"uniform1i\",\n    \"uniform1iv\",\n    \"uniform1ui\",\n    \"uniform1uiv\",\n    \"uniform2f\",\n    \"uniform2fv\",\n    \"uniform2i\",\n    \"uniform2iv\",\n    \"uniform2ui\",\n    \"uniform2uiv\",\n    \"uniform3f\",\n    \"uniform3fv\",\n    \"uniform3i\",\n    \"uniform3iv\",\n    \"uniform3ui\",\n    \"uniform3uiv\",\n    \"uniform4f\",\n    \"uniform4fv\",\n    \"uniform4i\",\n    \"uniform4iv\",\n    \"uniform4ui\",\n    \"uniform4uiv\",\n    \"uniformBlockBinding\",\n    \"uniformMatrix2fv\",\n    \"uniformMatrix2x3fv\",\n    \"uniformMatrix2x4fv\",\n    \"uniformMatrix3fv\",\n    \"uniformMatrix3x2fv\",\n    \"uniformMatrix3x4fv\",\n    \"uniformMatrix4fv\",\n    \"uniformMatrix4x2fv\",\n    \"uniformMatrix4x3fv\",\n    \"uninstallSelf\",\n    \"union\",\n    \"unique\",\n    \"uniqueID\",\n    \"uniqueNumber\",\n    \"unit\",\n    \"unitType\",\n    \"units\",\n    \"unloadEventEnd\",\n    \"unloadEventStart\",\n    \"unlock\",\n    \"unmap\",\n    \"unmount\",\n    \"unobserve\",\n    \"unpackColorSpace\",\n    \"unpause\",\n    \"unpauseAnimations\",\n    \"unreadCount\",\n    \"unregister\",\n    \"unregisterContentHandler\",\n    \"unregisterProtocolHandler\",\n    \"unscopables\",\n    \"unselectable\",\n    \"unshift\",\n    \"unsubscribe\",\n    \"unsuspendRedraw\",\n    \"unsuspendRedrawAll\",\n    \"unwatch\",\n    \"unwrapKey\",\n    \"upDegrees\",\n    \"upX\",\n    \"upY\",\n    \"upZ\",\n    \"update\",\n    \"updateAdInterestGroups\",\n    \"updateCallbackDone\",\n    \"updateCharacterBounds\",\n    \"updateCommands\",\n    \"updateControlBounds\",\n    \"updateCurrentEntry\",\n    \"updateIce\",\n    \"updateInkTrailStartPoint\",\n    \"updateInterval\",\n    \"updatePlaybackRate\",\n    \"updateRangeEnd\",\n    \"updateRangeStart\",\n    \"updateRenderState\",\n    \"updateSelection\",\n    \"updateSelectionBounds\",\n    \"updateSettings\",\n    \"updateText\",\n    \"updateTiming\",\n    \"updateViaCache\",\n    \"updateWith\",\n    \"updated\",\n    \"updating\",\n    \"upgrade\",\n    \"upload\",\n    \"uploadTotal\",\n    \"uploaded\",\n    \"upper\",\n    \"upperBound\",\n    \"upperOpen\",\n    \"uri\",\n    \"url\",\n    \"urn\",\n    \"urns\",\n    \"usage\",\n    \"usages\",\n    \"usb\",\n    \"usbVersionMajor\",\n    \"usbVersionMinor\",\n    \"usbVersionSubminor\",\n    \"useCurrentView\",\n    \"useMap\",\n    \"useProgram\",\n    \"usedSpace\",\n    \"user-select\",\n    \"userActivation\",\n    \"userAgent\",\n    \"userAgentData\",\n    \"userChoice\",\n    \"userHandle\",\n    \"userHint\",\n    \"userInitiated\",\n    \"userLanguage\",\n    \"userSelect\",\n    \"userState\",\n    \"userVisibleOnly\",\n    \"username\",\n    \"usernameFragment\",\n    \"utterance\",\n    \"uuid\",\n    \"v8BreakIterator\",\n    \"vAlign\",\n    \"vLink\",\n    \"valid\",\n    \"validate\",\n    \"validateProgram\",\n    \"validationMessage\",\n    \"validity\",\n    \"value\",\n    \"valueAsDate\",\n    \"valueAsNumber\",\n    \"valueAsString\",\n    \"valueInSpecifiedUnits\",\n    \"valueMissing\",\n    \"valueOf\",\n    \"valueText\",\n    \"valueType\",\n    \"values\",\n    \"variable\",\n    \"variant\",\n    \"variationSettings\",\n    \"vb\",\n    \"vector-effect\",\n    \"vectorEffect\",\n    \"velocityAngular\",\n    \"velocityExpansion\",\n    \"velocityX\",\n    \"velocityY\",\n    \"vendor\",\n    \"vendorId\",\n    \"vendorSub\",\n    \"verify\",\n    \"version\",\n    \"vertex\",\n    \"vertexAttrib1f\",\n    \"vertexAttrib1fv\",\n    \"vertexAttrib2f\",\n    \"vertexAttrib2fv\",\n    \"vertexAttrib3f\",\n    \"vertexAttrib3fv\",\n    \"vertexAttrib4f\",\n    \"vertexAttrib4fv\",\n    \"vertexAttribDivisor\",\n    \"vertexAttribDivisorANGLE\",\n    \"vertexAttribI4i\",\n    \"vertexAttribI4iv\",\n    \"vertexAttribI4ui\",\n    \"vertexAttribI4uiv\",\n    \"vertexAttribIPointer\",\n    \"vertexAttribPointer\",\n    \"vertical\",\n    \"vertical-align\",\n    \"verticalAlign\",\n    \"verticalOverflow\",\n    \"vh\",\n    \"vi\",\n    \"vibrate\",\n    \"vibrationActuator\",\n    \"videoBitsPerSecond\",\n    \"videoHeight\",\n    \"videoTracks\",\n    \"videoWidth\",\n    \"view\",\n    \"viewBox\",\n    \"viewBoxString\",\n    \"viewDimension\",\n    \"viewFormats\",\n    \"viewTarget\",\n    \"viewTargetString\",\n    \"viewTransition\",\n    \"viewport\",\n    \"viewportAnchorX\",\n    \"viewportAnchorY\",\n    \"viewportElement\",\n    \"views\",\n    \"violatedDirective\",\n    \"virtualKeyboard\",\n    \"virtualKeyboardPolicy\",\n    \"visibility\",\n    \"visibilityState\",\n    \"visible\",\n    \"visibleRect\",\n    \"visualViewport\",\n    \"vlinkColor\",\n    \"vmax\",\n    \"vmin\",\n    \"voice\",\n    \"voiceURI\",\n    \"volume\",\n    \"vrml\",\n    \"vspace\",\n    \"vw\",\n    \"w\",\n    \"wait\",\n    \"waitAsync\",\n    \"waitSync\",\n    \"waiting\",\n    \"wake\",\n    \"wakeLock\",\n    \"wand\",\n    \"warmup\",\n    \"warn\",\n    \"wasAlternateProtocolAvailable\",\n    \"wasClean\",\n    \"wasDiscarded\",\n    \"wasFetchedViaSpdy\",\n    \"wasNpnNegotiated\",\n    \"watch\",\n    \"watchAvailability\",\n    \"watchPosition\",\n    \"webNavigation\",\n    \"webRequest\",\n    \"webdriver\",\n    \"webkitAddKey\",\n    \"webkitAlignContent\",\n    \"webkitAlignItems\",\n    \"webkitAlignSelf\",\n    \"webkitAnimation\",\n    \"webkitAnimationDelay\",\n    \"webkitAnimationDirection\",\n    \"webkitAnimationDuration\",\n    \"webkitAnimationFillMode\",\n    \"webkitAnimationIterationCount\",\n    \"webkitAnimationName\",\n    \"webkitAnimationPlayState\",\n    \"webkitAnimationTimingFunction\",\n    \"webkitAppearance\",\n    \"webkitAudioContext\",\n    \"webkitAudioDecodedByteCount\",\n    \"webkitAudioPannerNode\",\n    \"webkitBackfaceVisibility\",\n    \"webkitBackground\",\n    \"webkitBackgroundAttachment\",\n    \"webkitBackgroundClip\",\n    \"webkitBackgroundColor\",\n    \"webkitBackgroundImage\",\n    \"webkitBackgroundOrigin\",\n    \"webkitBackgroundPosition\",\n    \"webkitBackgroundPositionX\",\n    \"webkitBackgroundPositionY\",\n    \"webkitBackgroundRepeat\",\n    \"webkitBackgroundSize\",\n    \"webkitBackingStorePixelRatio\",\n    \"webkitBorderBottomLeftRadius\",\n    \"webkitBorderBottomRightRadius\",\n    \"webkitBorderImage\",\n    \"webkitBorderImageOutset\",\n    \"webkitBorderImageRepeat\",\n    \"webkitBorderImageSlice\",\n    \"webkitBorderImageSource\",\n    \"webkitBorderImageWidth\",\n    \"webkitBorderRadius\",\n    \"webkitBorderTopLeftRadius\",\n    \"webkitBorderTopRightRadius\",\n    \"webkitBoxAlign\",\n    \"webkitBoxDirection\",\n    \"webkitBoxFlex\",\n    \"webkitBoxOrdinalGroup\",\n    \"webkitBoxOrient\",\n    \"webkitBoxPack\",\n    \"webkitBoxShadow\",\n    \"webkitBoxSizing\",\n    \"webkitCancelAnimationFrame\",\n    \"webkitCancelFullScreen\",\n    \"webkitCancelKeyRequest\",\n    \"webkitCancelRequestAnimationFrame\",\n    \"webkitClearResourceTimings\",\n    \"webkitClipPath\",\n    \"webkitClosedCaptionsVisible\",\n    \"webkitConvertPointFromNodeToPage\",\n    \"webkitConvertPointFromPageToNode\",\n    \"webkitCreateShadowRoot\",\n    \"webkitCurrentFullScreenElement\",\n    \"webkitCurrentPlaybackTargetIsWireless\",\n    \"webkitDecodedFrameCount\",\n    \"webkitDirectionInvertedFromDevice\",\n    \"webkitDisplayingFullscreen\",\n    \"webkitDroppedFrameCount\",\n    \"webkitEnterFullScreen\",\n    \"webkitEnterFullscreen\",\n    \"webkitEntries\",\n    \"webkitExitFullScreen\",\n    \"webkitExitFullscreen\",\n    \"webkitExitPointerLock\",\n    \"webkitFilter\",\n    \"webkitFlex\",\n    \"webkitFlexBasis\",\n    \"webkitFlexDirection\",\n    \"webkitFlexFlow\",\n    \"webkitFlexGrow\",\n    \"webkitFlexShrink\",\n    \"webkitFlexWrap\",\n    \"webkitFontFeatureSettings\",\n    \"webkitFullScreenKeyboardInputAllowed\",\n    \"webkitFullscreenElement\",\n    \"webkitFullscreenEnabled\",\n    \"webkitGenerateKeyRequest\",\n    \"webkitGetAsEntry\",\n    \"webkitGetDatabaseNames\",\n    \"webkitGetEntries\",\n    \"webkitGetEntriesByName\",\n    \"webkitGetEntriesByType\",\n    \"webkitGetFlowByName\",\n    \"webkitGetGamepads\",\n    \"webkitGetImageDataHD\",\n    \"webkitGetNamedFlows\",\n    \"webkitGetRegionFlowRanges\",\n    \"webkitGetUserMedia\",\n    \"webkitHasClosedCaptions\",\n    \"webkitHidden\",\n    \"webkitIDBCursor\",\n    \"webkitIDBDatabase\",\n    \"webkitIDBDatabaseError\",\n    \"webkitIDBDatabaseException\",\n    \"webkitIDBFactory\",\n    \"webkitIDBIndex\",\n    \"webkitIDBKeyRange\",\n    \"webkitIDBObjectStore\",\n    \"webkitIDBRequest\",\n    \"webkitIDBTransaction\",\n    \"webkitImageSmoothingEnabled\",\n    \"webkitIndexedDB\",\n    \"webkitInitMessageEvent\",\n    \"webkitIsFullScreen\",\n    \"webkitJustifyContent\",\n    \"webkitKeys\",\n    \"webkitLineClamp\",\n    \"webkitLineDashOffset\",\n    \"webkitLockOrientation\",\n    \"webkitMask\",\n    \"webkitMaskClip\",\n    \"webkitMaskComposite\",\n    \"webkitMaskImage\",\n    \"webkitMaskOrigin\",\n    \"webkitMaskPosition\",\n    \"webkitMaskPositionX\",\n    \"webkitMaskPositionY\",\n    \"webkitMaskRepeat\",\n    \"webkitMaskSize\",\n    \"webkitMatchesSelector\",\n    \"webkitMediaStream\",\n    \"webkitNotifications\",\n    \"webkitOfflineAudioContext\",\n    \"webkitOrder\",\n    \"webkitOrientation\",\n    \"webkitPeerConnection00\",\n    \"webkitPersistentStorage\",\n    \"webkitPerspective\",\n    \"webkitPerspectiveOrigin\",\n    \"webkitPointerLockElement\",\n    \"webkitPostMessage\",\n    \"webkitPreservesPitch\",\n    \"webkitPutImageDataHD\",\n    \"webkitRTCPeerConnection\",\n    \"webkitRegionOverset\",\n    \"webkitRelativePath\",\n    \"webkitRequestAnimationFrame\",\n    \"webkitRequestFileSystem\",\n    \"webkitRequestFullScreen\",\n    \"webkitRequestFullscreen\",\n    \"webkitRequestPointerLock\",\n    \"webkitResolveLocalFileSystemURL\",\n    \"webkitSetMediaKeys\",\n    \"webkitSetResourceTimingBufferSize\",\n    \"webkitShadowRoot\",\n    \"webkitShowPlaybackTargetPicker\",\n    \"webkitSlice\",\n    \"webkitSpeechGrammar\",\n    \"webkitSpeechGrammarList\",\n    \"webkitSpeechRecognition\",\n    \"webkitSpeechRecognitionError\",\n    \"webkitSpeechRecognitionEvent\",\n    \"webkitStorageInfo\",\n    \"webkitSupportsFullscreen\",\n    \"webkitTemporaryStorage\",\n    \"webkitTextFillColor\",\n    \"webkitTextSecurity\",\n    \"webkitTextSizeAdjust\",\n    \"webkitTextStroke\",\n    \"webkitTextStrokeColor\",\n    \"webkitTextStrokeWidth\",\n    \"webkitTransform\",\n    \"webkitTransformOrigin\",\n    \"webkitTransformStyle\",\n    \"webkitTransition\",\n    \"webkitTransitionDelay\",\n    \"webkitTransitionDuration\",\n    \"webkitTransitionProperty\",\n    \"webkitTransitionTimingFunction\",\n    \"webkitURL\",\n    \"webkitUnlockOrientation\",\n    \"webkitUserSelect\",\n    \"webkitVideoDecodedByteCount\",\n    \"webkitVisibilityState\",\n    \"webkitWirelessVideoPlaybackDisabled\",\n    \"webkitdirectory\",\n    \"webkitdropzone\",\n    \"webstore\",\n    \"weight\",\n    \"wgslLanguageFeatures\",\n    \"whatToShow\",\n    \"wheelDelta\",\n    \"wheelDeltaX\",\n    \"wheelDeltaY\",\n    \"whenDefined\",\n    \"which\",\n    \"white-space\",\n    \"white-space-collapse\",\n    \"whiteSpace\",\n    \"whiteSpaceCollapse\",\n    \"wholeText\",\n    \"widows\",\n    \"width\",\n    \"will-change\",\n    \"willChange\",\n    \"willValidate\",\n    \"window\",\n    \"windowAttribution\",\n    \"windowControlsOverlay\",\n    \"windowId\",\n    \"windowIds\",\n    \"windows\",\n    \"with\",\n    \"withCredentials\",\n    \"withResolvers\",\n    \"word-break\",\n    \"word-spacing\",\n    \"word-wrap\",\n    \"wordBreak\",\n    \"wordSpacing\",\n    \"wordWrap\",\n    \"workerStart\",\n    \"worklet\",\n    \"wow64\",\n    \"wrap\",\n    \"wrapKey\",\n    \"writable\",\n    \"writableAuxiliaries\",\n    \"write\",\n    \"writeBuffer\",\n    \"writeMask\",\n    \"writeText\",\n    \"writeTexture\",\n    \"writeTimestamp\",\n    \"writeValue\",\n    \"writeValueWithResponse\",\n    \"writeValueWithoutResponse\",\n    \"writeWithoutResponse\",\n    \"writeln\",\n    \"writing-mode\",\n    \"writingMode\",\n    \"writingSuggestions\",\n    \"x\",\n    \"x1\",\n    \"x2\",\n    \"xChannelSelector\",\n    \"xmlEncoding\",\n    \"xmlStandalone\",\n    \"xmlVersion\",\n    \"xmlbase\",\n    \"xmllang\",\n    \"xmlspace\",\n    \"xor\",\n    \"xr\",\n    \"y\",\n    \"y1\",\n    \"y2\",\n    \"yChannelSelector\",\n    \"yandex\",\n    \"yield\",\n    \"z\",\n    \"z-index\",\n    \"zIndex\",\n    \"zoom\",\n    \"zoomAndPan\",\n    \"zoomRectScreen\",\n];\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nfunction find_builtins(reserved) {\n    domprops.forEach(add);\n\n    // Compatibility fix for some standard defined globals not defined on every js environment\n    var new_globals = [\"Symbol\", \"Map\", \"Promise\", \"Proxy\", \"Reflect\", \"Set\", \"WeakMap\", \"WeakSet\"];\n    var objects = {};\n    var global_ref = typeof __webpack_require__.g === \"object\" ? __webpack_require__.g : self;\n\n    new_globals.forEach(function (new_global) {\n        objects[new_global] = global_ref[new_global] || function() {};\n    });\n\n    [\n        \"null\",\n        \"true\",\n        \"false\",\n        \"NaN\",\n        \"Infinity\",\n        \"-Infinity\",\n        \"undefined\",\n    ].forEach(add);\n    [ Object, Array, Function, Number,\n      String, Boolean, Error, Math,\n      Date, RegExp, objects.Symbol, ArrayBuffer,\n      DataView, decodeURI, decodeURIComponent,\n      encodeURI, encodeURIComponent, eval, EvalError,\n      Float32Array, Float64Array, Int8Array, Int16Array,\n      Int32Array, isFinite, isNaN, JSON, objects.Map, parseFloat,\n      parseInt, objects.Promise, objects.Proxy, RangeError, ReferenceError,\n      objects.Reflect, objects.Set, SyntaxError, TypeError, Uint8Array,\n      Uint8ClampedArray, Uint16Array, Uint32Array, URIError,\n      objects.WeakMap, objects.WeakSet\n    ].forEach(function(ctor) {\n        Object.getOwnPropertyNames(ctor).map(add);\n        if (ctor.prototype) {\n            Object.getOwnPropertyNames(ctor.prototype).map(add);\n        }\n    });\n    function add(name) {\n        reserved.add(name);\n    }\n}\n\nfunction reserve_quoted_keys(ast, reserved) {\n    function add(name) {\n        push_uniq(reserved, name);\n    }\n\n    ast.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_ObjectKeyVal && node.quote) {\n            add(node.key);\n        } else if (node instanceof AST_ObjectProperty && node.quote) {\n            add(node.key.name);\n        } else if (node instanceof AST_Sub) {\n            addStrings(node.property, add);\n        }\n    }));\n}\n\nfunction addStrings(node, add) {\n    node.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Sequence) {\n            addStrings(node.tail_node(), add);\n        } else if (node instanceof AST_String) {\n            add(node.value);\n        } else if (node instanceof AST_Conditional) {\n            addStrings(node.consequent, add);\n            addStrings(node.alternative, add);\n        }\n        return true;\n    }));\n}\n\nfunction mangle_private_properties(ast, options) {\n    var cprivate = -1;\n    var private_cache = new Map();\n    var nth_identifier = options.nth_identifier || base54;\n\n    ast =  ast.transform(new TreeTransformer(function(node) {\n        if (\n            node instanceof AST_ClassPrivateProperty\n            || node instanceof AST_PrivateMethod\n            || node instanceof AST_PrivateGetter\n            || node instanceof AST_PrivateSetter\n            || node instanceof AST_PrivateIn\n        ) {\n            node.key.name = mangle_private(node.key.name);\n        } else if (node instanceof AST_DotHash) {\n            node.property = mangle_private(node.property);\n        }\n    }));\n    return ast;\n\n    function mangle_private(name) {\n        let mangled = private_cache.get(name);\n        if (!mangled) {\n            mangled = nth_identifier.get(++cprivate);\n            private_cache.set(name, mangled);\n        }\n\n        return mangled;\n    }\n}\n\nfunction find_annotated_props(ast) {\n    var annotated_props = new Set();\n    walk(ast, node => {\n        if (\n            node instanceof AST_ClassPrivateProperty\n            || node instanceof AST_PrivateMethod\n            || node instanceof AST_PrivateGetter\n            || node instanceof AST_PrivateSetter\n            || node instanceof AST_DotHash\n        ) ; else if (node instanceof AST_ObjectKeyVal) {\n            if (typeof node.key == \"string\" && has_annotation(node, _MANGLEPROP)) {\n                annotated_props.add(node.key);\n            }\n        } else if (node instanceof AST_ObjectProperty) {\n            // setter or getter, since KeyVal is handled above\n            if (has_annotation(node, _MANGLEPROP)) {\n                annotated_props.add(node.key.name);\n            }\n        } else if (node instanceof AST_Dot) {\n            if (has_annotation(node, _MANGLEPROP)) {\n                annotated_props.add(node.property);\n            }\n        } else if (node instanceof AST_Sub) {\n            if (node.property instanceof AST_String && has_annotation(node, _MANGLEPROP)) {\n                annotated_props.add(node.property.value);\n            }\n        }\n    });\n    return annotated_props;\n}\n\nfunction mangle_properties(ast, options, annotated_props = find_annotated_props(ast)) {\n    options = defaults(options, {\n        builtins: false,\n        cache: null,\n        debug: false,\n        keep_quoted: false,\n        nth_identifier: base54,\n        only_cache: false,\n        regex: null,\n        reserved: null,\n        undeclared: false,\n        only_annotated: false,\n    }, true);\n\n    var nth_identifier = options.nth_identifier;\n\n    var reserved_option = options.reserved;\n    if (!Array.isArray(reserved_option)) reserved_option = [reserved_option];\n    var reserved = new Set(reserved_option);\n    if (!options.builtins) find_builtins(reserved);\n\n    var cname = -1;\n\n    var cache;\n    if (options.cache) {\n        cache = options.cache.props;\n    } else {\n        cache = new Map();\n    }\n\n    var only_annotated = options.only_annotated;\n    var regex = options.regex && new RegExp(options.regex);\n\n    // note debug is either false (disabled), or a string of the debug suffix to use (enabled).\n    // note debug may be enabled as an empty string, which is falsey. Also treat passing 'true'\n    // the same as passing an empty string.\n    var debug = options.debug !== false;\n    var debug_name_suffix;\n    if (debug) {\n        debug_name_suffix = (options.debug === true ? \"\" : options.debug);\n    }\n\n    var names_to_mangle = new Set();\n    var unmangleable = new Set();\n    // Track each already-mangled name to prevent nth_identifier from generating\n    // the same name.\n    cache.forEach((mangled_name) => unmangleable.add(mangled_name));\n\n    var keep_quoted = !!options.keep_quoted;\n\n    // step 1: find candidates to mangle\n    ast.walk(new TreeWalker(function(node) {\n        if (\n            node instanceof AST_ClassPrivateProperty\n            || node instanceof AST_PrivateMethod\n            || node instanceof AST_PrivateGetter\n            || node instanceof AST_PrivateSetter\n            || node instanceof AST_DotHash\n        ) ; else if (node instanceof AST_ObjectKeyVal) {\n            if (typeof node.key == \"string\" && (!keep_quoted || !node.quote)) {\n                add(node.key);\n            }\n        } else if (node instanceof AST_ObjectProperty) {\n            // setter or getter, since KeyVal is handled above\n            if (!keep_quoted || !node.quote) {\n                add(node.key.name);\n            }\n        } else if (node instanceof AST_Dot) {\n            var declared = !!options.undeclared;\n            if (!declared) {\n                var root = node;\n                while (root.expression) {\n                    root = root.expression;\n                }\n                declared = !(root.thedef && root.thedef.undeclared);\n            }\n            if (declared &&\n                (!keep_quoted || !node.quote)) {\n                add(node.property);\n            }\n        } else if (node instanceof AST_Sub) {\n            if (!keep_quoted) {\n                addStrings(node.property, add);\n            }\n        } else if (node instanceof AST_Call\n            && node.expression.print_to_string() == \"Object.defineProperty\") {\n            addStrings(node.args[1], add);\n        } else if (node instanceof AST_Binary && node.operator === \"in\") {\n            addStrings(node.left, add);\n        } else if (node instanceof AST_String && has_annotation(node, _KEY)) {\n            add(node.value);\n        }\n    }));\n\n    // step 2: transform the tree, renaming properties\n    return ast.transform(new TreeTransformer(function(node) {\n        if (\n            node instanceof AST_ClassPrivateProperty\n            || node instanceof AST_PrivateMethod\n            || node instanceof AST_PrivateGetter\n            || node instanceof AST_PrivateSetter\n            || node instanceof AST_DotHash\n        ) ; else if (node instanceof AST_ObjectKeyVal) {\n            if (typeof node.key == \"string\" && (!keep_quoted || !node.quote)) {\n                node.key = mangle(node.key);\n            }\n        } else if (node instanceof AST_ObjectProperty) {\n            // setter, getter, method or class field\n            if (!keep_quoted || !node.quote) {\n                if (!node.computed_key()) {\n                    node.key.name = mangle(node.key.name);\n                }\n            }\n        } else if (node instanceof AST_Dot) {\n            if (!keep_quoted || !node.quote) {\n                node.property = mangle(node.property);\n            }\n        } else if (!keep_quoted && node instanceof AST_Sub) {\n            node.property = mangleStrings(node.property);\n        } else if (node instanceof AST_Call\n            && node.expression.print_to_string() == \"Object.defineProperty\") {\n            node.args[1] = mangleStrings(node.args[1]);\n        } else if (node instanceof AST_Binary && node.operator === \"in\") {\n            node.left = mangleStrings(node.left);\n        } else if (node instanceof AST_String && has_annotation(node, _KEY)) {\n            // Clear _KEY annotation to prevent double mangling\n            clear_annotation(node, _KEY);\n            node.value = mangle(node.value);\n        }\n    }));\n\n    // only function declarations after this line\n\n    function can_mangle(name) {\n        if (unmangleable.has(name)) return false;\n        if (reserved.has(name)) return false;\n        if (options.only_cache) {\n            return cache.has(name);\n        }\n        if (/^-?[0-9]+(\\.[0-9]+)?(e[+-][0-9]+)?$/.test(name)) return false;\n        return true;\n    }\n\n    function should_mangle(name) {\n        if (only_annotated && !annotated_props.has(name)) return false;\n        if (regex && !regex.test(name)) {\n            return annotated_props.has(name);\n        }\n        if (reserved.has(name)) return false;\n        return cache.has(name)\n            || names_to_mangle.has(name);\n    }\n\n    function add(name) {\n        if (can_mangle(name)) {\n            names_to_mangle.add(name);\n        }\n\n        if (!should_mangle(name)) {\n            unmangleable.add(name);\n        }\n    }\n\n    function mangle(name) {\n        if (!should_mangle(name)) {\n            return name;\n        }\n\n        var mangled = cache.get(name);\n        if (!mangled) {\n            if (debug) {\n                // debug mode: use a prefix and suffix to preserve readability, e.g. o.foo -> o._$foo$NNN_.\n                var debug_mangled = \"_$\" + name + \"$\" + debug_name_suffix + \"_\";\n\n                if (can_mangle(debug_mangled)) {\n                    mangled = debug_mangled;\n                }\n            }\n\n            // either debug mode is off, or it is on and we could not use the mangled name\n            if (!mangled) {\n                do {\n                    mangled = nth_identifier.get(++cname);\n                } while (!can_mangle(mangled));\n            }\n\n            cache.set(name, mangled);\n        }\n        return mangled;\n    }\n\n    function mangleStrings(node) {\n        return node.transform(new TreeTransformer(function(node) {\n            if (node instanceof AST_Sequence) {\n                var last = node.expressions.length - 1;\n                node.expressions[last] = mangleStrings(node.expressions[last]);\n            } else if (node instanceof AST_String) {\n                // Clear _KEY annotation to prevent double mangling\n                clear_annotation(node, _KEY);\n                node.value = mangle(node.value);\n            } else if (node instanceof AST_Conditional) {\n                node.consequent = mangleStrings(node.consequent);\n                node.alternative = mangleStrings(node.alternative);\n            }\n            return node;\n        }));\n    }\n}\n\n// to/from base64 functions\n// Prefer built-in Buffer, if available, then use hack\n// https://developer.mozilla.org/en-US/docs/Glossary/Base64#The_Unicode_Problem\nvar to_ascii = typeof Buffer !== \"undefined\"\n    ? (b64) => Buffer.from(b64, \"base64\").toString()\n    : (b64) => decodeURIComponent(escape(atob(b64)));\nvar to_base64 = typeof Buffer !== \"undefined\"\n    ? (str) => Buffer.from(str).toString(\"base64\")\n    : (str) => btoa(unescape(encodeURIComponent(str)));\n\nfunction read_source_map(code) {\n    var match = /(?:^|[^.])\\/\\/# sourceMappingURL=data:application\\/json(;[\\w=-]*)?;base64,([+/0-9A-Za-z]*=*)\\s*$/.exec(code);\n    if (!match) {\n        console.warn(\"inline source map not found\");\n        return null;\n    }\n    return to_ascii(match[2]);\n}\n\nfunction set_shorthand(name, options, keys) {\n    if (options[name]) {\n        keys.forEach(function(key) {\n            if (options[key]) {\n                if (typeof options[key] != \"object\") options[key] = {};\n                if (!(name in options[key])) options[key][name] = options[name];\n            }\n        });\n    }\n}\n\nfunction init_cache(cache) {\n    if (!cache) return;\n    if (!(\"props\" in cache)) {\n        cache.props = new Map();\n    } else if (!(cache.props instanceof Map)) {\n        cache.props = map_from_object(cache.props);\n    }\n}\n\nfunction cache_to_json(cache) {\n    return {\n        props: map_to_object(cache.props)\n    };\n}\n\nfunction log_input(files, options, fs, debug_folder) {\n    if (!(fs && fs.writeFileSync && fs.mkdirSync)) {\n        return;\n    }\n\n    try {\n        fs.mkdirSync(debug_folder);\n    } catch (e) {\n        if (e.code !== \"EEXIST\") throw e;\n    }\n\n    const log_path = `${debug_folder}/terser-debug-${(Math.random() * 9999999) | 0}.log`;\n\n    options = options || {};\n\n    const options_str = JSON.stringify(options, (_key, thing) => {\n        if (typeof thing === \"function\") return \"[Function \" + thing.toString() + \"]\";\n        if (thing instanceof RegExp) return \"[RegExp \" + thing.toString() + \"]\";\n        return thing;\n    }, 4);\n\n    const files_str = (file) => {\n        if (typeof file === \"object\" && options.parse && options.parse.spidermonkey) {\n            return JSON.stringify(file, null, 2);\n        } else if (typeof file === \"object\") {\n            return Object.keys(file)\n                .map((key) => key + \": \" + files_str(file[key]))\n                .join(\"\\n\\n\");\n        } else if (typeof file === \"string\") {\n            return \"```\\n\" + file + \"\\n```\";\n        } else {\n            return file; // What do?\n        }\n    };\n\n    fs.writeFileSync(log_path, \"Options: \\n\" + options_str + \"\\n\\nInput files:\\n\\n\" + files_str(files) + \"\\n\");\n}\n\nfunction* minify_sync_or_async(files, options, _fs_module) {\n    if (\n        _fs_module\n        && typeof process === \"object\"\n        && process.env\n        && typeof process.env.TERSER_DEBUG_DIR === \"string\"\n    ) {\n        log_input(files, options, _fs_module, process.env.TERSER_DEBUG_DIR);\n    }\n\n    options = defaults(options, {\n        compress: {},\n        ecma: undefined,\n        enclose: false,\n        ie8: false,\n        keep_classnames: undefined,\n        keep_fnames: false,\n        mangle: {},\n        module: false,\n        nameCache: null,\n        output: null,\n        format: null,\n        parse: {},\n        rename: undefined,\n        safari10: false,\n        sourceMap: false,\n        spidermonkey: false,\n        timings: false,\n        toplevel: false,\n        warnings: false,\n        wrap: false,\n    }, true);\n\n    var timings = options.timings && {\n        start: Date.now()\n    };\n    if (options.keep_classnames === undefined) {\n        options.keep_classnames = options.keep_fnames;\n    }\n    if (options.rename === undefined) {\n        options.rename = options.compress && options.mangle;\n    }\n    if (options.output && options.format) {\n        throw new Error(\"Please only specify either output or format option, preferrably format.\");\n    }\n    options.format = options.format || options.output || {};\n    set_shorthand(\"ecma\", options, [ \"parse\", \"compress\", \"format\" ]);\n    set_shorthand(\"ie8\", options, [ \"compress\", \"mangle\", \"format\" ]);\n    set_shorthand(\"keep_classnames\", options, [ \"compress\", \"mangle\" ]);\n    set_shorthand(\"keep_fnames\", options, [ \"compress\", \"mangle\" ]);\n    set_shorthand(\"module\", options, [ \"parse\", \"compress\", \"mangle\" ]);\n    set_shorthand(\"safari10\", options, [ \"mangle\", \"format\" ]);\n    set_shorthand(\"toplevel\", options, [ \"compress\", \"mangle\" ]);\n    set_shorthand(\"warnings\", options, [ \"compress\" ]); // legacy\n    var quoted_props;\n    if (options.mangle) {\n        options.mangle = defaults(options.mangle, {\n            cache: options.nameCache && (options.nameCache.vars || {}),\n            eval: false,\n            ie8: false,\n            keep_classnames: false,\n            keep_fnames: false,\n            module: false,\n            nth_identifier: base54,\n            properties: false,\n            reserved: [],\n            safari10: false,\n            toplevel: false,\n        }, true);\n        if (options.mangle.properties) {\n            if (typeof options.mangle.properties != \"object\") {\n                options.mangle.properties = {};\n            }\n            if (options.mangle.properties.keep_quoted) {\n                quoted_props = options.mangle.properties.reserved;\n                if (!Array.isArray(quoted_props)) quoted_props = [];\n                options.mangle.properties.reserved = quoted_props;\n            }\n            if (options.nameCache && !(\"cache\" in options.mangle.properties)) {\n                options.mangle.properties.cache = options.nameCache.props || {};\n            }\n        }\n        init_cache(options.mangle.cache);\n        init_cache(options.mangle.properties.cache);\n    }\n    if (options.sourceMap) {\n        options.sourceMap = defaults(options.sourceMap, {\n            asObject: false,\n            content: null,\n            filename: null,\n            includeSources: false,\n            root: null,\n            url: null,\n        }, true);\n    }\n\n    // -- Parse phase --\n    if (timings) timings.parse = Date.now();\n    var toplevel;\n    if (files instanceof AST_Toplevel) {\n        toplevel = files;\n    } else {\n        if (typeof files == \"string\" || (options.parse.spidermonkey && !Array.isArray(files))) {\n            files = [ files ];\n        }\n        options.parse = options.parse || {};\n        options.parse.toplevel = null;\n\n        if (options.parse.spidermonkey) {\n            options.parse.toplevel = AST_Node.from_mozilla_ast(Object.keys(files).reduce(function(toplevel, name) {\n                if (!toplevel) return files[name];\n                toplevel.body = toplevel.body.concat(files[name].body);\n                return toplevel;\n            }, null));\n        } else {\n            delete options.parse.spidermonkey;\n\n            for (var name in files) if (HOP(files, name)) {\n                options.parse.filename = name;\n                options.parse.toplevel = parse(files[name], options.parse);\n                if (options.sourceMap && options.sourceMap.content == \"inline\") {\n                    if (Object.keys(files).length > 1)\n                        throw new Error(\"inline source map only works with singular input\");\n                    options.sourceMap.content = read_source_map(files[name]);\n                }\n            }\n        }\n        if (options.parse.toplevel === null) {\n            throw new Error(\"no source file given\");\n        }\n\n        toplevel = options.parse.toplevel;\n    }\n    if (quoted_props && options.mangle.properties.keep_quoted !== \"strict\") {\n        reserve_quoted_keys(toplevel, quoted_props);\n    }\n    var annotated_props;\n    if (options.mangle && options.mangle.properties) {\n        annotated_props = find_annotated_props(toplevel);\n    }\n    if (options.wrap) {\n        toplevel = toplevel.wrap_commonjs(options.wrap);\n    }\n    if (options.enclose) {\n        toplevel = toplevel.wrap_enclose(options.enclose);\n    }\n    if (timings) timings.rename = Date.now();\n\n    // -- Compress phase --\n    if (timings) timings.compress = Date.now();\n    if (options.compress) {\n        toplevel = new Compressor(options.compress, {\n            mangle_options: options.mangle\n        }).compress(toplevel);\n    }\n\n    // -- Mangle phase --\n    if (timings) timings.scope = Date.now();\n    if (options.mangle) toplevel.figure_out_scope(options.mangle);\n    if (timings) timings.mangle = Date.now();\n    if (options.mangle) {\n        toplevel.compute_char_frequency(options.mangle);\n        toplevel.mangle_names(options.mangle);\n        toplevel = mangle_private_properties(toplevel, options.mangle);\n    }\n    if (timings) timings.properties = Date.now();\n    if (options.mangle && options.mangle.properties) {\n        toplevel = mangle_properties(toplevel, options.mangle.properties, annotated_props);\n    }\n\n    // Format phase\n    if (timings) timings.format = Date.now();\n    var result = {};\n    if (options.format.ast) {\n        result.ast = toplevel;\n    }\n    if (options.format.spidermonkey) {\n        result.ast = toplevel.to_mozilla_ast();\n    }\n    let format_options;\n    if (!HOP(options.format, \"code\") || options.format.code) {\n        // Make a shallow copy so that we can modify without mutating the user's input.\n        format_options = {...options.format};\n        if (!format_options.ast) {\n            // Destroy stuff to save RAM. (unless the deprecated `ast` option is on)\n            format_options._destroy_ast = true;\n\n            walk(toplevel, node => {\n                if (node instanceof AST_Scope) {\n                    node.variables = undefined;\n                    node.enclosed = undefined;\n                    node.parent_scope = undefined;\n                }\n                if (node.block_scope) {\n                    node.block_scope.variables = undefined;\n                    node.block_scope.enclosed = undefined;\n                    node.block_scope.parent_scope = undefined;\n                }\n            });\n        }\n\n        if (options.sourceMap) {\n            if (options.sourceMap.includeSources && files instanceof AST_Toplevel) {\n                throw new Error(\"original source content unavailable\");\n            }\n            format_options.source_map = yield* SourceMap({\n                file: options.sourceMap.filename,\n                orig: options.sourceMap.content,\n                root: options.sourceMap.root,\n                files: options.sourceMap.includeSources ? files : null,\n            });\n        }\n        delete format_options.ast;\n        delete format_options.code;\n        delete format_options.spidermonkey;\n        var stream = OutputStream(format_options);\n        toplevel.print(stream);\n        result.code = stream.get();\n        if (options.sourceMap) {\n            Object.defineProperty(result, \"map\", {\n                configurable: true,\n                enumerable: true,\n                get() {\n                    const map = format_options.source_map.getEncoded();\n                    return (result.map = options.sourceMap.asObject ? map : JSON.stringify(map));\n                },\n                set(value) {\n                    Object.defineProperty(result, \"map\", {\n                        value,\n                        writable: true,\n                    });\n                }\n            });\n            result.decoded_map = format_options.source_map.getDecoded();\n            if (options.sourceMap.url == \"inline\") {\n                var sourceMap = typeof result.map === \"object\" ? JSON.stringify(result.map) : result.map;\n                result.code += \"\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,\" + to_base64(sourceMap);\n            } else if (options.sourceMap.url) {\n                result.code += \"\\n//# sourceMappingURL=\" + options.sourceMap.url;\n            }\n        }\n    }\n    if (options.nameCache && options.mangle) {\n        if (options.mangle.cache) options.nameCache.vars = cache_to_json(options.mangle.cache);\n        if (options.mangle.properties && options.mangle.properties.cache) {\n            options.nameCache.props = cache_to_json(options.mangle.properties.cache);\n        }\n    }\n    if (format_options && format_options.source_map) {\n        format_options.source_map.destroy();\n    }\n    if (timings) {\n        timings.end = Date.now();\n        result.timings = {\n            parse: 1e-3 * (timings.rename - timings.parse),\n            rename: 1e-3 * (timings.compress - timings.rename),\n            compress: 1e-3 * (timings.scope - timings.compress),\n            scope: 1e-3 * (timings.mangle - timings.scope),\n            mangle: 1e-3 * (timings.properties - timings.mangle),\n            properties: 1e-3 * (timings.format - timings.properties),\n            format: 1e-3 * (timings.end - timings.format),\n            total: 1e-3 * (timings.end - timings.start)\n        };\n    }\n    return result;\n}\n\nasync function minify(files, options, _fs_module) {\n    const gen = minify_sync_or_async(files, options, _fs_module);\n\n    let yielded;\n    let val;\n    do {\n        val = gen.next(await yielded);\n        yielded = val.value;\n    } while (!val.done);\n\n    return val.value;\n}\n\nfunction minify_sync(files, options, _fs_module) {\n    const gen = minify_sync_or_async(files, options, _fs_module);\n\n    let yielded;\n    let val;\n    do {\n        if (yielded && typeof yielded.then === \"function\") {\n            throw new Error(\"minify_sync cannot be used with the legacy source-map module\");\n        }\n        val = gen.next(yielded);\n        yielded = val.value;\n    } while (!val.done);\n\n    return val.value;\n}\n\nasync function run_cli({ program, packageJson, fs, path }) {\n    const skip_keys = new Set([ \"cname\", \"parent_scope\", \"scope\", \"uses_eval\", \"uses_with\" ]);\n    var files = {};\n    var options = {\n        compress: false,\n        mangle: false\n    };\n    const default_options = await _default_options();\n    program.version(packageJson.name + \" \" + packageJson.version);\n    program.parseArgv = program.parse;\n    program.parse = undefined;\n\n    if (process.argv.includes(\"ast\")) program.helpInformation = describe_ast;\n    else if (process.argv.includes(\"options\")) program.helpInformation = function() {\n        var text = [];\n        for (var option in default_options) {\n            text.push(\"--\" + (option === \"sourceMap\" ? \"source-map\" : option) + \" options:\");\n            text.push(format_object(default_options[option]));\n            text.push(\"\");\n        }\n        return text.join(\"\\n\");\n    };\n\n    program.option(\"-p, --parse <options>\", \"Specify parser options.\", parse_js());\n    program.option(\"-c, --compress [options]\", \"Enable compressor/specify compressor options.\", parse_js());\n    program.option(\"-m, --mangle [options]\", \"Mangle names/specify mangler options.\", parse_js());\n    program.option(\"--mangle-props [options]\", \"Mangle properties/specify mangler options.\", parse_js());\n    program.option(\"-f, --format [options]\", \"Format options.\", parse_js());\n    program.option(\"-b, --beautify [options]\", \"Alias for --format.\", parse_js());\n    program.option(\"-o, --output <file>\", \"Output file (default STDOUT).\");\n    program.option(\"--comments [filter]\", \"Preserve copyright comments in the output.\");\n    program.option(\"--config-file <file>\", \"Read minify() options from JSON file.\");\n    program.option(\"-d, --define <expr>[=value]\", \"Global definitions.\", parse_js(\"define\"));\n    program.option(\"--ecma <version>\", \"Specify ECMAScript release: 5, 2015, 2016 or 2017...\");\n    program.option(\"-e, --enclose [arg[,...][:value[,...]]]\", \"Embed output in a big function with configurable arguments and values.\");\n    program.option(\"--ie8\", \"Support non-standard Internet Explorer 8.\");\n    program.option(\"--keep-classnames\", \"Do not mangle/drop class names.\");\n    program.option(\"--keep-fnames\", \"Do not mangle/drop function names. Useful for code relying on Function.prototype.name.\");\n    program.option(\"--module\", \"Input is an ES6 module\");\n    program.option(\"--name-cache <file>\", \"File to hold mangled name mappings.\");\n    program.option(\"--rename\", \"Force symbol expansion.\");\n    program.option(\"--no-rename\", \"Disable symbol expansion.\");\n    program.option(\"--safari10\", \"Support non-standard Safari 10.\");\n    program.option(\"--source-map [options]\", \"Enable source map/specify source map options.\", parse_js());\n    program.option(\"--timings\", \"Display operations run time on STDERR.\");\n    program.option(\"--toplevel\", \"Compress and/or mangle variables in toplevel scope.\");\n    program.option(\"--wrap <name>\", \"Embed everything as a function with exports corresponding to name globally.\");\n    program.arguments(\"[files...]\").parseArgv(process.argv);\n    if (program.configFile) {\n        options = JSON.parse(read_file(program.configFile));\n    }\n    if (!program.output && program.sourceMap && program.sourceMap.url != \"inline\") {\n        fatal(\"ERROR: cannot write source map to STDOUT\");\n    }\n\n    [\n        \"compress\",\n        \"enclose\",\n        \"ie8\",\n        \"mangle\",\n        \"module\",\n        \"safari10\",\n        \"sourceMap\",\n        \"toplevel\",\n        \"wrap\"\n    ].forEach(function(name) {\n        if (name in program) {\n            options[name] = program[name];\n        }\n    });\n\n    if (\"ecma\" in program) {\n        if (program.ecma != (program.ecma | 0)) fatal(\"ERROR: ecma must be an integer\");\n        const ecma = program.ecma | 0;\n        if (ecma > 5 && ecma < 2015)\n            options.ecma = ecma + 2009;\n        else\n            options.ecma = ecma;\n    }\n    if (program.format || program.beautify) {\n        const chosenOption = program.format || program.beautify;\n        options.format = typeof chosenOption === \"object\" ? chosenOption : {};\n    }\n    if (program.comments) {\n        if (typeof options.format != \"object\") options.format = {};\n        options.format.comments = typeof program.comments == \"string\" ? (program.comments == \"false\" ? false : program.comments) : \"some\";\n    }\n    if (program.define) {\n        if (typeof options.compress != \"object\") options.compress = {};\n        if (typeof options.compress.global_defs != \"object\") options.compress.global_defs = {};\n        for (var expr in program.define) {\n            options.compress.global_defs[expr] = program.define[expr];\n        }\n    }\n    if (program.keepClassnames) {\n        options.keep_classnames = true;\n    }\n    if (program.keepFnames) {\n        options.keep_fnames = true;\n    }\n    if (program.mangleProps) {\n        if (program.mangleProps.domprops) {\n            delete program.mangleProps.domprops;\n        } else {\n            if (typeof program.mangleProps != \"object\") program.mangleProps = {};\n            if (!Array.isArray(program.mangleProps.reserved)) program.mangleProps.reserved = [];\n        }\n        if (typeof options.mangle != \"object\") options.mangle = {};\n        options.mangle.properties = program.mangleProps;\n    }\n    if (program.nameCache) {\n        options.nameCache = JSON.parse(read_file(program.nameCache, \"{}\"));\n    }\n    if (program.output == \"ast\") {\n        options.format = {\n            ast: true,\n            code: false\n        };\n    }\n    if (program.parse) {\n        if (!program.parse.acorn && !program.parse.spidermonkey) {\n            options.parse = program.parse;\n        } else if (program.sourceMap && program.sourceMap.content == \"inline\") {\n            fatal(\"ERROR: inline source map only works with built-in parser\");\n        }\n    }\n    if (~program.rawArgs.indexOf(\"--rename\")) {\n        options.rename = true;\n    } else if (!program.rename) {\n        options.rename = false;\n    }\n\n    let convert_path = name => name;\n    if (typeof program.sourceMap == \"object\" && \"base\" in program.sourceMap) {\n        convert_path = function() {\n            var base = program.sourceMap.base;\n            delete options.sourceMap.base;\n            return function(name) {\n                return path.relative(base, name);\n            };\n        }();\n    }\n\n    let filesList;\n    if (options.files && options.files.length) {\n        filesList = options.files;\n\n        delete options.files;\n    } else if (program.args.length) {\n        filesList = program.args;\n    }\n\n    if (filesList) {\n        simple_glob(filesList).forEach(function(name) {\n            files[convert_path(name)] = read_file(name);\n        });\n    } else {\n        await new Promise((resolve) => {\n            var chunks = [];\n            process.stdin.setEncoding(\"utf8\");\n            process.stdin.on(\"data\", function(chunk) {\n                chunks.push(chunk);\n            }).on(\"end\", function() {\n                files = [ chunks.join(\"\") ];\n                resolve();\n            });\n            process.stdin.resume();\n        });\n    }\n\n    await run_cli();\n\n    function convert_ast(fn) {\n        return AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));\n    }\n\n    async function run_cli() {\n        var content = program.sourceMap && program.sourceMap.content;\n        if (content && content !== \"inline\") {\n            options.sourceMap.content = read_file(content, content);\n        }\n        if (program.timings) options.timings = true;\n\n        try {\n            if (program.parse) {\n                if (program.parse.acorn) {\n                    files = convert_ast(function(toplevel, name) {\n                        return (__webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.js\").parse)(files[name], {\n                            ecmaVersion: 2024,\n                            locations: true,\n                            program: toplevel,\n                            sourceFile: name,\n                            sourceType: options.module || program.parse.module ? \"module\" : \"script\"\n                        });\n                    });\n                } else if (program.parse.spidermonkey) {\n                    files = convert_ast(function(toplevel, name) {\n                        var obj = JSON.parse(files[name]);\n                        if (!toplevel) return obj;\n                        toplevel.body = toplevel.body.concat(obj.body);\n                        return toplevel;\n                    });\n                }\n            }\n        } catch (ex) {\n            fatal(ex);\n        }\n\n        let result;\n        try {\n            result = await minify(files, options, fs);\n        } catch (ex) {\n            if (ex.name == \"SyntaxError\") {\n                print_error(\"Parse error at \" + ex.filename + \":\" + ex.line + \",\" + ex.col);\n                var col = ex.col;\n                var lines = files[ex.filename].split(/\\r?\\n/);\n                var line = lines[ex.line - 1];\n                if (!line && !col) {\n                    line = lines[ex.line - 2];\n                    col = line.length;\n                }\n                if (line) {\n                    var limit = 70;\n                    if (col > limit) {\n                        line = line.slice(col - limit);\n                        col = limit;\n                    }\n                    print_error(line.slice(0, 80));\n                    print_error(line.slice(0, col).replace(/\\S/g, \" \") + \"^\");\n                }\n            }\n            if (ex.defs) {\n                print_error(\"Supported options:\");\n                print_error(format_object(ex.defs));\n            }\n            fatal(ex);\n            return;\n        }\n\n        if (program.output == \"ast\") {\n            if (!options.compress && !options.mangle) {\n                result.ast.figure_out_scope({});\n            }\n            console.log(JSON.stringify(result.ast, function(key, value) {\n                if (value) switch (key) {\n                  case \"thedef\":\n                    return symdef(value);\n                  case \"enclosed\":\n                    return value.length ? value.map(symdef) : undefined;\n                  case \"variables\":\n                  case \"globals\":\n                    return value.size ? collect_from_map(value, symdef) : undefined;\n                }\n                if (skip_keys.has(key)) return;\n                if (value instanceof AST_Token) return;\n                if (value instanceof Map) return;\n                if (value instanceof AST_Node) {\n                    var result = {\n                        _class: \"AST_\" + value.TYPE\n                    };\n                    if (value.block_scope) {\n                        result.variables = value.block_scope.variables;\n                        result.enclosed = value.block_scope.enclosed;\n                    }\n                    value.CTOR.PROPS.forEach(function(prop) {\n                        if (prop !== \"block_scope\") {\n                            result[prop] = value[prop];\n                        }\n                    });\n                    return result;\n                }\n                return value;\n            }, 2));\n        } else if (program.output == \"spidermonkey\") {\n            try {\n                const minified = await minify(\n                    result.code,\n                    {\n                        compress: false,\n                        mangle: false,\n                        format: {\n                            ast: true,\n                            code: false\n                        }\n                    },\n                    fs\n                );\n                console.log(JSON.stringify(minified.ast.to_mozilla_ast(), null, 2));\n            } catch (ex) {\n                fatal(ex);\n                return;\n            }\n        } else if (program.output) {\n            fs.mkdirSync(path.dirname(program.output), { recursive: true });\n            fs.writeFileSync(program.output, result.code);\n            if (options.sourceMap && options.sourceMap.url !== \"inline\" && result.map) {\n                fs.writeFileSync(program.output + \".map\", result.map);\n            }\n        } else {\n            console.log(result.code);\n        }\n        if (program.nameCache) {\n            fs.writeFileSync(program.nameCache, JSON.stringify(options.nameCache));\n        }\n        if (result.timings) for (var phase in result.timings) {\n            print_error(\"- \" + phase + \": \" + result.timings[phase].toFixed(3) + \"s\");\n        }\n    }\n\n    function fatal(message) {\n        if (message instanceof Error) message = message.stack.replace(/^\\S*?Error:/, \"ERROR:\");\n        print_error(message);\n        process.exit(1);\n    }\n\n    // A file glob function that only supports \"*\" and \"?\" wildcards in the basename.\n    // Example: \"foo/bar/*baz??.*.js\"\n    // Argument `glob` may be a string or an array of strings.\n    // Returns an array of strings. Garbage in, garbage out.\n    function simple_glob(glob) {\n        if (Array.isArray(glob)) {\n            return [].concat.apply([], glob.map(simple_glob));\n        }\n        if (glob && glob.match(/[*?]/)) {\n            var dir = path.dirname(glob);\n            try {\n                var entries = fs.readdirSync(dir);\n            } catch (ex) {}\n            if (entries) {\n                var pattern = \"^\" + path.basename(glob)\n                    .replace(/[.+^$[\\]\\\\(){}]/g, \"\\\\$&\")\n                    .replace(/\\*/g, \"[^/\\\\\\\\]*\")\n                    .replace(/\\?/g, \"[^/\\\\\\\\]\") + \"$\";\n                var mod = process.platform === \"win32\" ? \"i\" : \"\";\n                var rx = new RegExp(pattern, mod);\n                var results = entries.filter(function(name) {\n                    return rx.test(name);\n                }).map(function(name) {\n                    return path.join(dir, name);\n                });\n                if (results.length) return results;\n            }\n        }\n        return [ glob ];\n    }\n\n    function read_file(path, default_value) {\n        try {\n            return fs.readFileSync(path, \"utf8\");\n        } catch (ex) {\n            if ((ex.code == \"ENOENT\" || ex.code == \"ENAMETOOLONG\") && default_value != null) return default_value;\n            fatal(ex);\n        }\n    }\n\n    function parse_js(flag) {\n        return function(value, options) {\n            options = options || {};\n            try {\n                walk(parse(value, { expression: true }), node => {\n                    if (node instanceof AST_Assign) {\n                        var name = node.left.print_to_string();\n                        var value = node.right;\n                        if (flag) {\n                            options[name] = value;\n                        } else if (value instanceof AST_Array) {\n                            options[name] = value.elements.map(to_string);\n                        } else if (value instanceof AST_RegExp) {\n                            value = value.value;\n                            options[name] = new RegExp(value.source, value.flags);\n                        } else {\n                            options[name] = to_string(value);\n                        }\n                        return true;\n                    }\n                    if (node instanceof AST_Symbol || node instanceof AST_PropAccess) {\n                        var name = node.print_to_string();\n                        options[name] = true;\n                        return true;\n                    }\n                    if (!(node instanceof AST_Sequence)) throw node;\n\n                    function to_string(value) {\n                        return value instanceof AST_Constant ? value.getValue() : value.print_to_string({\n                            quote_keys: true\n                        });\n                    }\n                });\n            } catch(ex) {\n                if (flag) {\n                    fatal(\"Error parsing arguments for '\" + flag + \"': \" + value);\n                } else {\n                    options[value] = null;\n                }\n            }\n            return options;\n        };\n    }\n\n    function symdef(def) {\n        var ret = (1e6 + def.id) + \" \" + def.name;\n        if (def.mangled_name) ret += \" \" + def.mangled_name;\n        return ret;\n    }\n\n    function collect_from_map(map, callback) {\n        var result = [];\n        map.forEach(function (def) {\n            result.push(callback(def));\n        });\n        return result;\n    }\n\n    function format_object(obj) {\n        var lines = [];\n        var padding = \"\";\n        Object.keys(obj).map(function(name) {\n            if (padding.length < name.length) padding = Array(name.length + 1).join(\" \");\n            return [ name, JSON.stringify(obj[name]) ];\n        }).forEach(function(tokens) {\n            lines.push(\"  \" + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);\n        });\n        return lines.join(\"\\n\");\n    }\n\n    function print_error(msg) {\n        process.stderr.write(msg);\n        process.stderr.write(\"\\n\");\n    }\n\n    function describe_ast() {\n        var out = OutputStream({ beautify: true });\n        function doitem(ctor) {\n            out.print(\"AST_\" + ctor.TYPE);\n            const props = ctor.SELF_PROPS.filter(prop => !/^\\$/.test(prop));\n\n            if (props.length > 0) {\n                out.space();\n                out.with_parens(function() {\n                    props.forEach(function(prop, i) {\n                        if (i) out.space();\n                        out.print(prop);\n                    });\n                });\n            }\n\n            if (ctor.documentation) {\n                out.space();\n                out.print_string(ctor.documentation);\n            }\n\n            if (ctor.SUBCLASSES.length > 0) {\n                out.space();\n                out.with_block(function() {\n                    ctor.SUBCLASSES.forEach(function(ctor) {\n                        out.indent();\n                        doitem(ctor);\n                        out.newline();\n                    });\n                });\n            }\n        }\n        doitem(AST_Node);\n        return out + \"\\n\";\n    }\n}\n\nasync function _default_options() {\n    const defs = {};\n\n    Object.keys(infer_options({ 0: 0 })).forEach((component) => {\n        const options = infer_options({\n            [component]: {0: 0}\n        });\n\n        if (options) defs[component] = options;\n    });\n    return defs;\n}\n\nasync function infer_options(options) {\n    try {\n        await minify(\"\", options);\n    } catch (error) {\n        return error.defs;\n    }\n}\n\nexports._default_options = _default_options;\nexports._run_cli = run_cli;\nexports.minify = minify;\nexports.minify_sync = minify_sync;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL2Rpc3QvYnVuZGxlLm1pbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLDRGQUF3QjtBQUNoSCxDQUN5SDtBQUN6SCxDQUFDLHlDQUF5Qzs7QUFFMUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxFQUFFO0FBQ25DO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0I7QUFDdEIsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVEQUF1RDs7QUFFdkQseURBQXlELEdBQUc7O0FBRTVELCtDQUErQyxJQUFJOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxxQkFBcUI7QUFDcEU7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxpQ0FBaUM7QUFDakMsbUVBQW1FO0FBQ25FLGtEQUFrRDtBQUNsRCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtDQUFrQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLEtBQUs7QUFDaEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdDQUFnQztBQUNyRixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTs7QUFFQTtBQUNBLHlDQUF5QyxrREFBa0Q7QUFDM0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdDQUFnQztBQUM3RSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdDQUFnQztBQUMxRSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdDQUFnQztBQUMxRSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qyw4QkFBOEI7QUFDOUIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLCtCQUErQixpQkFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQSxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQSxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLHNDQUFzQyw4QkFBOEI7QUFDcEUsY0FBYztBQUNkO0FBQ0EsMENBQTBDLHFEQUFxRDtBQUMvRixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2QkFBNkI7QUFDN0Isc0NBQXNDO0FBQ3RDLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZCx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQyxLQUFLOztBQUVMO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSxXQUFXO0FBQzdDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMEJBQTBCO0FBQ25FLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFLG9CQUFvQjs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBOztBQUVBLDBDQUEwQywwQkFBMEI7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0M7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjs7QUFFQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0NBQXNDLHdDQUF3QztBQUM5RSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBDQUEwQyxvQ0FBb0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTTtBQUNwRCxrQkFBa0IsdUJBQXVCLEVBQUUsT0FBTyxLQUFLLFVBQVUsR0FBRyxTQUFTLEVBQUUsYUFBYTtBQUM1Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsbURBQW1ELGdCQUFnQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRCx1Q0FBdUM7QUFDdkMsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRCw2Q0FBNkM7QUFDN0MsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsSUFBSTtBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5QkFBeUI7QUFDekIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUJBQXlCO0FBQ3pCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQSxjQUFjLGVBQWUsc0JBQXNCO0FBQ25EO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSw2REFBNkQsUUFBUTtBQUNyRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQWdDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUkseUJBQXlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSw4RUFBOEUseUNBQXlDOztBQUV2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxQ0FBcUM7QUFDOUY7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUE2QztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVFQUF1RSxjQUFjOztBQUVyRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9DQUFvQztBQUM1RCxvQ0FBb0MsdUNBQXVDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixVQUFVO0FBQ1Y7QUFDQSx3QkFBd0I7QUFDeEIsVUFBVTtBQUNWLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsaUJBQWlCLDhCQUE4QjtBQUN4RjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdCQUF3Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLGdCQUFnQjtBQUNoQixNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQkFBcUI7QUFDNUQsdUNBQXVDLG1DQUFtQztBQUMxRSx1Q0FBdUMsZ0VBQWdFO0FBQ3ZHLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0QsdUNBQXVDLHFCQUFxQjtBQUM1RCx1Q0FBdUMscUJBQXFCO0FBQzVELDJDQUEyQyxtQkFBbUI7QUFDOUQsdUNBQXVDLHFCQUFxQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGLHNFQUFzRSxNQUFNLGNBQWMsTUFBTTtBQUNoRztBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU0sR0FBRyxXQUFXO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZDQUE2QztBQUM3QyxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGNBQWM7QUFDZCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsY0FBYztBQUNkLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5Q0FBeUM7QUFDekMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSwrQkFBK0I7QUFDL0IsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCO0FBQzdCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU8sR0FBRyxNQUFNOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQsNENBQTRDLElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE1BQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0VBQXdFLE1BQU0sRUFBRSxLQUFLLEVBQUUsSUFBSTtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esd0NBQXdDLCtEQUErRDtBQUN2Ryx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsNERBQTRELElBQUk7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSwrQkFBK0Isc0JBQXNCOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRDs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDREQUE0RCxPQUFPO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUM7O0FBRXpDLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DLHFDQUFxQzs7QUFFckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGFBQWE7QUFDdkUsYUFBYSxrQ0FBa0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5RUFBeUUsS0FBSztBQUM5RTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQixtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0EsbUNBQW1DLGdEQUFnRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxtRUFBbUUsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJO0FBQ3JGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQyx5REFBeUQ7QUFDekQseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QywyQ0FBMkM7QUFDM0MseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQyw2Q0FBNkM7QUFDN0MsMkNBQTJDO0FBQzNDLDZDQUE2QztBQUM3QywyQ0FBMkM7QUFDM0MsNkNBQTZDO0FBQzdDLHlDQUF5QztBQUN6QywyQ0FBMkM7QUFDM0MseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FLE1BQU07QUFDTjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixVQUFVO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrRkFBa0YsVUFBVTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLE1BQU07QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsVUFBVTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUksdUJBQXVCLGFBQWEsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsOERBQThELG9CQUFvQjtBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7O0FBRVYsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0NBQXdDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUNBQWlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCLEdBQUc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsWUFBWTtBQUNqRjtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHdCQUF3QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0EsNERBQTRELFVBQVU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0JBQStCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsa0RBQWtEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxZQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNkRBQTZELFlBQVk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5REFBeUQsWUFBWTtBQUNyRSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNDQUFzQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUUsMkRBQTJELGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hELHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsK0VBQStFLFdBQVc7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDhEQUE4RCxXQUFXO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQiw4Q0FBOEM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0EscURBQXFELEVBQUU7QUFDdkQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxrQkFBa0IsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUksZUFBZSxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSSxXQUFXLElBQUksWUFBWSxJQUFJLE1BQU0sSUFBSTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7O0FBR0E7QUFDQSxnQkFBZ0IsVUFBVSxTQUFTLFVBQVU7QUFDN0MsZ0JBQWdCLFVBQVUsU0FBUyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQkFBZ0IsUUFBUTtBQUN4QyxnQkFBZ0IsZ0JBQWdCLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsZ0JBQWdCLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFVBQVUsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLFNBQVM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZSxLQUFLLGFBQWEsZ0NBQWdDLEtBQUs7QUFDL0Y7QUFDQSx5QkFBeUIsY0FBYyxnQ0FBZ0MsS0FBSztBQUM1RSx5QkFBeUIsYUFBYSxnQ0FBZ0MsS0FBSztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxjQUFjLElBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUIsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQU0sZ0JBQWdCLHFCQUFNOztBQUV4RDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEUsVUFBVTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsd0JBQXdCLGFBQWEsZ0JBQWdCLDhCQUE4Qjs7QUFFbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxjQUFjO0FBQzNGLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhFQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQSwwQkFBMEI7QUFDMUIsU0FBUzs7QUFFVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RpbnlzaGFkZS8uL25vZGVfbW9kdWxlcy90ZXJzZXIvZGlzdC9idW5kbGUubWluLmpzP2RjZjciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGpyaWRnZXdlbGwvc291cmNlLW1hcCcpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0BqcmlkZ2V3ZWxsL3NvdXJjZS1tYXAnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuVGVyc2VyID0ge30sIGdsb2JhbC5zb3VyY2VNYXApKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cywgc291cmNlTWFwKSB7ICd1c2Ugc3RyaWN0JztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5mdW5jdGlvbiBjaGFyYWN0ZXJzKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoXCJcIik7XG59XG5cbmZ1bmN0aW9uIG1lbWJlcihuYW1lLCBhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY2xhc3MgRGVmYXVsdHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2csIGRlZnMpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSBcIkRlZmF1bHRzRXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICAgICAgICB0aGlzLmRlZnMgPSBkZWZzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdHMoYXJncywgZGVmcywgY3JvYWspIHtcbiAgICBpZiAoYXJncyA9PT0gdHJ1ZSkge1xuICAgICAgICBhcmdzID0ge307XG4gICAgfSBlbHNlIGlmIChhcmdzICE9IG51bGwgJiYgdHlwZW9mIGFyZ3MgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgYXJncyA9IHsuLi5hcmdzfTtcbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSBhcmdzIHx8IHt9O1xuXG4gICAgaWYgKGNyb2FrKSBmb3IgKGNvbnN0IGkgaW4gcmV0KSBpZiAoSE9QKHJldCwgaSkgJiYgIUhPUChkZWZzLCBpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRGVmYXVsdHNFcnJvcihcImBcIiArIGkgKyBcImAgaXMgbm90IGEgc3VwcG9ydGVkIG9wdGlvblwiLCBkZWZzKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gZGVmcykgaWYgKEhPUChkZWZzLCBpKSkge1xuICAgICAgICBpZiAoIWFyZ3MgfHwgIUhPUChhcmdzLCBpKSkge1xuICAgICAgICAgICAgcmV0W2ldID0gZGVmc1tpXTtcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSBcImVjbWFcIikge1xuICAgICAgICAgICAgbGV0IGVjbWEgPSBhcmdzW2ldIHwgMDtcbiAgICAgICAgICAgIGlmIChlY21hID4gNSAmJiBlY21hIDwgMjAxNSkgZWNtYSArPSAyMDA5O1xuICAgICAgICAgICAgcmV0W2ldID0gZWNtYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldFtpXSA9IChhcmdzICYmIEhPUChhcmdzLCBpKSkgPyBhcmdzW2ldIDogZGVmc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gcmV0dXJuX2ZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cbmZ1bmN0aW9uIHJldHVybl90cnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuZnVuY3Rpb24gcmV0dXJuX3RoaXMoKSB7IHJldHVybiB0aGlzOyB9XG5mdW5jdGlvbiByZXR1cm5fbnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cblxudmFyIE1BUCA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNQVAoYSwgdHcsIGFsbG93X3NwbGljaW5nID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBuZXdfYSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBhW2ldO1xuICAgICAgICAgICAgbGV0IHJldCA9IGl0ZW0udHJhbnNmb3JtKHR3LCBhbGxvd19zcGxpY2luZyk7XG5cbiAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBBU1RfTm9kZSkge1xuICAgICAgICAgICAgICAgIG5ld19hLnB1c2gocmV0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0IGluc3RhbmNlb2YgU3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgbmV3X2EucHVzaCguLi5yZXQudik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3X2E7XG4gICAgfVxuXG4gICAgTUFQLnNwbGljZSA9IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gbmV3IFNwbGljZSh2YWwpOyB9O1xuICAgIE1BUC5za2lwID0ge307XG4gICAgZnVuY3Rpb24gU3BsaWNlKHZhbCkgeyB0aGlzLnYgPSB2YWw7IH1cbiAgICByZXR1cm4gTUFQO1xufSkoKTtcblxuZnVuY3Rpb24gbWFrZV9ub2RlKGN0b3IsIG9yaWcsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykgcHJvcHMgPSB7fTtcbiAgICBpZiAob3JpZykge1xuICAgICAgICBpZiAoIXByb3BzLnN0YXJ0KSBwcm9wcy5zdGFydCA9IG9yaWcuc3RhcnQ7XG4gICAgICAgIGlmICghcHJvcHMuZW5kKSBwcm9wcy5lbmQgPSBvcmlnLmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBjdG9yKHByb3BzKTtcbn1cblxuZnVuY3Rpb24gcHVzaF91bmlxKGFycmF5LCBlbCkge1xuICAgIGlmICghYXJyYXkuaW5jbHVkZXMoZWwpKVxuICAgICAgICBhcnJheS5wdXNoKGVsKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nX3RlbXBsYXRlKHRleHQsIHByb3BzKSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgveyguKz8pfS9nLCBmdW5jdGlvbihzdHIsIHApIHtcbiAgICAgICAgcmV0dXJuIHByb3BzICYmIHByb3BzW3BdO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGVsKSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZWwpIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlU29ydChhcnJheSwgY21wKSB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA8IDIpIHJldHVybiBhcnJheS5zbGljZSgpO1xuICAgIGZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgICAgICAgdmFyIHIgPSBbXSwgYWkgPSAwLCBiaSA9IDAsIGkgPSAwO1xuICAgICAgICB3aGlsZSAoYWkgPCBhLmxlbmd0aCAmJiBiaSA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjbXAoYVthaV0sIGJbYmldKSA8PSAwXG4gICAgICAgICAgICAgICAgPyByW2krK10gPSBhW2FpKytdXG4gICAgICAgICAgICAgICAgOiByW2krK10gPSBiW2JpKytdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhaSA8IGEubGVuZ3RoKSByLnB1c2guYXBwbHkociwgYS5zbGljZShhaSkpO1xuICAgICAgICBpZiAoYmkgPCBiLmxlbmd0aCkgci5wdXNoLmFwcGx5KHIsIGIuc2xpY2UoYmkpKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9tcyhhKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCA8PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIHZhciBtID0gTWF0aC5mbG9vcihhLmxlbmd0aCAvIDIpLCBsZWZ0ID0gYS5zbGljZSgwLCBtKSwgcmlnaHQgPSBhLnNsaWNlKG0pO1xuICAgICAgICBsZWZ0ID0gX21zKGxlZnQpO1xuICAgICAgICByaWdodCA9IF9tcyhyaWdodCk7XG4gICAgICAgIHJldHVybiBtZXJnZShsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBfbXMoYXJyYXkpO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJlZGljYXRlKHdvcmRzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSkgd29yZHMgPSB3b3Jkcy5zcGxpdChcIiBcIik7XG5cbiAgICByZXR1cm4gbmV3IFNldCh3b3Jkcy5zb3J0KCkpO1xufVxuXG5mdW5jdGlvbiBtYXBfYWRkKG1hcCwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChtYXAuaGFzKGtleSkpIHtcbiAgICAgICAgbWFwLmdldChrZXkpLnB1c2godmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBbIHZhbHVlIF0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFwX2Zyb21fb2JqZWN0KG9iaikge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoSE9QKG9iaiwga2V5KSAmJiBrZXkuY2hhckF0KDApID09PSBcIiRcIikge1xuICAgICAgICAgICAgbWFwLnNldChrZXkuc3Vic3RyKDEpLCBvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gbWFwX3RvX29iamVjdChtYXApIHtcbiAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBvYmpbXCIkXCIgKyBrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gSE9QKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZnVuY3Rpb24ga2VlcF9uYW1lKGtlZXBfc2V0dGluZywgbmFtZSkge1xuICAgIHJldHVybiBrZWVwX3NldHRpbmcgPT09IHRydWVcbiAgICAgICAgfHwgKGtlZXBfc2V0dGluZyBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBrZWVwX3NldHRpbmcudGVzdChuYW1lKSk7XG59XG5cbnZhciBsaW5lVGVybWluYXRvckVzY2FwZSA9IHtcbiAgICBcIlxcMFwiOiBcIjBcIixcbiAgICBcIlxcblwiOiBcIm5cIixcbiAgICBcIlxcclwiOiBcInJcIixcbiAgICBcIlxcdTIwMjhcIjogXCJ1MjAyOFwiLFxuICAgIFwiXFx1MjAyOVwiOiBcInUyMDI5XCIsXG59O1xuZnVuY3Rpb24gcmVnZXhwX3NvdXJjZV9maXgoc291cmNlKSB7XG4gICAgLy8gVjggZG9lcyBub3QgZXNjYXBlIGxpbmUgdGVybWluYXRvcnMgaW4gcmVnZXhwIHBhdHRlcm5zIGluIG5vZGUgMTJcbiAgICAvLyBXZSdsbCBhbHNvIHJlbW92ZSBsaXRlcmFsIFxcMFxuICAgIHJldHVybiBzb3VyY2UucmVwbGFjZSgvW1xcMFxcblxcclxcdTIwMjhcXHUyMDI5XS9nLCBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCkge1xuICAgICAgICB2YXIgZXNjYXBlZCA9IHNvdXJjZVtvZmZzZXQgLSAxXSA9PSBcIlxcXFxcIlxuICAgICAgICAgICAgJiYgKHNvdXJjZVtvZmZzZXQgLSAyXSAhPSBcIlxcXFxcIlxuICAgICAgICAgICAgfHwgLyg/Ol58W15cXFxcXSkoPzpcXFxcezJ9KSokLy50ZXN0KHNvdXJjZS5zbGljZSgwLCBvZmZzZXQgLSAxKSkpO1xuICAgICAgICByZXR1cm4gKGVzY2FwZWQgPyBcIlwiIDogXCJcXFxcXCIpICsgbGluZVRlcm1pbmF0b3JFc2NhcGVbbWF0Y2hdO1xuICAgIH0pO1xufVxuXG4vLyBTdWJzZXQgb2YgcmVnZXhwcyB0aGF0IGlzIG5vdCBnb2luZyB0byBjYXVzZSByZWdleHAgYmFzZWQgRERPU1xuLy8gaHR0cHM6Ly9vd2FzcC5vcmcvd3d3LWNvbW11bml0eS9hdHRhY2tzL1JlZ3VsYXJfZXhwcmVzc2lvbl9EZW5pYWxfb2ZfU2VydmljZV8tX1JlRG9TXG5jb25zdCByZV9zYWZlX3JlZ2V4cCA9IC9eW1xcXFwvfFxcMFxcc1xcd14kLltcXF0oKV0qJC87XG5cbi8qKiBDaGVjayBpZiB0aGUgcmVnZXhwIGlzIHNhZmUgZm9yIFRlcnNlciB0byBjcmVhdGUgd2l0aG91dCByaXNraW5nIGEgUmVnRXhwIERPUyAqL1xuY29uc3QgcmVnZXhwX2lzX3NhZmUgPSAoc291cmNlKSA9PiByZV9zYWZlX3JlZ2V4cC50ZXN0KHNvdXJjZSk7XG5cbmNvbnN0IGFsbF9mbGFncyA9IFwiZGdpbXN1eXZcIjtcbmZ1bmN0aW9uIHNvcnRfcmVnZXhwX2ZsYWdzKGZsYWdzKSB7XG4gICAgY29uc3QgZXhpc3RpbmdfZmxhZ3MgPSBuZXcgU2V0KGZsYWdzLnNwbGl0KFwiXCIpKTtcbiAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IGZsYWcgb2YgYWxsX2ZsYWdzKSB7XG4gICAgICAgIGlmIChleGlzdGluZ19mbGFncy5oYXMoZmxhZykpIHtcbiAgICAgICAgICAgIG91dCArPSBmbGFnO1xuICAgICAgICAgICAgZXhpc3RpbmdfZmxhZ3MuZGVsZXRlKGZsYWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleGlzdGluZ19mbGFncy5zaXplKSB7XG4gICAgICAgIC8vIEZsYWdzIFRlcnNlciBkb2Vzbid0IGtub3cgYWJvdXRcbiAgICAgICAgZXhpc3RpbmdfZmxhZ3MuZm9yRWFjaChmbGFnID0+IHsgb3V0ICs9IGZsYWc7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBoYXNfYW5ub3RhdGlvbihub2RlLCBhbm5vdGF0aW9uKSB7XG4gICAgcmV0dXJuIG5vZGUuX2Fubm90YXRpb25zICYgYW5ub3RhdGlvbjtcbn1cblxuZnVuY3Rpb24gc2V0X2Fubm90YXRpb24obm9kZSwgYW5ub3RhdGlvbikge1xuICAgIG5vZGUuX2Fubm90YXRpb25zIHw9IGFubm90YXRpb247XG59XG5cbmZ1bmN0aW9uIGNsZWFyX2Fubm90YXRpb24obm9kZSwgYW5ub3RhdGlvbikge1xuICAgIG5vZGUuX2Fubm90YXRpb25zICY9IH5hbm5vdGF0aW9uO1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgUGFyc2VyIGJhc2VkIG9uIHBhcnNlLWpzIChodHRwOi8vbWFyaWpuLmhhdmVyYmVrZS5ubC9wYXJzZS1qcy8pLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgTEFURVNUX1JBVyA9IFwiXCI7ICAvLyBPbmx5IHVzZWQgZm9yIG51bWJlcnMgYW5kIHRlbXBsYXRlIHN0cmluZ3NcbnZhciBURU1QTEFURV9SQVdTID0gbmV3IE1hcCgpOyAgLy8gUmF3IHRlbXBsYXRlIHN0cmluZ3NcblxudmFyIEtFWVdPUkRTID0gXCJicmVhayBjYXNlIGNhdGNoIGNsYXNzIGNvbnN0IGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZGVsZXRlIGRvIGVsc2UgZXhwb3J0IGV4dGVuZHMgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgaW4gaW5zdGFuY2VvZiBsZXQgbmV3IHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHR5cGVvZiB2YXIgdm9pZCB3aGlsZSB3aXRoXCI7XG52YXIgS0VZV09SRFNfQVRPTSA9IFwiZmFsc2UgbnVsbCB0cnVlXCI7XG52YXIgUkVTRVJWRURfV09SRFMgPSBcImVudW0gaW1wb3J0IHN1cGVyIHRoaXMgXCIgKyBLRVlXT1JEU19BVE9NICsgXCIgXCIgKyBLRVlXT1JEUztcbnZhciBBTExfUkVTRVJWRURfV09SRFMgPSBcImltcGxlbWVudHMgaW50ZXJmYWNlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyBcIiArIFJFU0VSVkVEX1dPUkRTO1xudmFyIEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OID0gXCJyZXR1cm4gbmV3IGRlbGV0ZSB0aHJvdyBlbHNlIGNhc2UgeWllbGQgYXdhaXRcIjtcblxuS0VZV09SRFMgPSBtYWtlUHJlZGljYXRlKEtFWVdPUkRTKTtcblJFU0VSVkVEX1dPUkRTID0gbWFrZVByZWRpY2F0ZShSRVNFUlZFRF9XT1JEUyk7XG5LRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTiA9IG1ha2VQcmVkaWNhdGUoS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04pO1xuS0VZV09SRFNfQVRPTSA9IG1ha2VQcmVkaWNhdGUoS0VZV09SRFNfQVRPTSk7XG5BTExfUkVTRVJWRURfV09SRFMgPSBtYWtlUHJlZGljYXRlKEFMTF9SRVNFUlZFRF9XT1JEUyk7XG5cbnZhciBPUEVSQVRPUl9DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIistKiYlPTw+IT98fl5cIikpO1xuXG52YXIgUkVfSEVYX05VTUJFUiA9IC9eMHhbMC05YS1mXSskL2k7XG52YXIgUkVfT0NUX05VTUJFUiA9IC9eMFswLTddKyQvO1xudmFyIFJFX0VTNl9PQ1RfTlVNQkVSID0gL14wb1swLTddKyQvaTtcbnZhciBSRV9CSU5fTlVNQkVSID0gL14wYlswMV0rJC9pO1xudmFyIFJFX0RFQ19OVU1CRVIgPSAvXlxcZCpcXC4/XFxkKig/OmVbKy1dP1xcZCooPzpcXGRcXC4/fFxcLj9cXGQpXFxkKik/JC9pO1xudmFyIFJFX0JJR19JTlQgPSAvXigwW3hvYl0pP1swLTlhLWZdK24kL2k7XG5cbnZhciBSRV9LRVlXT1JEX1JFTEFUSU9OQUxfT1BFUkFUT1JTID0gL2luKD86c3RhbmNlb2YpPy95O1xuXG52YXIgT1BFUkFUT1JTID0gbWFrZVByZWRpY2F0ZShbXG4gICAgXCJpblwiLFxuICAgIFwiaW5zdGFuY2VvZlwiLFxuICAgIFwidHlwZW9mXCIsXG4gICAgXCJuZXdcIixcbiAgICBcInZvaWRcIixcbiAgICBcImRlbGV0ZVwiLFxuICAgIFwiKytcIixcbiAgICBcIi0tXCIsXG4gICAgXCIrXCIsXG4gICAgXCItXCIsXG4gICAgXCIhXCIsXG4gICAgXCJ+XCIsXG4gICAgXCImXCIsXG4gICAgXCJ8XCIsXG4gICAgXCJeXCIsXG4gICAgXCIqXCIsXG4gICAgXCIqKlwiLFxuICAgIFwiL1wiLFxuICAgIFwiJVwiLFxuICAgIFwiPj5cIixcbiAgICBcIjw8XCIsXG4gICAgXCI+Pj5cIixcbiAgICBcIjxcIixcbiAgICBcIj5cIixcbiAgICBcIjw9XCIsXG4gICAgXCI+PVwiLFxuICAgIFwiPT1cIixcbiAgICBcIj09PVwiLFxuICAgIFwiIT1cIixcbiAgICBcIiE9PVwiLFxuICAgIFwiP1wiLFxuICAgIFwiPVwiLFxuICAgIFwiKz1cIixcbiAgICBcIi09XCIsXG4gICAgXCJ8fD1cIixcbiAgICBcIiYmPVwiLFxuICAgIFwiPz89XCIsXG4gICAgXCIvPVwiLFxuICAgIFwiKj1cIixcbiAgICBcIioqPVwiLFxuICAgIFwiJT1cIixcbiAgICBcIj4+PVwiLFxuICAgIFwiPDw9XCIsXG4gICAgXCI+Pj49XCIsXG4gICAgXCJ8PVwiLFxuICAgIFwiXj1cIixcbiAgICBcIiY9XCIsXG4gICAgXCImJlwiLFxuICAgIFwiPz9cIixcbiAgICBcInx8XCIsXG5dKTtcblxudmFyIFdISVRFU1BBQ0VfQ0hBUlMgPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCIgXFx1MDBhMFxcblxcclxcdFxcZlxcdTAwMGJcXHUyMDBiXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdUZFRkZcIikpO1xuXG52YXIgTkVXTElORV9DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIlxcblxcclxcdTIwMjhcXHUyMDI5XCIpKTtcblxudmFyIFBVTkNfQUZURVJfRVhQUkVTU0lPTiA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIjtdKSw6XCIpKTtcblxudmFyIFBVTkNfQkVGT1JFX0VYUFJFU1NJT04gPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCJbeygsOzpcIikpO1xuXG52YXIgUFVOQ19DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIltde30oKSw7OlwiKSk7XG5cbi8qIC0tLS0tWyBUb2tlbml6ZXIgXS0tLS0tICovXG5cbi8vIHN1cnJvZ2F0ZSBzYWZlIHJlZ2V4cHMgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3VuaWNvZGUtOC4wLjAvdHJlZS84OWI0MTJkOGE3MWVjY2E5ZWQ1OTNkOWU5ZmEwNzNhYjY0YWNmZWJlL0JpbmFyeV9Qcm9wZXJ0eVxudmFyIFVOSUNPREUgPSB7XG4gICAgSURfU3RhcnQ6IC9bJEEtWl9hLXpcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlCLVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxuICAgIElEX0NvbnRpbnVlOiAvKD86WyQwLTlBLVpfYS16XFx4QUFcXHhCNVxceEI3XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4Ni1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCNFxcdTA4RTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBBRjlcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4LVxcdTBDNUFcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzY5LVxcdTEzNzFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5LVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVEREZEXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REVFMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3QVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0EwLVxcdURDQTlcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVERENBLVxcdUREQ0NcXHVEREQwLVxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTM3XFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFRDAtXFx1REVFRFxcdURFRjAtXFx1REVGNFxcdURGMDAtXFx1REYzNlxcdURGNDAtXFx1REY0M1xcdURGNTAtXFx1REY1OVxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwLVxcdURGN0VcXHVERjhGLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENEMC1cXHVEQ0Q2XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1REI0MFtcXHVERDAwLVxcdURERUZdKSsvLFxufTtcblxuZnVuY3Rpb24gZ2V0X2Z1bGxfY2hhcihzdHIsIHBvcykge1xuICAgIGlmIChpc19zdXJyb2dhdGVfcGFpcl9oZWFkKHN0ci5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgIGlmIChpc19zdXJyb2dhdGVfcGFpcl90YWlsKHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQocG9zKSArIHN0ci5jaGFyQXQocG9zICsgMSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzX3N1cnJvZ2F0ZV9wYWlyX3RhaWwoc3RyLmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgaWYgKGlzX3N1cnJvZ2F0ZV9wYWlyX2hlYWQoc3RyLmNoYXJDb2RlQXQocG9zIC0gMSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLmNoYXJBdChwb3MgLSAxKSArIHN0ci5jaGFyQXQocG9zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyLmNoYXJBdChwb3MpO1xufVxuXG5mdW5jdGlvbiBnZXRfZnVsbF9jaGFyX2NvZGUoc3RyLCBwb3MpIHtcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbiAgICBpZiAoaXNfc3Vycm9nYXRlX3BhaXJfaGVhZChzdHIuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICByZXR1cm4gMHgxMDAwMCArIChzdHIuY2hhckNvZGVBdChwb3MpIC0gMHhkODAwIDw8IDEwKSArIHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpIC0gMHhkYzAwO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQocG9zKTtcbn1cblxuZnVuY3Rpb24gZ2V0X2Z1bGxfY2hhcl9sZW5ndGgoc3RyKSB7XG4gICAgdmFyIHN1cnJvZ2F0ZXMgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzX3N1cnJvZ2F0ZV9wYWlyX2hlYWQoc3RyLmNoYXJDb2RlQXQoaSkpICYmIGlzX3N1cnJvZ2F0ZV9wYWlyX3RhaWwoc3RyLmNoYXJDb2RlQXQoaSArIDEpKSkge1xuICAgICAgICAgICAgc3Vycm9nYXRlcysrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5sZW5ndGggLSBzdXJyb2dhdGVzO1xufVxuXG5mdW5jdGlvbiBmcm9tX2NoYXJfY29kZShjb2RlKSB7XG4gICAgLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLmZyb21Db2RlUG9pbnQvYmxvYi9tYXN0ZXIvZnJvbWNvZGVwb2ludC5qc1xuICAgIGlmIChjb2RlID4gMHhGRkZGKSB7XG4gICAgICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIChTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4RDgwMCkgK1xuICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSAlIDB4NDAwKSArIDB4REMwMCkpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbn1cblxuZnVuY3Rpb24gaXNfc3Vycm9nYXRlX3BhaXJfaGVhZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhkODAwICYmIGNvZGUgPD0gMHhkYmZmO1xufVxuXG5mdW5jdGlvbiBpc19zdXJyb2dhdGVfcGFpcl90YWlsKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweGRjMDAgJiYgY29kZSA8PSAweGRmZmY7XG59XG5cbmZ1bmN0aW9uIGlzX2RpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3O1xufVxuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX3N0YXJ0KGNoKSB7XG4gICAgcmV0dXJuIFVOSUNPREUuSURfU3RhcnQudGVzdChjaCk7XG59XG5cbmZ1bmN0aW9uIGlzX2lkZW50aWZpZXJfY2hhcihjaCkge1xuICAgIHJldHVybiBVTklDT0RFLklEX0NvbnRpbnVlLnRlc3QoY2gpO1xufVxuXG5jb25zdCBCQVNJQ19JREVOVCA9IC9eW2Etel8kXVthLXowLTlfJF0qJC9pO1xuXG5mdW5jdGlvbiBpc19iYXNpY19pZGVudGlmaWVyX3N0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gQkFTSUNfSURFTlQudGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX3N0cmluZyhzdHIsIGFsbG93X3N1cnJvZ2F0ZXMpIHtcbiAgICBpZiAoQkFTSUNfSURFTlQudGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWFsbG93X3N1cnJvZ2F0ZXMgJiYgL1tcXHVkODAwLVxcdWRmZmZdLy50ZXN0KHN0cikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSBVTklDT0RFLklEX1N0YXJ0LmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdHIgPSBzdHIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICBpZiAoIXN0cikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IFVOSUNPREUuSURfQ29udGludWUuZXhlYyhzdHIpO1xuICAgIHJldHVybiAhIW1hdGNoICYmIG1hdGNoWzBdLmxlbmd0aCA9PT0gc3RyLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gcGFyc2VfanNfbnVtYmVyKG51bSwgYWxsb3dfZSA9IHRydWUpIHtcbiAgICBpZiAoIWFsbG93X2UgJiYgbnVtLmluY2x1ZGVzKFwiZVwiKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBpZiAoUkVfSEVYX05VTUJFUi50ZXN0KG51bSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bS5zdWJzdHIoMiksIDE2KTtcbiAgICB9IGVsc2UgaWYgKFJFX09DVF9OVU1CRVIudGVzdChudW0pKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChudW0uc3Vic3RyKDEpLCA4KTtcbiAgICB9IGVsc2UgaWYgKFJFX0VTNl9PQ1RfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigyKSwgOCk7XG4gICAgfSBlbHNlIGlmIChSRV9CSU5fTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigyKSwgMik7XG4gICAgfSBlbHNlIGlmIChSRV9ERUNfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChudW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWwgPSBwYXJzZUZsb2F0KG51bSk7XG4gICAgICAgIGlmICh2YWwgPT0gbnVtKSByZXR1cm4gdmFsO1xuICAgIH1cbn1cblxuY2xhc3MgSlNfUGFyc2VfRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZmlsZW5hbWUsIGxpbmUsIGNvbCwgcG9zKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gXCJTeW50YXhFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuY29sID0gY29sO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGpzX2Vycm9yKG1lc3NhZ2UsIGZpbGVuYW1lLCBsaW5lLCBjb2wsIHBvcykge1xuICAgIHRocm93IG5ldyBKU19QYXJzZV9FcnJvcihtZXNzYWdlLCBmaWxlbmFtZSwgbGluZSwgY29sLCBwb3MpO1xufVxuXG5mdW5jdGlvbiBpc190b2tlbih0b2tlbiwgdHlwZSwgdmFsKSB7XG4gICAgcmV0dXJuIHRva2VuLnR5cGUgPT0gdHlwZSAmJiAodmFsID09IG51bGwgfHwgdG9rZW4udmFsdWUgPT0gdmFsKTtcbn1cblxudmFyIEVYX0VPRiA9IHt9O1xuXG5mdW5jdGlvbiB0b2tlbml6ZXIoJFRFWFQsIGZpbGVuYW1lLCBodG1sNV9jb21tZW50cywgc2hlYmFuZykge1xuICAgIHZhciBTID0ge1xuICAgICAgICB0ZXh0ICAgICAgICAgICAgOiAkVEVYVCxcbiAgICAgICAgZmlsZW5hbWUgICAgICAgIDogZmlsZW5hbWUsXG4gICAgICAgIHBvcyAgICAgICAgICAgICA6IDAsXG4gICAgICAgIHRva3BvcyAgICAgICAgICA6IDAsXG4gICAgICAgIGxpbmUgICAgICAgICAgICA6IDEsXG4gICAgICAgIHRva2xpbmUgICAgICAgICA6IDAsXG4gICAgICAgIGNvbCAgICAgICAgICAgICA6IDAsXG4gICAgICAgIHRva2NvbCAgICAgICAgICA6IDAsXG4gICAgICAgIG5ld2xpbmVfYmVmb3JlICA6IGZhbHNlLFxuICAgICAgICByZWdleF9hbGxvd2VkICAgOiBmYWxzZSxcbiAgICAgICAgYnJhY2VfY291bnRlciAgIDogMCxcbiAgICAgICAgdGVtcGxhdGVfYnJhY2VzIDogW10sXG4gICAgICAgIGNvbW1lbnRzX2JlZm9yZSA6IFtdLFxuICAgICAgICBkaXJlY3RpdmVzICAgICAgOiB7fSxcbiAgICAgICAgZGlyZWN0aXZlX3N0YWNrIDogW11cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGVlaygpIHsgcmV0dXJuIGdldF9mdWxsX2NoYXIoUy50ZXh0LCBTLnBvcyk7IH1cblxuICAgIC8vIFVzZWQgYmVjYXVzZSBwYXJzaW5nID8uIGludm9sdmVzIGEgbG9va2FoZWFkIGZvciBhIGRpZ2l0XG4gICAgZnVuY3Rpb24gaXNfb3B0aW9uX2NoYWluX29wKCkge1xuICAgICAgICBjb25zdCBtdXN0X2JlX2RvdCA9IFMudGV4dC5jaGFyQ29kZUF0KFMucG9zICsgMSkgPT09IDQ2O1xuICAgICAgICBpZiAoIW11c3RfYmVfZG90KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgY2Fubm90X2JlX2RpZ2l0ID0gUy50ZXh0LmNoYXJDb2RlQXQoUy5wb3MgKyAyKTtcbiAgICAgICAgcmV0dXJuIGNhbm5vdF9iZV9kaWdpdCA8IDQ4IHx8IGNhbm5vdF9iZV9kaWdpdCA+IDU3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHQoc2lnbmFsX2VvZiwgaW5fc3RyaW5nKSB7XG4gICAgICAgIHZhciBjaCA9IGdldF9mdWxsX2NoYXIoUy50ZXh0LCBTLnBvcysrKTtcbiAgICAgICAgaWYgKHNpZ25hbF9lb2YgJiYgIWNoKVxuICAgICAgICAgICAgdGhyb3cgRVhfRU9GO1xuICAgICAgICBpZiAoTkVXTElORV9DSEFSUy5oYXMoY2gpKSB7XG4gICAgICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gUy5uZXdsaW5lX2JlZm9yZSB8fCAhaW5fc3RyaW5nO1xuICAgICAgICAgICAgKytTLmxpbmU7XG4gICAgICAgICAgICBTLmNvbCA9IDA7XG4gICAgICAgICAgICBpZiAoY2ggPT0gXCJcXHJcIiAmJiBwZWVrKCkgPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIC8vIHRyZWF0IGEgXFxyXFxuIHNlcXVlbmNlIGFzIGEgc2luZ2xlIFxcblxuICAgICAgICAgICAgICAgICsrUy5wb3M7XG4gICAgICAgICAgICAgICAgY2ggPSBcIlxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICArK1MucG9zO1xuICAgICAgICAgICAgICAgICsrUy5jb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK1MuY29sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3J3YXJkKGkpIHtcbiAgICAgICAgd2hpbGUgKGktLSkgbmV4dCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb2tpbmdfYXQoc3RyKSB7XG4gICAgICAgIHJldHVybiBTLnRleHQuc3Vic3RyKFMucG9zLCBzdHIubGVuZ3RoKSA9PSBzdHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZF9lb2woKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gUy50ZXh0O1xuICAgICAgICBmb3IgKHZhciBpID0gUy5wb3MsIG4gPSBTLnRleHQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0ZXh0W2ldO1xuICAgICAgICAgICAgaWYgKE5FV0xJTkVfQ0hBUlMuaGFzKGNoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZCh3aGF0LCBzaWduYWxfZW9mKSB7XG4gICAgICAgIHZhciBwb3MgPSBTLnRleHQuaW5kZXhPZih3aGF0LCBTLnBvcyk7XG4gICAgICAgIGlmIChzaWduYWxfZW9mICYmIHBvcyA9PSAtMSkgdGhyb3cgRVhfRU9GO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0X3Rva2VuKCkge1xuICAgICAgICBTLnRva2xpbmUgPSBTLmxpbmU7XG4gICAgICAgIFMudG9rY29sID0gUy5jb2w7XG4gICAgICAgIFMudG9rcG9zID0gUy5wb3M7XG4gICAgfVxuXG4gICAgdmFyIHByZXZfd2FzX2RvdCA9IGZhbHNlO1xuICAgIHZhciBwcmV2aW91c190b2tlbiA9IG51bGw7XG4gICAgZnVuY3Rpb24gdG9rZW4odHlwZSwgdmFsdWUsIGlzX2NvbW1lbnQpIHtcbiAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gKCh0eXBlID09IFwib3BlcmF0b3JcIiAmJiAhVU5BUllfUE9TVEZJWC5oYXModmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT0gXCJrZXl3b3JkXCIgJiYgS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04uaGFzKHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09IFwicHVuY1wiICYmIFBVTkNfQkVGT1JFX0VYUFJFU1NJT04uaGFzKHZhbHVlKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PSBcImFycm93XCIpO1xuICAgICAgICBpZiAodHlwZSA9PSBcInB1bmNcIiAmJiAodmFsdWUgPT0gXCIuXCIgfHwgdmFsdWUgPT0gXCI/LlwiKSkge1xuICAgICAgICAgICAgcHJldl93YXNfZG90ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNfY29tbWVudCkge1xuICAgICAgICAgICAgcHJldl93YXNfZG90ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZSAgICAgPSBTLnRva2xpbmU7XG4gICAgICAgIGNvbnN0IGNvbCAgICAgID0gUy50b2tjb2w7XG4gICAgICAgIGNvbnN0IHBvcyAgICAgID0gUy50b2twb3M7XG4gICAgICAgIGNvbnN0IG5sYiAgICAgID0gUy5uZXdsaW5lX2JlZm9yZTtcbiAgICAgICAgY29uc3QgZmlsZSAgICAgPSBmaWxlbmFtZTtcbiAgICAgICAgbGV0IGNvbW1lbnRzX2JlZm9yZSA9IFtdO1xuICAgICAgICBsZXQgY29tbWVudHNfYWZ0ZXIgID0gW107XG5cbiAgICAgICAgaWYgKCFpc19jb21tZW50KSB7XG4gICAgICAgICAgICBjb21tZW50c19iZWZvcmUgPSBTLmNvbW1lbnRzX2JlZm9yZTtcbiAgICAgICAgICAgIGNvbW1lbnRzX2FmdGVyID0gUy5jb21tZW50c19iZWZvcmUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHRvayA9IG5ldyBBU1RfVG9rZW4odHlwZSwgdmFsdWUsIGxpbmUsIGNvbCwgcG9zLCBubGIsIGNvbW1lbnRzX2JlZm9yZSwgY29tbWVudHNfYWZ0ZXIsIGZpbGUpO1xuXG4gICAgICAgIGlmICghaXNfY29tbWVudCkgcHJldmlvdXNfdG9rZW4gPSB0b2s7XG4gICAgICAgIHJldHVybiB0b2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tpcF93aGl0ZXNwYWNlKCkge1xuICAgICAgICB3aGlsZSAoV0hJVEVTUEFDRV9DSEFSUy5oYXMocGVlaygpKSlcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWVrX25leHRfdG9rZW5fc3RhcnRfb3JfbmV3bGluZSgpIHtcbiAgICAgICAgdmFyIHBvcyA9IFMucG9zO1xuICAgICAgICBmb3IgKHZhciBpbl9tdWx0aWxpbmVfY29tbWVudCA9IGZhbHNlOyBwb3MgPCBTLnRleHQubGVuZ3RoOyApIHtcbiAgICAgICAgICAgIHZhciBjaCA9IGdldF9mdWxsX2NoYXIoUy50ZXh0LCBwb3MpO1xuICAgICAgICAgICAgaWYgKE5FV0xJTkVfQ0hBUlMuaGFzKGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYXI6IGNoLCBwb3M6IHBvcyB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbl9tdWx0aWxpbmVfY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIipcIiAmJiBnZXRfZnVsbF9jaGFyKFMudGV4dCwgcG9zICsgMSkgPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGluX211bHRpbGluZV9jb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghV0hJVEVTUEFDRV9DSEFSUy5oYXMoY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0X2NoID0gZ2V0X2Z1bGxfY2hhcihTLnRleHQsIHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dF9jaCA9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gZmluZF9lb2woKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYXI6IGdldF9mdWxsX2NoYXIoUy50ZXh0LCBwb3MpLCBwb3M6IHBvcyB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRfY2ggPT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluX211bHRpbGluZV9jb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhcjogY2gsIHBvczogcG9zIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYXI6IG51bGwsIHBvczogcG9zIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hfc3RhcnRzX2JpbmRpbmdfaWRlbnRpZmllcihjaCwgcG9zKSB7XG4gICAgICAgIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNfaWRlbnRpZmllcl9zdGFydChjaCkpIHtcbiAgICAgICAgICAgIFJFX0tFWVdPUkRfUkVMQVRJT05BTF9PUEVSQVRPUlMubGFzdEluZGV4ID0gcG9zO1xuICAgICAgICAgICAgaWYgKFJFX0tFWVdPUkRfUkVMQVRJT05BTF9PUEVSQVRPUlMudGVzdChTLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFmdGVyID0gZ2V0X2Z1bGxfY2hhcihTLnRleHQsIFJFX0tFWVdPUkRfUkVMQVRJT05BTF9PUEVSQVRPUlMubGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXJfY2hhcihhZnRlcikgJiYgYWZ0ZXIgIT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJpblwiIG9yIFwiaW5zdGFuY2VvZlwiIGFyZSBrZXl3b3Jkcywgbm90IGJpbmRpbmcgaWRlbnRpZmllcnNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZF93aGlsZShwcmVkKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiLCBjaCwgaSA9IDA7XG4gICAgICAgIHdoaWxlICgoY2ggPSBwZWVrKCkpICYmIHByZWQoY2gsIGkrKykpXG4gICAgICAgICAgICByZXQgKz0gbmV4dCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlX2Vycm9yKGVycikge1xuICAgICAgICBqc19lcnJvcihlcnIsIGZpbGVuYW1lLCBTLnRva2xpbmUsIFMudG9rY29sLCBTLnRva3Bvcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZF9udW0ocHJlZml4KSB7XG4gICAgICAgIHZhciBoYXNfZSA9IGZhbHNlLCBhZnRlcl9lID0gZmFsc2UsIGhhc194ID0gZmFsc2UsIGhhc19kb3QgPSBwcmVmaXggPT0gXCIuXCIsIGlzX2JpZ19pbnQgPSBmYWxzZSwgbnVtZXJpY19zZXBhcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIG51bSA9IHJlYWRfd2hpbGUoZnVuY3Rpb24oY2gsIGkpIHtcbiAgICAgICAgICAgIGlmIChpc19iaWdfaW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk1OiAvLyBfXG4gICAgICAgICAgICAgICAgcmV0dXJuIChudW1lcmljX3NlcGFyYXRvciA9IHRydWUpO1xuICAgICAgICAgICAgICBjYXNlIDk4OiBjYXNlIDY2OiAvLyBiQlxuICAgICAgICAgICAgICAgIHJldHVybiAoaGFzX3ggPSB0cnVlKTsgLy8gQ2FuIG9jY3VyIGluIGhleCBzZXF1ZW5jZSwgZG9uJ3QgcmV0dXJuIGZhbHNlIHlldFxuICAgICAgICAgICAgICBjYXNlIDExMTogY2FzZSA3OTogLy8gb09cbiAgICAgICAgICAgICAgY2FzZSAxMjA6IGNhc2UgODg6IC8vIHhYXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc194ID8gZmFsc2UgOiAoaGFzX3ggPSB0cnVlKTtcbiAgICAgICAgICAgICAgY2FzZSAxMDE6IGNhc2UgNjk6IC8vIGVFXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc194ID8gdHJ1ZSA6IGhhc19lID8gZmFsc2UgOiAoaGFzX2UgPSBhZnRlcl9lID0gdHJ1ZSk7XG4gICAgICAgICAgICAgIGNhc2UgNDU6IC8vIC1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXJfZSB8fCAoaSA9PSAwICYmICFwcmVmaXgpO1xuICAgICAgICAgICAgICBjYXNlIDQzOiAvLyArXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyX2U7XG4gICAgICAgICAgICAgIGNhc2UgKGFmdGVyX2UgPSBmYWxzZSwgNDYpOiAvLyAuXG4gICAgICAgICAgICAgICAgcmV0dXJuICghaGFzX2RvdCAmJiAhaGFzX3ggJiYgIWhhc19lKSA/IChoYXNfZG90ID0gdHJ1ZSkgOiBmYWxzZTtcbiAgICAgICAgICAgICAgY2FzZSAxMTA6IC8vIG5cbiAgICAgICAgICAgICAgICBpc19iaWdfaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcgLy8gMC05XG4gICAgICAgICAgICAgICAgfHwgY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMiAvLyBhLWZcbiAgICAgICAgICAgICAgICB8fCBjb2RlID49IDY1ICYmIGNvZGUgPD0gNzAgLy8gQS1GXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZWZpeCkgbnVtID0gcHJlZml4ICsgbnVtO1xuXG4gICAgICAgIExBVEVTVF9SQVcgPSBudW07XG5cbiAgICAgICAgaWYgKFJFX09DVF9OVU1CRVIudGVzdChudW0pICYmIG5leHRfdG9rZW4uaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikpIHtcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiTGVnYWN5IG9jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtZXJpY19zZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChudW0uZW5kc1dpdGgoXCJfXCIpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJOdW1lcmljIHNlcGFyYXRvcnMgYXJlIG5vdCBhbGxvd2VkIGF0IHRoZSBlbmQgb2YgbnVtZXJpYyBsaXRlcmFsc1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtLmluY2x1ZGVzKFwiX19cIikpIHtcbiAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcIk9ubHkgb25lIHVuZGVyc2NvcmUgaXMgYWxsb3dlZCBhcyBudW1lcmljIHNlcGFyYXRvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bSA9IG51bS5yZXBsYWNlKC9fL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19iaWdfaW50KSB7XG4gICAgICAgICAgICBjb25zdCB3aXRob3V0X24gPSBudW0uc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgY29uc3QgYWxsb3dfZSA9IFJFX0hFWF9OVU1CRVIudGVzdCh3aXRob3V0X24pO1xuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBwYXJzZV9qc19udW1iZXIod2l0aG91dF9uLCBhbGxvd19lKTtcbiAgICAgICAgICAgIGlmICghaGFzX2RvdCAmJiBSRV9CSUdfSU5ULnRlc3QobnVtKSAmJiAhaXNOYU4odmFsaWQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbihcImJpZ19pbnRcIiwgd2l0aG91dF9uKTtcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiSW52YWxpZCBvciB1bmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZCA9IHBhcnNlX2pzX251bWJlcihudW0pO1xuICAgICAgICBpZiAoIWlzTmFOKHZhbGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwibnVtXCIsIHZhbGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiSW52YWxpZCBzeW50YXg6IFwiICsgbnVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX29jdGFsKGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA+PSBcIjBcIiAmJiBjaCA8PSBcIjdcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkX2VzY2FwZWRfY2hhcihpbl9zdHJpbmcsIHN0cmljdF9oZXgsIHRlbXBsYXRlX3N0cmluZykge1xuICAgICAgICB2YXIgY2ggPSBuZXh0KHRydWUsIGluX3N0cmluZyk7XG4gICAgICAgIHN3aXRjaCAoY2guY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgIGNhc2UgMTEwIDogcmV0dXJuIFwiXFxuXCI7XG4gICAgICAgICAgY2FzZSAxMTQgOiByZXR1cm4gXCJcXHJcIjtcbiAgICAgICAgICBjYXNlIDExNiA6IHJldHVybiBcIlxcdFwiO1xuICAgICAgICAgIGNhc2UgOTggIDogcmV0dXJuIFwiXFxiXCI7XG4gICAgICAgICAgY2FzZSAxMTggOiByZXR1cm4gXCJcXHUwMDBiXCI7IC8vIFxcdlxuICAgICAgICAgIGNhc2UgMTAyIDogcmV0dXJuIFwiXFxmXCI7XG4gICAgICAgICAgY2FzZSAxMjAgOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhfYnl0ZXMoMiwgc3RyaWN0X2hleCkpOyAvLyBcXHhcbiAgICAgICAgICBjYXNlIDExNyA6IC8vIFxcdVxuICAgICAgICAgICAgaWYgKHBlZWsoKSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAgIG5leHQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBlZWsoKSA9PT0gXCJ9XCIpXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiRXhwZWN0aW5nIGhleC1jaGFyYWN0ZXIgYmV0d2VlbiB7fVwiKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocGVlaygpID09IFwiMFwiKSBuZXh0KHRydWUpOyAvLyBObyBzaWduaWZpY2FuY2VcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LCBsZW5ndGggPSBmaW5kKFwifVwiLCB0cnVlKSAtIFMucG9zO1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIDMyIGJpdCBpbnRlZ2VyIG92ZXJmbG93ICgxIDw8IDMyID09PSAxKVxuICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgZmlyc3QgY2hhcmFjdGVyIGlzbid0IDAgYW5kIHRodXMgb3V0IG9mIHJhbmdlIGFueXdheVxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPiA2IHx8IChyZXN1bHQgPSBoZXhfYnl0ZXMobGVuZ3RoLCBzdHJpY3RfaGV4KSkgPiAweDEwRkZGRikge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcIlVuaWNvZGUgcmVmZXJlbmNlIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21fY2hhcl9jb2RlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhfYnl0ZXMoNCwgc3RyaWN0X2hleCkpO1xuICAgICAgICAgIGNhc2UgMTAgIDogcmV0dXJuIFwiXCI7IC8vIG5ld2xpbmVcbiAgICAgICAgICBjYXNlIDEzICA6ICAgICAgICAgICAgLy8gXFxyXG4gICAgICAgICAgICBpZiAocGVlaygpID09IFwiXFxuXCIpIHsgLy8gRE9TIG5ld2xpbmVcbiAgICAgICAgICAgICAgICBuZXh0KHRydWUsIGluX3N0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX29jdGFsKGNoKSkge1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlX3N0cmluZyAmJiBzdHJpY3RfaGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwcmVzZW50c19udWxsX2NoYXJhY3RlciA9IGNoID09PSBcIjBcIiAmJiAhaXNfb2N0YWwocGVlaygpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcHJlc2VudHNfbnVsbF9jaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJPY3RhbCBlc2NhcGUgc2VxdWVuY2VzIGFyZSBub3QgYWxsb3dlZCBpbiB0ZW1wbGF0ZSBzdHJpbmdzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWFkX29jdGFsX2VzY2FwZV9zZXF1ZW5jZShjaCwgc3RyaWN0X2hleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRfb2N0YWxfZXNjYXBlX3NlcXVlbmNlKGNoLCBzdHJpY3Rfb2N0YWwpIHtcbiAgICAgICAgLy8gUmVhZFxuICAgICAgICB2YXIgcCA9IHBlZWsoKTtcbiAgICAgICAgaWYgKHAgPj0gXCIwXCIgJiYgcCA8PSBcIjdcIikge1xuICAgICAgICAgICAgY2ggKz0gbmV4dCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChjaFswXSA8PSBcIjNcIiAmJiAocCA9IHBlZWsoKSkgPj0gXCIwXCIgJiYgcCA8PSBcIjdcIilcbiAgICAgICAgICAgICAgICBjaCArPSBuZXh0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2VcbiAgICAgICAgaWYgKGNoID09PSBcIjBcIikgcmV0dXJuIFwiXFwwXCI7XG4gICAgICAgIGlmIChjaC5sZW5ndGggPiAwICYmIG5leHRfdG9rZW4uaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikgJiYgc3RyaWN0X29jdGFsKVxuICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJMZWdhY3kgb2N0YWwgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNoLCA4KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGV4X2J5dGVzKG4sIHN0cmljdF9oZXgpIHtcbiAgICAgICAgdmFyIG51bSA9IDA7XG4gICAgICAgIGZvciAoOyBuID4gMDsgLS1uKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmljdF9oZXggJiYgaXNOYU4ocGFyc2VJbnQocGVlaygpLCAxNikpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bSwgMTYpIHx8IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBuZXh0KHRydWUpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlSW50KGRpZ2l0LCAxNikpKVxuICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiSW52YWxpZCBoZXgtY2hhcmFjdGVyIHBhdHRlcm4gaW4gc3RyaW5nXCIpO1xuICAgICAgICAgICAgbnVtICs9IGRpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUludChudW0sIDE2KTtcbiAgICB9XG5cbiAgICB2YXIgcmVhZF9zdHJpbmcgPSB3aXRoX2VvZl9lcnJvcihcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3BvcyA9IFMucG9zO1xuICAgICAgICB2YXIgcXVvdGUgPSBuZXh0KCksIHJldCA9IFtdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBuZXh0KHRydWUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGNoID09IFwiXFxcXFwiKSBjaCA9IHJlYWRfZXNjYXBlZF9jaGFyKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gXCJcXHJcIiB8fCBjaCA9PSBcIlxcblwiKSBwYXJzZV9lcnJvcihcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PSBxdW90ZSkgYnJlYWs7XG4gICAgICAgICAgICByZXQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvayA9IHRva2VuKFwic3RyaW5nXCIsIHJldC5qb2luKFwiXCIpKTtcbiAgICAgICAgTEFURVNUX1JBVyA9IFMudGV4dC5zbGljZShzdGFydF9wb3MsIFMucG9zKTtcbiAgICAgICAgdG9rLnF1b3RlID0gcXVvdGU7XG4gICAgICAgIHJldHVybiB0b2s7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVhZF90ZW1wbGF0ZV9jaGFyYWN0ZXJzID0gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIiwgZnVuY3Rpb24oYmVnaW4pIHtcbiAgICAgICAgaWYgKGJlZ2luKSB7XG4gICAgICAgICAgICBTLnRlbXBsYXRlX2JyYWNlcy5wdXNoKFMuYnJhY2VfY291bnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiLCByYXcgPSBcIlwiLCBjaCwgdG9rO1xuICAgICAgICBuZXh0KHRydWUsIHRydWUpO1xuICAgICAgICB3aGlsZSAoKGNoID0gbmV4dCh0cnVlLCB0cnVlKSkgIT0gXCJgXCIpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlZWsoKSA9PSBcIlxcblwiKSArK1MucG9zO1xuICAgICAgICAgICAgICAgIGNoID0gXCJcXG5cIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIkXCIgJiYgcGVlaygpID09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgbmV4dCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBTLmJyYWNlX2NvdW50ZXIrKztcbiAgICAgICAgICAgICAgICB0b2sgPSB0b2tlbihiZWdpbiA/IFwidGVtcGxhdGVfaGVhZFwiIDogXCJ0ZW1wbGF0ZV9jb250XCIsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIFRFTVBMQVRFX1JBV1Muc2V0KHRvaywgcmF3KTtcbiAgICAgICAgICAgICAgICB0b2sudGVtcGxhdGVfZW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmF3ICs9IGNoO1xuICAgICAgICAgICAgaWYgKGNoID09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IFMucG9zO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2X2lzX3RhZyA9IHByZXZpb3VzX3Rva2VuICYmIChwcmV2aW91c190b2tlbi50eXBlID09PSBcIm5hbWVcIiB8fCBwcmV2aW91c190b2tlbi50eXBlID09PSBcInB1bmNcIiAmJiAocHJldmlvdXNfdG9rZW4udmFsdWUgPT09IFwiKVwiIHx8IHByZXZpb3VzX3Rva2VuLnZhbHVlID09PSBcIl1cIikpO1xuICAgICAgICAgICAgICAgIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIodHJ1ZSwgIXByZXZfaXNfdGFnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByYXcgKz0gUy50ZXh0LnN1YnN0cih0bXAsIFMucG9zIC0gdG1wKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGVudCArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICBTLnRlbXBsYXRlX2JyYWNlcy5wb3AoKTtcbiAgICAgICAgdG9rID0gdG9rZW4oYmVnaW4gPyBcInRlbXBsYXRlX2hlYWRcIiA6IFwidGVtcGxhdGVfY29udFwiLCBjb250ZW50KTtcbiAgICAgICAgVEVNUExBVEVfUkFXUy5zZXQodG9rLCByYXcpO1xuICAgICAgICB0b2sudGVtcGxhdGVfZW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRvaztcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHNraXBfbGluZV9jb21tZW50KHR5cGUpIHtcbiAgICAgICAgdmFyIHJlZ2V4X2FsbG93ZWQgPSBTLnJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgIHZhciBpID0gZmluZF9lb2woKSwgcmV0O1xuICAgICAgICBpZiAoaSA9PSAtMSkge1xuICAgICAgICAgICAgcmV0ID0gUy50ZXh0LnN1YnN0cihTLnBvcyk7XG4gICAgICAgICAgICBTLnBvcyA9IFMudGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBTLnRleHQuc3Vic3RyaW5nKFMucG9zLCBpKTtcbiAgICAgICAgICAgIFMucG9zID0gaTtcbiAgICAgICAgfVxuICAgICAgICBTLmNvbCA9IFMudG9rY29sICsgKFMucG9zIC0gUy50b2twb3MpO1xuICAgICAgICBTLmNvbW1lbnRzX2JlZm9yZS5wdXNoKHRva2VuKHR5cGUsIHJldCwgdHJ1ZSkpO1xuICAgICAgICBTLnJlZ2V4X2FsbG93ZWQgPSByZWdleF9hbGxvd2VkO1xuICAgICAgICByZXR1cm4gbmV4dF90b2tlbjtcbiAgICB9XG5cbiAgICB2YXIgc2tpcF9tdWx0aWxpbmVfY29tbWVudCA9IHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIG11bHRpbGluZSBjb21tZW50XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVnZXhfYWxsb3dlZCA9IFMucmVnZXhfYWxsb3dlZDtcbiAgICAgICAgdmFyIGkgPSBmaW5kKFwiKi9cIiwgdHJ1ZSk7XG4gICAgICAgIHZhciB0ZXh0ID0gUy50ZXh0LnN1YnN0cmluZyhTLnBvcywgaSkucmVwbGFjZSgvXFxyXFxufFxccnxcXHUyMDI4fFxcdTIwMjkvZywgXCJcXG5cIik7XG4gICAgICAgIC8vIHVwZGF0ZSBzdHJlYW0gcG9zaXRpb25cbiAgICAgICAgZm9yd2FyZChnZXRfZnVsbF9jaGFyX2xlbmd0aCh0ZXh0KSAvKiB0ZXh0IGxlbmd0aCBkb2Vzbid0IGNvdW50IFxcclxcbiBhcyAyIGNoYXIgd2hpbGUgUy5wb3MgLSBpIGRvZXMgKi8gKyAyKTtcbiAgICAgICAgUy5jb21tZW50c19iZWZvcmUucHVzaCh0b2tlbihcImNvbW1lbnQyXCIsIHRleHQsIHRydWUpKTtcbiAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IFMubmV3bGluZV9iZWZvcmUgfHwgdGV4dC5pbmNsdWRlcyhcIlxcblwiKTtcbiAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gcmVnZXhfYWxsb3dlZDtcbiAgICAgICAgcmV0dXJuIG5leHRfdG9rZW47XG4gICAgfSk7XG5cbiAgICB2YXIgcmVhZF9uYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgc3RhcnQgPSBTLnBvcywgZW5kID0gc3RhcnQgLSAxLCBjaCA9IFwiY1wiO1xuXG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgIChjaCA9IFMudGV4dC5jaGFyQXQoKytlbmQpKVxuICAgICAgICAgICAgJiYgKGNoID49IFwiYVwiICYmIGNoIDw9IFwielwiIHx8IGNoID49IFwiQVwiICYmIGNoIDw9IFwiWlwiKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIDB4N0YgaXMgdmVyeSByYXJlIGluIGFjdHVhbCBjb2RlLCBzbyB3ZSBjb21wYXJlIGl0IHRvIFwiflwiICgweDdFKVxuICAgICAgICBpZiAoZW5kID4gc3RhcnQgKyAxICYmIGNoICYmIGNoICE9PSBcIlxcXFxcIiAmJiAhaXNfaWRlbnRpZmllcl9jaGFyKGNoKSAmJiBjaCA8PSBcIn5cIikge1xuICAgICAgICAgICAgUy5wb3MgKz0gZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICBTLmNvbCArPSBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiBTLnRleHQuc2xpY2Uoc3RhcnQsIFMucG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWFkX25hbWVfaGFyZCgpO1xuICAgIH07XG5cbiAgICB2YXIgcmVhZF9uYW1lX2hhcmQgPSB3aXRoX2VvZl9lcnJvcihcIlVudGVybWluYXRlZCBpZGVudGlmaWVyIG5hbWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuYW1lID0gW10sIGNoLCBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciByZWFkX2VzY2FwZWRfaWRlbnRpZmllcl9jaGFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChwZWVrKCkgIT09IFwidVwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJFeHBlY3RpbmcgVW5pY29kZUVzY2FwZVNlcXVlbmNlIC0tIHVYWFhYIG9yIHV7WFhYWH1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVhZF9lc2NhcGVkX2NoYXIoZmFsc2UsIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlYWQgZmlyc3QgY2hhcmFjdGVyIChJRF9TdGFydClcbiAgICAgICAgaWYgKChjaCA9IHBlZWsoKSkgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICBjaCA9IHJlYWRfZXNjYXBlZF9pZGVudGlmaWVyX2NoYXIoKTtcbiAgICAgICAgICAgIGlmICghaXNfaWRlbnRpZmllcl9zdGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcIkZpcnN0IGlkZW50aWZpZXIgY2hhciBpcyBhbiBpbnZhbGlkIGlkZW50aWZpZXIgY2hhclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc19pZGVudGlmaWVyX3N0YXJ0KGNoKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lLnB1c2goY2gpO1xuXG4gICAgICAgIC8vIFJlYWQgSURfQ29udGludWVcbiAgICAgICAgd2hpbGUgKChjaCA9IHBlZWsoKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKChjaCA9IHBlZWsoKSkgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgY2ggPSByZWFkX2VzY2FwZWRfaWRlbnRpZmllcl9jaGFyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc19pZGVudGlmaWVyX2NoYXIoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiSW52YWxpZCBlc2NhcGVkIGlkZW50aWZpZXIgY2hhclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaXNfaWRlbnRpZmllcl9jaGFyKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZS5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lX3N0ciA9IG5hbWUuam9pbihcIlwiKTtcbiAgICAgICAgaWYgKFJFU0VSVkVEX1dPUkRTLmhhcyhuYW1lX3N0cikgJiYgZXNjYXBlZCkge1xuICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJFc2NhcGVkIGNoYXJhY3RlcnMgYXJlIG5vdCBhbGxvd2VkIGluIGtleXdvcmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lX3N0cjtcbiAgICB9KTtcblxuICAgIHZhciByZWFkX3JlZ2V4cCA9IHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgdmFyIHByZXZfYmFja3NsYXNoID0gZmFsc2UsIGNoLCBpbl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoKGNoID0gbmV4dCh0cnVlKSkpIGlmIChORVdMSU5FX0NIQVJTLmhhcyhjaCkpIHtcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiVW5leHBlY3RlZCBsaW5lIHRlcm1pbmF0b3JcIik7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldl9iYWNrc2xhc2gpIHtcbiAgICAgICAgICAgIGlmICgvXltcXHUwMDAwLVxcdTAwN0ZdJC8udGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCJcXFxcXCIgKyBjaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB1c2VsZXNzIHNsYXNoIGJlZm9yZSB0aGUgZXNjYXBlLCBidXQgb25seSBmb3IgY2hhcmFjdGVycyB0aGF0IHdvbid0IGJlIGFkZGVkIHRvIHJlZ2V4cCBzeW50YXhcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2X2JhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiW1wiKSB7XG4gICAgICAgICAgICBpbl9jbGFzcyA9IHRydWU7XG4gICAgICAgICAgICBzb3VyY2UgKz0gY2g7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJdXCIgJiYgaW5fY2xhc3MpIHtcbiAgICAgICAgICAgIGluX2NsYXNzID0gZmFsc2U7XG4gICAgICAgICAgICBzb3VyY2UgKz0gY2g7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIgJiYgIWluX2NsYXNzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcHJldl9iYWNrc2xhc2ggPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYWdzID0gcmVhZF9uYW1lKCk7XG4gICAgICAgIHJldHVybiB0b2tlbihcInJlZ2V4cFwiLCBcIi9cIiArIHNvdXJjZSArIFwiL1wiICsgZmxhZ3MpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmVhZF9vcGVyYXRvcihwcmVmaXgpIHtcbiAgICAgICAgZnVuY3Rpb24gZ3JvdyhvcCkge1xuICAgICAgICAgICAgaWYgKCFwZWVrKCkpIHJldHVybiBvcDtcbiAgICAgICAgICAgIHZhciBiaWdnZXIgPSBvcCArIHBlZWsoKTtcbiAgICAgICAgICAgIGlmIChPUEVSQVRPUlMuaGFzKGJpZ2dlcikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3coYmlnZ2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbihcIm9wZXJhdG9yXCIsIGdyb3cocHJlZml4IHx8IG5leHQoKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9zbGFzaCgpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBzd2l0Y2ggKHBlZWsoKSkge1xuICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gc2tpcF9saW5lX2NvbW1lbnQoXCJjb21tZW50MVwiKTtcbiAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNraXBfbXVsdGlsaW5lX2NvbW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUy5yZWdleF9hbGxvd2VkID8gcmVhZF9yZWdleHAoXCJcIikgOiByZWFkX29wZXJhdG9yKFwiL1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZXFfc2lnbigpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBpZiAocGVlaygpID09PSBcIj5cIikge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwiYXJyb3dcIiwgXCI9PlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkX29wZXJhdG9yKFwiPVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9kb3QoKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgaWYgKGlzX2RpZ2l0KHBlZWsoKS5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRfbnVtKFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVlaygpID09PSBcIi5cIikge1xuICAgICAgICAgICAgbmV4dCgpOyAgLy8gQ29uc3VtZSBzZWNvbmQgZG90XG4gICAgICAgICAgICBuZXh0KCk7ICAvLyBDb25zdW1lIHRoaXJkIGRvdFxuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwiZXhwYW5kXCIsIFwiLi4uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuKFwicHVuY1wiLCBcIi5cIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZF93b3JkKCkge1xuICAgICAgICB2YXIgd29yZCA9IHJlYWRfbmFtZSgpO1xuICAgICAgICBpZiAocHJldl93YXNfZG90KSByZXR1cm4gdG9rZW4oXCJuYW1lXCIsIHdvcmQpO1xuICAgICAgICByZXR1cm4gS0VZV09SRFNfQVRPTS5oYXMod29yZCkgPyB0b2tlbihcImF0b21cIiwgd29yZClcbiAgICAgICAgICAgIDogIUtFWVdPUkRTLmhhcyh3b3JkKSA/IHRva2VuKFwibmFtZVwiLCB3b3JkKVxuICAgICAgICAgICAgOiBPUEVSQVRPUlMuaGFzKHdvcmQpID8gdG9rZW4oXCJvcGVyYXRvclwiLCB3b3JkKVxuICAgICAgICAgICAgOiB0b2tlbihcImtleXdvcmRcIiwgd29yZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZF9wcml2YXRlX3dvcmQoKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuKFwicHJpdmF0ZW5hbWVcIiwgcmVhZF9uYW1lKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhfZW9mX2Vycm9yKGVvZl9lcnJvciwgY29udCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udCh4KTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXggPT09IEVYX0VPRikgcGFyc2VfZXJyb3IoZW9mX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHRfdG9rZW4oZm9yY2VfcmVnZXhwKSB7XG4gICAgICAgIGlmIChmb3JjZV9yZWdleHAgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiByZWFkX3JlZ2V4cChmb3JjZV9yZWdleHApO1xuICAgICAgICBpZiAoc2hlYmFuZyAmJiBTLnBvcyA9PSAwICYmIGxvb2tpbmdfYXQoXCIjIVwiKSkge1xuICAgICAgICAgICAgc3RhcnRfdG9rZW4oKTtcbiAgICAgICAgICAgIGZvcndhcmQoMik7XG4gICAgICAgICAgICBza2lwX2xpbmVfY29tbWVudChcImNvbW1lbnQ1XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHNraXBfd2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgc3RhcnRfdG9rZW4oKTtcbiAgICAgICAgICAgIGlmIChodG1sNV9jb21tZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChsb29raW5nX2F0KFwiPCEtLVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkKDQpO1xuICAgICAgICAgICAgICAgICAgICBza2lwX2xpbmVfY29tbWVudChcImNvbW1lbnQzXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tpbmdfYXQoXCItLT5cIikgJiYgUy5uZXdsaW5lX2JlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkKDMpO1xuICAgICAgICAgICAgICAgICAgICBza2lwX2xpbmVfY29tbWVudChcImNvbW1lbnQ0XCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2ggPSBwZWVrKCk7XG4gICAgICAgICAgICBpZiAoIWNoKSByZXR1cm4gdG9rZW4oXCJlb2ZcIik7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAzNDogY2FzZSAzOTogcmV0dXJuIHJlYWRfc3RyaW5nKCk7XG4gICAgICAgICAgICAgIGNhc2UgNDY6IHJldHVybiBoYW5kbGVfZG90KCk7XG4gICAgICAgICAgICAgIGNhc2UgNDc6IHtcbiAgICAgICAgICAgICAgICAgIHZhciB0b2sgPSBoYW5kbGVfc2xhc2goKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0b2sgPT09IG5leHRfdG9rZW4pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDYxOiByZXR1cm4gaGFuZGxlX2VxX3NpZ24oKTtcbiAgICAgICAgICAgICAgY2FzZSA2Mzoge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc19vcHRpb25fY2hhaW5fb3AoKSkgYnJlYWs7ICAvLyBIYW5kbGVkIGJlbG93XG5cbiAgICAgICAgICAgICAgICAgIG5leHQoKTsgLy8gP1xuICAgICAgICAgICAgICAgICAgbmV4dCgpOyAvLyAuXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbihcInB1bmNcIiwgXCI/LlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDk2OiByZXR1cm4gcmVhZF90ZW1wbGF0ZV9jaGFyYWN0ZXJzKHRydWUpO1xuICAgICAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgICAgICBTLmJyYWNlX2NvdW50ZXIrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgICAgICAgUy5icmFjZV9jb3VudGVyLS07XG4gICAgICAgICAgICAgICAgaWYgKFMudGVtcGxhdGVfYnJhY2VzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgJiYgUy50ZW1wbGF0ZV9icmFjZXNbUy50ZW1wbGF0ZV9icmFjZXMubGVuZ3RoIC0gMV0gPT09IFMuYnJhY2VfY291bnRlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRfdGVtcGxhdGVfY2hhcmFjdGVycyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNfZGlnaXQoY29kZSkpIHJldHVybiByZWFkX251bSgpO1xuICAgICAgICAgICAgaWYgKFBVTkNfQ0hBUlMuaGFzKGNoKSkgcmV0dXJuIHRva2VuKFwicHVuY1wiLCBuZXh0KCkpO1xuICAgICAgICAgICAgaWYgKE9QRVJBVE9SX0NIQVJTLmhhcyhjaCkpIHJldHVybiByZWFkX29wZXJhdG9yKCk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PSA5MiB8fCBpc19pZGVudGlmaWVyX3N0YXJ0KGNoKSkgcmV0dXJuIHJlYWRfd29yZCgpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT0gMzUpIHJldHVybiByZWFkX3ByaXZhdGVfd29yZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VfZXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICBuZXh0X3Rva2VuLm5leHQgPSBuZXh0O1xuICAgIG5leHRfdG9rZW4ucGVlayA9IHBlZWs7XG5cbiAgICBuZXh0X3Rva2VuLmNvbnRleHQgPSBmdW5jdGlvbihuYykge1xuICAgICAgICBpZiAobmMpIFMgPSBuYztcbiAgICAgICAgcmV0dXJuIFM7XG4gICAgfTtcblxuICAgIG5leHRfdG9rZW4uYWRkX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKGRpcmVjdGl2ZSkge1xuICAgICAgICBTLmRpcmVjdGl2ZV9zdGFja1tTLmRpcmVjdGl2ZV9zdGFjay5sZW5ndGggLSAxXS5wdXNoKGRpcmVjdGl2ZSk7XG5cbiAgICAgICAgaWYgKFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVdID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVdKys7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbmV4dF90b2tlbi5wdXNoX2RpcmVjdGl2ZXNfc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgUy5kaXJlY3RpdmVfc3RhY2sucHVzaChbXSk7XG4gICAgfTtcblxuICAgIG5leHRfdG9rZW4ucG9wX2RpcmVjdGl2ZXNfc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBTLmRpcmVjdGl2ZV9zdGFja1tTLmRpcmVjdGl2ZV9zdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVzW2ldXS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgUy5kaXJlY3RpdmVfc3RhY2sucG9wKCk7XG4gICAgfTtcblxuICAgIG5leHRfdG9rZW4uaGFzX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKGRpcmVjdGl2ZSkge1xuICAgICAgICByZXR1cm4gUy5kaXJlY3RpdmVzW2RpcmVjdGl2ZV0gPiAwO1xuICAgIH07XG5cbiAgICBuZXh0X3Rva2VuLnBlZWtfbmV4dF90b2tlbl9zdGFydF9vcl9uZXdsaW5lID0gcGVla19uZXh0X3Rva2VuX3N0YXJ0X29yX25ld2xpbmU7XG4gICAgbmV4dF90b2tlbi5jaF9zdGFydHNfYmluZGluZ19pZGVudGlmaWVyID0gY2hfc3RhcnRzX2JpbmRpbmdfaWRlbnRpZmllcjtcblxuICAgIHJldHVybiBuZXh0X3Rva2VuO1xuXG59XG5cbi8qIC0tLS0tWyBQYXJzZXIgKGNvbnN0YW50cykgXS0tLS0tICovXG5cbnZhciBVTkFSWV9QUkVGSVggPSBtYWtlUHJlZGljYXRlKFtcbiAgICBcInR5cGVvZlwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwiZGVsZXRlXCIsXG4gICAgXCItLVwiLFxuICAgIFwiKytcIixcbiAgICBcIiFcIixcbiAgICBcIn5cIixcbiAgICBcIi1cIixcbiAgICBcIitcIlxuXSk7XG5cbnZhciBVTkFSWV9QT1NURklYID0gbWFrZVByZWRpY2F0ZShbIFwiLS1cIiwgXCIrK1wiIF0pO1xuXG52YXIgQVNTSUdOTUVOVCA9IG1ha2VQcmVkaWNhdGUoWyBcIj1cIiwgXCIrPVwiLCBcIi09XCIsIFwiPz89XCIsIFwiJiY9XCIsIFwifHw9XCIsIFwiLz1cIiwgXCIqPVwiLCBcIioqPVwiLCBcIiU9XCIsIFwiPj49XCIsIFwiPDw9XCIsIFwiPj4+PVwiLCBcInw9XCIsIFwiXj1cIiwgXCImPVwiIF0pO1xuXG52YXIgTE9HSUNBTF9BU1NJR05NRU5UID0gbWFrZVByZWRpY2F0ZShbIFwiPz89XCIsIFwiJiY9XCIsIFwifHw9XCIgXSk7XG5cbnZhciBQUkVDRURFTkNFID0gKGZ1bmN0aW9uKGEsIHJldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIGFbaV0pIHtcbiAgICAgICAgICAgIHJldFtvcF0gPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufSkoXG4gICAgW1xuICAgICAgICBbXCJ8fFwiXSxcbiAgICAgICAgW1wiPz9cIl0sXG4gICAgICAgIFtcIiYmXCJdLFxuICAgICAgICBbXCJ8XCJdLFxuICAgICAgICBbXCJeXCJdLFxuICAgICAgICBbXCImXCJdLFxuICAgICAgICBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdLFxuICAgICAgICBbXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIl0sXG4gICAgICAgIFtcIj4+XCIsIFwiPDxcIiwgXCI+Pj5cIl0sXG4gICAgICAgIFtcIitcIiwgXCItXCJdLFxuICAgICAgICBbXCIqXCIsIFwiL1wiLCBcIiVcIl0sXG4gICAgICAgIFtcIioqXCJdXG4gICAgXSxcbiAgICB7fVxuKTtcblxudmFyIEFUT01JQ19TVEFSVF9UT0tFTiA9IG1ha2VQcmVkaWNhdGUoWyBcImF0b21cIiwgXCJudW1cIiwgXCJiaWdfaW50XCIsIFwic3RyaW5nXCIsIFwicmVnZXhwXCIsIFwibmFtZVwiXSk7XG5cbi8qIC0tLS0tWyBQYXJzZXIgXS0tLS0tICovXG5cbmZ1bmN0aW9uIHBhcnNlKCRURVhULCBvcHRpb25zKSB7XG4gICAgLy8gbWFwcyBzdGFydCB0b2tlbnMgdG8gY291bnQgb2YgY29tbWVudHMgZm91bmQgb3V0c2lkZSBvZiB0aGVpciBwYXJlbnNcbiAgICAvLyBFeGFtcGxlOiAvKiBJIGNvdW50ICovICggLyogSSBkb24ndCAqLyBmb28oKSApXG4gICAgLy8gVXNlZnVsIGJlY2F1c2UgY29tbWVudHNfYmVmb3JlIHByb3BlcnR5IG9mIGNhbGwgd2l0aCBwYXJlbnMgb3V0c2lkZVxuICAgIC8vIGNvbnRhaW5zIGJvdGggY29tbWVudHMgaW5zaWRlIGFuZCBvdXRzaWRlIHRoZXNlIHBhcmVucy4gVXNlZCB0byBmaW5kIHRoZVxuICAgIFxuICAgIGNvbnN0IG91dGVyX2NvbW1lbnRzX2JlZm9yZV9jb3VudHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgYmFyZV9yZXR1cm5zICAgOiBmYWxzZSxcbiAgICAgICAgZWNtYSAgICAgICAgICAgOiBudWxsLCAgLy8gTGVnYWN5XG4gICAgICAgIGV4cHJlc3Npb24gICAgIDogZmFsc2UsXG4gICAgICAgIGZpbGVuYW1lICAgICAgIDogbnVsbCxcbiAgICAgICAgaHRtbDVfY29tbWVudHMgOiB0cnVlLFxuICAgICAgICBtb2R1bGUgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBzaGViYW5nICAgICAgICA6IHRydWUsXG4gICAgICAgIHN0cmljdCAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHRvcGxldmVsICAgICAgIDogbnVsbCxcbiAgICB9LCB0cnVlKTtcblxuICAgIHZhciBTID0ge1xuICAgICAgICBpbnB1dCAgICAgICAgIDogKHR5cGVvZiAkVEVYVCA9PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyB0b2tlbml6ZXIoJFRFWFQsIG9wdGlvbnMuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5odG1sNV9jb21tZW50cywgb3B0aW9ucy5zaGViYW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgIDogJFRFWFQpLFxuICAgICAgICB0b2tlbiAgICAgICAgIDogbnVsbCxcbiAgICAgICAgcHJldiAgICAgICAgICA6IG51bGwsXG4gICAgICAgIHBlZWtlZCAgICAgICAgOiBudWxsLFxuICAgICAgICBpbl9mdW5jdGlvbiAgIDogMCxcbiAgICAgICAgaW5fYXN5bmMgICAgICA6IC0xLFxuICAgICAgICBpbl9nZW5lcmF0b3IgIDogLTEsXG4gICAgICAgIGluX2RpcmVjdGl2ZXMgOiB0cnVlLFxuICAgICAgICBpbl9sb29wICAgICAgIDogMCxcbiAgICAgICAgbGFiZWxzICAgICAgICA6IFtdXG4gICAgfTtcblxuICAgIFMudG9rZW4gPSBuZXh0KCk7XG5cbiAgICBmdW5jdGlvbiBpcyh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNfdG9rZW4oUy50b2tlbiwgdHlwZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZWsoKSB7IHJldHVybiBTLnBlZWtlZCB8fCAoUy5wZWVrZWQgPSBTLmlucHV0KCkpOyB9XG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBTLnByZXYgPSBTLnRva2VuO1xuXG4gICAgICAgIGlmICghUy5wZWVrZWQpIHBlZWsoKTtcbiAgICAgICAgUy50b2tlbiA9IFMucGVla2VkO1xuICAgICAgICBTLnBlZWtlZCA9IG51bGw7XG4gICAgICAgIFMuaW5fZGlyZWN0aXZlcyA9IFMuaW5fZGlyZWN0aXZlcyAmJiAoXG4gICAgICAgICAgICBTLnRva2VuLnR5cGUgPT0gXCJzdHJpbmdcIiB8fCBpcyhcInB1bmNcIiwgXCI7XCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBTLnRva2VuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIHJldHVybiBTLnByZXY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JvYWsobXNnLCBsaW5lLCBjb2wsIHBvcykge1xuICAgICAgICB2YXIgY3R4ID0gUy5pbnB1dC5jb250ZXh0KCk7XG4gICAgICAgIGpzX2Vycm9yKG1zZyxcbiAgICAgICAgICAgICAgICAgY3R4LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICBsaW5lICE9IG51bGwgPyBsaW5lIDogY3R4LnRva2xpbmUsXG4gICAgICAgICAgICAgICAgIGNvbCAhPSBudWxsID8gY29sIDogY3R4LnRva2NvbCxcbiAgICAgICAgICAgICAgICAgcG9zICE9IG51bGwgPyBwb3MgOiBjdHgudG9rcG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbl9lcnJvcih0b2tlbiwgbXNnKSB7XG4gICAgICAgIGNyb2FrKG1zZywgdG9rZW4ubGluZSwgdG9rZW4uY29sKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmV4cGVjdGVkKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PSBudWxsKVxuICAgICAgICAgICAgdG9rZW4gPSBTLnRva2VuO1xuICAgICAgICB0b2tlbl9lcnJvcih0b2tlbiwgXCJVbmV4cGVjdGVkIHRva2VuOiBcIiArIHRva2VuLnR5cGUgKyBcIiAoXCIgKyB0b2tlbi52YWx1ZSArIFwiKVwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBlY3RfdG9rZW4odHlwZSwgdmFsKSB7XG4gICAgICAgIGlmIChpcyh0eXBlLCB2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuX2Vycm9yKFMudG9rZW4sIFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIFMudG9rZW4udHlwZSArIFwiIMKrXCIgKyBTLnRva2VuLnZhbHVlICsgXCLCu1wiICsgXCIsIGV4cGVjdGVkIFwiICsgdHlwZSArIFwiIMKrXCIgKyB2YWwgKyBcIsK7XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGVjdChwdW5jKSB7IHJldHVybiBleHBlY3RfdG9rZW4oXCJwdW5jXCIsIHB1bmMpOyB9XG5cbiAgICBmdW5jdGlvbiBoYXNfbmV3bGluZV9iZWZvcmUodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLm5sYiB8fCAhdG9rZW4uY29tbWVudHNfYmVmb3JlLmV2ZXJ5KChjb21tZW50KSA9PiAhY29tbWVudC5ubGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbl9pbnNlcnRfc2VtaWNvbG9uKCkge1xuICAgICAgICByZXR1cm4gIW9wdGlvbnMuc3RyaWN0XG4gICAgICAgICAgICAmJiAoaXMoXCJlb2ZcIikgfHwgaXMoXCJwdW5jXCIsIFwifVwiKSB8fCBoYXNfbmV3bGluZV9iZWZvcmUoUy50b2tlbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2luX2dlbmVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIFMuaW5fZ2VuZXJhdG9yID09PSBTLmluX2Z1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2luX2FzeW5jKCkge1xuICAgICAgICByZXR1cm4gUy5pbl9hc3luYyA9PT0gUy5pbl9mdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5fYXdhaXQoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBTLmluX2FzeW5jID09PSBTLmluX2Z1bmN0aW9uXG4gICAgICAgICAgICB8fCBTLmluX2Z1bmN0aW9uID09PSAwICYmIFMuaW5wdXQuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZW1pY29sb24ob3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIjtcIikpIG5leHQoKTtcbiAgICAgICAgZWxzZSBpZiAoIW9wdGlvbmFsICYmICFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB1bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyZW50aGVzaXNlZCgpIHtcbiAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgdmFyIGV4cCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1iZWRfdG9rZW5zKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2VtYmVkX3Rva2Vuc193cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSBwYXJzZXIoLi4uYXJncyk7XG4gICAgICAgICAgICBleHByLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBleHByLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9yZWdleHAoKSB7XG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiL1wiKSB8fCBpcyhcIm9wZXJhdG9yXCIsIFwiLz1cIikpIHtcbiAgICAgICAgICAgIFMucGVla2VkID0gbnVsbDtcbiAgICAgICAgICAgIFMudG9rZW4gPSBTLmlucHV0KFMudG9rZW4udmFsdWUuc3Vic3RyKDEpKTsgLy8gZm9yY2UgcmVnZXhwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RhdGVtZW50ID0gZW1iZWRfdG9rZW5zKGZ1bmN0aW9uIHN0YXRlbWVudChpc19leHBvcnRfZGVmYXVsdCwgaXNfZm9yX2JvZHksIGlzX2lmX2JvZHkpIHtcbiAgICAgICAgaGFuZGxlX3JlZ2V4cCgpO1xuICAgICAgICBzd2l0Y2ggKFMudG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGlmIChTLmluX2RpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBwZWVrKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFMQVRFU1RfUkFXLmluY2x1ZGVzKFwiXFxcXFwiKVxuICAgICAgICAgICAgICAgICAgICAmJiAoaXNfdG9rZW4odG9rZW4sIFwicHVuY1wiLCBcIjtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGlzX3Rva2VuKHRva2VuLCBcInB1bmNcIiwgXCJ9XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBoYXNfbmV3bGluZV9iZWZvcmUodG9rZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBpc190b2tlbih0b2tlbiwgXCJlb2ZcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIFMuaW5wdXQuYWRkX2RpcmVjdGl2ZShTLnRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlyID0gUy5pbl9kaXJlY3RpdmVzLCBzdGF0ID0gc2ltcGxlX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIGRpciAmJiBzdGF0LmJvZHkgaW5zdGFuY2VvZiBBU1RfU3RyaW5nID8gbmV3IEFTVF9EaXJlY3RpdmUoc3RhdC5ib2R5KSA6IHN0YXQ7XG4gICAgICAgICAgY2FzZSBcInRlbXBsYXRlX2hlYWRcIjpcbiAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgY2FzZSBcImJpZ19pbnRcIjpcbiAgICAgICAgICBjYXNlIFwicmVnZXhwXCI6XG4gICAgICAgICAgY2FzZSBcIm9wZXJhdG9yXCI6XG4gICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgIHJldHVybiBzaW1wbGVfc3RhdGVtZW50KCk7XG5cbiAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgaWYgKFMudG9rZW4udmFsdWUgPT0gXCJhc3luY1wiICYmIGlzX3Rva2VuKHBlZWsoKSwgXCJrZXl3b3JkXCIsIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc19mb3JfYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBjcm9hayhcImZ1bmN0aW9ucyBhcmUgbm90IGFsbG93ZWQgYXMgdGhlIGJvZHkgb2YgYSBsb29wXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25fKEFTVF9EZWZ1biwgZmFsc2UsIHRydWUsIGlzX2V4cG9ydF9kZWZhdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChTLnRva2VuLnZhbHVlID09IFwiaW1wb3J0XCIgJiYgIWlzX3Rva2VuKHBlZWsoKSwgXCJwdW5jXCIsIFwiKFwiKSAmJiAhaXNfdG9rZW4ocGVlaygpLCBcInB1bmNcIiwgXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gaW1wb3J0X3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFMudG9rZW4udmFsdWUgPT0gXCJ1c2luZ1wiICYmIGlzX3Rva2VuKHBlZWsoKSwgXCJuYW1lXCIpICYmICFoYXNfbmV3bGluZV9iZWZvcmUocGVlaygpKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHVzaW5nXygpO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFMudG9rZW4udmFsdWUgPT0gXCJhd2FpdFwiICYmIGNhbl9hd2FpdCgpICYmIGlzX3Rva2VuKHBlZWsoKSwgXCJuYW1lXCIsIFwidXNpbmdcIikgJiYgIWhhc19uZXdsaW5lX2JlZm9yZShwZWVrKCkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRfbmV4dCA9IFMuaW5wdXQucGVla19uZXh0X3Rva2VuX3N0YXJ0X29yX25ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoUy5pbnB1dC5jaF9zdGFydHNfYmluZGluZ19pZGVudGlmaWVyKG5leHRfbmV4dC5jaGFyLCBuZXh0X25leHQucG9zKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBcInVzaW5nXCIgdG9rZW4gd2lsbCBiZSBjb25zdW1lZCBieSB0aGUgYXdhaXRfdXNpbmdfIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGF3YWl0X3VzaW5nXygpO1xuICAgICAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzX3Rva2VuKHBlZWsoKSwgXCJwdW5jXCIsIFwiOlwiKVxuICAgICAgICAgICAgICAgID8gbGFiZWxlZF9zdGF0ZW1lbnQoKVxuICAgICAgICAgICAgICAgIDogc2ltcGxlX3N0YXRlbWVudCgpO1xuXG4gICAgICAgICAgY2FzZSBcInByaXZhdGVuYW1lXCI6XG4gICAgICAgICAgICBpZighUy5pbl9jbGFzcylcbiAgICAgICAgICAgICAgY3JvYWsoXCJQcml2YXRlIGZpZWxkIG11c3QgYmUgdXNlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3NcIik7XG4gICAgICAgICAgICByZXR1cm4gc2ltcGxlX3N0YXRlbWVudCgpO1xuXG4gICAgICAgICAgY2FzZSBcInB1bmNcIjpcbiAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Jsb2NrU3RhdGVtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgOiBTLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICA6IGJsb2NrXygpLFxuICAgICAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGVfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgICAgICAgUy5pbl9kaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0VtcHR5U3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiYnJlYWtcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrX2NvbnQoQVNUX0JyZWFrKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrX2NvbnQoQVNUX0NvbnRpbnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZGVidWdnZXJcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVidWdnZXIoKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZG9cIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBpbl9sb29wKHN0YXRlbWVudCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0X3Rva2VuKFwia2V5d29yZFwiLCBcIndoaWxlXCIpO1xuICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSBwYXJlbnRoZXNpc2VkKCk7XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0RvKHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgIDogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uIDogY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIndoaWxlXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1doaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uIDogcGFyZW50aGVzaXNlZCgpLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgOiBpbl9sb29wKGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhdGVtZW50KGZhbHNlLCB0cnVlKTsgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZm9yXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JfKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc19mb3JfYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBjcm9hayhcImNsYXNzZXMgYXJlIG5vdCBhbGxvd2VkIGFzIHRoZSBib2R5IG9mIGEgbG9vcFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzX2lmX2JvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJjbGFzc2VzIGFyZSBub3QgYWxsb3dlZCBhcyB0aGUgYm9keSBvZiBhbiBpZlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzXyhBU1RfRGVmQ2xhc3MsIGlzX2V4cG9ydF9kZWZhdWx0KTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzX2Zvcl9ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiZnVuY3Rpb25zIGFyZSBub3QgYWxsb3dlZCBhcyB0aGUgYm9keSBvZiBhIGxvb3BcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbl8oQVNUX0RlZnVuLCBmYWxzZSwgZmFsc2UsIGlzX2V4cG9ydF9kZWZhdWx0KTtcblxuICAgICAgICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmXygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgICAgICAgICAgICBpZiAoUy5pbl9mdW5jdGlvbiA9PSAwICYmICFvcHRpb25zLmJhcmVfcmV0dXJucylcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCI7XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1JldHVybih7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJzd2l0Y2hcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfU3dpdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IHBhcmVudGhlc2lzZWQoKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgICA6IGluX2xvb3Aoc3dpdGNoX2JvZHlfKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ0aHJvd1wiOlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzX25ld2xpbmVfYmVmb3JlKFMudG9rZW4pKVxuICAgICAgICAgICAgICAgICAgICBjcm9hayhcIklsbGVnYWwgbmV3bGluZSBhZnRlciAndGhyb3cnXCIpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVGhyb3coe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwidHJ5XCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnlfKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInZhclwiOlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHZhcl8oKTtcbiAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcblxuICAgICAgICAgICAgICBjYXNlIFwibGV0XCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbGV0XygpO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJjb25zdFwiOlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNvbnN0XygpO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ3aXRoXCI6XG4gICAgICAgICAgICAgICAgaWYgKFMuaW5wdXQuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJTdHJpY3QgbW9kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1dpdGgoe1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogcGFyZW50aGVzaXNlZCgpLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgIDogc3RhdGVtZW50KClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZXhwb3J0XCI6XG4gICAgICAgICAgICAgICAgaWYgKCFpc190b2tlbihwZWVrKCksIFwicHVuY1wiLCBcIihcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGV4cG9ydF9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIjtcIikpIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbGFiZWxlZF9zdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGFzX3N5bWJvbChBU1RfTGFiZWwpO1xuICAgICAgICBpZiAobGFiZWwubmFtZSA9PT0gXCJhd2FpdFwiICYmIGlzX2luX2FzeW5jKCkpIHtcbiAgICAgICAgICAgIHRva2VuX2Vycm9yKFMucHJldiwgXCJhd2FpdCBjYW5ub3QgYmUgdXNlZCBhcyBsYWJlbCBpbnNpZGUgYXN5bmMgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFMubGFiZWxzLnNvbWUoKGwpID0+IGwubmFtZSA9PT0gbGFiZWwubmFtZSkpIHtcbiAgICAgICAgICAgIC8vIEVDTUEtMjYyLCAxMi4xMjogQW4gRUNNQVNjcmlwdCBwcm9ncmFtIGlzIGNvbnNpZGVyZWRcbiAgICAgICAgICAgIC8vIHN5bnRhY3RpY2FsbHkgaW5jb3JyZWN0IGlmIGl0IGNvbnRhaW5zIGFcbiAgICAgICAgICAgIC8vIExhYmVsbGVkU3RhdGVtZW50IHRoYXQgaXMgZW5jbG9zZWQgYnkgYVxuICAgICAgICAgICAgLy8gTGFiZWxsZWRTdGF0ZW1lbnQgd2l0aCB0aGUgc2FtZSBJZGVudGlmaWVyIGFzIGxhYmVsLlxuICAgICAgICAgICAgY3JvYWsoXCJMYWJlbCBcIiArIGxhYmVsLm5hbWUgKyBcIiBkZWZpbmVkIHR3aWNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgIFMubGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudCgpO1xuICAgICAgICBTLmxhYmVscy5wb3AoKTtcbiAgICAgICAgaWYgKCEoc3RhdCBpbnN0YW5jZW9mIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgYGNvbnRpbnVlYCB0aGF0IHJlZmVycyB0byB0aGlzIGxhYmVsLlxuICAgICAgICAgICAgLy8gdGhvc2Ugc2hvdWxkIGJlIHJlcG9ydGVkIGFzIHN5bnRheCBlcnJvcnMuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvMjg3XG4gICAgICAgICAgICBsYWJlbC5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIEFTVF9Db250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWYgPSByZWYubGFiZWwuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiQ29udGludWUgbGFiZWwgYFwiICsgbGFiZWwubmFtZSArIFwiYCByZWZlcnMgdG8gbm9uLUl0ZXJhdGlvblN0YXRlbWVudC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmxpbmUsIHJlZi5jb2wsIHJlZi5wb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0xhYmVsZWRTdGF0ZW1lbnQoeyBib2R5OiBzdGF0LCBsYWJlbDogbGFiZWwgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2ltcGxlX3N0YXRlbWVudCh0bXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfU2ltcGxlU3RhdGVtZW50KHsgYm9keTogKHRtcCA9IGV4cHJlc3Npb24odHJ1ZSksIHNlbWljb2xvbigpLCB0bXApIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJyZWFrX2NvbnQodHlwZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBsZGVmO1xuICAgICAgICBpZiAoIWNhbl9pbnNlcnRfc2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgIGxhYmVsID0gYXNfc3ltYm9sKEFTVF9MYWJlbFJlZiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxkZWYgPSBTLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IGxhYmVsLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCFsZGVmKVxuICAgICAgICAgICAgICAgIGNyb2FrKFwiVW5kZWZpbmVkIGxhYmVsIFwiICsgbGFiZWwubmFtZSk7XG4gICAgICAgICAgICBsYWJlbC50aGVkZWYgPSBsZGVmO1xuICAgICAgICB9IGVsc2UgaWYgKFMuaW5fbG9vcCA9PSAwKVxuICAgICAgICAgICAgY3JvYWsodHlwZS5UWVBFICsgXCIgbm90IGluc2lkZSBhIGxvb3Agb3Igc3dpdGNoXCIpO1xuICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgdmFyIHN0YXQgPSBuZXcgdHlwZSh7IGxhYmVsOiBsYWJlbCB9KTtcbiAgICAgICAgaWYgKGxkZWYpIGxkZWYucmVmZXJlbmNlcy5wdXNoKHN0YXQpO1xuICAgICAgICByZXR1cm4gc3RhdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JfKCkge1xuICAgICAgICB2YXIgZm9yX2F3YWl0X2Vycm9yID0gXCJgZm9yIGF3YWl0YCBpbnZhbGlkIGluIHRoaXMgY29udGV4dFwiO1xuICAgICAgICB2YXIgYXdhaXRfdG9rID0gUy50b2tlbjtcbiAgICAgICAgaWYgKGF3YWl0X3Rvay50eXBlID09IFwibmFtZVwiICYmIGF3YWl0X3Rvay52YWx1ZSA9PSBcImF3YWl0XCIpIHtcbiAgICAgICAgICAgIGlmICghY2FuX2F3YWl0KCkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihhd2FpdF90b2ssIGZvcl9hd2FpdF9lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdF90b2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICB2YXIgaW5pdCA9IG51bGw7XG4gICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiO1wiKSkge1xuICAgICAgICAgICAgaW5pdCA9XG4gICAgICAgICAgICAgICAgaXMoXCJrZXl3b3JkXCIsIFwidmFyXCIpID8gKG5leHQoKSwgdmFyXyh0cnVlKSkgOlxuICAgICAgICAgICAgICAgIGlzKFwia2V5d29yZFwiLCBcImxldFwiKSA/IChuZXh0KCksIGxldF8odHJ1ZSkpIDpcbiAgICAgICAgICAgICAgICBpcyhcImtleXdvcmRcIiwgXCJjb25zdFwiKSA/IChuZXh0KCksIGNvbnN0Xyh0cnVlKSkgOlxuICAgICAgICAgICAgICAgIGlzKFwibmFtZVwiLCBcInVzaW5nXCIpICYmIGlzX3Rva2VuKHBlZWsoKSwgXCJuYW1lXCIpICYmIChwZWVrKCkudmFsdWUgIT0gXCJvZlwiIHx8IFMuaW5wdXQucGVla19uZXh0X3Rva2VuX3N0YXJ0X29yX25ld2xpbmUoKS5jaGFyID09IFwiPVwiKSA/IChuZXh0KCksIHVzaW5nXyh0cnVlKSkgOlxuICAgICAgICAgICAgICAgIGlzKFwibmFtZVwiLCBcImF3YWl0XCIpICYmIGNhbl9hd2FpdCgpICYmIGlzX3Rva2VuKHBlZWsoKSwgXCJuYW1lXCIsIFwidXNpbmdcIikgPyAobmV4dCgpLCBhd2FpdF91c2luZ18odHJ1ZSkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24odHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgaXNfaW4gPSBpcyhcIm9wZXJhdG9yXCIsIFwiaW5cIik7XG4gICAgICAgICAgICB2YXIgaXNfb2YgPSBpcyhcIm5hbWVcIiwgXCJvZlwiKTtcbiAgICAgICAgICAgIGlmIChhd2FpdF90b2sgJiYgIWlzX29mKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IoYXdhaXRfdG9rLCBmb3JfYXdhaXRfZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzX2luIHx8IGlzX29mKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnNMaWtlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0LmRlZmluaXRpb25zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihpbml0LnN0YXJ0LCBcIk9ubHkgb25lIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGFsbG93ZWQgaW4gZm9yLi5pbiBsb29wXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfaW4gJiYgaW5pdCBpbnN0YW5jZW9mIEFTVF9Vc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IoaW5pdC5zdGFydCwgXCJJbnZhbGlkIHVzaW5nIGRlY2xhcmF0aW9uIGluIGZvci4uaW4gbG9vcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIShpc19hc3NpZ25hYmxlKGluaXQpIHx8IChpbml0ID0gdG9fZGVzdHJ1Y3R1cmluZyhpbml0KSkgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IoaW5pdC5zdGFydCwgXCJJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci4uaW4gbG9vcFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc19pbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9yX2luKGluaXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3Jfb2YoaW5pdCwgISFhd2FpdF90b2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhd2FpdF90b2spIHtcbiAgICAgICAgICAgIHRva2VuX2Vycm9yKGF3YWl0X3RvaywgZm9yX2F3YWl0X2Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVndWxhcl9mb3IoaW5pdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVndWxhcl9mb3IoaW5pdCkge1xuICAgICAgICBleHBlY3QoXCI7XCIpO1xuICAgICAgICB2YXIgdGVzdCA9IGlzKFwicHVuY1wiLCBcIjtcIikgPyBudWxsIDogZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgZXhwZWN0KFwiO1wiKTtcbiAgICAgICAgdmFyIHN0ZXAgPSBpcyhcInB1bmNcIiwgXCIpXCIpID8gbnVsbCA6IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0Zvcih7XG4gICAgICAgICAgICBpbml0ICAgICAgOiBpbml0LFxuICAgICAgICAgICAgY29uZGl0aW9uIDogdGVzdCxcbiAgICAgICAgICAgIHN0ZXAgICAgICA6IHN0ZXAsXG4gICAgICAgICAgICBib2R5ICAgICAgOiBpbl9sb29wKGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhdGVtZW50KGZhbHNlLCB0cnVlKTsgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9yX29mKGluaXQsIGlzX2F3YWl0KSB7XG4gICAgICAgIHZhciBsaHMgPSBpbml0IGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zTGlrZSA/IGluaXQuZGVmaW5pdGlvbnNbMF0ubmFtZSA6IG51bGw7XG4gICAgICAgIHZhciBvYmogPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Gb3JPZih7XG4gICAgICAgICAgICBhd2FpdCAgOiBpc19hd2FpdCxcbiAgICAgICAgICAgIGluaXQgICA6IGluaXQsXG4gICAgICAgICAgICBuYW1lICAgOiBsaHMsXG4gICAgICAgICAgICBvYmplY3QgOiBvYmosXG4gICAgICAgICAgICBib2R5ICAgOiBpbl9sb29wKGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhdGVtZW50KGZhbHNlLCB0cnVlKTsgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9yX2luKGluaXQpIHtcbiAgICAgICAgdmFyIG9iaiA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0ZvckluKHtcbiAgICAgICAgICAgIGluaXQgICA6IGluaXQsXG4gICAgICAgICAgICBvYmplY3QgOiBvYmosXG4gICAgICAgICAgICBib2R5ICAgOiBpbl9sb29wKGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhdGVtZW50KGZhbHNlLCB0cnVlKTsgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGFycm93X2Z1bmN0aW9uID0gZnVuY3Rpb24oc3RhcnQsIGFyZ25hbWVzLCBpc19hc3luYykge1xuICAgICAgICBpZiAoaGFzX25ld2xpbmVfYmVmb3JlKFMudG9rZW4pKSB7XG4gICAgICAgICAgICBjcm9hayhcIlVuZXhwZWN0ZWQgbmV3bGluZSBiZWZvcmUgYXJyb3cgKD0+KVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdF90b2tlbihcImFycm93XCIsIFwiPT5cIik7XG5cbiAgICAgICAgdmFyIGJvZHkgPSBfZnVuY3Rpb25fYm9keShpcyhcInB1bmNcIiwgXCJ7XCIpLCBmYWxzZSwgaXNfYXN5bmMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgQVNUX0Fycm93KHtcbiAgICAgICAgICAgIHN0YXJ0ICAgIDogc3RhcnQsXG4gICAgICAgICAgICBlbmQgICAgICA6IGJvZHkuZW5kLFxuICAgICAgICAgICAgYXN5bmMgICAgOiBpc19hc3luYyxcbiAgICAgICAgICAgIGFyZ25hbWVzIDogYXJnbmFtZXMsXG4gICAgICAgICAgICBib2R5ICAgICA6IGJvZHlcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBmdW5jdGlvbl8gPSBmdW5jdGlvbihjdG9yLCBpc19nZW5lcmF0b3IsIGlzX2FzeW5jLCBpc19leHBvcnRfZGVmYXVsdCkge1xuICAgICAgICB2YXIgaW5fc3RhdGVtZW50ID0gY3RvciA9PT0gQVNUX0RlZnVuO1xuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIipcIikpIHtcbiAgICAgICAgICAgIGlzX2dlbmVyYXRvciA9IHRydWU7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSA9IGlzKFwibmFtZVwiKSA/IGFzX3N5bWJvbChpbl9zdGF0ZW1lbnQgPyBBU1RfU3ltYm9sRGVmdW4gOiBBU1RfU3ltYm9sTGFtYmRhKSA6IG51bGw7XG4gICAgICAgIGlmIChpbl9zdGF0ZW1lbnQgJiYgIW5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc19leHBvcnRfZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGN0b3IgPSBBU1RfRnVuY3Rpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lICYmIGN0b3IgIT09IEFTVF9BY2Nlc3NvciAmJiAhKG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVjbGFyYXRpb24pKVxuICAgICAgICAgICAgdW5leHBlY3RlZChwcmV2KCkpO1xuXG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIHZhciBib2R5ID0gX2Z1bmN0aW9uX2JvZHkodHJ1ZSwgaXNfZ2VuZXJhdG9yLCBpc19hc3luYywgbmFtZSwgYXJncyk7XG4gICAgICAgIHJldHVybiBuZXcgY3Rvcih7XG4gICAgICAgICAgICBzdGFydCA6IGFyZ3Muc3RhcnQsXG4gICAgICAgICAgICBlbmQgICA6IGJvZHkuZW5kLFxuICAgICAgICAgICAgaXNfZ2VuZXJhdG9yOiBpc19nZW5lcmF0b3IsXG4gICAgICAgICAgICBhc3luYyA6IGlzX2FzeW5jLFxuICAgICAgICAgICAgbmFtZSAgOiBuYW1lLFxuICAgICAgICAgICAgYXJnbmFtZXM6IGFyZ3MsXG4gICAgICAgICAgICBib2R5ICA6IGJvZHlcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNsYXNzIFVzZWRQYXJhbWV0ZXJzVHJhY2tlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGlzX3BhcmFtZXRlciwgc3RyaWN0LCBkdXBsaWNhdGVzX29rID0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaXNfcGFyYW1ldGVyID0gaXNfcGFyYW1ldGVyO1xuICAgICAgICAgICAgdGhpcy5kdXBsaWNhdGVzX29rID0gZHVwbGljYXRlc19vaztcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMuZHVwbGljYXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdF9hc3NpZ25tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNwcmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdHJpY3RfbW9kZSA9ICEhc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGFkZF9wYXJhbWV0ZXIodG9rZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuaGFzKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmR1cGxpY2F0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmR1cGxpY2F0ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrX3N0cmljdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuYWRkKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc19wYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcmd1bWVudHNcIjpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXZhbFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ5aWVsZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RyaWN0X21vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcih0b2tlbiwgXCJVbmV4cGVjdGVkIFwiICsgdG9rZW4udmFsdWUgKyBcIiBpZGVudGlmaWVyIGFzIHBhcmFtZXRlciBpbnNpZGUgc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFU0VSVkVEX1dPUkRTLmhhcyh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFya19kZWZhdWx0X2Fzc2lnbm1lbnQodG9rZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRfYXNzaWdubWVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRfYXNzaWdubWVudCA9IHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hcmtfc3ByZWFkKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcHJlYWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJlYWQgPSB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXJrX3N0cmljdF9tb2RlKCkge1xuICAgICAgICAgICAgdGhpcy5zdHJpY3RfbW9kZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaXNfc3RyaWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdF9hc3NpZ25tZW50ICE9PSBmYWxzZSB8fCB0aGlzLnNwcmVhZCAhPT0gZmFsc2UgfHwgdGhpcy5zdHJpY3RfbW9kZTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja19zdHJpY3QoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19zdHJpY3QoKSAmJiB0aGlzLmR1cGxpY2F0ZSAhPT0gbnVsbCAmJiAhdGhpcy5kdXBsaWNhdGVzX29rKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IodGhpcy5kdXBsaWNhdGUsIFwiUGFyYW1ldGVyIFwiICsgdGhpcy5kdXBsaWNhdGUudmFsdWUgKyBcIiB3YXMgdXNlZCBhbHJlYWR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIHVzZWRfcGFyYW1ldGVycyA9IG5ldyBVc2VkUGFyYW1ldGVyc1RyYWNrZXIodHJ1ZSwgUy5pbnB1dC5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSk7XG5cbiAgICAgICAgZXhwZWN0KFwiKFwiKTtcblxuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIilcIikpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtZXRlcih1c2VkX3BhcmFtZXRlcnMpO1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuXG4gICAgICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIilcIikpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW0gaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyYW1ldGVyKHVzZWRfcGFyYW1ldGVycywgc3ltYm9sX3R5cGUpIHtcbiAgICAgICAgdmFyIHBhcmFtO1xuICAgICAgICB2YXIgZXhwYW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh1c2VkX3BhcmFtZXRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzID0gbmV3IFVzZWRQYXJhbWV0ZXJzVHJhY2tlcih0cnVlLCBTLmlucHV0Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJleHBhbmRcIiwgXCIuLi5cIikpIHtcbiAgICAgICAgICAgIGV4cGFuZCA9IFMudG9rZW47XG4gICAgICAgICAgICB1c2VkX3BhcmFtZXRlcnMubWFya19zcHJlYWQoUy50b2tlbik7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW0gPSBiaW5kaW5nX2VsZW1lbnQodXNlZF9wYXJhbWV0ZXJzLCBzeW1ib2xfdHlwZSk7XG5cbiAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpICYmIGV4cGFuZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVzZWRfcGFyYW1ldGVycy5tYXJrX2RlZmF1bHRfYXNzaWdubWVudChTLnRva2VuKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHBhcmFtID0gbmV3IEFTVF9EZWZhdWx0QXNzaWduKHtcbiAgICAgICAgICAgICAgICBzdGFydDogcGFyYW0uc3RhcnQsXG4gICAgICAgICAgICAgICAgbGVmdDogcGFyYW0sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBleHByZXNzaW9uKGZhbHNlKSxcbiAgICAgICAgICAgICAgICBlbmQ6IFMudG9rZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cGFuZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtID0gbmV3IEFTVF9FeHBhbnNpb24oe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBleHBhbmQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogcGFyYW0sXG4gICAgICAgICAgICAgICAgZW5kOiBleHBhbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVzZWRfcGFyYW1ldGVycy5jaGVja19zdHJpY3QoKTtcblxuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZGluZ19lbGVtZW50KHVzZWRfcGFyYW1ldGVycywgc3ltYm9sX3R5cGUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgICAgIHZhciBpc19leHBhbmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4cGFuZF90b2tlbjtcbiAgICAgICAgdmFyIGZpcnN0X3Rva2VuID0gUy50b2tlbjtcbiAgICAgICAgaWYgKHVzZWRfcGFyYW1ldGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpY3QgPSBTLmlucHV0Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpO1xuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlc19vayA9IHN5bWJvbF90eXBlID09PSBBU1RfU3ltYm9sVmFyO1xuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzID0gbmV3IFVzZWRQYXJhbWV0ZXJzVHJhY2tlcihmYWxzZSwgc3RyaWN0LCBkdXBsaWNhdGVzX29rKTtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2xfdHlwZSA9IHN5bWJvbF90eXBlID09PSB1bmRlZmluZWQgPyBBU1RfU3ltYm9sRnVuYXJnIDogc3ltYm9sX3R5cGU7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJbXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIl1cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpcyhcImV4cGFuZFwiLCBcIi4uLlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpc19leHBhbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRfdG9rZW4gPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICB1c2VkX3BhcmFtZXRlcnMubWFya19zcHJlYWQoUy50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKFMudG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChuZXcgQVNUX0hvbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBTLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogUy50b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIl1cIjogLy8gVHJhaWxpbmcgY29tbWEgYWZ0ZXIgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGJpbmRpbmdfZWxlbWVudCh1c2VkX3BhcmFtZXRlcnMsIHN5bWJvbF90eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhcIm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmFkZF9wYXJhbWV0ZXIoUy50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYXNfc3ltYm9sKHN5bWJvbF90eXBlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJJbnZhbGlkIGZ1bmN0aW9uIHBhcmFtZXRlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpICYmIGlzX2V4cGFuZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLm1hcmtfZGVmYXVsdF9hc3NpZ25tZW50KFMudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdID0gbmV3IEFTVF9EZWZhdWx0QXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGV4cHJlc3Npb24oZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBTLnRva2VuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfZXhwYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiXVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJSZXN0IGVsZW1lbnQgbXVzdCBiZSBsYXN0IGVsZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0gPSBuZXcgQVNUX0V4cGFuc2lvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZXhwYW5kX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGV4cGFuZF90b2tlblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3QoXCJdXCIpO1xuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmNoZWNrX3N0cmljdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVzdHJ1Y3R1cmluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0X3Rva2VuLFxuICAgICAgICAgICAgICAgIG5hbWVzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICBpc19hcnJheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMoXCJwdW5jXCIsIFwie1wiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwiZXhwYW5kXCIsIFwiLi4uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzX2V4cGFuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZF90b2tlbiA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHVzZWRfcGFyYW1ldGVycy5tYXJrX3NwcmVhZChTLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJuYW1lXCIpICYmIChpc190b2tlbihwZWVrKCksIFwicHVuY1wiKSB8fCBpc190b2tlbihwZWVrKCksIFwib3BlcmF0b3JcIikpICYmIFtcIixcIiwgXCJ9XCIsIFwiPVwiXS5pbmNsdWRlcyhwZWVrKCkudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZWRfcGFyYW1ldGVycy5hZGRfcGFyYW1ldGVyKFMudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBwcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFzX3N5bWJvbChzeW1ib2xfdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19leHBhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobmV3IEFTVF9FeHBhbnNpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBleHBhbmRfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB2YWx1ZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5ldyBBU1RfT2JqZWN0S2V5VmFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB2YWx1ZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHZhbHVlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gQWxsb3cgdHJhaWxpbmcgaG9sZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eV90b2tlbiA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IGFzX3Byb3BlcnR5X25hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKHByZXYoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldigpLnR5cGUgPT09IFwibmFtZVwiICYmICFpcyhcInB1bmNcIiwgXCI6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5ldyBBU1RfT2JqZWN0S2V5VmFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJldigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBzeW1ib2xfdHlwZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChuZXcgQVNUX09iamVjdEtleVZhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHByb3BlcnR5X3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlOiBwcm9wZXJ0eV90b2tlbi5xdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBiaW5kaW5nX2VsZW1lbnQodXNlZF9wYXJhbWV0ZXJzLCBzeW1ib2xfdHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfZXhwYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJSZXN0IGVsZW1lbnQgbXVzdCBiZSBsYXN0IGVsZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZWRfcGFyYW1ldGVycy5tYXJrX2RlZmF1bHRfYXNzaWdubWVudChTLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS52YWx1ZSA9IG5ldyBBU1RfRGVmYXVsdEFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0udmFsdWUuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBleHByZXNzaW9uKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogUy50b2tlblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3QoXCJ9XCIpO1xuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmNoZWNrX3N0cmljdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVzdHJ1Y3R1cmluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0X3Rva2VuLFxuICAgICAgICAgICAgICAgIG5hbWVzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICBpc19hcnJheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzKFwibmFtZVwiKSkge1xuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmFkZF9wYXJhbWV0ZXIoUy50b2tlbik7XG4gICAgICAgICAgICByZXR1cm4gYXNfc3ltYm9sKHN5bWJvbF90eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCBmdW5jdGlvbiBwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJhbXNfb3Jfc2VxXyhhbGxvd19hcnJvd3MsIG1heWJlX3NlcXVlbmNlKSB7XG4gICAgICAgIHZhciBzcHJlYWRfdG9rZW47XG4gICAgICAgIHZhciBpbnZhbGlkX3NlcXVlbmNlO1xuICAgICAgICB2YXIgdHJhaWxpbmdfY29tbWE7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgaWYgKHNwcmVhZF90b2tlbikgdW5leHBlY3RlZChzcHJlYWRfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGlzKFwiZXhwYW5kXCIsIFwiLi4uXCIpKSB7XG4gICAgICAgICAgICAgICAgc3ByZWFkX3Rva2VuID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVfc2VxdWVuY2UpIGludmFsaWRfc2VxdWVuY2UgPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBhLnB1c2gobmV3IEFTVF9FeHBhbnNpb24oe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJldigpLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogUy50b2tlbixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGEucHVzaChleHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpcyhcInB1bmNcIiwgXCIpXCIpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ19jb21tYSA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlX3NlcXVlbmNlKSBpbnZhbGlkX3NlcXVlbmNlID0gdHJhaWxpbmdfY29tbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgIGlmIChhbGxvd19hcnJvd3MgJiYgaXMoXCJhcnJvd1wiLCBcIj0+XCIpKSB7XG4gICAgICAgICAgICBpZiAoc3ByZWFkX3Rva2VuICYmIHRyYWlsaW5nX2NvbW1hKSB1bmV4cGVjdGVkKHRyYWlsaW5nX2NvbW1hKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnZhbGlkX3NlcXVlbmNlKSB7XG4gICAgICAgICAgICB1bmV4cGVjdGVkKGludmFsaWRfc2VxdWVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mdW5jdGlvbl9ib2R5KGJsb2NrLCBnZW5lcmF0b3IsIGlzX2FzeW5jLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgIHZhciBsb29wID0gUy5pbl9sb29wO1xuICAgICAgICB2YXIgbGFiZWxzID0gUy5sYWJlbHM7XG4gICAgICAgIHZhciBjdXJyZW50X2dlbmVyYXRvciA9IFMuaW5fZ2VuZXJhdG9yO1xuICAgICAgICB2YXIgY3VycmVudF9hc3luYyA9IFMuaW5fYXN5bmM7XG4gICAgICAgICsrUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgaWYgKGdlbmVyYXRvcilcbiAgICAgICAgICAgIFMuaW5fZ2VuZXJhdG9yID0gUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgaWYgKGlzX2FzeW5jKVxuICAgICAgICAgICAgUy5pbl9hc3luYyA9IFMuaW5fZnVuY3Rpb247XG4gICAgICAgIGlmIChhcmdzKSBwYXJhbWV0ZXJzKGFyZ3MpO1xuICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICBTLmluX2xvb3AgPSAwO1xuICAgICAgICBTLmxhYmVscyA9IFtdO1xuICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgIFMuaW5wdXQucHVzaF9kaXJlY3RpdmVzX3N0YWNrKCk7XG4gICAgICAgICAgICB2YXIgYSA9IGJsb2NrXygpO1xuICAgICAgICAgICAgaWYgKG5hbWUpIF92ZXJpZnlfc3ltYm9sKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGFyZ3MpIGFyZ3MuZm9yRWFjaChfdmVyaWZ5X3N5bWJvbCk7XG4gICAgICAgICAgICBTLmlucHV0LnBvcF9kaXJlY3RpdmVzX3N0YWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYSA9IFtuZXcgQVNUX1JldHVybih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IFMudG9rZW4sXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4cHJlc3Npb24oZmFsc2UpLFxuICAgICAgICAgICAgICAgIGVuZDogUy50b2tlblxuICAgICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICAgIC0tUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgUy5pbl9sb29wID0gbG9vcDtcbiAgICAgICAgUy5sYWJlbHMgPSBsYWJlbHM7XG4gICAgICAgIFMuaW5fZ2VuZXJhdG9yID0gY3VycmVudF9nZW5lcmF0b3I7XG4gICAgICAgIFMuaW5fYXN5bmMgPSBjdXJyZW50X2FzeW5jO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXdhaXRfZXhwcmVzc2lvbigpIHtcbiAgICAgICAgLy8gUHJldmlvdXMgdG9rZW4gbXVzdCBiZSBcImF3YWl0XCIgYW5kIG5vdCBiZSBpbnRlcnByZXRlZCBhcyBhbiBpZGVudGlmaWVyXG4gICAgICAgIGlmICghY2FuX2F3YWl0KCkpIHtcbiAgICAgICAgICAgIGNyb2FrKFwiVW5leHBlY3RlZCBhd2FpdCBleHByZXNzaW9uIG91dHNpZGUgYXN5bmMgZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBTLnByZXYubGluZSwgUy5wcmV2LmNvbCwgUy5wcmV2LnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGF3YWl0IGV4cHJlc3Npb24gaXMgcGFyc2VkIGFzIGEgdW5hcnkgZXhwcmVzc2lvbiBpbiBCYWJlbFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9Bd2FpdCh7XG4gICAgICAgICAgICBzdGFydDogcHJldigpLFxuICAgICAgICAgICAgZW5kOiBTLnRva2VuLFxuICAgICAgICAgICAgZXhwcmVzc2lvbiA6IG1heWJlX3VuYXJ5KHRydWUpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeWllbGRfZXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIHN0YXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc19leHByZXNzaW9uID0gdHJ1ZTtcblxuICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBleHByZXNzaW9uIG9yIHN0YXIgKGFuZCB0aGVuIHRoZSBtYW5kYXRvcnkgZXhwcmVzc2lvbilcbiAgICAgICAgLy8gYmVoaW5kIHlpZWxkIG9uIHRoZSBzYW1lIGxpbmUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIG5vdGhpbmcgZm9sbG93cyBvbiB0aGUgc2FtZSBsaW5lIG9mIHRoZSB5aWVsZEV4cHJlc3Npb24sXG4gICAgICAgIC8vIGl0IHNob3VsZCBkZWZhdWx0IHRvIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBmb3IgeWllbGQgdG8gcmV0dXJuLlxuICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHRoZSBgdW5kZWZpbmVkYCBzdG9yZWQgYXMgYG51bGxgIGluIGFzdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSAxOiBJdCBpc24ndCBhbGxvd2VkIGZvciB5aWVsZCogdG8gY2xvc2Ugd2l0aG91dCBhbiBleHByZXNzaW9uXG4gICAgICAgIC8vIE5vdGUgMjogSWYgdGhlcmUgaXMgYSBubGIgYmV0d2VlbiB5aWVsZCBhbmQgc3RhciwgaXQgaXMgaW50ZXJwcmV0IGFzXG4gICAgICAgIC8vICAgICAgICAgeWllbGQgPGV4cGxpY2l0IHVuZGVmaW5lZD4gPGluc2VydGVkIGF1dG9tYXRpYyBzZW1pY29sb24+ICpcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2FuX2luc2VydF9zZW1pY29sb24oKVxuICAgICAgICAgICAgfHwgaXMoXCJwdW5jXCIpICYmIFBVTkNfQUZURVJfRVhQUkVTU0lPTi5oYXMoUy50b2tlbi52YWx1ZSlcbiAgICAgICAgICAgIHx8IGlzKFwidGVtcGxhdGVfY29udFwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGhhc19leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIipcIikpIHtcbiAgICAgICAgICAgIHN0YXIgPSB0cnVlO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfWWllbGQoe1xuICAgICAgICAgICAgc3RhcnQgICAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgaXNfc3RhciAgICA6IHN0YXIsXG4gICAgICAgICAgICBleHByZXNzaW9uIDogaGFzX2V4cHJlc3Npb24gPyBleHByZXNzaW9uKCkgOiBudWxsLFxuICAgICAgICAgICAgZW5kICAgICAgICA6IHByZXYoKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpZl8oKSB7XG4gICAgICAgIHZhciBjb25kID0gcGFyZW50aGVzaXNlZCgpLCBib2R5ID0gc3RhdGVtZW50KGZhbHNlLCBmYWxzZSwgdHJ1ZSksIGJlbHNlID0gbnVsbDtcbiAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImVsc2VcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGJlbHNlID0gc3RhdGVtZW50KGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfSWYoe1xuICAgICAgICAgICAgY29uZGl0aW9uICAgOiBjb25kLFxuICAgICAgICAgICAgYm9keSAgICAgICAgOiBib2R5LFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmUgOiBiZWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBibG9ja18oKSB7XG4gICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgaWYgKGlzKFwiZW9mXCIpKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICBhLnB1c2goc3RhdGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3dpdGNoX2JvZHlfKCkge1xuICAgICAgICBleHBlY3QoXCJ7XCIpO1xuICAgICAgICB2YXIgYSA9IFtdLCBjdXIgPSBudWxsLCBicmFuY2ggPSBudWxsLCB0bXA7XG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgaWYgKGlzKFwiZW9mXCIpKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiY2FzZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChicmFuY2gpIGJyYW5jaC5lbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICAgICAgY3VyID0gW107XG4gICAgICAgICAgICAgICAgYnJhbmNoID0gbmV3IEFTVF9DYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgICAgICA6ICh0bXAgPSBTLnRva2VuLCBuZXh0KCksIHRtcCksXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBleHByZXNzaW9uKHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgIDogY3VyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYS5wdXNoKGJyYW5jaCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChicmFuY2gpIGJyYW5jaC5lbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICAgICAgY3VyID0gW107XG4gICAgICAgICAgICAgICAgYnJhbmNoID0gbmV3IEFTVF9EZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgOiAodG1wID0gUy50b2tlbiwgbmV4dCgpLCBleHBlY3QoXCI6XCIpLCB0bXApLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICA6IGN1clxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGEucHVzaChicmFuY2gpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cikgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgIGN1ci5wdXNoKHN0YXRlbWVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhbmNoKSBicmFuY2guZW5kID0gcHJldigpO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyeV8oKSB7XG4gICAgICAgIHZhciBib2R5LCBiY2F0Y2ggPSBudWxsLCBiZmluYWxseSA9IG51bGw7XG4gICAgICAgIGJvZHkgPSBuZXcgQVNUX1RyeUJsb2NrKHtcbiAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcbiAgICAgICAgICAgIGJvZHkgIDogYmxvY2tfKCksXG4gICAgICAgICAgICBlbmQgICA6IHByZXYoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJjYXRjaFwiKSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJ7XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcGFyYW1ldGVyKHVuZGVmaW5lZCwgQVNUX1N5bWJvbENhdGNoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmNhdGNoID0gbmV3IEFTVF9DYXRjaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGFyZ25hbWUgOiBuYW1lLFxuICAgICAgICAgICAgICAgIGJvZHkgICAgOiBibG9ja18oKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZmluYWxseVwiKSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGJmaW5hbGx5ID0gbmV3IEFTVF9GaW5hbGx5KHtcbiAgICAgICAgICAgICAgICBzdGFydCA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGJvZHkgIDogYmxvY2tfKCksXG4gICAgICAgICAgICAgICAgZW5kICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmNhdGNoICYmICFiZmluYWxseSlcbiAgICAgICAgICAgIGNyb2FrKFwiTWlzc2luZyBjYXRjaC9maW5hbGx5IGJsb2Nrc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVHJ5KHtcbiAgICAgICAgICAgIGJvZHkgICAgIDogYm9keSxcbiAgICAgICAgICAgIGJjYXRjaCAgIDogYmNhdGNoLFxuICAgICAgICAgICAgYmZpbmFsbHkgOiBiZmluYWxseVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB2YXJcbiAgICAgKiAgIHZhcmRlZjEgPSAyLFxuICAgICAqICAgdmFyZGVmMiA9IDM7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFyZGVmcyhub19pbiwga2luZCkge1xuICAgICAgICB2YXIgdmFyX2RlZnMgPSBbXTtcbiAgICAgICAgdmFyIGRlZjtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgdmFyIHN5bV90eXBlID1cbiAgICAgICAgICAgICAgICBraW5kID09PSBcInZhclwiID8gQVNUX1N5bWJvbFZhciA6XG4gICAgICAgICAgICAgICAga2luZCA9PT0gXCJjb25zdFwiID8gQVNUX1N5bWJvbENvbnN0IDpcbiAgICAgICAgICAgICAgICBraW5kID09PSBcImxldFwiID8gQVNUX1N5bWJvbExldCA6XG4gICAgICAgICAgICAgICAga2luZCA9PT0gXCJ1c2luZ1wiID8gQVNUX1N5bWJvbFVzaW5nIDpcbiAgICAgICAgICAgICAgICBraW5kID09PSBcImF3YWl0IHVzaW5nXCIgPyBBU1RfU3ltYm9sVXNpbmcgOiBudWxsO1xuICAgICAgICAgICAgdmFyIGRlZl90eXBlID0ga2luZCA9PT0gXCJ1c2luZ1wiIHx8IGtpbmQgPT09IFwiYXdhaXQgdXNpbmdcIiA/IEFTVF9Vc2luZ0RlZiA6IEFTVF9WYXJEZWY7XG4gICAgICAgICAgICAvLyB2YXIgeyBhIH0gPSBiXG4gICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwie1wiKSB8fCBpcyhcInB1bmNcIiwgXCJbXCIpKSB7XG4gICAgICAgICAgICAgICAgZGVmID0gbmV3IGRlZl90eXBlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFMudG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGJpbmRpbmdfZWxlbWVudCh1bmRlZmluZWQsIHN5bV90eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpID8gKGV4cGVjdF90b2tlbihcIm9wZXJhdG9yXCIsIFwiPVwiKSwgZXhwcmVzc2lvbihmYWxzZSwgbm9faW4pKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZiA9IG5ldyBkZWZfdHlwZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgbmFtZSAgOiBhc19zeW1ib2woc3ltX3R5cGUpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChuZXh0KCksIGV4cHJlc3Npb24oZmFsc2UsIG5vX2luKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogIW5vX2luICYmIChraW5kID09PSBcImNvbnN0XCIgfHwga2luZCA9PT0gXCJ1c2luZ1wiIHx8IGtpbmQgPT09IFwiYXdhaXQgdXNpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNyb2FrKFwiTWlzc2luZyBpbml0aWFsaXplciBpbiBcIiArIGtpbmQgKyBcIiBkZWNsYXJhdGlvblwiKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5uYW1lLm5hbWUgPT0gXCJpbXBvcnRcIikgY3JvYWsoXCJVbmV4cGVjdGVkIHRva2VuOiBpbXBvcnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXJfZGVmcy5wdXNoKGRlZik7XG4gICAgICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIixcIikpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcl9kZWZzO1xuICAgIH1cblxuICAgIHZhciB2YXJfID0gZnVuY3Rpb24obm9faW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVmFyKHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogcHJldigpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbnMgOiB2YXJkZWZzKG5vX2luLCBcInZhclwiKSxcbiAgICAgICAgICAgIGVuZCAgICAgICAgIDogcHJldigpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgbGV0XyA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0xldCh7XG4gICAgICAgICAgICBzdGFydCAgICAgICA6IHByZXYoKSxcbiAgICAgICAgICAgIGRlZmluaXRpb25zIDogdmFyZGVmcyhub19pbiwgXCJsZXRcIiksXG4gICAgICAgICAgICBlbmQgICAgICAgICA6IHByZXYoKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbnN0XyA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0NvbnN0KHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogcHJldigpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbnMgOiB2YXJkZWZzKG5vX2luLCBcImNvbnN0XCIpLFxuICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciB1c2luZ18gPSBmdW5jdGlvbihub19pbikge1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Vc2luZyh7XG4gICAgICAgICAgICBzdGFydCAgICAgICA6IHByZXYoKSxcbiAgICAgICAgICAgIGF3YWl0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBkZWZpbml0aW9ucyA6IHZhcmRlZnMobm9faW4sIFwidXNpbmdcIiksXG4gICAgICAgICAgICBlbmQgICAgICAgICA6IHByZXYoKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGF3YWl0X3VzaW5nXyA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIC8vIEFzc3VtcHRpb246IFdoZW4gYXdhaXRfdXNpbmdfIGlzIGNhbGxlZCwgb25seSB0aGUgYGF3YWl0YCB0b2tlbiBoYXMgYmVlbiBjb25zdW1lZC5cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVXNpbmcoe1xuICAgICAgICAgICAgc3RhcnQgICAgICAgOiBwcmV2KCksXG4gICAgICAgICAgICBhd2FpdCAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWZpbml0aW9ucyA6IChuZXh0KCksIHZhcmRlZnMobm9faW4sIFwiYXdhaXQgdXNpbmdcIikpLFxuICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBuZXdfID0gZnVuY3Rpb24oYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgZXhwZWN0X3Rva2VuKFwib3BlcmF0b3JcIiwgXCJuZXdcIik7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIuXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBleHBlY3RfdG9rZW4oXCJuYW1lXCIsIFwidGFyZ2V0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9OZXdUYXJnZXQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld2V4cCA9IGV4cHJfYXRvbShmYWxzZSksIGFyZ3M7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIoXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBhcmdzID0gZXhwcl9saXN0KFwiKVwiLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbCA9IG5ldyBBU1RfTmV3KHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgIGV4cHJlc3Npb24gOiBuZXdleHAsXG4gICAgICAgICAgICBhcmdzICAgICAgIDogYXJncyxcbiAgICAgICAgICAgIGVuZCAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSk7XG4gICAgICAgIGFubm90YXRlKGNhbGwpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhjYWxsLCBhbGxvd19jYWxscyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzX2F0b21fbm9kZSgpIHtcbiAgICAgICAgdmFyIHRvayA9IFMudG9rZW4sIHJldDtcbiAgICAgICAgc3dpdGNoICh0b2sudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICByZXQgPSBfbWFrZV9zeW1ib2woQVNUX1N5bWJvbFJlZik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgICByZXQgPSBuZXcgQVNUX051bWJlcih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRvayxcbiAgICAgICAgICAgICAgICBlbmQ6IHRvayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdG9rLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJhdzogTEFURVNUX1JBV1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYmlnX2ludFwiOlxuICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9CaWdJbnQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB0b2ssXG4gICAgICAgICAgICAgICAgZW5kOiB0b2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRvay52YWx1ZSxcbiAgICAgICAgICAgICAgICByYXc6IExBVEVTVF9SQVcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfU3RyaW5nKHtcbiAgICAgICAgICAgICAgICBzdGFydCA6IHRvayxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHRvayxcbiAgICAgICAgICAgICAgICB2YWx1ZSA6IHRvay52YWx1ZSxcbiAgICAgICAgICAgICAgICBxdW90ZSA6IHRvay5xdW90ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbm5vdGF0ZShyZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJlZ2V4cFwiOlxuICAgICAgICAgICAgY29uc3QgW18sIHNvdXJjZSwgZmxhZ3NdID0gdG9rLnZhbHVlLm1hdGNoKC9eXFwvKC4qKVxcLyhcXHcqKSQvKTtcblxuICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9SZWdFeHAoeyBzdGFydDogdG9rLCBlbmQ6IHRvaywgdmFsdWU6IHsgc291cmNlLCBmbGFncyB9IH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgIHN3aXRjaCAodG9rLnZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfRmFsc2UoeyBzdGFydDogdG9rLCBlbmQ6IHRvayB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAgICAgICAgICByZXQgPSBuZXcgQVNUX1RydWUoeyBzdGFydDogdG9rLCBlbmQ6IHRvayB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICByZXQgPSBuZXcgQVNUX051bGwoeyBzdGFydDogdG9rLCBlbmQ6IHRvayB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b19mdW5fYXJncyhleCwgZGVmYXVsdF9zZWVuX2Fib3ZlKSB7XG4gICAgICAgIHZhciBpbnNlcnRfZGVmYXVsdCA9IGZ1bmN0aW9uKGV4LCBkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0RlZmF1bHRBc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogZXguc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGV4LFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9XCIsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGRlZmF1bHRfdmFsdWUuZW5kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXg7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChleCBpbnN0YW5jZW9mIEFTVF9PYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRfZGVmYXVsdChuZXcgQVNUX0Rlc3RydWN0dXJpbmcoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBleC5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGV4LmVuZCxcbiAgICAgICAgICAgICAgICBpc19hcnJheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmFtZXM6IGV4LnByb3BlcnRpZXMubWFwKHByb3AgPT4gdG9fZnVuX2FyZ3MocHJvcCkpXG4gICAgICAgICAgICB9KSwgZGVmYXVsdF9zZWVuX2Fib3ZlKTtcbiAgICAgICAgfSBlbHNlIGlmIChleCBpbnN0YW5jZW9mIEFTVF9PYmplY3RLZXlWYWwpIHtcbiAgICAgICAgICAgIGV4LnZhbHVlID0gdG9fZnVuX2FyZ3MoZXgudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydF9kZWZhdWx0KGV4LCBkZWZhdWx0X3NlZW5fYWJvdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0hvbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBleDtcbiAgICAgICAgfSBlbHNlIGlmIChleCBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nKSB7XG4gICAgICAgICAgICBleC5uYW1lcyA9IGV4Lm5hbWVzLm1hcChuYW1lID0+IHRvX2Z1bl9hcmdzKG5hbWUpKTtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRfZGVmYXVsdChleCwgZGVmYXVsdF9zZWVuX2Fib3ZlKTtcbiAgICAgICAgfSBlbHNlIGlmIChleCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRfZGVmYXVsdChuZXcgQVNUX1N5bWJvbEZ1bmFyZyh7XG4gICAgICAgICAgICAgICAgbmFtZTogZXgubmFtZSxcbiAgICAgICAgICAgICAgICBzdGFydDogZXguc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBleC5lbmRcbiAgICAgICAgICAgIH0pLCBkZWZhdWx0X3NlZW5fYWJvdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikge1xuICAgICAgICAgICAgZXguZXhwcmVzc2lvbiA9IHRvX2Z1bl9hcmdzKGV4LmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydF9kZWZhdWx0KGV4LCBkZWZhdWx0X3NlZW5fYWJvdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0FycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0X2RlZmF1bHQobmV3IEFTVF9EZXN0cnVjdHVyaW5nKHtcbiAgICAgICAgICAgICAgICBzdGFydDogZXguc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBleC5lbmQsXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgbmFtZXM6IGV4LmVsZW1lbnRzLm1hcChlbG0gPT4gdG9fZnVuX2FyZ3MoZWxtKSlcbiAgICAgICAgICAgIH0pLCBkZWZhdWx0X3NlZW5fYWJvdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydF9kZWZhdWx0KHRvX2Z1bl9hcmdzKGV4LmxlZnQsIGV4LnJpZ2h0KSwgZGVmYXVsdF9zZWVuX2Fib3ZlKTtcbiAgICAgICAgfSBlbHNlIGlmIChleCBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0QXNzaWduKSB7XG4gICAgICAgICAgICBleC5sZWZ0ID0gdG9fZnVuX2FyZ3MoZXgubGVmdCk7XG4gICAgICAgICAgICByZXR1cm4gZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcm9hayhcIkludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyXCIsIGV4LnN0YXJ0LmxpbmUsIGV4LnN0YXJ0LmNvbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXhwcl9hdG9tID0gZnVuY3Rpb24oYWxsb3dfY2FsbHMsIGFsbG93X2Fycm93cykge1xuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIm5ld1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld18oYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcIm5hbWVcIiwgXCJpbXBvcnRcIikgJiYgaXNfdG9rZW4ocGVlaygpLCBcInB1bmNcIiwgXCIuXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0X21ldGEoYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIHZhciBwZWVrZWQ7XG4gICAgICAgIHZhciBhc3luYyA9IGlzKFwibmFtZVwiLCBcImFzeW5jXCIpXG4gICAgICAgICAgICAmJiAocGVla2VkID0gcGVlaygpKS52YWx1ZSAhPSBcIltcIlxuICAgICAgICAgICAgJiYgcGVla2VkLnR5cGUgIT0gXCJhcnJvd1wiXG4gICAgICAgICAgICAmJiBhc19hdG9tX25vZGUoKTtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiKSkge1xuICAgICAgICAgICAgc3dpdGNoIChTLnRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgaWYgKGFzeW5jICYmICFhbGxvd19jYWxscykgYnJlYWs7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHJzID0gcGFyYW1zX29yX3NlcV8oYWxsb3dfYXJyb3dzLCAhYXN5bmMpO1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd19hcnJvd3MgJiYgaXMoXCJhcnJvd1wiLCBcIj0+XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJvd19mdW5jdGlvbihzdGFydCwgZXhwcnMubWFwKGUgPT4gdG9fZnVuX2FyZ3MoZSkpLCAhIWFzeW5jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV4ID0gYXN5bmMgPyBuZXcgQVNUX0NhbGwoe1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBhc3luYyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogZXhwcnNcbiAgICAgICAgICAgICAgICB9KSA6IHRvX2V4cHJfb3Jfc2VxdWVuY2Uoc3RhcnQsIGV4cHJzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXguc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0ZXJfY29tbWVudHNfYmVmb3JlID0gc3RhcnQuY29tbWVudHNfYmVmb3JlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJfY29tbWVudHNfYmVmb3JlX2NvdW50cy5zZXQoc3RhcnQsIG91dGVyX2NvbW1lbnRzX2JlZm9yZSk7XG4gICAgICAgICAgICAgICAgICAgIGV4LnN0YXJ0LmNvbW1lbnRzX2JlZm9yZS51bnNoaWZ0KC4uLnN0YXJ0LmNvbW1lbnRzX2JlZm9yZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LmNvbW1lbnRzX2JlZm9yZSA9IGV4LnN0YXJ0LmNvbW1lbnRzX2JlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dGVyX2NvbW1lbnRzX2JlZm9yZSA9PSAwICYmIHN0YXJ0LmNvbW1lbnRzX2JlZm9yZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHN0YXJ0LmNvbW1lbnRzX2JlZm9yZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29tbWVudC5ubGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50Lm5sYiA9IHN0YXJ0Lm5sYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydC5ubGIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydC5jb21tZW50c19hZnRlciA9IGV4LnN0YXJ0LmNvbW1lbnRzX2FmdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4LmVuZCkge1xuICAgICAgICAgICAgICAgICAgICBlbmQuY29tbWVudHNfYmVmb3JlID0gZXguZW5kLmNvbW1lbnRzX2JlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgZXguZW5kLmNvbW1lbnRzX2FmdGVyLnB1c2goLi4uZW5kLmNvbW1lbnRzX2FmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kLmNvbW1lbnRzX2FmdGVyID0gZXguZW5kLmNvbW1lbnRzX2FmdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0NhbGwpIGFubm90YXRlKGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhleCwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGFycmF5XygpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMob2JqZWN0X29yX2Rlc3RydWN0dXJpbmdfKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXN5bmMpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dfYXJyb3dzICYmIGlzKFwibmFtZVwiKSAmJiBpc190b2tlbihwZWVrKCksIFwiYXJyb3dcIikpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IG5ldyBBU1RfU3ltYm9sRnVuYXJnKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBTLnRva2VuLnZhbHVlLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IHN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gYXJyb3dfZnVuY3Rpb24oc3RhcnQsIFtwYXJhbV0sICEhYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbl8oQVNUX0Z1bmN0aW9uLCBmYWxzZSwgISFhc3luYyk7XG4gICAgICAgICAgICBmdW5jLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBmdW5jLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGZ1bmMsIGFsbG93X2NhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN5bmMpIHJldHVybiBzdWJzY3JpcHRzKGFzeW5jLCBhbGxvd19jYWxscyk7XG4gICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJjbGFzc1wiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdmFyIGNscyA9IGNsYXNzXyhBU1RfQ2xhc3NFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGNscy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2xzLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGNscywgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcInRlbXBsYXRlX2hlYWRcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKHRlbXBsYXRlX3N0cmluZygpLCBhbGxvd19jYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFUT01JQ19TVEFSVF9UT0tFTi5oYXMoUy50b2tlbi50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXNfYXRvbV9ub2RlKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRlbXBsYXRlX3N0cmluZygpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gW10sIHN0YXJ0ID0gUy50b2tlbjtcblxuICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBBU1RfVGVtcGxhdGVTZWdtZW50KHtcbiAgICAgICAgICAgIHN0YXJ0OiBTLnRva2VuLFxuICAgICAgICAgICAgcmF3OiBURU1QTEFURV9SQVdTLmdldChTLnRva2VuKSxcbiAgICAgICAgICAgIHZhbHVlOiBTLnRva2VuLnZhbHVlLFxuICAgICAgICAgICAgZW5kOiBTLnRva2VuXG4gICAgICAgIH0pKTtcblxuICAgICAgICB3aGlsZSAoIVMudG9rZW4udGVtcGxhdGVfZW5kKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBoYW5kbGVfcmVnZXhwKCk7XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKGV4cHJlc3Npb24odHJ1ZSkpO1xuXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBBU1RfVGVtcGxhdGVTZWdtZW50KHtcbiAgICAgICAgICAgICAgICBzdGFydDogUy50b2tlbixcbiAgICAgICAgICAgICAgICByYXc6IFRFTVBMQVRFX1JBV1MuZ2V0KFMudG9rZW4pLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBTLnRva2VuLnZhbHVlLFxuICAgICAgICAgICAgICAgIGVuZDogUy50b2tlblxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcblxuICAgICAgICByZXR1cm4gbmV3IEFTVF9UZW1wbGF0ZVN0cmluZyh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgICAgICAgICBlbmQ6IFMudG9rZW5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwcl9saXN0KGNsb3NpbmcsIGFsbG93X3RyYWlsaW5nX2NvbW1hLCBhbGxvd19lbXB0eSkge1xuICAgICAgICB2YXIgZmlyc3QgPSB0cnVlLCBhID0gW107XG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIGNsb3NpbmcpKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIGZpcnN0ID0gZmFsc2U7IGVsc2UgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgIGlmIChhbGxvd190cmFpbGluZ19jb21tYSAmJiBpcyhcInB1bmNcIiwgY2xvc2luZykpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIixcIikgJiYgYWxsb3dfZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBhLnB1c2gobmV3IEFTVF9Ib2xlKHsgc3RhcnQ6IFMudG9rZW4sIGVuZDogUy50b2tlbiB9KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzKFwiZXhwYW5kXCIsIFwiLi4uXCIpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX0V4cGFuc2lvbih7c3RhcnQ6IHByZXYoKSwgZXhwcmVzc2lvbjogZXhwcmVzc2lvbigpLGVuZDogUy50b2tlbn0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKGV4cHJlc3Npb24oZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciBhcnJheV8gPSBlbWJlZF90b2tlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChcIltcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0FycmF5KHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBleHByX2xpc3QoXCJdXCIsICFvcHRpb25zLnN0cmljdCwgdHJ1ZSlcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgY3JlYXRlX2FjY2Vzc29yID0gZW1iZWRfdG9rZW5zKChpc19nZW5lcmF0b3IsIGlzX2FzeW5jKSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbl8oQVNUX0FjY2Vzc29yLCBpc19nZW5lcmF0b3IsIGlzX2FzeW5jKTtcbiAgICB9KTtcblxuICAgIHZhciBvYmplY3Rfb3JfZGVzdHJ1Y3R1cmluZ18gPSBlbWJlZF90b2tlbnMoZnVuY3Rpb24gb2JqZWN0X29yX2Rlc3RydWN0dXJpbmdfKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuLCBmaXJzdCA9IHRydWUsIGEgPSBbXTtcbiAgICAgICAgZXhwZWN0KFwie1wiKTtcbiAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIGZpcnN0ID0gZmFsc2U7IGVsc2UgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QgJiYgaXMoXCJwdW5jXCIsIFwifVwiKSlcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyB0cmFpbGluZyBjb21tYVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICBpZiAoc3RhcnQudHlwZSA9PSBcImV4cGFuZFwiKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX0V4cGFuc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbihmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGlzKFwicHJpdmF0ZW5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICBjcm9hayhcInByaXZhdGUgZmllbGRzIGFyZSBub3QgYWxsb3dlZCBpbiBhbiBvYmplY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFzX3Byb3BlcnR5X25hbWUoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgcHJvcGVydHkgYW5kIGZldGNoIHZhbHVlXG4gICAgICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIjpcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uY2lzZSA9IG9iamVjdF9vcl9jbGFzc19wcm9wZXJ0eShuYW1lLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmNpc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGNvbmNpc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBBU1RfU3ltYm9sUmVmKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHByZXYoKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQocHJldigpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpOyAvLyBgOmAgLSBzZWUgZmlyc3QgY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBleHByZXNzaW9uKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGRlZmF1bHQgdmFsdWUgYW5kIGFsdGVyIHZhbHVlIGFjY29yZGluZ2x5IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFTVF9Bc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9XCIsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBleHByZXNzaW9uKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgbG9naWNhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBwcm9wZXJ0eVxuICAgICAgICAgICAgY29uc3Qga3YgPSBuZXcgQVNUX09iamVjdEtleVZhbCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIHF1b3RlOiBzdGFydC5xdW90ZSxcbiAgICAgICAgICAgICAgICBrZXk6IG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGEucHVzaChhbm5vdGF0ZShrdikpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0KHsgcHJvcGVydGllczogYSB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNsYXNzXyhLaW5kT2ZDbGFzcywgaXNfZXhwb3J0X2RlZmF1bHQpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBtZXRob2QsIGNsYXNzX25hbWUsIGV4dGVuZHNfLCBwcm9wZXJ0aWVzID0gW107XG5cbiAgICAgICAgUy5pbnB1dC5wdXNoX2RpcmVjdGl2ZXNfc3RhY2soKTsgLy8gUHVzaCBkaXJlY3RpdmUgc3RhY2ssIGJ1dCBub3Qgc2NvcGUgc3RhY2tcbiAgICAgICAgUy5pbnB1dC5hZGRfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKTtcblxuICAgICAgICBpZiAoUy50b2tlbi50eXBlID09IFwibmFtZVwiICYmIFMudG9rZW4udmFsdWUgIT0gXCJleHRlbmRzXCIpIHtcbiAgICAgICAgICAgIGNsYXNzX25hbWUgPSBhc19zeW1ib2woS2luZE9mQ2xhc3MgPT09IEFTVF9EZWZDbGFzcyA/IEFTVF9TeW1ib2xEZWZDbGFzcyA6IEFTVF9TeW1ib2xDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoS2luZE9mQ2xhc3MgPT09IEFTVF9EZWZDbGFzcyAmJiAhY2xhc3NfbmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzX2V4cG9ydF9kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgS2luZE9mQ2xhc3MgPSBBU1RfQ2xhc3NFeHByZXNzaW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUy50b2tlbi52YWx1ZSA9PSBcImV4dGVuZHNcIikge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgZXh0ZW5kc18gPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KFwie1wiKTtcbiAgICAgICAgLy8gbWFyayBpbiBjbGFzcyBmZWlsZCxcbiAgICAgICAgY29uc3Qgc2F2ZV9pbl9jbGFzcyA9IFMuaW5fY2xhc3M7XG4gICAgICAgIFMuaW5fY2xhc3MgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoaXMoXCJwdW5jXCIsIFwiO1wiKSkgeyBuZXh0KCk7IH0gIC8vIExlYWRpbmcgc2VtaWNvbG9ucyBhcmUgb2theSBpbiBjbGFzcyBib2RpZXMuXG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgbWV0aG9kID0gb2JqZWN0X29yX2NsYXNzX3Byb3BlcnR5KGFzX3Byb3BlcnR5X25hbWUoKSwgc3RhcnQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFtZXRob2QpIHsgdW5leHBlY3RlZCgpOyB9XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gobWV0aG9kKTtcbiAgICAgICAgICAgIHdoaWxlIChpcyhcInB1bmNcIiwgXCI7XCIpKSB7IG5leHQoKTsgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1hcmsgaW4gY2xhc3MgZmVpbGQsXG4gICAgICAgIFMuaW5fY2xhc3MgPSBzYXZlX2luX2NsYXNzO1xuXG4gICAgICAgIFMuaW5wdXQucG9wX2RpcmVjdGl2ZXNfc3RhY2soKTtcblxuICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBLaW5kT2ZDbGFzcyh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBuYW1lOiBjbGFzc19uYW1lLFxuICAgICAgICAgICAgZXh0ZW5kczogZXh0ZW5kc18sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgZW5kOiBwcmV2KCksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9iamVjdF9vcl9jbGFzc19wcm9wZXJ0eShuYW1lLCBzdGFydCwgaXNfY2xhc3MpIHtcbiAgICAgICAgY29uc3QgZ2V0X3N5bWJvbF9hc3QgPSAobmFtZSwgU3ltYm9sQ2xhc3MpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sQ2xhc3MoeyBzdGFydCwgbmFtZSwgZW5kOiBwcmV2KCkgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaXNfcHJpdmF0ZSA9IHByZXYoKS50eXBlID09PSBcInByaXZhdGVuYW1lXCI7XG4gICAgICAgIGNvbnN0IGlzX25vdF9tZXRob2Rfc3RhcnQgPSAoKSA9PlxuICAgICAgICAgICAgIWlzKFwicHVuY1wiLCBcIihcIikgJiYgIWlzKFwicHVuY1wiLCBcIixcIikgJiYgIWlzKFwicHVuY1wiLCBcIn1cIikgJiYgIWlzKFwicHVuY1wiLCBcIjtcIikgJiYgIWlzKFwib3BlcmF0b3JcIiwgXCI9XCIpICYmICFpc19wcml2YXRlO1xuXG4gICAgICAgIHZhciBpc19hc3luYyA9IGZhbHNlO1xuICAgICAgICB2YXIgaXNfc3RhdGljID0gZmFsc2U7XG4gICAgICAgIHZhciBpc19nZW5lcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFjY2Vzc29yX3R5cGUgPSBudWxsO1xuXG4gICAgICAgIGlmIChpc19jbGFzcyAmJiBuYW1lID09PSBcInN0YXRpY1wiICYmIGlzX25vdF9tZXRob2Rfc3RhcnQoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGljX2Jsb2NrID0gY2xhc3Nfc3RhdGljX2Jsb2NrKCk7XG4gICAgICAgICAgICBpZiAoc3RhdGljX2Jsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGljX2Jsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNfc3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09IFwiYXN5bmNcIiAmJiBpc19ub3RfbWV0aG9kX3N0YXJ0KCkpIHtcbiAgICAgICAgICAgIGlzX2FzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXYoKS50eXBlID09PSBcIm9wZXJhdG9yXCIgJiYgcHJldigpLnZhbHVlID09PSBcIipcIikge1xuICAgICAgICAgICAgaXNfZ2VuZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChuYW1lID09PSBcImdldFwiIHx8IG5hbWUgPT09IFwic2V0XCIpICYmIGlzX25vdF9tZXRob2Rfc3RhcnQoKSkge1xuICAgICAgICAgICAgYWNjZXNzb3JfdHlwZSA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gYXNfcHJvcGVydHlfbmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNfcHJpdmF0ZSAmJiBwcmV2KCkudHlwZSA9PT0gXCJwcml2YXRlbmFtZVwiKSB7XG4gICAgICAgICAgICBpc19wcml2YXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb3BlcnR5X3Rva2VuID0gcHJldigpO1xuXG4gICAgICAgIGlmIChhY2Nlc3Nvcl90eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghaXNfcHJpdmF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IEFjY2Vzc29yQ2xhc3MgPSBhY2Nlc3Nvcl90eXBlID09PSBcImdldFwiXG4gICAgICAgICAgICAgICAgICAgID8gQVNUX09iamVjdEdldHRlclxuICAgICAgICAgICAgICAgICAgICA6IEFTVF9PYmplY3RTZXR0ZXI7XG5cbiAgICAgICAgICAgICAgICBuYW1lID0gZ2V0X3N5bWJvbF9hc3QobmFtZSwgQVNUX1N5bWJvbE1ldGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRlKG5ldyBBY2Nlc3NvckNsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpYzogaXNfc3RhdGljLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlOiBuYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbE1ldGhvZCA/IHByb3BlcnR5X3Rva2VuLnF1b3RlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3JlYXRlX2FjY2Vzc29yKCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBBY2Nlc3NvckNsYXNzID0gYWNjZXNzb3JfdHlwZSA9PT0gXCJnZXRcIlxuICAgICAgICAgICAgICAgICAgICA/IEFTVF9Qcml2YXRlR2V0dGVyXG4gICAgICAgICAgICAgICAgICAgIDogQVNUX1ByaXZhdGVTZXR0ZXI7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGUobmV3IEFjY2Vzc29yQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljOiBpc19zdGF0aWMsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZ2V0X3N5bWJvbF9hc3QobmFtZSwgQVNUX1N5bWJvbE1ldGhvZCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjcmVhdGVfYWNjZXNzb3IoKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIihcIikpIHtcbiAgICAgICAgICAgIG5hbWUgPSBnZXRfc3ltYm9sX2FzdChuYW1lLCBBU1RfU3ltYm9sTWV0aG9kKTtcbiAgICAgICAgICAgIGNvbnN0IEFTVF9NZXRob2RWYXJpYW50ID0gaXNfcHJpdmF0ZVxuICAgICAgICAgICAgICAgID8gQVNUX1ByaXZhdGVNZXRob2RcbiAgICAgICAgICAgICAgICA6IEFTVF9Db25jaXNlTWV0aG9kO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgQVNUX01ldGhvZFZhcmlhbnQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhdGljICAgICAgOiBpc19zdGF0aWMsXG4gICAgICAgICAgICAgICAga2V5ICAgICAgICAgOiBuYW1lLFxuICAgICAgICAgICAgICAgIHF1b3RlICAgICAgIDogbmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xNZXRob2QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlfdG9rZW4ucXVvdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgOiBjcmVhdGVfYWNjZXNzb3IoaXNfZ2VuZXJhdG9yLCBpc19hc3luYyksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFubm90YXRlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzX2NsYXNzKSB7XG4gICAgICAgICAgICBjb25zdCBBU1RfU3ltYm9sVmFyaWFudCA9IGlzX3ByaXZhdGVcbiAgICAgICAgICAgICAgICA/IEFTVF9TeW1ib2xQcml2YXRlUHJvcGVydHlcbiAgICAgICAgICAgICAgICA6IEFTVF9TeW1ib2xDbGFzc1Byb3BlcnR5O1xuICAgICAgICAgICAgY29uc3QgQVNUX0NsYXNzUHJvcGVydHlWYXJpYW50ID0gaXNfcHJpdmF0ZVxuICAgICAgICAgICAgICAgID8gQVNUX0NsYXNzUHJpdmF0ZVByb3BlcnR5XG4gICAgICAgICAgICAgICAgOiBBU1RfQ2xhc3NQcm9wZXJ0eTtcblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0X3N5bWJvbF9hc3QobmFtZSwgQVNUX1N5bWJvbFZhcmlhbnQpO1xuICAgICAgICAgICAgY29uc3QgcXVvdGUgPSBrZXkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2xhc3NQcm9wZXJ0eVxuICAgICAgICAgICAgICAgID8gcHJvcGVydHlfdG9rZW4ucXVvdGVcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiPVwiKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGUoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBBU1RfQ2xhc3NQcm9wZXJ0eVZhcmlhbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWM6IGlzX3N0YXRpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGV4cHJlc3Npb24oZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBpcyhcIm5hbWVcIilcbiAgICAgICAgICAgICAgICB8fCBpcyhcInByaXZhdGVuYW1lXCIpXG4gICAgICAgICAgICAgICAgfHwgaXMoXCJwdW5jXCIsIFwiW1wiKVxuICAgICAgICAgICAgICAgIHx8IGlzKFwib3BlcmF0b3JcIiwgXCIqXCIpXG4gICAgICAgICAgICAgICAgfHwgaXMoXCJwdW5jXCIsIFwiO1wiKVxuICAgICAgICAgICAgICAgIHx8IGlzKFwicHVuY1wiLCBcIn1cIilcbiAgICAgICAgICAgICAgICB8fCBpcyhcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHx8IGlzKFwibnVtXCIpXG4gICAgICAgICAgICAgICAgfHwgaXMoXCJiaWdfaW50XCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGUoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBBU1RfQ2xhc3NQcm9wZXJ0eVZhcmlhbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWM6IGlzX3N0YXRpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhc3Nfc3RhdGljX2Jsb2NrKCkge1xuICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIntcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICBjb25zdCBib2R5ID0gW107XG5cbiAgICAgICAgbmV4dCgpO1xuXG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgYm9keS5wdXNoKHN0YXRlbWVudCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKTtcblxuICAgICAgICByZXR1cm4gbmV3IEFTVF9DbGFzc1N0YXRpY0Jsb2NrKHsgc3RhcnQsIGJvZHksIGVuZDogcHJldigpIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heWJlX2ltcG9ydF9hdHRyaWJ1dGVzKCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXMoXCJrZXl3b3JkXCIsIFwid2l0aFwiKSB8fCBpcyhcIm5hbWVcIiwgXCJhc3NlcnRcIikpXG4gICAgICAgICAgICAmJiAhaGFzX25ld2xpbmVfYmVmb3JlKFMudG9rZW4pXG4gICAgICAgICkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdF9vcl9kZXN0cnVjdHVyaW5nXygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydF9zdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHByZXYoKTtcblxuICAgICAgICB2YXIgaW1wb3J0ZWRfbmFtZTtcbiAgICAgICAgdmFyIGltcG9ydGVkX25hbWVzO1xuICAgICAgICBpZiAoaXMoXCJuYW1lXCIpKSB7XG4gICAgICAgICAgICBpbXBvcnRlZF9uYW1lID0gYXNfc3ltYm9sKEFTVF9TeW1ib2xJbXBvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltcG9ydGVkX25hbWVzID0gbWFwX25hbWVzKHRydWUpO1xuXG4gICAgICAgIGlmIChpbXBvcnRlZF9uYW1lcyB8fCBpbXBvcnRlZF9uYW1lKSB7XG4gICAgICAgICAgICBleHBlY3RfdG9rZW4oXCJuYW1lXCIsIFwiZnJvbVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kX3N0ciA9IFMudG9rZW47XG4gICAgICAgIGlmIChtb2Rfc3RyLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG1heWJlX2ltcG9ydF9hdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfSW1wb3J0KHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgaW1wb3J0ZWRfbmFtZSxcbiAgICAgICAgICAgIGltcG9ydGVkX25hbWVzLFxuICAgICAgICAgICAgbW9kdWxlX25hbWU6IG5ldyBBU1RfU3RyaW5nKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbW9kX3N0cixcbiAgICAgICAgICAgICAgICB2YWx1ZTogbW9kX3N0ci52YWx1ZSxcbiAgICAgICAgICAgICAgICBxdW90ZTogbW9kX3N0ci5xdW90ZSxcbiAgICAgICAgICAgICAgICBlbmQ6IG1vZF9zdHIsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBlbmQ6IFMudG9rZW4sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydF9tZXRhKGFsbG93X2NhbGxzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIGV4cGVjdF90b2tlbihcIm5hbWVcIiwgXCJpbXBvcnRcIik7XG4gICAgICAgIGV4cGVjdF90b2tlbihcInB1bmNcIiwgXCIuXCIpO1xuICAgICAgICBleHBlY3RfdG9rZW4oXCJuYW1lXCIsIFwibWV0YVwiKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9JbXBvcnRNZXRhKHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgIH0pLCBhbGxvd19jYWxscyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwX25hbWUoaXNfaW1wb3J0KSB7XG4gICAgICAgIGZ1bmN0aW9uIG1ha2Vfc3ltYm9sKHR5cGUsIHF1b3RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGFzX3Byb3BlcnR5X25hbWUoKSxcbiAgICAgICAgICAgICAgICBxdW90ZTogcXVvdGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2KCksXG4gICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvcmVpZ25fdHlwZSA9IGlzX2ltcG9ydCA/IEFTVF9TeW1ib2xJbXBvcnRGb3JlaWduIDogQVNUX1N5bWJvbEV4cG9ydEZvcmVpZ247XG4gICAgICAgIHZhciB0eXBlID0gaXNfaW1wb3J0ID8gQVNUX1N5bWJvbEltcG9ydCA6IEFTVF9TeW1ib2xFeHBvcnQ7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIHZhciBmb3JlaWduX25hbWU7XG4gICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgIGlmIChpc19pbXBvcnQpIHtcbiAgICAgICAgICAgIGZvcmVpZ25fbmFtZSA9IG1ha2Vfc3ltYm9sKGZvcmVpZ25fdHlwZSwgc3RhcnQucXVvdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG1ha2Vfc3ltYm9sKHR5cGUsIHN0YXJ0LnF1b3RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJuYW1lXCIsIFwiYXNcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTsgIC8vIFRoZSBcImFzXCIgd29yZFxuICAgICAgICAgICAgaWYgKGlzX2ltcG9ydCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBtYWtlX3N5bWJvbCh0eXBlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yZWlnbl9uYW1lID0gbWFrZV9zeW1ib2woZm9yZWlnbl90eXBlLCBTLnRva2VuLnF1b3RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc19pbXBvcnQpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmV3IHR5cGUoZm9yZWlnbl9uYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yZWlnbl9uYW1lID0gbmV3IGZvcmVpZ25fdHlwZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQVNUX05hbWVNYXBwaW5nKHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGZvcmVpZ25fbmFtZTogZm9yZWlnbl9uYW1lLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGVuZDogcHJldigpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXBfbmFtZUFzdGVyaXNrKGlzX2ltcG9ydCwgaW1wb3J0X29yX2V4cG9ydF9mb3JlaWduX25hbWUpIHtcbiAgICAgICAgdmFyIGZvcmVpZ25fdHlwZSA9IGlzX2ltcG9ydCA/IEFTVF9TeW1ib2xJbXBvcnRGb3JlaWduIDogQVNUX1N5bWJvbEV4cG9ydEZvcmVpZ247XG4gICAgICAgIHZhciB0eXBlID0gaXNfaW1wb3J0ID8gQVNUX1N5bWJvbEltcG9ydCA6IEFTVF9TeW1ib2xFeHBvcnQ7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIHZhciBuYW1lLCBmb3JlaWduX25hbWU7XG4gICAgICAgIHZhciBlbmQgPSBwcmV2KCk7XG5cbiAgICAgICAgaWYgKGlzX2ltcG9ydCkge1xuICAgICAgICAgICAgbmFtZSA9IGltcG9ydF9vcl9leHBvcnRfZm9yZWlnbl9uYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yZWlnbl9uYW1lID0gaW1wb3J0X29yX2V4cG9ydF9mb3JlaWduX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZSB8fCBuZXcgdHlwZSh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBuYW1lOiBcIipcIixcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICB9KTtcblxuICAgICAgICBmb3JlaWduX25hbWUgPSBmb3JlaWduX25hbWUgfHwgbmV3IGZvcmVpZ25fdHlwZSh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBuYW1lOiBcIipcIixcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IEFTVF9OYW1lTWFwcGluZyh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBmb3JlaWduX25hbWU6IGZvcmVpZ25fbmFtZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwX25hbWVzKGlzX2ltcG9ydCkge1xuICAgICAgICB2YXIgbmFtZXM7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJ7XCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICAgICAgbmFtZXMucHVzaChtYXBfbmFtZShpc19pbXBvcnQpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiLFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCIqXCIpKSB7XG4gICAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChpcyhcIm5hbWVcIiwgXCJhc1wiKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTsgIC8vIFRoZSBcImFzXCIgd29yZFxuICAgICAgICAgICAgICAgIG5hbWUgPSBpc19pbXBvcnQgPyBhc19zeW1ib2woQVNUX1N5bWJvbEltcG9ydCkgOiBhc19zeW1ib2xfb3Jfc3RyaW5nKEFTVF9TeW1ib2xFeHBvcnRGb3JlaWduKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWVzID0gW21hcF9uYW1lQXN0ZXJpc2soaXNfaW1wb3J0LCBuYW1lKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydF9zdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIHZhciBpc19kZWZhdWx0O1xuICAgICAgICB2YXIgZXhwb3J0ZWRfbmFtZXM7XG5cbiAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImRlZmF1bHRcIikpIHtcbiAgICAgICAgICAgIGlzX2RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cG9ydGVkX25hbWVzID0gbWFwX25hbWVzKGZhbHNlKSkge1xuICAgICAgICAgICAgaWYgKGlzKFwibmFtZVwiLCBcImZyb21cIikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbW9kX3N0ciA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgaWYgKG1vZF9zdHIudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBtYXliZV9pbXBvcnRfYXR0cmlidXRlcygpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRXhwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc19kZWZhdWx0OiBpc19kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZF9uYW1lczogZXhwb3J0ZWRfbmFtZXMsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZV9uYW1lOiBuZXcgQVNUX1N0cmluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbW9kX3N0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtb2Rfc3RyLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGU6IG1vZF9zdHIucXVvdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG1vZF9zdHIsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9FeHBvcnQoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGlzX2RlZmF1bHQ6IGlzX2RlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkX25hbWVzOiBleHBvcnRlZF9uYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdmFyIGV4cG9ydGVkX3ZhbHVlO1xuICAgICAgICB2YXIgZXhwb3J0ZWRfZGVmaW5pdGlvbjtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIntcIilcbiAgICAgICAgICAgIHx8IGlzX2RlZmF1bHRcbiAgICAgICAgICAgICAgICAmJiAoaXMoXCJrZXl3b3JkXCIsIFwiY2xhc3NcIikgfHwgaXMoXCJrZXl3b3JkXCIsIFwiZnVuY3Rpb25cIikpXG4gICAgICAgICAgICAgICAgJiYgaXNfdG9rZW4ocGVlaygpLCBcInB1bmNcIikpIHtcbiAgICAgICAgICAgIGV4cG9ydGVkX3ZhbHVlID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgfSBlbHNlIGlmICgobm9kZSA9IHN0YXRlbWVudChpc19kZWZhdWx0KSkgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMgJiYgaXNfZGVmYXVsdCkge1xuICAgICAgICAgICAgdW5leHBlY3RlZChub2RlLnN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnNcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW5cbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmQ2xhc3NcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBleHBvcnRlZF9kZWZpbml0aW9uID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3NFeHByZXNzaW9uXG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0Z1bmN0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgICAgZXhwb3J0ZWRfdmFsdWUgPSBub2RlO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICBleHBvcnRlZF92YWx1ZSA9IG5vZGUuYm9keTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQobm9kZS5zdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEFTVF9FeHBvcnQoe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgaXNfZGVmYXVsdDogaXNfZGVmYXVsdCxcbiAgICAgICAgICAgIGV4cG9ydGVkX3ZhbHVlOiBleHBvcnRlZF92YWx1ZSxcbiAgICAgICAgICAgIGV4cG9ydGVkX2RlZmluaXRpb246IGV4cG9ydGVkX2RlZmluaXRpb24sXG4gICAgICAgICAgICBlbmQ6IHByZXYoKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNfcHJvcGVydHlfbmFtZSgpIHtcbiAgICAgICAgdmFyIHRtcCA9IFMudG9rZW47XG4gICAgICAgIHN3aXRjaCAodG1wLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwicHVuY1wiOlxuICAgICAgICAgICAgaWYgKHRtcC52YWx1ZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4ID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiXVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXg7XG4gICAgICAgICAgICB9IGVsc2UgdW5leHBlY3RlZCh0bXApO1xuICAgICAgICAgIGNhc2UgXCJvcGVyYXRvclwiOlxuICAgICAgICAgICAgaWYgKHRtcC52YWx1ZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVtcImRlbGV0ZVwiLCBcImluXCIsIFwiaW5zdGFuY2VvZlwiLCBcIm5ld1wiLCBcInR5cGVvZlwiLCBcInZvaWRcIl0uaW5jbHVkZXModG1wLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQodG1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgIGNhc2UgXCJwcml2YXRlbmFtZVwiOlxuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBjYXNlIFwia2V5d29yZFwiOlxuICAgICAgICAgIGNhc2UgXCJhdG9tXCI6XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdG1wLnZhbHVlO1xuICAgICAgICAgIGNhc2UgXCJudW1cIjpcbiAgICAgICAgICBjYXNlIFwiYmlnX2ludFwiOlxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB0bXAudmFsdWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQodG1wKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzX25hbWUoKSB7XG4gICAgICAgIHZhciB0bXAgPSBTLnRva2VuO1xuICAgICAgICBpZiAodG1wLnR5cGUgIT0gXCJuYW1lXCIgJiYgdG1wLnR5cGUgIT0gXCJwcml2YXRlbmFtZVwiKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRtcC52YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfbWFrZV9zeW1ib2wodHlwZSkge1xuICAgICAgICB2YXIgbmFtZSA9IFMudG9rZW4udmFsdWU7XG4gICAgICAgIHJldHVybiBuZXcgKG5hbWUgPT0gXCJ0aGlzXCIgPyBBU1RfVGhpcyA6XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPT0gXCJzdXBlclwiID8gQVNUX1N1cGVyIDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSkoe1xuICAgICAgICAgICAgbmFtZSAgOiBTdHJpbmcobmFtZSksXG4gICAgICAgICAgICBzdGFydCA6IFMudG9rZW4sXG4gICAgICAgICAgICBlbmQgICA6IFMudG9rZW5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3ZlcmlmeV9zeW1ib2woc3ltKSB7XG4gICAgICAgIHZhciBuYW1lID0gc3ltLm5hbWU7XG4gICAgICAgIGlmIChpc19pbl9nZW5lcmF0b3IoKSAmJiBuYW1lID09IFwieWllbGRcIikge1xuICAgICAgICAgICAgdG9rZW5fZXJyb3Ioc3ltLnN0YXJ0LCBcIllpZWxkIGNhbm5vdCBiZSB1c2VkIGFzIGlkZW50aWZpZXIgaW5zaWRlIGdlbmVyYXRvcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFMuaW5wdXQuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwieWllbGRcIikge1xuICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKHN5bS5zdGFydCwgXCJVbmV4cGVjdGVkIHlpZWxkIGlkZW50aWZpZXIgaW5zaWRlIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN5bSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbiAmJiAobmFtZSA9PSBcImFyZ3VtZW50c1wiIHx8IG5hbWUgPT0gXCJldmFsXCIpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5fZXJyb3Ioc3ltLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgXCIgKyBuYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc19zeW1ib2wodHlwZSwgbm9lcnJvcikge1xuICAgICAgICBpZiAoIWlzKFwibmFtZVwiKSkge1xuICAgICAgICAgICAgaWYgKCFub2Vycm9yKSBjcm9hayhcIk5hbWUgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ltID0gX21ha2Vfc3ltYm9sKHR5cGUpO1xuICAgICAgICBfdmVyaWZ5X3N5bWJvbChzeW0pO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBzeW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNfc3ltYm9sX29yX3N0cmluZyh0eXBlKSB7XG4gICAgICAgIGlmICghaXMoXCJuYW1lXCIpKSB7XG4gICAgICAgICAgICBpZiAoIWlzKFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgY3JvYWsoXCJOYW1lIG9yIHN0cmluZyBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b2sgPSBTLnRva2VuO1xuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyB0eXBlKHtcbiAgICAgICAgICAgICAgICBzdGFydCA6IHRvayxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHRvayxcbiAgICAgICAgICAgICAgICBuYW1lIDogdG9rLnZhbHVlLFxuICAgICAgICAgICAgICAgIHF1b3RlIDogdG9rLnF1b3RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN5bSA9IF9tYWtlX3N5bWJvbCh0eXBlKTtcbiAgICAgICAgX3ZlcmlmeV9zeW1ib2woc3ltKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gc3ltO1xuICAgIH1cblxuICAgIC8vIEFubm90YXRlIEFTVF9DYWxsLCBBU1RfTGFtYmRhIG9yIEFTVF9OZXcgd2l0aCB0aGUgc3BlY2lhbCBjb21tZW50c1xuICAgIGZ1bmN0aW9uIGFubm90YXRlKG5vZGUsIGJlZm9yZV90b2tlbiA9IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgdmFyIGNvbW1lbnRzID0gYmVmb3JlX3Rva2VuLmNvbW1lbnRzX2JlZm9yZTtcbiAgICAgICAgY29uc3QgY29tbWVudHNfb3V0c2lkZV9wYXJlbnMgPSBvdXRlcl9jb21tZW50c19iZWZvcmVfY291bnRzLmdldChiZWZvcmVfdG9rZW4pO1xuICAgICAgICB2YXIgaSA9IGNvbW1lbnRzX291dHNpZGVfcGFyZW5zICE9IG51bGwgPyBjb21tZW50c19vdXRzaWRlX3BhcmVucyA6IGNvbW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IGNvbW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKC9bQCNdX18vLnRlc3QoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoL1tAI11fX1BVUkVfXy8udGVzdChjb21tZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRfYW5ub3RhdGlvbihub2RlLCBfUFVSRSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL1tAI11fX0lOTElORV9fLy50ZXN0KGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldF9hbm5vdGF0aW9uKG5vZGUsIF9JTkxJTkUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9bQCNdX19OT0lOTElORV9fLy50ZXN0KGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldF9hbm5vdGF0aW9uKG5vZGUsIF9OT0lOTElORSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL1tAI11fX0tFWV9fLy50ZXN0KGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldF9hbm5vdGF0aW9uKG5vZGUsIF9LRVkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9bQCNdX19NQU5HTEVfUFJPUF9fLy50ZXN0KGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldF9hbm5vdGF0aW9uKG5vZGUsIF9NQU5HTEVQUk9QKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHZhciBzdWJzY3JpcHRzID0gZnVuY3Rpb24oZXhwciwgYWxsb3dfY2FsbHMsIGlzX2NoYWluKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGV4cHIuc3RhcnQ7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIuXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZihpcyhcInByaXZhdGVuYW1lXCIpICYmICFTLmluX2NsYXNzKSBcbiAgICAgICAgICAgICAgICBjcm9hayhcIlByaXZhdGUgZmllbGQgbXVzdCBiZSB1c2VkIGluIGFuIGVuY2xvc2luZyBjbGFzc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IEFTVF9Eb3RWYXJpYW50ID0gaXMoXCJwcml2YXRlbmFtZVwiKSA/IEFTVF9Eb3RIYXNoIDogQVNUX0RvdDtcbiAgICAgICAgICAgIHJldHVybiBhbm5vdGF0ZShzdWJzY3JpcHRzKG5ldyBBU1RfRG90VmFyaWFudCh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBleHByLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgIDogYXNfbmFtZSgpLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscywgaXNfY2hhaW4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiW1wiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdmFyIHByb3AgPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KFwiXVwiKTtcbiAgICAgICAgICAgIHJldHVybiBhbm5vdGF0ZShzdWJzY3JpcHRzKG5ldyBBU1RfU3ViKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHIsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWwgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5ICAgOiBwcm9wLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscywgaXNfY2hhaW4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dfY2FsbHMgJiYgaXMoXCJwdW5jXCIsIFwiKFwiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdmFyIGNhbGwgPSBuZXcgQVNUX0NhbGwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcixcbiAgICAgICAgICAgICAgICBvcHRpb25hbCAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXJncyAgICAgICA6IGNhbGxfYXJncygpLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5ub3RhdGUoY2FsbCk7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhjYWxsLCB0cnVlLCBpc19jaGFpbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbCBjaGFpblxuICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiPy5cIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgICAgbGV0IGNoYWluX2NvbnRlbnRzO1xuXG4gICAgICAgICAgICBpZiAoYWxsb3dfY2FsbHMgJiYgaXMoXCJwdW5jXCIsIFwiKFwiKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGwgPSBuZXcgQVNUX0NhbGwoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGNhbGxfYXJncygpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFubm90YXRlKGNhbGwpO1xuXG4gICAgICAgICAgICAgICAgY2hhaW5fY29udGVudHMgPSBzdWJzY3JpcHRzKGNhbGwsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhcIm5hbWVcIikgfHwgaXMoXCJwcml2YXRlbmFtZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmKGlzKFwicHJpdmF0ZW5hbWVcIikgJiYgIVMuaW5fY2xhc3MpIFxuICAgICAgICAgICAgICAgICAgICBjcm9hayhcIlByaXZhdGUgZmllbGQgbXVzdCBiZSB1c2VkIGluIGFuIGVuY2xvc2luZyBjbGFzc1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBBU1RfRG90VmFyaWFudCA9IGlzKFwicHJpdmF0ZW5hbWVcIikgPyBBU1RfRG90SGFzaCA6IEFTVF9Eb3Q7XG4gICAgICAgICAgICAgICAgY2hhaW5fY29udGVudHMgPSBhbm5vdGF0ZShzdWJzY3JpcHRzKG5ldyBBU1RfRG90VmFyaWFudCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGFzX25hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMsIHRydWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXMoXCJwdW5jXCIsIFwiW1wiKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiXVwiKTtcbiAgICAgICAgICAgICAgICBjaGFpbl9jb250ZW50cyA9IGFubm90YXRlKHN1YnNjcmlwdHMobmV3IEFTVF9TdWIoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscywgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoYWluX2NvbnRlbnRzKSB1bmV4cGVjdGVkKCk7XG5cbiAgICAgICAgICAgIGlmIChjaGFpbl9jb250ZW50cyBpbnN0YW5jZW9mIEFTVF9DaGFpbikgcmV0dXJuIGNoYWluX2NvbnRlbnRzO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9DaGFpbih7XG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogY2hhaW5fY29udGVudHMsXG4gICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzKFwidGVtcGxhdGVfaGVhZFwiKSkge1xuICAgICAgICAgICAgaWYgKGlzX2NoYWluKSB7XG4gICAgICAgICAgICAgICAgLy8gYT8uYmBjYCBpcyBhIHN5bnRheCBlcnJvclxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9QcmVmaXhlZFRlbXBsYXRlU3RyaW5nKHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBleHByLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlX3N0cmluZzogdGVtcGxhdGVfc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGxfYXJncygpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCIpXCIpKSB7XG4gICAgICAgICAgICBpZiAoaXMoXCJleHBhbmRcIiwgXCIuLi5cIikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKG5ldyBBU1RfRXhwYW5zaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHByZXYoKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbihmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcmVzc2lvbihmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpcyhcInB1bmNcIiwgXCIpXCIpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIHZhciBtYXliZV91bmFyeSA9IGZ1bmN0aW9uKGFsbG93X2NhbGxzLCBhbGxvd19hcnJvd3MpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgaWYgKHN0YXJ0LnR5cGUgPT0gXCJuYW1lXCIgJiYgc3RhcnQudmFsdWUgPT0gXCJhd2FpdFwiICYmIGNhbl9hd2FpdCgpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gX2F3YWl0X2V4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiKSAmJiBVTkFSWV9QUkVGSVguaGFzKHN0YXJ0LnZhbHVlKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaGFuZGxlX3JlZ2V4cCgpO1xuICAgICAgICAgICAgdmFyIGV4ID0gbWFrZV91bmFyeShBU1RfVW5hcnlQcmVmaXgsIHN0YXJ0LCBtYXliZV91bmFyeShhbGxvd19jYWxscykpO1xuICAgICAgICAgICAgZXguc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGV4LmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIHJldHVybiBleDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsID0gZXhwcl9hdG9tKGFsbG93X2NhbGxzLCBhbGxvd19hcnJvd3MpO1xuICAgICAgICB3aGlsZSAoaXMoXCJvcGVyYXRvclwiKSAmJiBVTkFSWV9QT1NURklYLmhhcyhTLnRva2VuLnZhbHVlKSAmJiAhaGFzX25ld2xpbmVfYmVmb3JlKFMudG9rZW4pKSB7XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQVNUX0Fycm93KSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB2YWwgPSBtYWtlX3VuYXJ5KEFTVF9VbmFyeVBvc3RmaXgsIFMudG9rZW4sIHZhbCk7XG4gICAgICAgICAgICB2YWwuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHZhbC5lbmQgPSBTLnRva2VuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VfdW5hcnkoY3RvciwgdG9rZW4sIGV4cHIpIHtcbiAgICAgICAgdmFyIG9wID0gdG9rZW4udmFsdWU7XG4gICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICBjYXNlIFwiKytcIjpcbiAgICAgICAgICBjYXNlIFwiLS1cIjpcbiAgICAgICAgICAgIGlmICghaXNfYXNzaWduYWJsZShleHByKSlcbiAgICAgICAgICAgICAgICBjcm9hayhcIkludmFsaWQgdXNlIG9mIFwiICsgb3AgKyBcIiBvcGVyYXRvclwiLCB0b2tlbi5saW5lLCB0b2tlbi5jb2wsIHRva2VuLnBvcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgUy5pbnB1dC5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSlcbiAgICAgICAgICAgICAgICBjcm9hayhcIkNhbGxpbmcgZGVsZXRlIG9uIGV4cHJlc3Npb24gbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGVcIiwgZXhwci5zdGFydC5saW5lLCBleHByLnN0YXJ0LmNvbCwgZXhwci5zdGFydC5wb3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHsgb3BlcmF0b3I6IG9wLCBleHByZXNzaW9uOiBleHByIH0pO1xuICAgIH1cblxuICAgIHZhciBleHByX29wID0gZnVuY3Rpb24obGVmdCwgbWluX3ByZWMsIG5vX2luKSB7XG4gICAgICAgIHZhciBvcCA9IGlzKFwib3BlcmF0b3JcIikgPyBTLnRva2VuLnZhbHVlIDogbnVsbDtcbiAgICAgICAgaWYgKG9wID09IFwiaW5cIiAmJiBub19pbikgb3AgPSBudWxsO1xuICAgICAgICBpZiAob3AgPT0gXCIqKlwiICYmIGxlZnQgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgIC8qIHVuYXJ5IHRva2VuIGluIGZyb250IG5vdCBhbGxvd2VkIC0gcGFyZW50aGVzaXMgcmVxdWlyZWQgKi9cbiAgICAgICAgICAgICYmICFpc190b2tlbihsZWZ0LnN0YXJ0LCBcInB1bmNcIiwgXCIoXCIpXG4gICAgICAgICAgICAmJiBsZWZ0Lm9wZXJhdG9yICE9PSBcIi0tXCIgJiYgbGVmdC5vcGVyYXRvciAhPT0gXCIrK1wiKVxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQobGVmdC5zdGFydCk7XG4gICAgICAgIHZhciBwcmVjID0gb3AgIT0gbnVsbCA/IFBSRUNFREVOQ0Vbb3BdIDogbnVsbDtcbiAgICAgICAgaWYgKHByZWMgIT0gbnVsbCAmJiAocHJlYyA+IG1pbl9wcmVjIHx8IChvcCA9PT0gXCIqKlwiICYmIG1pbl9wcmVjID09PSBwcmVjKSkpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IGV4cHJfb3BzKG5vX2luLCBwcmVjLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBleHByX29wKG5ldyBBU1RfQmluYXJ5KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICA6IGxlZnQuc3RhcnQsXG4gICAgICAgICAgICAgICAgbGVmdCAgICAgOiBsZWZ0LFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogb3AsXG4gICAgICAgICAgICAgICAgcmlnaHQgICAgOiByaWdodCxcbiAgICAgICAgICAgICAgICBlbmQgICAgICA6IHJpZ2h0LmVuZFxuICAgICAgICAgICAgfSksIG1pbl9wcmVjLCBub19pbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4cHJfb3BzKG5vX2luLCBtaW5fcHJlYywgYWxsb3dfY2FsbHMsIGFsbG93X2Fycm93cykge1xuICAgICAgICAvLyBtYXliZV91bmFyeSB3b24ndCByZXR1cm4gdXMgYSBBU1RfU3ltYm9sUHJpdmF0ZVByb3BlcnR5XG4gICAgICAgIGlmICghbm9faW4gJiYgbWluX3ByZWMgPCBQUkVDRURFTkNFW1wiaW5cIl0gJiYgaXMoXCJwcml2YXRlbmFtZVwiKSkge1xuICAgICAgICAgICAgaWYoIVMuaW5fY2xhc3MpIHtcbiAgICAgICAgICAgICAgICBjcm9hayhcIlByaXZhdGUgZmllbGQgbXVzdCBiZSB1c2VkIGluIGFuIGVuY2xvc2luZyBjbGFzc1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IEFTVF9TeW1ib2xQcml2YXRlUHJvcGVydHkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIG5hbWU6IHN0YXJ0LnZhbHVlLFxuICAgICAgICAgICAgICAgIGVuZDogc3RhcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgZXhwZWN0X3Rva2VuKFwib3BlcmF0b3JcIiwgXCJpblwiKTtcblxuICAgICAgICAgICAgY29uc3QgcHJpdmF0ZV9pbiA9IG5ldyBBU1RfUHJpdmF0ZUluKHtcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4cHJfb3BzKG5vX2luLCBQUkVDRURFTkNFW1wiaW5cIl0sIHRydWUpLFxuICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGV4cHJfb3AocHJpdmF0ZV9pbiwgMCwgbm9faW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJfb3AobWF5YmVfdW5hcnkoYWxsb3dfY2FsbHMsIGFsbG93X2Fycm93cyksIG1pbl9wcmVjLCBub19pbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWF5YmVfY29uZGl0aW9uYWwgPSBmdW5jdGlvbihub19pbikge1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICB2YXIgZXhwciA9IGV4cHJfb3BzKG5vX2luLCAwLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI/XCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgeWVzID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ29uZGl0aW9uYWwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uICAgOiBleHByLFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQgIDogeWVzLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlIDogZXhwcmVzc2lvbihmYWxzZSwgbm9faW4pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNfYXNzaWduYWJsZShleHByKSB7XG4gICAgICAgIHJldHVybiBleHByIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgfHwgZXhwciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9fZGVzdHJ1Y3R1cmluZyhub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdCkge1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBBU1RfRGVzdHJ1Y3R1cmluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuc3RhcnQsXG4gICAgICAgICAgICAgICAgbmFtZXM6IG5vZGUucHJvcGVydGllcy5tYXAodG9fZGVzdHJ1Y3R1cmluZyksXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVuZDogbm9kZS5lbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFsbG93IGV4cGFuc2lvbiBhcyBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5lbGVtZW50c1tpXSBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxICE9PSBub2RlLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5fZXJyb3Iobm9kZS5lbGVtZW50c1tpXS5zdGFydCwgXCJTcHJlYWQgbXVzdCB0aGUgYmUgbGFzdCBlbGVtZW50IGluIGRlc3RydWN0dXJpbmcgYXJyYXlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5lbGVtZW50c1tpXS5leHByZXNzaW9uID0gdG9fZGVzdHJ1Y3R1cmluZyhub2RlLmVsZW1lbnRzW2ldLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2godG9fZGVzdHJ1Y3R1cmluZyhub2RlLmVsZW1lbnRzW2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBuZXcgQVNUX0Rlc3RydWN0dXJpbmcoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIG5hbWVzOiBuYW1lcyxcbiAgICAgICAgICAgICAgICBpc19hcnJheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdFByb3BlcnR5KSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gdG9fZGVzdHJ1Y3R1cmluZyhub2RlLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBBU1RfRGVmYXVsdEFzc2lnbih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuc3RhcnQsXG4gICAgICAgICAgICAgICAgbGVmdDogbm9kZS5sZWZ0LFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICByaWdodDogbm9kZS5yaWdodCxcbiAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvLyBJbiBFUzYsIEFzc2lnbm1lbnRFeHByZXNzaW9uIGNhbiBhbHNvIGJlIGFuIEFycm93RnVuY3Rpb25cbiAgICB2YXIgbWF5YmVfYXNzaWduID0gZnVuY3Rpb24obm9faW4pIHtcbiAgICAgICAgaGFuZGxlX3JlZ2V4cCgpO1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuXG4gICAgICAgIGlmIChzdGFydC50eXBlID09IFwibmFtZVwiICYmIHN0YXJ0LnZhbHVlID09IFwieWllbGRcIikge1xuICAgICAgICAgICAgaWYgKGlzX2luX2dlbmVyYXRvcigpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfeWllbGRfZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChTLmlucHV0Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IoUy50b2tlbiwgXCJVbmV4cGVjdGVkIHlpZWxkIGlkZW50aWZpZXIgaW5zaWRlIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlZnQgPSBtYXliZV9jb25kaXRpb25hbChub19pbik7XG4gICAgICAgIHZhciB2YWwgPSBTLnRva2VuLnZhbHVlO1xuXG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIpICYmIEFTU0lHTk1FTlQuaGFzKHZhbCkpIHtcbiAgICAgICAgICAgIGlmIChpc19hc3NpZ25hYmxlKGxlZnQpIHx8IChsZWZ0ID0gdG9fZGVzdHJ1Y3R1cmluZyhsZWZ0KSkgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZykge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Fzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogbWF5YmVfYXNzaWduKG5vX2luKSxcbiAgICAgICAgICAgICAgICAgICAgbG9naWNhbCAgOiBMT0dJQ0FMX0FTU0lHTk1FTlQuaGFzKHZhbCksXG4gICAgICAgICAgICAgICAgICAgIGVuZCAgICAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcm9hayhcIkludmFsaWQgYXNzaWdubWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9O1xuXG4gICAgdmFyIHRvX2V4cHJfb3Jfc2VxdWVuY2UgPSBmdW5jdGlvbihzdGFydCwgZXhwcnMpIHtcbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cHJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1NlcXVlbmNlKHsgc3RhcnQsIGV4cHJlc3Npb25zOiBleHBycywgZW5kOiBwZWVrKCkgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcm9hayhcIkludmFsaWQgcGFyZW50aGVzaXplZCBleHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBleHByZXNzaW9uID0gZnVuY3Rpb24oY29tbWFzLCBub19pbikge1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICB2YXIgZXhwcnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGV4cHJzLnB1c2gobWF5YmVfYXNzaWduKG5vX2luKSk7XG4gICAgICAgICAgICBpZiAoIWNvbW1hcyB8fCAhaXMoXCJwdW5jXCIsIFwiLFwiKSkgYnJlYWs7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBjb21tYXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b19leHByX29yX3NlcXVlbmNlKHN0YXJ0LCBleHBycyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGluX2xvb3AoY29udCkge1xuICAgICAgICArK1MuaW5fbG9vcDtcbiAgICAgICAgdmFyIHJldCA9IGNvbnQoKTtcbiAgICAgICAgLS1TLmluX2xvb3A7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbih0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uIHBhcnNlX3RvcGxldmVsKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICB2YXIgYm9keSA9IFtdO1xuICAgICAgICBTLmlucHV0LnB1c2hfZGlyZWN0aXZlc19zdGFjaygpO1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGUpIFMuaW5wdXQuYWRkX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIik7XG4gICAgICAgIHdoaWxlICghaXMoXCJlb2ZcIikpIHtcbiAgICAgICAgICAgIGJvZHkucHVzaChzdGF0ZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgUy5pbnB1dC5wb3BfZGlyZWN0aXZlc19zdGFjaygpO1xuICAgICAgICB2YXIgZW5kID0gcHJldigpO1xuICAgICAgICB2YXIgdG9wbGV2ZWwgPSBvcHRpb25zLnRvcGxldmVsO1xuICAgICAgICBpZiAodG9wbGV2ZWwpIHtcbiAgICAgICAgICAgIHRvcGxldmVsLmJvZHkgPSB0b3BsZXZlbC5ib2R5LmNvbmNhdChib2R5KTtcbiAgICAgICAgICAgIHRvcGxldmVsLmVuZCA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcGxldmVsID0gbmV3IEFTVF9Ub3BsZXZlbCh7IHN0YXJ0OiBzdGFydCwgYm9keTogYm9keSwgZW5kOiBlbmQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgVEVNUExBVEVfUkFXUyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIHRvcGxldmVsO1xuICAgIH0pKCk7XG5cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5mdW5jdGlvbiBERUZOT0RFKHR5cGUsIHByb3BzLCBjdG9yLCBtZXRob2RzLCBiYXNlID0gQVNUX05vZGUpIHtcbiAgICBpZiAoIXByb3BzKSBwcm9wcyA9IFtdO1xuICAgIGVsc2UgcHJvcHMgPSBwcm9wcy5zcGxpdCgvXFxzKy8pO1xuICAgIHZhciBzZWxmX3Byb3BzID0gcHJvcHM7XG4gICAgaWYgKGJhc2UgJiYgYmFzZS5QUk9QUylcbiAgICAgICAgcHJvcHMgPSBwcm9wcy5jb25jYXQoYmFzZS5QUk9QUyk7XG4gICAgY29uc3QgcHJvdG8gPSBiYXNlICYmIE9iamVjdC5jcmVhdGUoYmFzZS5wcm90b3R5cGUpO1xuICAgIGlmIChwcm90bykge1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICBjdG9yLkJBU0UgPSBiYXNlO1xuICAgIH1cbiAgICBpZiAoYmFzZSkgYmFzZS5TVUJDTEFTU0VTLnB1c2goY3Rvcik7XG4gICAgY3Rvci5wcm90b3R5cGUuQ1RPUiA9IGN0b3I7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICAgIGN0b3IuUFJPUFMgPSBwcm9wcyB8fCBudWxsO1xuICAgIGN0b3IuU0VMRl9QUk9QUyA9IHNlbGZfcHJvcHM7XG4gICAgY3Rvci5TVUJDTEFTU0VTID0gW107XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUuVFlQRSA9IGN0b3IuVFlQRSA9IHR5cGU7XG4gICAgfVxuICAgIGlmIChtZXRob2RzKSBmb3IgKGxldCBpIGluIG1ldGhvZHMpIGlmIChIT1AobWV0aG9kcywgaSkpIHtcbiAgICAgICAgaWYgKGlbMF0gPT09IFwiJFwiKSB7XG4gICAgICAgICAgICBjdG9yW2kuc3Vic3RyKDEpXSA9IG1ldGhvZHNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZVtpXSA9IG1ldGhvZHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3Rvci5ERUZNRVRIT0QgPSBmdW5jdGlvbihuYW1lLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbiAgICByZXR1cm4gY3Rvcjtcbn1cblxuY29uc3QgaGFzX3Rva19mbGFnID0gKHRvaywgZmxhZykgPT4gQm9vbGVhbih0b2suZmxhZ3MgJiBmbGFnKTtcbmNvbnN0IHNldF90b2tfZmxhZyA9ICh0b2ssIGZsYWcsIHRydXRoKSA9PiB7XG4gICAgaWYgKHRydXRoKSB7XG4gICAgICAgIHRvay5mbGFncyB8PSBmbGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRvay5mbGFncyAmPSB+ZmxhZztcbiAgICB9XG59O1xuXG5jb25zdCBUT0tfRkxBR19OTEIgICAgICAgICAgPSAwYjAwMDE7XG5jb25zdCBUT0tfRkxBR19RVU9URV9TSU5HTEUgPSAwYjAwMTA7XG5jb25zdCBUT0tfRkxBR19RVU9URV9FWElTVFMgPSAwYjAxMDA7XG5jb25zdCBUT0tfRkxBR19URU1QTEFURV9FTkQgPSAwYjEwMDA7XG5cbmNsYXNzIEFTVF9Ub2tlbiB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgdmFsdWUsIGxpbmUsIGNvbCwgcG9zLCBubGIsIGNvbW1lbnRzX2JlZm9yZSwgY29tbWVudHNfYWZ0ZXIsIGZpbGUpIHtcbiAgICAgICAgdGhpcy5mbGFncyA9IChubGIgPyAxIDogMCk7XG5cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuY29tbWVudHNfYmVmb3JlID0gY29tbWVudHNfYmVmb3JlO1xuICAgICAgICB0aGlzLmNvbW1lbnRzX2FmdGVyID0gY29tbWVudHNfYWZ0ZXI7XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG5cbiAgICAgICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgc3RyaW5nIHN1bW1hcnkgb2YgdGhlIHRva2VuIGZvciBub2RlLmpzIGNvbnNvbGUubG9nXG4gICAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oX2RlcHRoLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNwZWNpYWwgPSBzdHIgPT4gb3B0aW9ucy5zdHlsaXplKHN0ciwgXCJzcGVjaWFsXCIpO1xuICAgICAgICBjb25zdCBxdW90ZSA9IHR5cGVvZiB0aGlzLnZhbHVlID09PSBcInN0cmluZ1wiICYmIHRoaXMudmFsdWUuaW5jbHVkZXMoXCJgXCIpID8gXCInXCIgOiBcImBcIjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBgJHtxdW90ZX0ke3RoaXMudmFsdWV9JHtxdW90ZX1gO1xuICAgICAgICByZXR1cm4gYCR7c3BlY2lhbChcIltBU1RfVG9rZW5cIil9ICR7dmFsdWV9IGF0ICR7dGhpcy5saW5lfToke3RoaXMuY29sfSR7c3BlY2lhbChcIl1cIil9YDtcbiAgICB9XG5cbiAgICBnZXQgbmxiKCkge1xuICAgICAgICByZXR1cm4gaGFzX3Rva19mbGFnKHRoaXMsIFRPS19GTEFHX05MQik7XG4gICAgfVxuXG4gICAgc2V0IG5sYihuZXdfbmxiKSB7XG4gICAgICAgIHNldF90b2tfZmxhZyh0aGlzLCBUT0tfRkxBR19OTEIsIG5ld19ubGIpO1xuICAgIH1cblxuICAgIGdldCBxdW90ZSgpIHtcbiAgICAgICAgcmV0dXJuICFoYXNfdG9rX2ZsYWcodGhpcywgVE9LX0ZMQUdfUVVPVEVfRVhJU1RTKVxuICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICA6IChoYXNfdG9rX2ZsYWcodGhpcywgVE9LX0ZMQUdfUVVPVEVfU0lOR0xFKSA/IFwiJ1wiIDogJ1wiJyk7XG4gICAgfVxuXG4gICAgc2V0IHF1b3RlKHF1b3RlX3R5cGUpIHtcbiAgICAgICAgc2V0X3Rva19mbGFnKHRoaXMsIFRPS19GTEFHX1FVT1RFX1NJTkdMRSwgcXVvdGVfdHlwZSA9PT0gXCInXCIpO1xuICAgICAgICBzZXRfdG9rX2ZsYWcodGhpcywgVE9LX0ZMQUdfUVVPVEVfRVhJU1RTLCAhIXF1b3RlX3R5cGUpO1xuICAgIH1cblxuICAgIGdldCB0ZW1wbGF0ZV9lbmQoKSB7XG4gICAgICAgIHJldHVybiBoYXNfdG9rX2ZsYWcodGhpcywgVE9LX0ZMQUdfVEVNUExBVEVfRU5EKTtcbiAgICB9XG5cbiAgICBzZXQgdGVtcGxhdGVfZW5kKG5ld190ZW1wbGF0ZV9lbmQpIHtcbiAgICAgICAgc2V0X3Rva19mbGFnKHRoaXMsIFRPS19GTEFHX1RFTVBMQVRFX0VORCwgbmV3X3RlbXBsYXRlX2VuZCk7XG4gICAgfVxufVxuXG52YXIgQVNUX05vZGUgPSBERUZOT0RFKFwiTm9kZVwiLCBcInN0YXJ0IGVuZFwiLCBmdW5jdGlvbiBBU1RfTm9kZShwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgIF9jbG9uZTogZnVuY3Rpb24oZGVlcCkge1xuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2xvbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5DVE9SKHRoaXMpO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGRlZXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lKGRlZXApO1xuICAgIH0sXG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBvZiBhbGwgQVNUIG5vZGVzXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgc3RhcnQ6IFwiW0FTVF9Ub2tlbl0gVGhlIGZpcnN0IHRva2VuIG9mIHRoaXMgbm9kZVwiLFxuICAgICAgICBlbmQ6IFwiW0FTVF9Ub2tlbl0gVGhlIGxhc3QgdG9rZW4gb2YgdGhpcyBub2RlXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzKTtcbiAgICB9LFxuICAgIHdhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhbGsodmlzaXRvcik7IC8vIG5vdCBzdXJlIHRoZSBpbmRpcmVjdGlvbiB3aWxsIGJlIGFueSBoZWxwXG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzOiAoKSA9PiB7fVxufSwgbnVsbCk7XG5cbi8qIC0tLS0tWyBzdGF0ZW1lbnRzIF0tLS0tLSAqL1xuXG52YXIgQVNUX1N0YXRlbWVudCA9IERFRk5PREUoXCJTdGF0ZW1lbnRcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1N0YXRlbWVudChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3Mgb2YgYWxsIHN0YXRlbWVudHNcIixcbn0pO1xuXG52YXIgQVNUX0RlYnVnZ2VyID0gREVGTk9ERShcIkRlYnVnZ2VyXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9EZWJ1Z2dlcihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlJlcHJlc2VudHMgYSBkZWJ1Z2dlciBzdGF0ZW1lbnRcIixcbn0sIEFTVF9TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX0RpcmVjdGl2ZSA9IERFRk5PREUoXCJEaXJlY3RpdmVcIiwgXCJ2YWx1ZSBxdW90ZVwiLCBmdW5jdGlvbiBBU1RfRGlyZWN0aXZlKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5xdW90ZSA9IHByb3BzLnF1b3RlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlJlcHJlc2VudHMgYSBkaXJlY3RpdmUsIGxpa2UgXFxcInVzZSBzdHJpY3RcXFwiO1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIltzdHJpbmddIFRoZSB2YWx1ZSBvZiB0aGlzIGRpcmVjdGl2ZSBhcyBhIHBsYWluIHN0cmluZyAoaXQncyBub3QgYW4gQVNUX1N0cmluZyEpXCIsXG4gICAgICAgIHF1b3RlOiBcIltzdHJpbmddIHRoZSBvcmlnaW5hbCBxdW90ZSBjaGFyYWN0ZXJcIlxuICAgIH0sXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9TaW1wbGVTdGF0ZW1lbnQgPSBERUZOT0RFKFwiU2ltcGxlU3RhdGVtZW50XCIsIFwiYm9keVwiLCBmdW5jdGlvbiBBU1RfU2ltcGxlU3RhdGVtZW50KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBzdGF0ZW1lbnQgY29uc2lzdGluZyBvZiBhbiBleHByZXNzaW9uLCBpLmUuIGEgPSAxICsgMlwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9Ob2RlXSBhbiBleHByZXNzaW9uIG5vZGUgKHNob3VsZCBub3QgYmUgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5ib2R5KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50KTtcblxuZnVuY3Rpb24gd2Fsa19ib2R5KG5vZGUsIHZpc2l0b3IpIHtcbiAgICBjb25zdCBib2R5ID0gbm9kZS5ib2R5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGJvZHlbaV0uX3dhbGsodmlzaXRvcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZV9ibG9ja19zY29wZShkZWVwKSB7XG4gICAgdmFyIGNsb25lID0gdGhpcy5fY2xvbmUoZGVlcCk7XG4gICAgaWYgKHRoaXMuYmxvY2tfc2NvcGUpIHtcbiAgICAgICAgY2xvbmUuYmxvY2tfc2NvcGUgPSB0aGlzLmJsb2NrX3Njb3BlLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cblxudmFyIEFTVF9CbG9jayA9IERFRk5PREUoXCJCbG9ja1wiLCBcImJvZHkgYmxvY2tfc2NvcGVcIiwgZnVuY3Rpb24gQVNUX0Jsb2NrKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGJvZHkgb2Ygc3RhdGVtZW50cyAodXN1YWxseSBicmFjZWQpXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgYm9keTogXCJbQVNUX1N0YXRlbWVudCpdIGFuIGFycmF5IG9mIHN0YXRlbWVudHNcIixcbiAgICAgICAgYmxvY2tfc2NvcGU6IFwiW0FTVF9TY29wZV0gdGhlIGJsb2NrIHNjb3BlXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHdhbGtfYm9keSh0aGlzLCB2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmJvZHkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMuYm9keVtpXSk7XG4gICAgfSxcbiAgICBjbG9uZTogY2xvbmVfYmxvY2tfc2NvcGVcbn0sIEFTVF9TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX0Jsb2NrU3RhdGVtZW50ID0gREVGTk9ERShcIkJsb2NrU3RhdGVtZW50XCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9CbG9ja1N0YXRlbWVudChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmJvZHkgPSBwcm9wcy5ib2R5O1xuICAgICAgICB0aGlzLmJsb2NrX3Njb3BlID0gcHJvcHMuYmxvY2tfc2NvcGU7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBibG9jayBzdGF0ZW1lbnRcIixcbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfRW1wdHlTdGF0ZW1lbnQgPSBERUZOT0RFKFwiRW1wdHlTdGF0ZW1lbnRcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX0VtcHR5U3RhdGVtZW50KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGVtcHR5IHN0YXRlbWVudCAoZW1wdHkgYmxvY2sgb3Igc2ltcGx5IGEgc2VtaWNvbG9uKVwiXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9TdGF0ZW1lbnRXaXRoQm9keSA9IERFRk5PREUoXCJTdGF0ZW1lbnRXaXRoQm9keVwiLCBcImJvZHlcIiwgZnVuY3Rpb24gQVNUX1N0YXRlbWVudFdpdGhCb2R5KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYWxsIHN0YXRlbWVudHMgdGhhdCBjb250YWluIG9uZSBuZXN0ZWQgYm9keTogYEZvcmAsIGBGb3JJbmAsIGBEb2AsIGBXaGlsZWAsIGBXaXRoYFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9TdGF0ZW1lbnRdIHRoZSBib2R5OyB0aGlzIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCwgZXZlbiBpZiBpdCdzIGFuIEFTVF9FbXB0eVN0YXRlbWVudFwiXG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfTGFiZWxlZFN0YXRlbWVudCA9IERFRk5PREUoXCJMYWJlbGVkU3RhdGVtZW50XCIsIFwibGFiZWxcIiwgZnVuY3Rpb24gQVNUX0xhYmVsZWRTdGF0ZW1lbnQocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHByb3BzLmxhYmVsO1xuICAgICAgICB0aGlzLmJvZHkgPSBwcm9wcy5ib2R5O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN0YXRlbWVudCB3aXRoIGEgbGFiZWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsYWJlbDogXCJbQVNUX0xhYmVsXSBhIGxhYmVsIGRlZmluaXRpb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmJvZHkpO1xuICAgICAgICBwdXNoKHRoaXMubGFiZWwpO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGRlZXApIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jbG9uZShkZWVwKTtcbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IG5vZGUubGFiZWw7XG4gICAgICAgICAgICB2YXIgZGVmID0gdGhpcy5sYWJlbDtcbiAgICAgICAgICAgIG5vZGUud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2xcbiAgICAgICAgICAgICAgICAgICAgJiYgbm9kZS5sYWJlbCAmJiBub2RlLmxhYmVsLnRoZWRlZiA9PT0gZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGFiZWwudGhlZGVmID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnJlZmVyZW5jZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudFdpdGhCb2R5KTtcblxudmFyIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQgPSBERUZOT0RFKFxuICAgIFwiSXRlcmF0aW9uU3RhdGVtZW50XCIsXG4gICAgXCJibG9ja19zY29wZVwiLFxuICAgIGZ1bmN0aW9uIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrX3Njb3BlID0gcHJvcHMuYmxvY2tfc2NvcGU7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBwcm9wcy5ib2R5O1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZsYWdzID0gMDtcbiAgICB9LFxuICAgIHtcbiAgICAgICAgJGRvY3VtZW50YXRpb246IFwiSW50ZXJuYWwgY2xhc3MuICBBbGwgbG9vcHMgaW5oZXJpdCBmcm9tIGl0LlwiLFxuICAgICAgICAkcHJvcGRvYzoge1xuICAgICAgICAgICAgYmxvY2tfc2NvcGU6IFwiW0FTVF9TY29wZV0gdGhlIGJsb2NrIHNjb3BlIGZvciB0aGlzIGl0ZXJhdGlvbiBzdGF0ZW1lbnQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmU6IGNsb25lX2Jsb2NrX3Njb3BlXG4gICAgfSxcbiAgICBBU1RfU3RhdGVtZW50V2l0aEJvZHlcbik7XG5cbnZhciBBU1RfRFdMb29wID0gREVGTk9ERShcIkRXTG9vcFwiLCBcImNvbmRpdGlvblwiLCBmdW5jdGlvbiBBU1RfRFdMb29wKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gcHJvcHMuY29uZGl0aW9uO1xuICAgICAgICB0aGlzLmJsb2NrX3Njb3BlID0gcHJvcHMuYmxvY2tfc2NvcGU7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgZG8vd2hpbGUgc3RhdGVtZW50c1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGNvbmRpdGlvbjogXCJbQVNUX05vZGVdIHRoZSBsb29wIGNvbmRpdGlvbi4gIFNob3VsZCBub3QgYmUgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50XCJcbiAgICB9XG59LCBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KTtcblxudmFyIEFTVF9EbyA9IERFRk5PREUoXCJEb1wiLCBudWxsLCBmdW5jdGlvbiBBU1RfRG8ocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBwcm9wcy5jb25kaXRpb247XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBkb2Agc3RhdGVtZW50XCIsXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5jb25kaXRpb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5jb25kaXRpb24pO1xuICAgICAgICBwdXNoKHRoaXMuYm9keSk7XG4gICAgfVxufSwgQVNUX0RXTG9vcCk7XG5cbnZhciBBU1RfV2hpbGUgPSBERUZOT0RFKFwiV2hpbGVcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1doaWxlKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gcHJvcHMuY29uZGl0aW9uO1xuICAgICAgICB0aGlzLmJsb2NrX3Njb3BlID0gcHJvcHMuYmxvY2tfc2NvcGU7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgd2hpbGVgIHN0YXRlbWVudFwiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBwdXNoKHRoaXMuYm9keSk7XG4gICAgICAgIHB1c2godGhpcy5jb25kaXRpb24pO1xuICAgIH0sXG59LCBBU1RfRFdMb29wKTtcblxudmFyIEFTVF9Gb3IgPSBERUZOT0RFKFwiRm9yXCIsIFwiaW5pdCBjb25kaXRpb24gc3RlcFwiLCBmdW5jdGlvbiBBU1RfRm9yKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuaW5pdCA9IHByb3BzLmluaXQ7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gcHJvcHMuY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnN0ZXAgPSBwcm9wcy5zdGVwO1xuICAgICAgICB0aGlzLmJsb2NrX3Njb3BlID0gcHJvcHMuYmxvY2tfc2NvcGU7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZm9yYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBpbml0OiBcIltBU1RfTm9kZT9dIHRoZSBgZm9yYCBpbml0aWFsaXphdGlvbiBjb2RlLCBvciBudWxsIGlmIGVtcHR5XCIsXG4gICAgICAgIGNvbmRpdGlvbjogXCJbQVNUX05vZGU/XSB0aGUgYGZvcmAgdGVybWluYXRpb24gY2xhdXNlLCBvciBudWxsIGlmIGVtcHR5XCIsXG4gICAgICAgIHN0ZXA6IFwiW0FTVF9Ob2RlP10gdGhlIGBmb3JgIHVwZGF0ZSBjbGF1c2UsIG9yIG51bGwgaWYgZW1wdHlcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdCkgdGhpcy5pbml0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uKSB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZXApIHRoaXMuc3RlcC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmJvZHkpO1xuICAgICAgICBpZiAodGhpcy5zdGVwKSBwdXNoKHRoaXMuc3RlcCk7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbikgcHVzaCh0aGlzLmNvbmRpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmluaXQpIHB1c2godGhpcy5pbml0KTtcbiAgICB9LFxufSwgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCk7XG5cbnZhciBBU1RfRm9ySW4gPSBERUZOT0RFKFwiRm9ySW5cIiwgXCJpbml0IG9iamVjdFwiLCBmdW5jdGlvbiBBU1RfRm9ySW4ocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5pbml0ID0gcHJvcHMuaW5pdDtcbiAgICAgICAgdGhpcy5vYmplY3QgPSBwcm9wcy5vYmplY3Q7XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBmb3IgLi4uIGluYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBpbml0OiBcIltBU1RfTm9kZV0gdGhlIGBmb3IvaW5gIGluaXRpYWxpemF0aW9uIGNvZGVcIixcbiAgICAgICAgb2JqZWN0OiBcIltBU1RfTm9kZV0gdGhlIG9iamVjdCB0aGF0IHdlJ3JlIGxvb3BpbmcgdGhyb3VnaFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLm9iamVjdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmJvZHkpO1xuICAgICAgICBpZiAodGhpcy5vYmplY3QpIHB1c2godGhpcy5vYmplY3QpO1xuICAgICAgICBpZiAodGhpcy5pbml0KSBwdXNoKHRoaXMuaW5pdCk7XG4gICAgfSxcbn0sIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX0Zvck9mID0gREVGTk9ERShcIkZvck9mXCIsIFwiYXdhaXRcIiwgZnVuY3Rpb24gQVNUX0Zvck9mKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuYXdhaXQgPSBwcm9wcy5hd2FpdDtcbiAgICAgICAgdGhpcy5pbml0ID0gcHJvcHMuaW5pdDtcbiAgICAgICAgdGhpcy5vYmplY3QgPSBwcm9wcy5vYmplY3Q7XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBmb3IgLi4uIG9mYCBzdGF0ZW1lbnRcIixcbn0sIEFTVF9Gb3JJbik7XG5cbnZhciBBU1RfV2l0aCA9IERFRk5PREUoXCJXaXRoXCIsIFwiZXhwcmVzc2lvblwiLCBmdW5jdGlvbiBBU1RfV2l0aChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBwcm9wcy5leHByZXNzaW9uO1xuICAgICAgICB0aGlzLmJvZHkgPSBwcm9wcy5ib2R5O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHdpdGhgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSB0aGUgYHdpdGhgIGV4cHJlc3Npb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBwdXNoKHRoaXMuYm9keSk7XG4gICAgICAgIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9LFxufSwgQVNUX1N0YXRlbWVudFdpdGhCb2R5KTtcblxuLyogLS0tLS1bIHNjb3BlIGFuZCBmdW5jdGlvbnMgXS0tLS0tICovXG5cbnZhciBBU1RfU2NvcGUgPSBERUZOT0RFKFxuICAgIFwiU2NvcGVcIixcbiAgICBcInZhcmlhYmxlcyB1c2VzX3dpdGggdXNlc19ldmFsIHBhcmVudF9zY29wZSBlbmNsb3NlZCBjbmFtZVwiLFxuICAgIGZ1bmN0aW9uIEFTVF9TY29wZShwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzID0gcHJvcHMudmFyaWFibGVzO1xuICAgICAgICAgICAgdGhpcy51c2VzX3dpdGggPSBwcm9wcy51c2VzX3dpdGg7XG4gICAgICAgICAgICB0aGlzLnVzZXNfZXZhbCA9IHByb3BzLnVzZXNfZXZhbDtcbiAgICAgICAgICAgIHRoaXMucGFyZW50X3Njb3BlID0gcHJvcHMucGFyZW50X3Njb3BlO1xuICAgICAgICAgICAgdGhpcy5lbmNsb3NlZCA9IHByb3BzLmVuY2xvc2VkO1xuICAgICAgICAgICAgdGhpcy5jbmFtZSA9IHByb3BzLmNuYW1lO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgfSxcbiAgICB7XG4gICAgICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGFsbCBzdGF0ZW1lbnRzIGludHJvZHVjaW5nIGEgbGV4aWNhbCBzY29wZVwiLFxuICAgICAgICAkcHJvcGRvYzoge1xuICAgICAgICAgICAgdmFyaWFibGVzOiBcIltNYXAvU10gYSBtYXAgb2YgbmFtZSAtPiBTeW1ib2xEZWYgZm9yIGFsbCB2YXJpYWJsZXMvZnVuY3Rpb25zIGRlZmluZWQgaW4gdGhpcyBzY29wZVwiLFxuICAgICAgICAgICAgdXNlc193aXRoOiBcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBzY29wZSB1c2VzIHRoZSBgd2l0aGAgc3RhdGVtZW50XCIsXG4gICAgICAgICAgICB1c2VzX2V2YWw6IFwiW2Jvb2xlYW4vU10gdGVsbHMgd2hldGhlciB0aGlzIHNjb3BlIGNvbnRhaW5zIGEgZGlyZWN0IGNhbGwgdG8gdGhlIGdsb2JhbCBgZXZhbGBcIixcbiAgICAgICAgICAgIHBhcmVudF9zY29wZTogXCJbQVNUX1Njb3BlPy9TXSBsaW5rIHRvIHRoZSBwYXJlbnQgc2NvcGVcIixcbiAgICAgICAgICAgIGVuY2xvc2VkOiBcIltTeW1ib2xEZWYqL1NdIGEgbGlzdCBvZiBhbGwgc3ltYm9sIGRlZmluaXRpb25zIHRoYXQgYXJlIGFjY2Vzc2VkIGZyb20gdGhpcyBzY29wZSBvciBhbnkgc3Vic2NvcGVzXCIsXG4gICAgICAgICAgICBjbmFtZTogXCJbaW50ZWdlci9TXSBjdXJyZW50IGluZGV4IGZvciBtYW5nbGluZyB2YXJpYWJsZXMgKHVzZWQgaW50ZXJuYWxseSBieSB0aGUgbWFuZ2xlcilcIixcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0X2RlZnVuX3Njb3BlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChzZWxmLmlzX2Jsb2NrX3Njb3BlKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gc2VsZi5wYXJlbnRfc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKGRlZXAsIHRvcGxldmVsKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2Nsb25lKGRlZXApO1xuICAgICAgICAgICAgaWYgKGRlZXAgJiYgdGhpcy52YXJpYWJsZXMgJiYgdG9wbGV2ZWwgJiYgIXRoaXMuX2Jsb2NrX3Njb3BlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5maWd1cmVfb3V0X3Njb3BlKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGxldmVsOiB0b3BsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50X3Njb3BlOiB0aGlzLnBhcmVudF9zY29wZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YXJpYWJsZXMpIG5vZGUudmFyaWFibGVzID0gbmV3IE1hcCh0aGlzLnZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5jbG9zZWQpIG5vZGUuZW5jbG9zZWQgPSB0aGlzLmVuY2xvc2VkLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Jsb2NrX3Njb3BlKSBub2RlLl9ibG9ja19zY29wZSA9IHRoaXMuX2Jsb2NrX3Njb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIHBpbm5lZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2VzX2V2YWwgfHwgdGhpcy51c2VzX3dpdGg7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIEFTVF9CbG9ja1xuKTtcblxudmFyIEFTVF9Ub3BsZXZlbCA9IERFRk5PREUoXCJUb3BsZXZlbFwiLCBcImdsb2JhbHNcIiwgZnVuY3Rpb24gQVNUX1RvcGxldmVsKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IHByb3BzLmdsb2JhbHM7XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gcHJvcHMudmFyaWFibGVzO1xuICAgICAgICB0aGlzLnVzZXNfd2l0aCA9IHByb3BzLnVzZXNfd2l0aDtcbiAgICAgICAgdGhpcy51c2VzX2V2YWwgPSBwcm9wcy51c2VzX2V2YWw7XG4gICAgICAgIHRoaXMucGFyZW50X3Njb3BlID0gcHJvcHMucGFyZW50X3Njb3BlO1xuICAgICAgICB0aGlzLmVuY2xvc2VkID0gcHJvcHMuZW5jbG9zZWQ7XG4gICAgICAgIHRoaXMuY25hbWUgPSBwcm9wcy5jbmFtZTtcbiAgICAgICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICAgICAgdGhpcy5ibG9ja19zY29wZSA9IHByb3BzLmJsb2NrX3Njb3BlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSB0b3BsZXZlbCBzY29wZVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGdsb2JhbHM6IFwiW01hcC9TXSBhIG1hcCBvZiBuYW1lIC0+IFN5bWJvbERlZiBmb3IgYWxsIHVuZGVjbGFyZWQgbmFtZXNcIixcbiAgICB9LFxuICAgIHdyYXBfY29tbW9uanM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLmJvZHk7XG4gICAgICAgIHZhciB3cmFwcGVkX3RsID0gXCIoZnVuY3Rpb24oZXhwb3J0cyl7JyRPUklHJzt9KSh0eXBlb2YgXCIgKyBuYW1lICsgXCI9PSd1bmRlZmluZWQnPyhcIiArIG5hbWUgKyBcIj17fSk6XCIgKyBuYW1lICsgXCIpO1wiO1xuICAgICAgICB3cmFwcGVkX3RsID0gcGFyc2Uod3JhcHBlZF90bCk7XG4gICAgICAgIHdyYXBwZWRfdGwgPSB3cmFwcGVkX3RsLnRyYW5zZm9ybShuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RpcmVjdGl2ZSAmJiBub2RlLnZhbHVlID09IFwiJE9SSUdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNQVAuc3BsaWNlKGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB3cmFwcGVkX3RsO1xuICAgIH0sXG4gICAgd3JhcF9lbmNsb3NlOiBmdW5jdGlvbihhcmdzX3ZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NfdmFsdWVzICE9IFwic3RyaW5nXCIpIGFyZ3NfdmFsdWVzID0gXCJcIjtcbiAgICAgICAgdmFyIGluZGV4ID0gYXJnc192YWx1ZXMuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gYXJnc192YWx1ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMuYm9keTtcbiAgICAgICAgcmV0dXJuIHBhcnNlKFtcbiAgICAgICAgICAgIFwiKGZ1bmN0aW9uKFwiLFxuICAgICAgICAgICAgYXJnc192YWx1ZXMuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgICAgJyl7XCIkT1JJR1wifSkoJyxcbiAgICAgICAgICAgIGFyZ3NfdmFsdWVzLnNsaWNlKGluZGV4ICsgMSksXG4gICAgICAgICAgICBcIilcIlxuICAgICAgICBdLmpvaW4oXCJcIikpLnRyYW5zZm9ybShuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RpcmVjdGl2ZSAmJiBub2RlLnZhbHVlID09IFwiJE9SSUdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNQVAuc3BsaWNlKGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxufSwgQVNUX1Njb3BlKTtcblxudmFyIEFTVF9FeHBhbnNpb24gPSBERUZOT0RFKFwiRXhwYW5zaW9uXCIsIFwiZXhwcmVzc2lvblwiLCBmdW5jdGlvbiBBU1RfRXhwYW5zaW9uKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHByb3BzLmV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gZXhwYW5kaWJsZSBhcmd1bWVudCwgc3VjaCBhcyAuLi5yZXN0LCBhIHNwbGF0LCBzdWNoIGFzIFsxLDIsLi4uYWxsXSwgb3IgYW4gZXhwYW5zaW9uIGluIGEgdmFyaWFibGUgZGVjbGFyYXRpb24sIHN1Y2ggYXMgdmFyIFtmaXJzdCwgLi4ucmVzdF0gPSBsaXN0XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIHRoZSB0aGluZyB0byBiZSBleHBhbmRlZFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24ud2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmV4cHJlc3Npb24pO1xuICAgIH0sXG59KTtcblxudmFyIEFTVF9MYW1iZGEgPSBERUZOT0RFKFxuICAgIFwiTGFtYmRhXCIsXG4gICAgXCJuYW1lIGFyZ25hbWVzIHVzZXNfYXJndW1lbnRzIGlzX2dlbmVyYXRvciBhc3luY1wiLFxuICAgIGZ1bmN0aW9uIEFTVF9MYW1iZGEocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICAgICAgdGhpcy5hcmduYW1lcyA9IHByb3BzLmFyZ25hbWVzO1xuICAgICAgICAgICAgdGhpcy51c2VzX2FyZ3VtZW50cyA9IHByb3BzLnVzZXNfYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5pc19nZW5lcmF0b3IgPSBwcm9wcy5pc19nZW5lcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmFzeW5jID0gcHJvcHMuYXN5bmM7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHByb3BzLnZhcmlhYmxlcztcbiAgICAgICAgICAgIHRoaXMudXNlc193aXRoID0gcHJvcHMudXNlc193aXRoO1xuICAgICAgICAgICAgdGhpcy51c2VzX2V2YWwgPSBwcm9wcy51c2VzX2V2YWw7XG4gICAgICAgICAgICB0aGlzLnBhcmVudF9zY29wZSA9IHByb3BzLnBhcmVudF9zY29wZTtcbiAgICAgICAgICAgIHRoaXMuZW5jbG9zZWQgPSBwcm9wcy5lbmNsb3NlZDtcbiAgICAgICAgICAgIHRoaXMuY25hbWUgPSBwcm9wcy5jbmFtZTtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgICAgICB0aGlzLmJsb2NrX3Njb3BlID0gcHJvcHMuYmxvY2tfc2NvcGU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgIH0sXG4gICAge1xuICAgICAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBmdW5jdGlvbnNcIixcbiAgICAgICAgJHByb3Bkb2M6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiW0FTVF9TeW1ib2xEZWNsYXJhdGlvbj9dIHRoZSBuYW1lIG9mIHRoaXMgZnVuY3Rpb25cIixcbiAgICAgICAgICAgIGFyZ25hbWVzOiBcIltBU1RfU3ltYm9sRnVuYXJnfEFTVF9EZXN0cnVjdHVyaW5nfEFTVF9FeHBhbnNpb258QVNUX0RlZmF1bHRBc3NpZ24qXSBhcnJheSBvZiBmdW5jdGlvbiBhcmd1bWVudHMsIGRlc3RydWN0dXJpbmdzLCBvciBleHBhbmRpbmcgYXJndW1lbnRzXCIsXG4gICAgICAgICAgICB1c2VzX2FyZ3VtZW50czogXCJbYm9vbGVhbi9TXSB0ZWxscyB3aGV0aGVyIHRoaXMgZnVuY3Rpb24gYWNjZXNzZXMgdGhlIGFyZ3VtZW50cyBhcnJheVwiLFxuICAgICAgICAgICAgaXNfZ2VuZXJhdG9yOiBcIltib29sZWFuXSBpcyB0aGlzIGEgZ2VuZXJhdG9yIG1ldGhvZFwiLFxuICAgICAgICAgICAgYXN5bmM6IFwiW2Jvb2xlYW5dIGlzIHRoaXMgbWV0aG9kIGFzeW5jXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGFyZ3NfYXNfbmFtZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmduYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyZ25hbWVzW2ldIGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goLi4udGhpcy5hcmduYW1lc1tpXS5hbGxfc3ltYm9scygpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaCh0aGlzLmFyZ25hbWVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5hbWUpIHRoaXMubmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgYXJnbmFtZXMgPSB0aGlzLmFyZ25hbWVzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmduYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmduYW1lc1tpXS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLmJvZHkubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmJvZHlbaV0pO1xuXG4gICAgICAgICAgICBpID0gdGhpcy5hcmduYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMuYXJnbmFtZXNbaV0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lKSBwdXNoKHRoaXMubmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzX2JyYWNlbGVzcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHlbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuICYmIHRoaXMuYm9keVswXS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRGVmYXVsdCBhcmdzIGFuZCBleHBhbnNpb24gZG9uJ3QgY291bnQsIHNvIC5hcmduYW1lcy5sZW5ndGggZG9lc24ndCBjdXQgaXRcbiAgICAgICAgbGVuZ3RoX3Byb3BlcnR5KCkge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIHRoaXMuYXJnbmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZyB8fCBhcmcgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZykge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIEFTVF9TY29wZVxuKTtcblxudmFyIEFTVF9BY2Nlc3NvciA9IERFRk5PREUoXCJBY2Nlc3NvclwiLCBudWxsLCBmdW5jdGlvbiBBU1RfQWNjZXNzb3IocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy5hcmduYW1lcyA9IHByb3BzLmFyZ25hbWVzO1xuICAgICAgICB0aGlzLnVzZXNfYXJndW1lbnRzID0gcHJvcHMudXNlc19hcmd1bWVudHM7XG4gICAgICAgIHRoaXMuaXNfZ2VuZXJhdG9yID0gcHJvcHMuaXNfZ2VuZXJhdG9yO1xuICAgICAgICB0aGlzLmFzeW5jID0gcHJvcHMuYXN5bmM7XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gcHJvcHMudmFyaWFibGVzO1xuICAgICAgICB0aGlzLnVzZXNfd2l0aCA9IHByb3BzLnVzZXNfd2l0aDtcbiAgICAgICAgdGhpcy51c2VzX2V2YWwgPSBwcm9wcy51c2VzX2V2YWw7XG4gICAgICAgIHRoaXMucGFyZW50X3Njb3BlID0gcHJvcHMucGFyZW50X3Njb3BlO1xuICAgICAgICB0aGlzLmVuY2xvc2VkID0gcHJvcHMuZW5jbG9zZWQ7XG4gICAgICAgIHRoaXMuY25hbWUgPSBwcm9wcy5jbmFtZTtcbiAgICAgICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICAgICAgdGhpcy5ibG9ja19zY29wZSA9IHByb3BzLmJsb2NrX3Njb3BlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgc2V0dGVyL2dldHRlciBmdW5jdGlvbi4gIFRoZSBgbmFtZWAgcHJvcGVydHkgaXMgYWx3YXlzIG51bGwuXCJcbn0sIEFTVF9MYW1iZGEpO1xuXG52YXIgQVNUX0Z1bmN0aW9uID0gREVGTk9ERShcIkZ1bmN0aW9uXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9GdW5jdGlvbihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLmFyZ25hbWVzID0gcHJvcHMuYXJnbmFtZXM7XG4gICAgICAgIHRoaXMudXNlc19hcmd1bWVudHMgPSBwcm9wcy51c2VzX2FyZ3VtZW50cztcbiAgICAgICAgdGhpcy5pc19nZW5lcmF0b3IgPSBwcm9wcy5pc19nZW5lcmF0b3I7XG4gICAgICAgIHRoaXMuYXN5bmMgPSBwcm9wcy5hc3luYztcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSBwcm9wcy52YXJpYWJsZXM7XG4gICAgICAgIHRoaXMudXNlc193aXRoID0gcHJvcHMudXNlc193aXRoO1xuICAgICAgICB0aGlzLnVzZXNfZXZhbCA9IHByb3BzLnVzZXNfZXZhbDtcbiAgICAgICAgdGhpcy5wYXJlbnRfc2NvcGUgPSBwcm9wcy5wYXJlbnRfc2NvcGU7XG4gICAgICAgIHRoaXMuZW5jbG9zZWQgPSBwcm9wcy5lbmNsb3NlZDtcbiAgICAgICAgdGhpcy5jbmFtZSA9IHByb3BzLmNuYW1lO1xuICAgICAgICB0aGlzLmJvZHkgPSBwcm9wcy5ib2R5O1xuICAgICAgICB0aGlzLmJsb2NrX3Njb3BlID0gcHJvcHMuYmxvY2tfc2NvcGU7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBmdW5jdGlvbiBleHByZXNzaW9uXCJcbn0sIEFTVF9MYW1iZGEpO1xuXG52YXIgQVNUX0Fycm93ID0gREVGTk9ERShcIkFycm93XCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9BcnJvdyhwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLmFyZ25hbWVzID0gcHJvcHMuYXJnbmFtZXM7XG4gICAgICAgIHRoaXMudXNlc19hcmd1bWVudHMgPSBwcm9wcy51c2VzX2FyZ3VtZW50cztcbiAgICAgICAgdGhpcy5pc19nZW5lcmF0b3IgPSBwcm9wcy5pc19nZW5lcmF0b3I7XG4gICAgICAgIHRoaXMuYXN5bmMgPSBwcm9wcy5hc3luYztcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSBwcm9wcy52YXJpYWJsZXM7XG4gICAgICAgIHRoaXMudXNlc193aXRoID0gcHJvcHMudXNlc193aXRoO1xuICAgICAgICB0aGlzLnVzZXNfZXZhbCA9IHByb3BzLnVzZXNfZXZhbDtcbiAgICAgICAgdGhpcy5wYXJlbnRfc2NvcGUgPSBwcm9wcy5wYXJlbnRfc2NvcGU7XG4gICAgICAgIHRoaXMuZW5jbG9zZWQgPSBwcm9wcy5lbmNsb3NlZDtcbiAgICAgICAgdGhpcy5jbmFtZSA9IHByb3BzLmNuYW1lO1xuICAgICAgICB0aGlzLmJvZHkgPSBwcm9wcy5ib2R5O1xuICAgICAgICB0aGlzLmJsb2NrX3Njb3BlID0gcHJvcHMuYmxvY2tfc2NvcGU7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gRVM2IEFycm93IGZ1bmN0aW9uICgoYSkgPT4gYilcIlxufSwgQVNUX0xhbWJkYSk7XG5cbnZhciBBU1RfRGVmdW4gPSBERUZOT0RFKFwiRGVmdW5cIiwgbnVsbCwgZnVuY3Rpb24gQVNUX0RlZnVuKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIHRoaXMuYXJnbmFtZXMgPSBwcm9wcy5hcmduYW1lcztcbiAgICAgICAgdGhpcy51c2VzX2FyZ3VtZW50cyA9IHByb3BzLnVzZXNfYXJndW1lbnRzO1xuICAgICAgICB0aGlzLmlzX2dlbmVyYXRvciA9IHByb3BzLmlzX2dlbmVyYXRvcjtcbiAgICAgICAgdGhpcy5hc3luYyA9IHByb3BzLmFzeW5jO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHByb3BzLnZhcmlhYmxlcztcbiAgICAgICAgdGhpcy51c2VzX3dpdGggPSBwcm9wcy51c2VzX3dpdGg7XG4gICAgICAgIHRoaXMudXNlc19ldmFsID0gcHJvcHMudXNlc19ldmFsO1xuICAgICAgICB0aGlzLnBhcmVudF9zY29wZSA9IHByb3BzLnBhcmVudF9zY29wZTtcbiAgICAgICAgdGhpcy5lbmNsb3NlZCA9IHByb3BzLmVuY2xvc2VkO1xuICAgICAgICB0aGlzLmNuYW1lID0gcHJvcHMuY25hbWU7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGZ1bmN0aW9uIGRlZmluaXRpb25cIlxufSwgQVNUX0xhbWJkYSk7XG5cbi8qIC0tLS0tWyBERVNUUlVDVFVSSU5HIF0tLS0tLSAqL1xudmFyIEFTVF9EZXN0cnVjdHVyaW5nID0gREVGTk9ERShcIkRlc3RydWN0dXJpbmdcIiwgXCJuYW1lcyBpc19hcnJheVwiLCBmdW5jdGlvbiBBU1RfRGVzdHJ1Y3R1cmluZyhwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLm5hbWVzID0gcHJvcHMubmFtZXM7XG4gICAgICAgIHRoaXMuaXNfYXJyYXkgPSBwcm9wcy5pc19hcnJheTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGRlc3RydWN0dXJpbmcgb2Ygc2V2ZXJhbCBuYW1lcy4gVXNlZCBpbiBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQgYW5kIHdpdGggZGVzdHJ1Y3R1cmluZyBmdW5jdGlvbiBhcmd1bWVudCBuYW1lc1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIFwibmFtZXNcIjogXCJbQVNUX05vZGUqXSBBcnJheSBvZiBwcm9wZXJ0aWVzIG9yIGVsZW1lbnRzXCIsXG4gICAgICAgIFwiaXNfYXJyYXlcIjogXCJbQm9vbGVhbl0gV2hldGhlciB0aGUgZGVzdHJ1Y3R1cmluZyByZXByZXNlbnRzIGFuIG9iamVjdCBvciBhcnJheVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIG5hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLm5hbWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLm5hbWVzW2ldKTtcbiAgICB9LFxuICAgIGFsbF9zeW1ib2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICB3YWxrKHRoaXMsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59KTtcblxudmFyIEFTVF9QcmVmaXhlZFRlbXBsYXRlU3RyaW5nID0gREVGTk9ERShcbiAgICBcIlByZWZpeGVkVGVtcGxhdGVTdHJpbmdcIixcbiAgICBcInRlbXBsYXRlX3N0cmluZyBwcmVmaXhcIixcbiAgICBmdW5jdGlvbiBBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZyhwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVfc3RyaW5nID0gcHJvcHMudGVtcGxhdGVfc3RyaW5nO1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSBwcm9wcy5wcmVmaXg7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgIH0sXG4gICAge1xuICAgICAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHRlbXBsYXRlc3RyaW5nIHdpdGggYSBwcmVmaXgsIHN1Y2ggYXMgU3RyaW5nLnJhd2Bmb29iYXJiYXpgXCIsXG4gICAgICAgICRwcm9wZG9jOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZV9zdHJpbmc6IFwiW0FTVF9UZW1wbGF0ZVN0cmluZ10gVGhlIHRlbXBsYXRlIHN0cmluZ1wiLFxuICAgICAgICAgICAgcHJlZml4OiBcIltBU1RfTm9kZV0gVGhlIHByZWZpeCwgd2hpY2ggd2lsbCBnZXQgY2FsbGVkLlwiXG4gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlZml4Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIHRoaXMudGVtcGxhdGVfc3RyaW5nLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICAgICAgcHVzaCh0aGlzLnRlbXBsYXRlX3N0cmluZyk7XG4gICAgICAgICAgICBwdXNoKHRoaXMucHJlZml4KTtcbiAgICAgICAgfSxcbiAgICB9XG4pO1xuXG52YXIgQVNUX1RlbXBsYXRlU3RyaW5nID0gREVGTk9ERShcIlRlbXBsYXRlU3RyaW5nXCIsIFwic2VnbWVudHNcIiwgZnVuY3Rpb24gQVNUX1RlbXBsYXRlU3RyaW5nKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBwcm9wcy5zZWdtZW50cztcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHRlbXBsYXRlIHN0cmluZyBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgc2VnbWVudHM6IFwiW0FTVF9Ob2RlKl0gT25lIG9yIG1vcmUgc2VnbWVudHMsIHN0YXJ0aW5nIHdpdGggQVNUX1RlbXBsYXRlU2VnbWVudC4gQVNUX05vZGUgbWF5IGZvbGxvdyBBU1RfVGVtcGxhdGVTZWdtZW50LCBidXQgZWFjaCBBU1RfTm9kZSBtdXN0IGJlIGZvbGxvd2VkIGJ5IEFTVF9UZW1wbGF0ZVNlZ21lbnQuXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWcpIHtcbiAgICAgICAgICAgICAgICBzZWcuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLnNlZ21lbnRzW2ldKTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9UZW1wbGF0ZVNlZ21lbnQgPSBERUZOT0RFKFwiVGVtcGxhdGVTZWdtZW50XCIsIFwidmFsdWUgcmF3XCIsIGZ1bmN0aW9uIEFTVF9UZW1wbGF0ZVNlZ21lbnQocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB0aGlzLnJhdyA9IHByb3BzLnJhdztcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHNlZ21lbnQgb2YgYSB0ZW1wbGF0ZSBzdHJpbmcgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIkNvbnRlbnQgb2YgdGhlIHNlZ21lbnRcIixcbiAgICAgICAgcmF3OiBcIlJhdyBzb3VyY2Ugb2YgdGhlIHNlZ21lbnRcIixcbiAgICB9XG59KTtcblxuLyogLS0tLS1bIEpVTVBTIF0tLS0tLSAqL1xuXG52YXIgQVNUX0p1bXAgPSBERUZOT0RFKFwiSnVtcFwiLCBudWxsLCBmdW5jdGlvbiBBU1RfSnVtcChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIOKAnGp1bXBz4oCdIChmb3Igbm93IHRoYXQncyBgcmV0dXJuYCwgYHRocm93YCwgYGJyZWFrYCBhbmQgYGNvbnRpbnVlYClcIlxufSwgQVNUX1N0YXRlbWVudCk7XG5cbi8qKiBCYXNlIGNsYXNzIGZvciDigJxleGl0c+KAnSAoYHJldHVybmAgYW5kIGB0aHJvd2ApICovXG52YXIgQVNUX0V4aXQgPSBERUZOT0RFKFwiRXhpdFwiLCBcInZhbHVlXCIsIGZ1bmN0aW9uIEFTVF9FeGl0KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciDigJxleGl0c+KAnSAoYHJldHVybmAgYW5kIGB0aHJvd2ApXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgdmFsdWU6IFwiW0FTVF9Ob2RlP10gdGhlIHZhbHVlIHJldHVybmVkIG9yIHRocm93biBieSB0aGlzIHN0YXRlbWVudDsgY291bGQgYmUgbnVsbCBmb3IgQVNUX1JldHVyblwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgdGhpcy52YWx1ZSAmJiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSBwdXNoKHRoaXMudmFsdWUpO1xuICAgIH0sXG59LCBBU1RfSnVtcCk7XG5cbnZhciBBU1RfUmV0dXJuID0gREVGTk9ERShcIlJldHVyblwiLCBudWxsLCBmdW5jdGlvbiBBU1RfUmV0dXJuKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGByZXR1cm5gIHN0YXRlbWVudFwiXG59LCBBU1RfRXhpdCk7XG5cbnZhciBBU1RfVGhyb3cgPSBERUZOT0RFKFwiVGhyb3dcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1Rocm93KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB0aHJvd2Agc3RhdGVtZW50XCJcbn0sIEFTVF9FeGl0KTtcblxudmFyIEFTVF9Mb29wQ29udHJvbCA9IERFRk5PREUoXCJMb29wQ29udHJvbFwiLCBcImxhYmVsXCIsIGZ1bmN0aW9uIEFTVF9Mb29wQ29udHJvbChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmxhYmVsID0gcHJvcHMubGFiZWw7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgbG9vcCBjb250cm9sIHN0YXRlbWVudHMgKGBicmVha2AgYW5kIGBjb250aW51ZWApXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgbGFiZWw6IFwiW0FTVF9MYWJlbFJlZj9dIHRoZSBsYWJlbCwgb3IgbnVsbCBpZiBub25lXCIsXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgdGhpcy5sYWJlbCAmJiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWwuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSBwdXNoKHRoaXMubGFiZWwpO1xuICAgIH0sXG59LCBBU1RfSnVtcCk7XG5cbnZhciBBU1RfQnJlYWsgPSBERUZOT0RFKFwiQnJlYWtcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX0JyZWFrKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMubGFiZWwgPSBwcm9wcy5sYWJlbDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBicmVha2Agc3RhdGVtZW50XCJcbn0sIEFTVF9Mb29wQ29udHJvbCk7XG5cbnZhciBBU1RfQ29udGludWUgPSBERUZOT0RFKFwiQ29udGludWVcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX0NvbnRpbnVlKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMubGFiZWwgPSBwcm9wcy5sYWJlbDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBjb250aW51ZWAgc3RhdGVtZW50XCJcbn0sIEFTVF9Mb29wQ29udHJvbCk7XG5cbnZhciBBU1RfQXdhaXQgPSBERUZOT0RFKFwiQXdhaXRcIiwgXCJleHByZXNzaW9uXCIsIGZ1bmN0aW9uIEFTVF9Bd2FpdChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBwcm9wcy5leHByZXNzaW9uO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIGBhd2FpdGAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIHRoZSBtYW5kYXRvcnkgZXhwcmVzc2lvbiBiZWluZyBhd2FpdGVkXCIsXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfWWllbGQgPSBERUZOT0RFKFwiWWllbGRcIiwgXCJleHByZXNzaW9uIGlzX3N0YXJcIiwgZnVuY3Rpb24gQVNUX1lpZWxkKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHByb3BzLmV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuaXNfc3RhciA9IHByb3BzLmlzX3N0YXI7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgeWllbGRgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlP10gdGhlIHZhbHVlIHJldHVybmVkIG9yIHRocm93biBieSB0aGlzIHN0YXRlbWVudDsgY291bGQgYmUgbnVsbCAocmVwcmVzZW50aW5nIHVuZGVmaW5lZCkgYnV0IG9ubHkgd2hlbiBpc19zdGFyIGlzIHNldCB0byBmYWxzZVwiLFxuICAgICAgICBpc19zdGFyOiBcIltCb29sZWFuXSBXaGV0aGVyIHRoaXMgaXMgYSB5aWVsZCBvciB5aWVsZCogc3RhdGVtZW50XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCB0aGlzLmV4cHJlc3Npb24gJiYgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb24pIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9XG59KTtcblxuLyogLS0tLS1bIElGIF0tLS0tLSAqL1xuXG52YXIgQVNUX0lmID0gREVGTk9ERShcIklmXCIsIFwiY29uZGl0aW9uIGFsdGVybmF0aXZlXCIsIGZ1bmN0aW9uIEFTVF9JZihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IHByb3BzLmNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZSA9IHByb3BzLmFsdGVybmF0aXZlO1xuICAgICAgICB0aGlzLmJvZHkgPSBwcm9wcy5ib2R5O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGlmYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjb25kaXRpb246IFwiW0FTVF9Ob2RlXSB0aGUgYGlmYCBjb25kaXRpb25cIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiW0FTVF9TdGF0ZW1lbnQ/XSB0aGUgYGVsc2VgIHBhcnQsIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb25kaXRpb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5hbHRlcm5hdGl2ZSkgdGhpcy5hbHRlcm5hdGl2ZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgaWYgKHRoaXMuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHB1c2godGhpcy5hbHRlcm5hdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaCh0aGlzLmJvZHkpO1xuICAgICAgICBwdXNoKHRoaXMuY29uZGl0aW9uKTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG4vKiAtLS0tLVsgU1dJVENIIF0tLS0tLSAqL1xuXG52YXIgQVNUX1N3aXRjaCA9IERFRk5PREUoXCJTd2l0Y2hcIiwgXCJleHByZXNzaW9uXCIsIGZ1bmN0aW9uIEFTVF9Td2l0Y2gocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gcHJvcHMuZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICAgICAgdGhpcy5ibG9ja19zY29wZSA9IHByb3BzLmJsb2NrX3Njb3BlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHN3aXRjaGAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIHRoZSBgc3dpdGNoYCDigJxkaXNjcmltaW5hbnTigJ1cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMuYm9keS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHB1c2godGhpcy5ib2R5W2ldKTtcbiAgICAgICAgcHVzaCh0aGlzLmV4cHJlc3Npb24pO1xuICAgIH1cbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfU3dpdGNoQnJhbmNoID0gREVGTk9ERShcIlN3aXRjaEJyYW5jaFwiLCBudWxsLCBmdW5jdGlvbiBBU1RfU3dpdGNoQnJhbmNoKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBgc3dpdGNoYCBicmFuY2hlc1wiLFxufSwgQVNUX0Jsb2NrKTtcblxudmFyIEFTVF9EZWZhdWx0ID0gREVGTk9ERShcIkRlZmF1bHRcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX0RlZmF1bHQocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICAgICAgdGhpcy5ibG9ja19zY29wZSA9IHByb3BzLmJsb2NrX3Njb3BlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGRlZmF1bHRgIHN3aXRjaCBicmFuY2hcIixcbn0sIEFTVF9Td2l0Y2hCcmFuY2gpO1xuXG52YXIgQVNUX0Nhc2UgPSBERUZOT0RFKFwiQ2FzZVwiLCBcImV4cHJlc3Npb25cIiwgZnVuY3Rpb24gQVNUX0Nhc2UocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gcHJvcHMuZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICAgICAgdGhpcy5ibG9ja19zY29wZSA9IHByb3BzLmJsb2NrX3Njb3BlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGNhc2VgIHN3aXRjaCBicmFuY2hcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gdGhlIGBjYXNlYCBleHByZXNzaW9uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHdhbGtfYm9keSh0aGlzLCB2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmJvZHkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMuYm9keVtpXSk7XG4gICAgICAgIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9LFxufSwgQVNUX1N3aXRjaEJyYW5jaCk7XG5cbi8qIC0tLS0tWyBFWENFUFRJT05TIF0tLS0tLSAqL1xuXG52YXIgQVNUX1RyeSA9IERFRk5PREUoXCJUcnlcIiwgXCJib2R5IGJjYXRjaCBiZmluYWxseVwiLCBmdW5jdGlvbiBBU1RfVHJ5KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuYmNhdGNoID0gcHJvcHMuYmNhdGNoO1xuICAgICAgICB0aGlzLmJmaW5hbGx5ID0gcHJvcHMuYmZpbmFsbHk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgdHJ5YCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBib2R5OiBcIltBU1RfVHJ5QmxvY2tdIHRoZSB0cnkgYmxvY2tcIixcbiAgICAgICAgYmNhdGNoOiBcIltBU1RfQ2F0Y2g/XSB0aGUgY2F0Y2ggYmxvY2ssIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIixcbiAgICAgICAgYmZpbmFsbHk6IFwiW0FTVF9GaW5hbGx5P10gdGhlIGZpbmFsbHkgYmxvY2ssIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmNhdGNoKSB0aGlzLmJjYXRjaC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJmaW5hbGx5KSB0aGlzLmJmaW5hbGx5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBpZiAodGhpcy5iZmluYWxseSkgcHVzaCh0aGlzLmJmaW5hbGx5KTtcbiAgICAgICAgaWYgKHRoaXMuYmNhdGNoKSBwdXNoKHRoaXMuYmNhdGNoKTtcbiAgICAgICAgcHVzaCh0aGlzLmJvZHkpO1xuICAgIH0sXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9UcnlCbG9jayA9IERFRk5PREUoXCJUcnlCbG9ja1wiLCBudWxsLCBmdW5jdGlvbiBBU1RfVHJ5QmxvY2socHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICAgICAgdGhpcy5ibG9ja19zY29wZSA9IHByb3BzLmJsb2NrX3Njb3BlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgdHJ5YCBibG9jayBvZiBhIHRyeSBzdGF0ZW1lbnRcIlxufSwgQVNUX0Jsb2NrKTtcblxudmFyIEFTVF9DYXRjaCA9IERFRk5PREUoXCJDYXRjaFwiLCBcImFyZ25hbWVcIiwgZnVuY3Rpb24gQVNUX0NhdGNoKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuYXJnbmFtZSA9IHByb3BzLmFyZ25hbWU7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBjYXRjaGAgbm9kZTsgb25seSBtYWtlcyBzZW5zZSBhcyBwYXJ0IG9mIGEgYHRyeWAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgYXJnbmFtZTogXCJbQVNUX1N5bWJvbENhdGNofEFTVF9EZXN0cnVjdHVyaW5nfEFTVF9FeHBhbnNpb258QVNUX0RlZmF1bHRBc3NpZ25dIHN5bWJvbCBmb3IgdGhlIGV4Y2VwdGlvblwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmduYW1lKSB0aGlzLmFyZ25hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5ib2R5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmJvZHlbaV0pO1xuICAgICAgICBpZiAodGhpcy5hcmduYW1lKSBwdXNoKHRoaXMuYXJnbmFtZSk7XG4gICAgfSxcbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfRmluYWxseSA9IERFRk5PREUoXCJGaW5hbGx5XCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9GaW5hbGx5KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBmaW5hbGx5YCBub2RlOyBvbmx5IG1ha2VzIHNlbnNlIGFzIHBhcnQgb2YgYSBgdHJ5YCBzdGF0ZW1lbnRcIlxufSwgQVNUX0Jsb2NrKTtcblxuLyogLS0tLS1bIFZBUi9DT05TVCBdLS0tLS0gKi9cblxudmFyIEFTVF9EZWZpbml0aW9uc0xpa2UgPSBERUZOT0RFKFwiRGVmaW5pdGlvbnNMaWtlXCIsIFwiZGVmaW5pdGlvbnNcIiwgZnVuY3Rpb24gQVNUX0RlZmluaXRpb25zTGlrZShwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zID0gcHJvcHMuZGVmaW5pdGlvbnM7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgdmFyaWFibGUgZGVmaW5pdGlvbnMgYW5kIGB1c2luZ2BcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBkZWZpbml0aW9uczogXCJbQVNUX1ZhckRlZip8QVNUX1VzaW5nRGVmKl0gYXJyYXkgb2YgdmFyaWFibGUgZGVmaW5pdGlvbnNcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRlZmluaXRpb25zID0gdGhpcy5kZWZpbml0aW9ucztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZWZpbml0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25zW2ldLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMuZGVmaW5pdGlvbnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMuZGVmaW5pdGlvbnNbaV0pO1xuICAgIH0sXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9EZWZpbml0aW9ucyA9IERFRk5PREUoXCJEZWZpbml0aW9uc1wiLCBudWxsLCBmdW5jdGlvbiBBU1RfRGVmaW5pdGlvbnMocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IHByb3BzLmRlZmluaXRpb25zO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGB2YXJgIG9yIGBjb25zdGAgbm9kZXMgKHZhcmlhYmxlIGRlY2xhcmF0aW9ucy9pbml0aWFsaXphdGlvbnMpXCIsXG59LCBBU1RfRGVmaW5pdGlvbnNMaWtlKTtcblxudmFyIEFTVF9WYXIgPSBERUZOT0RFKFwiVmFyXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9WYXIocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IHByb3BzLmRlZmluaXRpb25zO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHZhcmAgc3RhdGVtZW50XCJcbn0sIEFTVF9EZWZpbml0aW9ucyk7XG5cbnZhciBBU1RfTGV0ID0gREVGTk9ERShcIkxldFwiLCBudWxsLCBmdW5jdGlvbiBBU1RfTGV0KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBwcm9wcy5kZWZpbml0aW9ucztcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBsZXRgIHN0YXRlbWVudFwiXG59LCBBU1RfRGVmaW5pdGlvbnMpO1xuXG52YXIgQVNUX0NvbnN0ID0gREVGTk9ERShcIkNvbnN0XCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9Db25zdChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zID0gcHJvcHMuZGVmaW5pdGlvbnM7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY29uc3RgIHN0YXRlbWVudFwiXG59LCBBU1RfRGVmaW5pdGlvbnMpO1xuXG52YXIgQVNUX1VzaW5nID0gREVGTk9ERShcIlVzaW5nXCIsIFwiYXdhaXRcIiwgZnVuY3Rpb24gQVNUX1VzaW5nKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuYXdhaXQgPSBwcm9wcy5hd2FpdDtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IHByb3BzLmRlZmluaXRpb25zO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHVzaW5nYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBhd2FpdDogXCJbYm9vbGVhbl0gV2hldGhlciBpdCdzIGBhd2FpdCB1c2luZ2BcIlxuICAgIH0sXG59LCBBU1RfRGVmaW5pdGlvbnNMaWtlKTtcblxudmFyIEFTVF9WYXJEZWZMaWtlID0gREVGTk9ERShcIlZhckRlZkxpa2VcIiwgXCJuYW1lIHZhbHVlXCIsIGZ1bmN0aW9uIEFTVF9WYXJEZWZMaWtlKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIG5hbWU9dmFsdWUgcGFpciBpbiBhIHZhcmlhYmxlIGRlZmluaXRpb24gc3RhdGVtZW50IG9yIGB1c2luZ2BcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltBU1RfRGVzdHJ1Y3R1cmluZ3xBU1RfU3ltYm9sRGVjbGFyYXRpb25dIG5hbWUgb2YgdGhlIHZhcmlhYmxlXCIsXG4gICAgICAgIHZhbHVlOiBcIltBU1RfTm9kZT9dIGluaXRpYWxpemVyLCBvciBudWxsIG9mIHRoZXJlJ3Mgbm8gaW5pdGlhbGl6ZXJcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5uYW1lLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHRoaXMudmFsdWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSBwdXNoKHRoaXMudmFsdWUpO1xuICAgICAgICBwdXNoKHRoaXMubmFtZSk7XG4gICAgfSxcbiAgICBkZWNsYXJhdGlvbnNfYXNfbmFtZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5uYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUuYWxsX3N5bWJvbHMoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgQVNUX1ZhckRlZiA9IERFRk5PREUoXCJWYXJEZWZcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1ZhckRlZihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSB2YXJpYWJsZSBkZWNsYXJhdGlvbjsgb25seSBhcHBlYXJzIGluIGEgQVNUX0RlZmluaXRpb25zIG5vZGVcIixcbn0sIEFTVF9WYXJEZWZMaWtlKTtcblxudmFyIEFTVF9Vc2luZ0RlZiA9IERFRk5PREUoXCJVc2luZ0RlZlwiLCBudWxsLCBmdW5jdGlvbiBBU1RfVXNpbmdEZWYocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkxpa2UgVmFyRGVmIGJ1dCBzcGVjaWZpYyB0byBBU1RfVXNpbmdcIixcbn0sIEFTVF9WYXJEZWZMaWtlKTtcblxudmFyIEFTVF9OYW1lTWFwcGluZyA9IERFRk5PREUoXCJOYW1lTWFwcGluZ1wiLCBcImZvcmVpZ25fbmFtZSBuYW1lXCIsIGZ1bmN0aW9uIEFTVF9OYW1lTWFwcGluZyhwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmZvcmVpZ25fbmFtZSA9IHByb3BzLmZvcmVpZ25fbmFtZTtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgcGFydCBvZiB0aGUgZXhwb3J0L2ltcG9ydCBzdGF0ZW1lbnQgdGhhdCBkZWNsYXJlIG5hbWVzIGZyb20gYSBtb2R1bGUuXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZm9yZWlnbl9uYW1lOiBcIltBU1RfU3ltYm9sRXhwb3J0Rm9yZWlnbnxBU1RfU3ltYm9sSW1wb3J0Rm9yZWlnbl0gVGhlIG5hbWUgYmVpbmcgZXhwb3J0ZWQvaW1wb3J0ZWQgKGFzIHNwZWNpZmllZCBpbiB0aGUgbW9kdWxlKVwiLFxuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sRXhwb3J0fEFTVF9TeW1ib2xJbXBvcnRdIFRoZSBuYW1lIGFzIGl0IGlzIHZpc2libGUgdG8gdGhpcyBtb2R1bGUuXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmZvcmVpZ25fbmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMubmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLm5hbWUpO1xuICAgICAgICBwdXNoKHRoaXMuZm9yZWlnbl9uYW1lKTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfSW1wb3J0ID0gREVGTk9ERShcbiAgICBcIkltcG9ydFwiLFxuICAgIFwiaW1wb3J0ZWRfbmFtZSBpbXBvcnRlZF9uYW1lcyBtb2R1bGVfbmFtZSBhdHRyaWJ1dGVzXCIsXG4gICAgZnVuY3Rpb24gQVNUX0ltcG9ydChwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0ZWRfbmFtZSA9IHByb3BzLmltcG9ydGVkX25hbWU7XG4gICAgICAgICAgICB0aGlzLmltcG9ydGVkX25hbWVzID0gcHJvcHMuaW1wb3J0ZWRfbmFtZXM7XG4gICAgICAgICAgICB0aGlzLm1vZHVsZV9uYW1lID0gcHJvcHMubW9kdWxlX25hbWU7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBwcm9wcy5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZsYWdzID0gMDtcbiAgICB9LFxuICAgIHtcbiAgICAgICAgJGRvY3VtZW50YXRpb246IFwiQW4gYGltcG9ydGAgc3RhdGVtZW50XCIsXG4gICAgICAgICRwcm9wZG9jOiB7XG4gICAgICAgICAgICBpbXBvcnRlZF9uYW1lOiBcIltBU1RfU3ltYm9sSW1wb3J0XSBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgaG9sZGluZyB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQuXCIsXG4gICAgICAgICAgICBpbXBvcnRlZF9uYW1lczogXCJbQVNUX05hbWVNYXBwaW5nKl0gVGhlIG5hbWVzIG9mIG5vbi1kZWZhdWx0IGltcG9ydGVkIHZhcmlhYmxlc1wiLFxuICAgICAgICAgICAgbW9kdWxlX25hbWU6IFwiW0FTVF9TdHJpbmddIFN0cmluZyBsaXRlcmFsIGRlc2NyaWJpbmcgd2hlcmUgdGhpcyBtb2R1bGUgY2FtZSBmcm9tXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBcIltBU1RfT2JqZWN0P10gVGhlIGltcG9ydCBhdHRyaWJ1dGVzICh3aXRoIHsuLi59KVwiXG4gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1wb3J0ZWRfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydGVkX25hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmltcG9ydGVkX25hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0ZWRfbmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lX2ltcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZV9pbXBvcnQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1vZHVsZV9uYW1lLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICAgICAgcHVzaCh0aGlzLm1vZHVsZV9uYW1lKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmltcG9ydGVkX25hbWVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSB0aGlzLmltcG9ydGVkX25hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMuaW1wb3J0ZWRfbmFtZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW1wb3J0ZWRfbmFtZSkgcHVzaCh0aGlzLmltcG9ydGVkX25hbWUpO1xuICAgICAgICB9LFxuICAgIH1cbik7XG5cbnZhciBBU1RfSW1wb3J0TWV0YSA9IERFRk5PREUoXCJJbXBvcnRNZXRhXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9JbXBvcnRNZXRhKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSByZWZlcmVuY2UgdG8gaW1wb3J0Lm1ldGFcIixcbn0pO1xuXG52YXIgQVNUX0V4cG9ydCA9IERFRk5PREUoXG4gICAgXCJFeHBvcnRcIixcbiAgICBcImV4cG9ydGVkX2RlZmluaXRpb24gZXhwb3J0ZWRfdmFsdWUgaXNfZGVmYXVsdCBleHBvcnRlZF9uYW1lcyBtb2R1bGVfbmFtZSBhdHRyaWJ1dGVzXCIsXG4gICAgZnVuY3Rpb24gQVNUX0V4cG9ydChwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWRfZGVmaW5pdGlvbiA9IHByb3BzLmV4cG9ydGVkX2RlZmluaXRpb247XG4gICAgICAgICAgICB0aGlzLmV4cG9ydGVkX3ZhbHVlID0gcHJvcHMuZXhwb3J0ZWRfdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmlzX2RlZmF1bHQgPSBwcm9wcy5pc19kZWZhdWx0O1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZF9uYW1lcyA9IHByb3BzLmV4cG9ydGVkX25hbWVzO1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVfbmFtZSA9IHByb3BzLm1vZHVsZV9uYW1lO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gcHJvcHMuYXR0cmlidXRlcztcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgfSxcbiAgICB7XG4gICAgICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIGBleHBvcnRgIHN0YXRlbWVudFwiLFxuICAgICAgICAkcHJvcGRvYzoge1xuICAgICAgICAgICAgZXhwb3J0ZWRfZGVmaW5pdGlvbjogXCJbQVNUX0RlZnVufEFTVF9EZWZpbml0aW9uc3xBU1RfRGVmQ2xhc3M/XSBBbiBleHBvcnRlZCBkZWZpbml0aW9uXCIsXG4gICAgICAgICAgICBleHBvcnRlZF92YWx1ZTogXCJbQVNUX05vZGU/XSBBbiBleHBvcnRlZCB2YWx1ZVwiLFxuICAgICAgICAgICAgZXhwb3J0ZWRfbmFtZXM6IFwiW0FTVF9OYW1lTWFwcGluZyo/XSBMaXN0IG9mIGV4cG9ydGVkIG5hbWVzXCIsXG4gICAgICAgICAgICBtb2R1bGVfbmFtZTogXCJbQVNUX1N0cmluZz9dIE5hbWUgb2YgdGhlIGZpbGUgdG8gbG9hZCBleHBvcnRzIGZyb21cIixcbiAgICAgICAgICAgIGlzX2RlZmF1bHQ6IFwiW0Jvb2xlYW5dIFdoZXRoZXIgdGhpcyBpcyB0aGUgZGVmYXVsdCBleHBvcnRlZCB2YWx1ZSBvZiB0aGlzIG1vZHVsZVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogXCJbQVNUX09iamVjdD9dIFRoZSBpbXBvcnQgYXR0cmlidXRlc1wiXG4gICAgICAgIH0sXG4gICAgICAgIF93YWxrOiBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5leHBvcnRlZF9kZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWRfZGVmaW5pdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXhwb3J0ZWRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBvcnRlZF92YWx1ZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXhwb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBvcnRlZF9uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWVfZXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lX2V4cG9ydC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vZHVsZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kdWxlX25hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kdWxlX25hbWUpIHB1c2godGhpcy5tb2R1bGVfbmFtZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5leHBvcnRlZF9uYW1lcykge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdGhpcy5leHBvcnRlZF9uYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmV4cG9ydGVkX25hbWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmV4cG9ydGVkX3ZhbHVlKSBwdXNoKHRoaXMuZXhwb3J0ZWRfdmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwb3J0ZWRfZGVmaW5pdGlvbikgcHVzaCh0aGlzLmV4cG9ydGVkX2RlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBBU1RfU3RhdGVtZW50XG4pO1xuXG4vKiAtLS0tLVsgT1RIRVIgXS0tLS0tICovXG5cbnZhciBBU1RfQ2FsbCA9IERFRk5PREUoXG4gICAgXCJDYWxsXCIsXG4gICAgXCJleHByZXNzaW9uIGFyZ3Mgb3B0aW9uYWwgX2Fubm90YXRpb25zXCIsXG4gICAgZnVuY3Rpb24gQVNUX0NhbGwocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBwcm9wcy5leHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5hcmdzID0gcHJvcHMuYXJncztcbiAgICAgICAgICAgIHRoaXMub3B0aW9uYWwgPSBwcm9wcy5vcHRpb25hbDtcbiAgICAgICAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gcHJvcHMuX2Fubm90YXRpb25zO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgIH0sXG4gICAge1xuICAgICAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGZ1bmN0aW9uIGNhbGwgZXhwcmVzc2lvblwiLFxuICAgICAgICAkcHJvcGRvYzoge1xuICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIGV4cHJlc3Npb24gdG8gaW52b2tlIGFzIGZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBhcmdzOiBcIltBU1RfTm9kZSpdIGFycmF5IG9mIGFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgb3B0aW9uYWw6IFwiW2Jvb2xlYW5dIHdoZXRoZXIgdGhpcyBpcyBhbiBvcHRpb25hbCBjYWxsIChJRSA/LigpIClcIixcbiAgICAgICAgICAgIF9hbm5vdGF0aW9uczogXCJbbnVtYmVyXSBiaXRmaWVsZCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYWxsXCJcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbm5vdGF0aW9ucyA9PSBudWxsKSB0aGlzLl9hbm5vdGF0aW9ucyA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIF93YWxrKHZpc2l0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJncztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7ICAvLyBUT0RPIHdoeSBkbyB3ZSBuZWVkIHRvIGNyYXdsIHRoaXMgbGFzdD9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5hcmdzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHB1c2godGhpcy5hcmdzW2ldKTtcbiAgICAgICAgICAgIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICAgICAgfSxcbiAgICB9XG4pO1xuXG52YXIgQVNUX05ldyA9IERFRk5PREUoXCJOZXdcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX05ldyhwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBwcm9wcy5leHByZXNzaW9uO1xuICAgICAgICB0aGlzLmFyZ3MgPSBwcm9wcy5hcmdzO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gcHJvcHMub3B0aW9uYWw7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gcHJvcHMuX2Fubm90YXRpb25zO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBvYmplY3QgaW5zdGFudGlhdGlvbi4gIERlcml2ZXMgZnJvbSBhIGZ1bmN0aW9uIGNhbGwgc2luY2UgaXQgaGFzIGV4YWN0bHkgdGhlIHNhbWUgcHJvcGVydGllc1wiXG59LCBBU1RfQ2FsbCk7XG5cbnZhciBBU1RfU2VxdWVuY2UgPSBERUZOT0RFKFwiU2VxdWVuY2VcIiwgXCJleHByZXNzaW9uc1wiLCBmdW5jdGlvbiBBU1RfU2VxdWVuY2UocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IHByb3BzLmV4cHJlc3Npb25zO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgc2VxdWVuY2UgZXhwcmVzc2lvbiAoY29tbWEtc2VwYXJhdGVkIGV4cHJlc3Npb25zKVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb25zOiBcIltBU1RfTm9kZSpdIGFycmF5IG9mIGV4cHJlc3Npb25zIChhdCBsZWFzdCB0d28pXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMuZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMuZXhwcmVzc2lvbnNbaV0pO1xuICAgIH0sXG59KTtcblxudmFyIEFTVF9Qcm9wQWNjZXNzID0gREVGTk9ERShcbiAgICBcIlByb3BBY2Nlc3NcIixcbiAgICBcImV4cHJlc3Npb24gcHJvcGVydHkgb3B0aW9uYWxcIixcbiAgICBmdW5jdGlvbiBBU1RfUHJvcEFjY2Vzcyhwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHByb3BzLmV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcHMucHJvcGVydHk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbmFsID0gcHJvcHMub3B0aW9uYWw7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgIH0sXG4gICAge1xuICAgICAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBwcm9wZXJ0eSBhY2Nlc3MgZXhwcmVzc2lvbnMsIGkuZS4gYGEuZm9vYCBvciBgYVtcXFwiZm9vXFxcIl1gXCIsXG4gICAgICAgICRwcm9wZG9jOiB7XG4gICAgICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gdGhlIOKAnGNvbnRhaW5lcuKAnSBleHByZXNzaW9uXCIsXG4gICAgICAgICAgICBwcm9wZXJ0eTogXCJbQVNUX05vZGV8c3RyaW5nXSB0aGUgcHJvcGVydHkgdG8gYWNjZXNzLiAgRm9yIEFTVF9Eb3QgJiBBU1RfRG90SGFzaCB0aGlzIGlzIGFsd2F5cyBhIHBsYWluIHN0cmluZywgd2hpbGUgZm9yIEFTVF9TdWIgaXQncyBhbiBhcmJpdHJhcnkgQVNUX05vZGVcIixcblxuICAgICAgICAgICAgb3B0aW9uYWw6IFwiW2Jvb2xlYW5dIHdoZXRoZXIgdGhpcyBpcyBhbiBvcHRpb25hbCBwcm9wZXJ0eSBhY2Nlc3MgKElFID8uKVwiXG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG52YXIgQVNUX0RvdCA9IERFRk5PREUoXCJEb3RcIiwgXCJxdW90ZVwiLCBmdW5jdGlvbiBBU1RfRG90KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMucXVvdGUgPSBwcm9wcy5xdW90ZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gcHJvcHMuZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BzLnByb3BlcnR5O1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gcHJvcHMub3B0aW9uYWw7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gcHJvcHMuX2Fubm90YXRpb25zO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgZG90dGVkIHByb3BlcnR5IGFjY2VzcyBleHByZXNzaW9uXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgcXVvdGU6IFwiW3N0cmluZ10gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlciB3aGVuIHRyYW5zZm9ybWVkIGZyb20gQVNUX1N1YlwiLFxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBwdXNoKHRoaXMuZXhwcmVzc2lvbik7XG4gICAgfSxcbn0sIEFTVF9Qcm9wQWNjZXNzKTtcblxudmFyIEFTVF9Eb3RIYXNoID0gREVGTk9ERShcIkRvdEhhc2hcIiwgXCJcIiwgZnVuY3Rpb24gQVNUX0RvdEhhc2gocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gcHJvcHMuZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BzLnByb3BlcnR5O1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gcHJvcHMub3B0aW9uYWw7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBkb3R0ZWQgcHJvcGVydHkgYWNjZXNzIHRvIGEgcHJpdmF0ZSBwcm9wZXJ0eVwiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmV4cHJlc3Npb24pO1xuICAgIH0sXG59LCBBU1RfUHJvcEFjY2Vzcyk7XG5cbnZhciBBU1RfU3ViID0gREVGTk9ERShcIlN1YlwiLCBudWxsLCBmdW5jdGlvbiBBU1RfU3ViKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHByb3BzLmV4cHJlc3Npb247XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wcy5wcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHByb3BzLm9wdGlvbmFsO1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9ucyA9IHByb3BzLl9hbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJJbmRleC1zdHlsZSBwcm9wZXJ0eSBhY2Nlc3MsIGkuZS4gYGFbXFxcImZvb1xcXCJdYFwiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5wcm9wZXJ0eSk7XG4gICAgICAgIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9LFxufSwgQVNUX1Byb3BBY2Nlc3MpO1xuXG52YXIgQVNUX0NoYWluID0gREVGTk9ERShcIkNoYWluXCIsIFwiZXhwcmVzc2lvblwiLCBmdW5jdGlvbiBBU1RfQ2hhaW4ocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gcHJvcHMuZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGNoYWluIGV4cHJlc3Npb24gbGlrZSBhPy5iPy4oYyk/LltkXVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9DYWxsfEFTVF9Eb3R8QVNUX0RvdEhhc2h8QVNUX1N1Yl0gY2hhaW4gZWxlbWVudC5cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmV4cHJlc3Npb24pO1xuICAgIH0sXG59KTtcblxudmFyIEFTVF9VbmFyeSA9IERFRk5PREUoXCJVbmFyeVwiLCBcIm9wZXJhdG9yIGV4cHJlc3Npb25cIiwgZnVuY3Rpb24gQVNUX1VuYXJ5KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBwcm9wcy5vcGVyYXRvcjtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gcHJvcHMuZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciB1bmFyeSBleHByZXNzaW9uc1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIG9wZXJhdG9yOiBcIltzdHJpbmddIHRoZSBvcGVyYXRvclwiLFxuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gZXhwcmVzc2lvbiB0aGF0IHRoaXMgdW5hcnkgb3BlcmF0b3IgYXBwbGllcyB0b1wiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfVW5hcnlQcmVmaXggPSBERUZOT0RFKFwiVW5hcnlQcmVmaXhcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1VuYXJ5UHJlZml4KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBwcm9wcy5vcGVyYXRvcjtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gcHJvcHMuZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJVbmFyeSBwcmVmaXggZXhwcmVzc2lvbiwgaS5lLiBgdHlwZW9mIGlgIG9yIGArK2lgXCJcbn0sIEFTVF9VbmFyeSk7XG5cbnZhciBBU1RfVW5hcnlQb3N0Zml4ID0gREVGTk9ERShcIlVuYXJ5UG9zdGZpeFwiLCBudWxsLCBmdW5jdGlvbiBBU1RfVW5hcnlQb3N0Zml4KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBwcm9wcy5vcGVyYXRvcjtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gcHJvcHMuZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJVbmFyeSBwb3N0Zml4IGV4cHJlc3Npb24sIGkuZS4gYGkrK2BcIlxufSwgQVNUX1VuYXJ5KTtcblxudmFyIEFTVF9CaW5hcnkgPSBERUZOT0RFKFwiQmluYXJ5XCIsIFwib3BlcmF0b3IgbGVmdCByaWdodFwiLCBmdW5jdGlvbiBBU1RfQmluYXJ5KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBwcm9wcy5vcGVyYXRvcjtcbiAgICAgICAgdGhpcy5sZWZ0ID0gcHJvcHMubGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHByb3BzLnJpZ2h0O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJpbmFyeSBleHByZXNzaW9uLCBpLmUuIGBhICsgYmBcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsZWZ0OiBcIltBU1RfTm9kZV0gbGVmdC1oYW5kIHNpZGUgZXhwcmVzc2lvblwiLFxuICAgICAgICBvcGVyYXRvcjogXCJbc3RyaW5nXSB0aGUgb3BlcmF0b3JcIixcbiAgICAgICAgcmlnaHQ6IFwiW0FTVF9Ob2RlXSByaWdodC1oYW5kIHNpZGUgZXhwcmVzc2lvblwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBwdXNoKHRoaXMucmlnaHQpO1xuICAgICAgICBwdXNoKHRoaXMubGVmdCk7XG4gICAgfSxcbn0pO1xuXG52YXIgQVNUX0NvbmRpdGlvbmFsID0gREVGTk9ERShcbiAgICBcIkNvbmRpdGlvbmFsXCIsXG4gICAgXCJjb25kaXRpb24gY29uc2VxdWVudCBhbHRlcm5hdGl2ZVwiLFxuICAgIGZ1bmN0aW9uIEFTVF9Db25kaXRpb25hbChwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gcHJvcHMuY29uZGl0aW9uO1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gcHJvcHMuY29uc2VxdWVudDtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmUgPSBwcm9wcy5hbHRlcm5hdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgfSxcbiAgICB7XG4gICAgICAgICRkb2N1bWVudGF0aW9uOiBcIkNvbmRpdGlvbmFsIGV4cHJlc3Npb24gdXNpbmcgdGhlIHRlcm5hcnkgb3BlcmF0b3IsIGkuZS4gYGEgPyBiIDogY2BcIixcbiAgICAgICAgJHByb3Bkb2M6IHtcbiAgICAgICAgICAgIGNvbmRpdGlvbjogXCJbQVNUX05vZGVdXCIsXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBcIltBU1RfTm9kZV1cIixcbiAgICAgICAgICAgIGFsdGVybmF0aXZlOiBcIltBU1RfTm9kZV1cIlxuICAgICAgICB9LFxuICAgICAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc2VxdWVudC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsdGVybmF0aXZlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICAgICAgcHVzaCh0aGlzLmFsdGVybmF0aXZlKTtcbiAgICAgICAgICAgIHB1c2godGhpcy5jb25zZXF1ZW50KTtcbiAgICAgICAgICAgIHB1c2godGhpcy5jb25kaXRpb24pO1xuICAgICAgICB9LFxuICAgIH1cbik7XG5cbnZhciBBU1RfQXNzaWduID0gREVGTk9ERShcIkFzc2lnblwiLCBcImxvZ2ljYWxcIiwgZnVuY3Rpb24gQVNUX0Fzc2lnbihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmxvZ2ljYWwgPSBwcm9wcy5sb2dpY2FsO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gcHJvcHMub3BlcmF0b3I7XG4gICAgICAgIHRoaXMubGVmdCA9IHByb3BzLmxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSBwcm9wcy5yaWdodDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBhc3NpZ25tZW50IGV4cHJlc3Npb24g4oCUIGBhID0gYiArIDVgXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgbG9naWNhbDogXCJXaGV0aGVyIGl0J3MgYSBsb2dpY2FsIGFzc2lnbm1lbnRcIlxuICAgIH1cbn0sIEFTVF9CaW5hcnkpO1xuXG52YXIgQVNUX0RlZmF1bHRBc3NpZ24gPSBERUZOT0RFKFwiRGVmYXVsdEFzc2lnblwiLCBudWxsLCBmdW5jdGlvbiBBU1RfRGVmYXVsdEFzc2lnbihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gcHJvcHMub3BlcmF0b3I7XG4gICAgICAgIHRoaXMubGVmdCA9IHByb3BzLmxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSBwcm9wcy5yaWdodDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGRlZmF1bHQgYXNzaWdubWVudCBleHByZXNzaW9uIGxpa2UgaW4gYChhID0gMykgPT4gYWBcIlxufSwgQVNUX0JpbmFyeSk7XG5cbi8qIC0tLS0tWyBMSVRFUkFMUyBdLS0tLS0gKi9cblxudmFyIEFTVF9BcnJheSA9IERFRk5PREUoXCJBcnJheVwiLCBcImVsZW1lbnRzXCIsIGZ1bmN0aW9uIEFTVF9BcnJheShwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gcHJvcHMuZWxlbWVudHM7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gYXJyYXkgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGVsZW1lbnRzOiBcIltBU1RfTm9kZSpdIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1tpXS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmVsZW1lbnRzW2ldKTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfT2JqZWN0ID0gREVGTk9ERShcIk9iamVjdFwiLCBcInByb3BlcnRpZXNcIiwgZnVuY3Rpb24gQVNUX09iamVjdChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wcy5wcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIG9iamVjdCBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgcHJvcGVydGllczogXCJbQVNUX09iamVjdFByb3BlcnR5Kl0gYXJyYXkgb2YgcHJvcGVydGllc1wiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1tpXS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnByb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMucHJvcGVydGllc1tpXSk7XG4gICAgfSxcbn0pO1xuXG4vKiAtLS0tLVsgT0JKRUNUL0NMQVNTIFBST1BFUlRJRVMgXS0tLS0tICovXG5cbi8qKlxuICogRXZlcnl0aGluZyBpbnNpZGUgdGhlIGN1cmx5IGJyYWNlcyBvZiBhbiBvYmplY3QvY2xhc3MgaXMgYSBzdWJjbGFzcyBvZiBBU1RfT2JqZWN0UHJvcGVydHksIGV4Y2VwdCBmb3IgQVNUX0NsYXNzU3RhdGljQmxvY2suXG4gKiovXG52YXIgQVNUX09iamVjdFByb3BlcnR5ID0gREVGTk9ERShcIk9iamVjdFByb3BlcnR5XCIsIFwia2V5IHZhbHVlXCIsIGZ1bmN0aW9uIEFTVF9PYmplY3RQcm9wZXJ0eShwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmtleSA9IHByb3BzLmtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9ucyA9IHByb3BzLl9hbm5vdGF0aW9ucztcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBsaXRlcmFsIG9iamVjdCBwcm9wZXJ0aWVzXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAga2V5OiBcIltzdHJpbmd8QVNUX05vZGVdIHByb3BlcnR5IG5hbWUuIEZvciBPYmplY3RLZXlWYWwgdGhpcyBpcyBhIHN0cmluZy4gRm9yIGdldHRlcnMsIHNldHRlcnMgYW5kIGNvbXB1dGVkIHByb3BlcnR5IHRoaXMgaXMgYW4gQVNUX05vZGUuXCIsXG4gICAgICAgIHZhbHVlOiBcIltBU1RfTm9kZV0gcHJvcGVydHkgdmFsdWUuICBGb3IgZ2V0dGVycywgc2V0dGVycyBhbmQgbWV0aG9kcyB0aGlzIGlzIGFuIEFTVF9BY2Nlc3Nvci5cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMua2V5IGluc3RhbmNlb2YgQVNUX05vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5rZXkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBwdXNoKHRoaXMudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSkgcHVzaCh0aGlzLmtleSk7XG4gICAgfSxcbn0pO1xuXG52YXIgQVNUX09iamVjdEtleVZhbCA9IERFRk5PREUoXCJPYmplY3RLZXlWYWxcIiwgXCJxdW90ZVwiLCBmdW5jdGlvbiBBU1RfT2JqZWN0S2V5VmFsKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMucXVvdGUgPSBwcm9wcy5xdW90ZTtcbiAgICAgICAgdGhpcy5rZXkgPSBwcm9wcy5rZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBwcm9wcy5fYW5ub3RhdGlvbnM7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBrZXk6IHZhbHVlIG9iamVjdCBwcm9wZXJ0eVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHF1b3RlOiBcIltzdHJpbmddIHRoZSBvcmlnaW5hbCBxdW90ZSBjaGFyYWN0ZXJcIlxuICAgIH0sXG4gICAgY29tcHV0ZWRfa2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZTtcbiAgICB9XG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX1ByaXZhdGVTZXR0ZXIgPSBERUZOT0RFKFwiUHJpdmF0ZVNldHRlclwiLCBcInN0YXRpY1wiLCBmdW5jdGlvbiBBU1RfUHJpdmF0ZVNldHRlcihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnN0YXRpYyA9IHByb3BzLnN0YXRpYztcbiAgICAgICAgdGhpcy5rZXkgPSBwcm9wcy5rZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBzdGF0aWM6IFwiW2Jvb2xlYW5dIHdoZXRoZXIgdGhpcyBpcyBhIHN0YXRpYyBwcml2YXRlIHNldHRlclwiXG4gICAgfSxcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHByaXZhdGUgc2V0dGVyIHByb3BlcnR5XCIsXG4gICAgY29tcHV0ZWRfa2V5KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSwgQVNUX09iamVjdFByb3BlcnR5KTtcblxudmFyIEFTVF9Qcml2YXRlR2V0dGVyID0gREVGTk9ERShcIlByaXZhdGVHZXR0ZXJcIiwgXCJzdGF0aWNcIiwgZnVuY3Rpb24gQVNUX1ByaXZhdGVHZXR0ZXIocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGF0aWMgPSBwcm9wcy5zdGF0aWM7XG4gICAgICAgIHRoaXMua2V5ID0gcHJvcHMua2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgc3RhdGljOiBcIltib29sZWFuXSB3aGV0aGVyIHRoaXMgaXMgYSBzdGF0aWMgcHJpdmF0ZSBnZXR0ZXJcIlxuICAgIH0sXG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBwcml2YXRlIGdldHRlciBwcm9wZXJ0eVwiLFxuICAgIGNvbXB1dGVkX2tleSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0sIEFTVF9PYmplY3RQcm9wZXJ0eSk7XG5cbnZhciBBU1RfT2JqZWN0U2V0dGVyID0gREVGTk9ERShcIk9iamVjdFNldHRlclwiLCBcInF1b3RlIHN0YXRpY1wiLCBmdW5jdGlvbiBBU1RfT2JqZWN0U2V0dGVyKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMucXVvdGUgPSBwcm9wcy5xdW90ZTtcbiAgICAgICAgdGhpcy5zdGF0aWMgPSBwcm9wcy5zdGF0aWM7XG4gICAgICAgIHRoaXMua2V5ID0gcHJvcHMua2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gcHJvcHMuX2Fubm90YXRpb25zO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHF1b3RlOiBcIltzdHJpbmd8dW5kZWZpbmVkXSB0aGUgb3JpZ2luYWwgcXVvdGUgY2hhcmFjdGVyLCBpZiBhbnlcIixcbiAgICAgICAgc3RhdGljOiBcIltib29sZWFuXSB3aGV0aGVyIHRoaXMgaXMgYSBzdGF0aWMgc2V0dGVyIChjbGFzc2VzIG9ubHkpXCJcbiAgICB9LFxuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIG9iamVjdCBzZXR0ZXIgcHJvcGVydHlcIixcbiAgICBjb21wdXRlZF9rZXkoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMua2V5IGluc3RhbmNlb2YgQVNUX1N5bWJvbE1ldGhvZCk7XG4gICAgfVxufSwgQVNUX09iamVjdFByb3BlcnR5KTtcblxudmFyIEFTVF9PYmplY3RHZXR0ZXIgPSBERUZOT0RFKFwiT2JqZWN0R2V0dGVyXCIsIFwicXVvdGUgc3RhdGljXCIsIGZ1bmN0aW9uIEFTVF9PYmplY3RHZXR0ZXIocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5xdW90ZSA9IHByb3BzLnF1b3RlO1xuICAgICAgICB0aGlzLnN0YXRpYyA9IHByb3BzLnN0YXRpYztcbiAgICAgICAgdGhpcy5rZXkgPSBwcm9wcy5rZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBwcm9wcy5fYW5ub3RhdGlvbnM7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgcXVvdGU6IFwiW3N0cmluZ3x1bmRlZmluZWRdIHRoZSBvcmlnaW5hbCBxdW90ZSBjaGFyYWN0ZXIsIGlmIGFueVwiLFxuICAgICAgICBzdGF0aWM6IFwiW2Jvb2xlYW5dIHdoZXRoZXIgdGhpcyBpcyBhIHN0YXRpYyBnZXR0ZXIgKGNsYXNzZXMgb25seSlcIlxuICAgIH0sXG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gb2JqZWN0IGdldHRlciBwcm9wZXJ0eVwiLFxuICAgIGNvbXB1dGVkX2tleSgpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kKTtcbiAgICB9XG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX0NvbmNpc2VNZXRob2QgPSBERUZOT0RFKFwiQ29uY2lzZU1ldGhvZFwiLCBcInF1b3RlIHN0YXRpY1wiLCBmdW5jdGlvbiBBU1RfQ29uY2lzZU1ldGhvZChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnF1b3RlID0gcHJvcHMucXVvdGU7XG4gICAgICAgIHRoaXMuc3RhdGljID0gcHJvcHMuc3RhdGljO1xuICAgICAgICB0aGlzLmtleSA9IHByb3BzLmtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9ucyA9IHByb3BzLl9hbm5vdGF0aW9ucztcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBxdW90ZTogXCJbc3RyaW5nfHVuZGVmaW5lZF0gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlciwgaWYgYW55XCIsXG4gICAgICAgIHN0YXRpYzogXCJbYm9vbGVhbl0gaXMgdGhpcyBtZXRob2Qgc3RhdGljIChjbGFzc2VzIG9ubHkpXCIsXG4gICAgfSxcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBFUzYgY29uY2lzZSBtZXRob2QgaW5zaWRlIGFuIG9iamVjdCBvciBjbGFzc1wiLFxuICAgIGNvbXB1dGVkX2tleSgpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kKTtcbiAgICB9XG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX1ByaXZhdGVNZXRob2QgPSBERUZOT0RFKFwiUHJpdmF0ZU1ldGhvZFwiLCBcInN0YXRpY1wiLCBmdW5jdGlvbiBBU1RfUHJpdmF0ZU1ldGhvZChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnN0YXRpYyA9IHByb3BzLnN0YXRpYztcbiAgICAgICAgdGhpcy5rZXkgPSBwcm9wcy5rZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHByaXZhdGUgY2xhc3MgbWV0aG9kIGluc2lkZSBhIGNsYXNzXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgc3RhdGljOiBcIltib29sZWFuXSBpcyB0aGlzIGEgc3RhdGljIHByaXZhdGUgbWV0aG9kXCIsXG4gICAgfSxcbiAgICBjb21wdXRlZF9rZXkoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxufSwgQVNUX09iamVjdFByb3BlcnR5KTtcblxudmFyIEFTVF9DbGFzcyA9IERFRk5PREUoXCJDbGFzc1wiLCBcIm5hbWUgZXh0ZW5kcyBwcm9wZXJ0aWVzXCIsIGZ1bmN0aW9uIEFTVF9DbGFzcyhwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLmV4dGVuZHMgPSBwcm9wcy5leHRlbmRzO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wcy5wcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHByb3BzLnZhcmlhYmxlcztcbiAgICAgICAgdGhpcy51c2VzX3dpdGggPSBwcm9wcy51c2VzX3dpdGg7XG4gICAgICAgIHRoaXMudXNlc19ldmFsID0gcHJvcHMudXNlc19ldmFsO1xuICAgICAgICB0aGlzLnBhcmVudF9zY29wZSA9IHByb3BzLnBhcmVudF9zY29wZTtcbiAgICAgICAgdGhpcy5lbmNsb3NlZCA9IHByb3BzLmVuY2xvc2VkO1xuICAgICAgICB0aGlzLmNuYW1lID0gcHJvcHMuY25hbWU7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sQ2xhc3N8QVNUX1N5bWJvbERlZkNsYXNzP10gb3B0aW9uYWwgY2xhc3MgbmFtZS5cIixcbiAgICAgICAgZXh0ZW5kczogXCJbQVNUX05vZGVdPyBvcHRpb25hbCBwYXJlbnQgY2xhc3NcIixcbiAgICAgICAgcHJvcGVydGllczogXCJbQVNUX09iamVjdFByb3BlcnR5fEFTVF9DbGFzc1N0YXRpY0Jsb2NrXSogYXJyYXkgb2YgcHJvcGVydGllcyBvciBzdGF0aWMgYmxvY2tzXCJcbiAgICB9LFxuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIEVTNiBjbGFzc1wiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5leHRlbmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRzLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHByb3AuX3dhbGsodmlzaXRvcikpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMucHJvcGVydGllcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHB1c2godGhpcy5wcm9wZXJ0aWVzW2ldKTtcbiAgICAgICAgaWYgKHRoaXMuZXh0ZW5kcykgcHVzaCh0aGlzLmV4dGVuZHMpO1xuICAgICAgICBpZiAodGhpcy5uYW1lKSBwdXNoKHRoaXMubmFtZSk7XG4gICAgfSxcbiAgICAvKiogZ28gdGhyb3VnaCB0aGUgYml0cyB0aGF0IGFyZSBleGVjdXRlZCBpbnN0YW50bHksIG5vdCB3aGVuIHRoZSBjbGFzcyBpcyBgbmV3YCdkLiBEb2Vzbid0IHdhbGsgdGhlIG5hbWUuICovXG4gICAgdmlzaXRfbm9uZGVmZXJyZWRfY2xhc3NfcGFydHModmlzaXRvcikge1xuICAgICAgICBpZiAodGhpcy5leHRlbmRzKSB7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZHMuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgQVNUX0NsYXNzU3RhdGljQmxvY2spIHtcbiAgICAgICAgICAgICAgICBwcm9wLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wLmNvbXB1dGVkX2tleSgpKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRvci5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIHByb3Aua2V5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIHZpc2l0b3IucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcHJvcCBpbnN0YW5jZW9mIEFTVF9DbGFzc1ByaXZhdGVQcm9wZXJ0eSAmJiBwcm9wLnN0YXRpYyAmJiBwcm9wLnZhbHVlXG4gICAgICAgICAgICAgICAgfHwgcHJvcCBpbnN0YW5jZW9mIEFTVF9DbGFzc1Byb3BlcnR5ICYmIHByb3Auc3RhdGljICYmIHByb3AudmFsdWVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZpc2l0b3IucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICBwcm9wLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIHZpc2l0b3IucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqIGdvIHRocm91Z2ggdGhlIGJpdHMgdGhhdCBhcmUgZXhlY3V0ZWQgbGF0ZXIsIHdoZW4gdGhlIGNsYXNzIGlzIGBuZXdgJ2Qgb3IgYSBzdGF0aWMgbWV0aG9kIGlzIGNhbGxlZCAqL1xuICAgIHZpc2l0X2RlZmVycmVkX2NsYXNzX3BhcnRzKHZpc2l0b3IpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwcm9wIGluc3RhbmNlb2YgQVNUX0NvbmNpc2VNZXRob2RcbiAgICAgICAgICAgICAgICB8fCBwcm9wIGluc3RhbmNlb2YgQVNUX1ByaXZhdGVNZXRob2RcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb3Aud2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgcHJvcCBpbnN0YW5jZW9mIEFTVF9DbGFzc1Byb3BlcnR5ICYmICFwcm9wLnN0YXRpYyAmJiBwcm9wLnZhbHVlXG4gICAgICAgICAgICAgICAgfHwgcHJvcCBpbnN0YW5jZW9mIEFTVF9DbGFzc1ByaXZhdGVQcm9wZXJ0eSAmJiAhcHJvcC5zdGF0aWMgJiYgcHJvcC52YWx1ZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRvci5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIHByb3AudmFsdWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgdmlzaXRvci5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBpc19zZWxmX3JlZmVyZW50aWFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgdGhpc19pZCA9IHRoaXMubmFtZSAmJiB0aGlzLm5hbWUuZGVmaW5pdGlvbigpLmlkO1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNsYXNzX3RoaXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpc2l0X25vbmRlZmVycmVkX2NsYXNzX3BhcnRzKG5ldyBUcmVlV2Fsa2VyKChub2RlLCBkZXNjZW5kKSA9PiB7XG4gICAgICAgICAgICBpZiAoZm91bmQpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVGhpcykgcmV0dXJuIChmb3VuZCA9IGNsYXNzX3RoaXMpO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSByZXR1cm4gKGZvdW5kID0gbm9kZS5kZWZpbml0aW9uKCkuaWQgPT09IHRoaXNfaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhICYmICEobm9kZSBpbnN0YW5jZW9mIEFTVF9BcnJvdykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc190aGlzX3NhdmUgPSBjbGFzc190aGlzO1xuICAgICAgICAgICAgICAgIGNsYXNzX3RoaXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICAgICAgY2xhc3NfdGhpcyA9IGNsYXNzX3RoaXNfc2F2ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfSxcbn0sIEFTVF9TY29wZSAvKiBUT0RPIGEgY2xhc3MgbWlnaHQgaGF2ZSBhIHNjb3BlIGJ1dCBpdCdzIG5vdCBhIHNjb3BlICovKTtcblxudmFyIEFTVF9DbGFzc1Byb3BlcnR5ID0gREVGTk9ERShcIkNsYXNzUHJvcGVydHlcIiwgXCJzdGF0aWMgcXVvdGVcIiwgZnVuY3Rpb24gQVNUX0NsYXNzUHJvcGVydHkocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGF0aWMgPSBwcm9wcy5zdGF0aWM7XG4gICAgICAgIHRoaXMucXVvdGUgPSBwcm9wcy5xdW90ZTtcbiAgICAgICAgdGhpcy5rZXkgPSBwcm9wcy5rZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBwcm9wcy5fYW5ub3RhdGlvbnM7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBjbGFzcyBwcm9wZXJ0eVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHN0YXRpYzogXCJbYm9vbGVhbl0gd2hldGhlciB0aGlzIGlzIGEgc3RhdGljIGtleVwiLFxuICAgICAgICBxdW90ZTogXCJbc3RyaW5nXSB3aGljaCBxdW90ZSBpcyBiZWluZyB1c2VkXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmtleSBpbnN0YW5jZW9mIEFTVF9Ob2RlKVxuICAgICAgICAgICAgICAgIHRoaXMua2V5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBBU1RfTm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSBpbnN0YW5jZW9mIEFTVF9Ob2RlKSBwdXNoKHRoaXMudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSkgcHVzaCh0aGlzLmtleSk7XG4gICAgfSxcbiAgICBjb21wdXRlZF9rZXkoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMua2V5IGluc3RhbmNlb2YgQVNUX1N5bWJvbENsYXNzUHJvcGVydHkpO1xuICAgIH1cbn0sIEFTVF9PYmplY3RQcm9wZXJ0eSk7XG5cbnZhciBBU1RfQ2xhc3NQcml2YXRlUHJvcGVydHkgPSBERUZOT0RFKFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiwgXCJcIiwgZnVuY3Rpb24gQVNUX0NsYXNzUHJpdmF0ZVByb3BlcnR5KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc3RhdGljID0gcHJvcHMuc3RhdGljO1xuICAgICAgICB0aGlzLmtleSA9IHByb3BzLmtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgY2xhc3MgcHJvcGVydHkgZm9yIGEgcHJpdmF0ZSBwcm9wZXJ0eVwiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgQVNUX05vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBBU1RfTm9kZSkgcHVzaCh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIGNvbXB1dGVkX2tleSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX1ByaXZhdGVJbiA9IERFRk5PREUoXCJQcml2YXRlSW5cIiwgXCJrZXkgdmFsdWVcIiwgZnVuY3Rpb24gQVNUX1ByaXZhdGVJbihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmtleSA9IHByb3BzLmtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIGBpbmAgYmlub3Agd2hlbiB0aGUga2V5IGlzIHByaXZhdGUsIGVnICN4IGluIHRoaXNcIixcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmtleS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy52YWx1ZSk7XG4gICAgICAgIHB1c2godGhpcy5rZXkpO1xuICAgIH0sXG59KTtcblxudmFyIEFTVF9EZWZDbGFzcyA9IERFRk5PREUoXCJEZWZDbGFzc1wiLCBudWxsLCBmdW5jdGlvbiBBU1RfRGVmQ2xhc3MocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy5leHRlbmRzID0gcHJvcHMuZXh0ZW5kcztcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcHMucHJvcGVydGllcztcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSBwcm9wcy52YXJpYWJsZXM7XG4gICAgICAgIHRoaXMudXNlc193aXRoID0gcHJvcHMudXNlc193aXRoO1xuICAgICAgICB0aGlzLnVzZXNfZXZhbCA9IHByb3BzLnVzZXNfZXZhbDtcbiAgICAgICAgdGhpcy5wYXJlbnRfc2NvcGUgPSBwcm9wcy5wYXJlbnRfc2NvcGU7XG4gICAgICAgIHRoaXMuZW5jbG9zZWQgPSBwcm9wcy5lbmNsb3NlZDtcbiAgICAgICAgdGhpcy5jbmFtZSA9IHByb3BzLmNuYW1lO1xuICAgICAgICB0aGlzLmJvZHkgPSBwcm9wcy5ib2R5O1xuICAgICAgICB0aGlzLmJsb2NrX3Njb3BlID0gcHJvcHMuYmxvY2tfc2NvcGU7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBjbGFzcyBkZWZpbml0aW9uXCIsXG59LCBBU1RfQ2xhc3MpO1xuXG52YXIgQVNUX0NsYXNzU3RhdGljQmxvY2sgPSBERUZOT0RFKFwiQ2xhc3NTdGF0aWNCbG9ja1wiLCBcImJvZHkgYmxvY2tfc2NvcGVcIiwgZnVuY3Rpb24gQVNUX0NsYXNzU3RhdGljQmxvY2sgKHByb3BzKSB7XG4gICAgdGhpcy5ib2R5ID0gcHJvcHMuYm9keTtcbiAgICB0aGlzLmJsb2NrX3Njb3BlID0gcHJvcHMuYmxvY2tfc2NvcGU7XG4gICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYmxvY2sgY29udGFpbmluZyBzdGF0ZW1lbnRzIHRvIGJlIGV4ZWN1dGVkIGluIHRoZSBjb250ZXh0IG9mIHRoZSBjbGFzc1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9TdGF0ZW1lbnQqXSBhbiBhcnJheSBvZiBzdGF0ZW1lbnRzXCIsXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5ib2R5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmJvZHlbaV0pO1xuICAgIH0sXG4gICAgY2xvbmU6IGNsb25lX2Jsb2NrX3Njb3BlLFxuICAgIGNvbXB1dGVkX2tleSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG59LCBBU1RfU2NvcGUpO1xuXG52YXIgQVNUX0NsYXNzRXhwcmVzc2lvbiA9IERFRk5PREUoXCJDbGFzc0V4cHJlc3Npb25cIiwgbnVsbCwgZnVuY3Rpb24gQVNUX0NsYXNzRXhwcmVzc2lvbihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLmV4dGVuZHMgPSBwcm9wcy5leHRlbmRzO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wcy5wcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHByb3BzLnZhcmlhYmxlcztcbiAgICAgICAgdGhpcy51c2VzX3dpdGggPSBwcm9wcy51c2VzX3dpdGg7XG4gICAgICAgIHRoaXMudXNlc19ldmFsID0gcHJvcHMudXNlc19ldmFsO1xuICAgICAgICB0aGlzLnBhcmVudF9zY29wZSA9IHByb3BzLnBhcmVudF9zY29wZTtcbiAgICAgICAgdGhpcy5lbmNsb3NlZCA9IHByb3BzLmVuY2xvc2VkO1xuICAgICAgICB0aGlzLmNuYW1lID0gcHJvcHMuY25hbWU7XG4gICAgICAgIHRoaXMuYm9keSA9IHByb3BzLmJvZHk7XG4gICAgICAgIHRoaXMuYmxvY2tfc2NvcGUgPSBwcm9wcy5ibG9ja19zY29wZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGNsYXNzIGV4cHJlc3Npb24uXCJcbn0sIEFTVF9DbGFzcyk7XG5cbnZhciBBU1RfU3ltYm9sID0gREVGTk9ERShcIlN5bWJvbFwiLCBcInNjb3BlIG5hbWUgdGhlZGVmXCIsIGZ1bmN0aW9uIEFTVF9TeW1ib2wocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHByb3BzLnNjb3BlO1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHByb3BzLnRoZWRlZjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltzdHJpbmddIG5hbWUgb2YgdGhpcyBzeW1ib2xcIixcbiAgICAgICAgc2NvcGU6IFwiW0FTVF9TY29wZS9TXSB0aGUgY3VycmVudCBzY29wZSAobm90IG5lY2Vzc2FyaWx5IHRoZSBkZWZpbml0aW9uIHNjb3BlKVwiLFxuICAgICAgICB0aGVkZWY6IFwiW1N5bWJvbERlZi9TXSB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzIHN5bWJvbFwiXG4gICAgfSxcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgc3ltYm9sc1wiXG59KTtcblxudmFyIEFTVF9OZXdUYXJnZXQgPSBERUZOT0RFKFwiTmV3VGFyZ2V0XCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9OZXdUYXJnZXQocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHJlZmVyZW5jZSB0byBuZXcudGFyZ2V0XCJcbn0pO1xuXG52YXIgQVNUX1N5bWJvbERlY2xhcmF0aW9uID0gREVGTk9ERShcIlN5bWJvbERlY2xhcmF0aW9uXCIsIFwiaW5pdFwiLCBmdW5jdGlvbiBBU1RfU3ltYm9sRGVjbGFyYXRpb24ocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5pbml0ID0gcHJvcHMuaW5pdDtcbiAgICAgICAgdGhpcy5zY29wZSA9IHByb3BzLnNjb3BlO1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHByb3BzLnRoZWRlZjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGRlY2xhcmF0aW9uIHN5bWJvbCAoc3ltYm9sIGluIHZhci9jb25zdCwgZnVuY3Rpb24gbmFtZSBvciBhcmd1bWVudCwgc3ltYm9sIGluIGNhdGNoKVwiLFxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfU3ltYm9sVmFyID0gREVGTk9ERShcIlN5bWJvbFZhclwiLCBudWxsLCBmdW5jdGlvbiBBU1RfU3ltYm9sVmFyKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuaW5pdCA9IHByb3BzLmluaXQ7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBwcm9wcy5zY29wZTtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy50aGVkZWYgPSBwcm9wcy50aGVkZWY7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIGRlZmluaW5nIGEgdmFyaWFibGVcIixcbn0sIEFTVF9TeW1ib2xEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbiA9IERFRk5PREUoXG4gICAgXCJTeW1ib2xCbG9ja0RlY2xhcmF0aW9uXCIsXG4gICAgbnVsbCxcbiAgICBmdW5jdGlvbiBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbihwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IHByb3BzLmluaXQ7XG4gICAgICAgICAgICB0aGlzLnNjb3BlID0gcHJvcHMuc2NvcGU7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICAgICAgdGhpcy50aGVkZWYgPSBwcm9wcy50aGVkZWY7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgIH0sXG4gICAge1xuICAgICAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBibG9jay1zY29wZWQgZGVjbGFyYXRpb24gc3ltYm9sc1wiXG4gICAgfSxcbiAgICBBU1RfU3ltYm9sRGVjbGFyYXRpb25cbik7XG5cbnZhciBBU1RfU3ltYm9sQ29uc3QgPSBERUZOT0RFKFwiU3ltYm9sQ29uc3RcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1N5bWJvbENvbnN0KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuaW5pdCA9IHByb3BzLmluaXQ7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBwcm9wcy5zY29wZTtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy50aGVkZWYgPSBwcm9wcy50aGVkZWY7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBjb25zdGFudCBkZWNsYXJhdGlvblwiXG59LCBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfU3ltYm9sVXNpbmcgPSBERUZOT0RFKFwiU3ltYm9sVXNpbmdcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1N5bWJvbFVzaW5nKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuaW5pdCA9IHByb3BzLmluaXQ7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBwcm9wcy5zY29wZTtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy50aGVkZWYgPSBwcm9wcy50aGVkZWY7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgdXNpbmdgIGRlY2xhcmF0aW9uXCJcbn0sIEFTVF9TeW1ib2xCbG9ja0RlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xMZXQgPSBERUZOT0RFKFwiU3ltYm9sTGV0XCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9TeW1ib2xMZXQocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5pbml0ID0gcHJvcHMuaW5pdDtcbiAgICAgICAgdGhpcy5zY29wZSA9IHByb3BzLnNjb3BlO1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHByb3BzLnRoZWRlZjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGJsb2NrLXNjb3BlZCBgbGV0YCBkZWNsYXJhdGlvblwiXG59LCBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfU3ltYm9sRnVuYXJnID0gREVGTk9ERShcIlN5bWJvbEZ1bmFyZ1wiLCBudWxsLCBmdW5jdGlvbiBBU1RfU3ltYm9sRnVuYXJnKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuaW5pdCA9IHByb3BzLmluaXQ7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBwcm9wcy5zY29wZTtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy50aGVkZWYgPSBwcm9wcy50aGVkZWY7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIG5hbWluZyBhIGZ1bmN0aW9uIGFyZ3VtZW50XCIsXG59LCBBU1RfU3ltYm9sVmFyKTtcblxudmFyIEFTVF9TeW1ib2xEZWZ1biA9IERFRk5PREUoXCJTeW1ib2xEZWZ1blwiLCBudWxsLCBmdW5jdGlvbiBBU1RfU3ltYm9sRGVmdW4ocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5pbml0ID0gcHJvcHMuaW5pdDtcbiAgICAgICAgdGhpcy5zY29wZSA9IHByb3BzLnNjb3BlO1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHByb3BzLnRoZWRlZjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgZGVmaW5pbmcgYSBmdW5jdGlvblwiLFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xNZXRob2QgPSBERUZOT0RFKFwiU3ltYm9sTWV0aG9kXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9TeW1ib2xNZXRob2QocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHByb3BzLnNjb3BlO1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHByb3BzLnRoZWRlZjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgaW4gYW4gb2JqZWN0IGRlZmluaW5nIGEgbWV0aG9kXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9TeW1ib2xDbGFzc1Byb3BlcnR5ID0gREVGTk9ERShcIlN5bWJvbENsYXNzUHJvcGVydHlcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1N5bWJvbENsYXNzUHJvcGVydHkocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHByb3BzLnNjb3BlO1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHByb3BzLnRoZWRlZjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgZm9yIGEgY2xhc3MgcHJvcGVydHlcIixcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX1N5bWJvbExhbWJkYSA9IERFRk5PREUoXCJTeW1ib2xMYW1iZGFcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1N5bWJvbExhbWJkYShwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmluaXQgPSBwcm9wcy5pbml0O1xuICAgICAgICB0aGlzLnNjb3BlID0gcHJvcHMuc2NvcGU7XG4gICAgICAgIHRoaXMubmFtZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIHRoaXMudGhlZGVmID0gcHJvcHMudGhlZGVmO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBuYW1pbmcgYSBmdW5jdGlvbiBleHByZXNzaW9uXCIsXG59LCBBU1RfU3ltYm9sRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX1N5bWJvbERlZkNsYXNzID0gREVGTk9ERShcIlN5bWJvbERlZkNsYXNzXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9TeW1ib2xEZWZDbGFzcyhwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmluaXQgPSBwcm9wcy5pbml0O1xuICAgICAgICB0aGlzLnNjb3BlID0gcHJvcHMuc2NvcGU7XG4gICAgICAgIHRoaXMubmFtZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIHRoaXMudGhlZGVmID0gcHJvcHMudGhlZGVmO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBuYW1pbmcgYSBjbGFzcydzIG5hbWUgaW4gYSBjbGFzcyBkZWNsYXJhdGlvbi4gTGV4aWNhbGx5IHNjb3BlZCB0byBpdHMgY29udGFpbmluZyBzY29wZSwgYW5kIGFjY2Vzc2libGUgd2l0aGluIHRoZSBjbGFzcy5cIlxufSwgQVNUX1N5bWJvbEJsb2NrRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX1N5bWJvbENsYXNzID0gREVGTk9ERShcIlN5bWJvbENsYXNzXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9TeW1ib2xDbGFzcyhwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmluaXQgPSBwcm9wcy5pbml0O1xuICAgICAgICB0aGlzLnNjb3BlID0gcHJvcHMuc2NvcGU7XG4gICAgICAgIHRoaXMubmFtZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIHRoaXMudGhlZGVmID0gcHJvcHMudGhlZGVmO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBuYW1pbmcgYSBjbGFzcydzIG5hbWUuIExleGljYWxseSBzY29wZWQgdG8gdGhlIGNsYXNzLlwiXG59LCBBU1RfU3ltYm9sRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX1N5bWJvbENhdGNoID0gREVGTk9ERShcIlN5bWJvbENhdGNoXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9TeW1ib2xDYXRjaChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmluaXQgPSBwcm9wcy5pbml0O1xuICAgICAgICB0aGlzLnNjb3BlID0gcHJvcHMuc2NvcGU7XG4gICAgICAgIHRoaXMubmFtZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIHRoaXMudGhlZGVmID0gcHJvcHMudGhlZGVmO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBuYW1pbmcgdGhlIGV4Y2VwdGlvbiBpbiBjYXRjaFwiLFxufSwgQVNUX1N5bWJvbEJsb2NrRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX1N5bWJvbEltcG9ydCA9IERFRk5PREUoXCJTeW1ib2xJbXBvcnRcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1N5bWJvbEltcG9ydChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLmluaXQgPSBwcm9wcy5pbml0O1xuICAgICAgICB0aGlzLnNjb3BlID0gcHJvcHMuc2NvcGU7XG4gICAgICAgIHRoaXMubmFtZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIHRoaXMudGhlZGVmID0gcHJvcHMudGhlZGVmO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCByZWZlcnJpbmcgdG8gYW4gaW1wb3J0ZWQgbmFtZVwiLFxufSwgQVNUX1N5bWJvbEJsb2NrRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX1N5bWJvbEltcG9ydEZvcmVpZ24gPSBERUZOT0RFKFwiU3ltYm9sSW1wb3J0Rm9yZWlnblwiLCBcInF1b3RlXCIsIGZ1bmN0aW9uIEFTVF9TeW1ib2xJbXBvcnRGb3JlaWduKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMucXVvdGUgPSBwcm9wcy5xdW90ZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHByb3BzLnNjb3BlO1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHByb3BzLnRoZWRlZjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHN5bWJvbCBpbXBvcnRlZCBmcm9tIGEgbW9kdWxlLCBidXQgaXQgaXMgZGVmaW5lZCBpbiB0aGUgb3RoZXIgbW9kdWxlLCBhbmQgaXRzIHJlYWwgbmFtZSBpcyBpcnJlbGV2YW50IGZvciB0aGlzIG1vZHVsZSdzIHB1cnBvc2VzXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9MYWJlbCA9IERFRk5PREUoXCJMYWJlbFwiLCBcInJlZmVyZW5jZXNcIiwgZnVuY3Rpb24gQVNUX0xhYmVsKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHByb3BzLnJlZmVyZW5jZXM7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBwcm9wcy5zY29wZTtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy50aGVkZWYgPSBwcm9wcy50aGVkZWY7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBuYW1pbmcgYSBsYWJlbCAoZGVjbGFyYXRpb24pXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgcmVmZXJlbmNlczogXCJbQVNUX0xvb3BDb250cm9sKl0gYSBsaXN0IG9mIG5vZGVzIHJlZmVycmluZyB0byB0aGlzIGxhYmVsXCJcbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy50aGVkZWYgPSB0aGlzO1xuICAgIH1cbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX1N5bWJvbFJlZiA9IERFRk5PREUoXCJTeW1ib2xSZWZcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1N5bWJvbFJlZihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnNjb3BlID0gcHJvcHMuc2NvcGU7XG4gICAgICAgIHRoaXMubmFtZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIHRoaXMudGhlZGVmID0gcHJvcHMudGhlZGVmO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlJlZmVyZW5jZSB0byBzb21lIHN5bWJvbCAobm90IGRlZmluaXRpb24vZGVjbGFyYXRpb24pXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9TeW1ib2xFeHBvcnQgPSBERUZOT0RFKFwiU3ltYm9sRXhwb3J0XCIsIFwicXVvdGVcIiwgZnVuY3Rpb24gQVNUX1N5bWJvbEV4cG9ydChwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnF1b3RlID0gcHJvcHMucXVvdGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBwcm9wcy5zY29wZTtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy50aGVkZWYgPSBwcm9wcy50aGVkZWY7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIHJlZmVycmluZyB0byBhIG5hbWUgdG8gZXhwb3J0XCIsXG59LCBBU1RfU3ltYm9sUmVmKTtcblxudmFyIEFTVF9TeW1ib2xFeHBvcnRGb3JlaWduID0gREVGTk9ERShcIlN5bWJvbEV4cG9ydEZvcmVpZ25cIiwgXCJxdW90ZVwiLCBmdW5jdGlvbiBBU1RfU3ltYm9sRXhwb3J0Rm9yZWlnbihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnF1b3RlID0gcHJvcHMucXVvdGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBwcm9wcy5zY29wZTtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy50aGVkZWYgPSBwcm9wcy50aGVkZWY7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBzeW1ib2wgZXhwb3J0ZWQgZnJvbSB0aGlzIG1vZHVsZSwgYnV0IGl0IGlzIHVzZWQgaW4gdGhlIG90aGVyIG1vZHVsZSwgYW5kIGl0cyByZWFsIG5hbWUgaXMgaXJyZWxldmFudCBmb3IgdGhpcyBtb2R1bGUncyBwdXJwb3Nlc1wiLFxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfTGFiZWxSZWYgPSBERUZOT0RFKFwiTGFiZWxSZWZcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX0xhYmVsUmVmKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBwcm9wcy5zY29wZTtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy50aGVkZWYgPSBwcm9wcy50aGVkZWY7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiUmVmZXJlbmNlIHRvIGEgbGFiZWwgc3ltYm9sXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9TeW1ib2xQcml2YXRlUHJvcGVydHkgPSBERUZOT0RFKFwiU3ltYm9sUHJpdmF0ZVByb3BlcnR5XCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9TeW1ib2xQcml2YXRlUHJvcGVydHkocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHByb3BzLnNjb3BlO1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHByb3BzLnRoZWRlZjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHN5bWJvbCB0aGF0IHJlZmVycyB0byBhIHByaXZhdGUgcHJvcGVydHlcIixcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX1RoaXMgPSBERUZOT0RFKFwiVGhpc1wiLCBudWxsLCBmdW5jdGlvbiBBU1RfVGhpcyhwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnNjb3BlID0gcHJvcHMuc2NvcGU7XG4gICAgICAgIHRoaXMubmFtZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIHRoaXMudGhlZGVmID0gcHJvcHMudGhlZGVmO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgdGhpc2Agc3ltYm9sXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9TdXBlciA9IERFRk5PREUoXCJTdXBlclwiLCBudWxsLCBmdW5jdGlvbiBBU1RfU3VwZXIocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHByb3BzLnNjb3BlO1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHByb3BzLnRoZWRlZjtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYHN1cGVyYCBzeW1ib2xcIixcbn0sIEFTVF9UaGlzKTtcblxudmFyIEFTVF9Db25zdGFudCA9IERFRk5PREUoXCJDb25zdGFudFwiLCBudWxsLCBmdW5jdGlvbiBBU1RfQ29uc3RhbnQocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgY29uc3RhbnRzXCIsXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9TdHJpbmcgPSBERUZOT0RFKFwiU3RyaW5nXCIsIFwidmFsdWUgcXVvdGVcIiwgZnVuY3Rpb24gQVNUX1N0cmluZyhwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIHRoaXMucXVvdGUgPSBwcm9wcy5xdW90ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBwcm9wcy5fYW5ub3RhdGlvbnM7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBzdHJpbmcgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIltzdHJpbmddIHRoZSBjb250ZW50cyBvZiB0aGlzIHN0cmluZ1wiLFxuICAgICAgICBxdW90ZTogXCJbc3RyaW5nXSB0aGUgb3JpZ2luYWwgcXVvdGUgY2hhcmFjdGVyXCJcbiAgICB9XG59LCBBU1RfQ29uc3RhbnQpO1xuXG52YXIgQVNUX051bWJlciA9IERFRk5PREUoXCJOdW1iZXJcIiwgXCJ2YWx1ZSByYXdcIiwgZnVuY3Rpb24gQVNUX051bWJlcihwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIHRoaXMucmF3ID0gcHJvcHMucmF3O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgbnVtYmVyIGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbbnVtYmVyXSB0aGUgbnVtZXJpYyB2YWx1ZVwiLFxuICAgICAgICByYXc6IFwiW3N0cmluZ10gbnVtZXJpYyB2YWx1ZSBhcyBzdHJpbmdcIlxuICAgIH1cbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfQmlnSW50ID0gREVGTk9ERShcIkJpZ0ludFwiLCBcInZhbHVlIHJhd1wiLCBmdW5jdGlvbiBBU1RfQmlnSW50KHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgICAgdGhpcy5yYXcgPSBwcm9wcy5yYXc7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBiaWcgaW50IGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbc3RyaW5nXSBiaWcgaW50IHZhbHVlLCByZXByZXNlbnRlZCBhcyBhIHN0cmluZ1wiLFxuICAgICAgICByYXc6IFwiW3N0cmluZ10gdGhlIG9yaWdpbmFsIGZvcm1hdCBwcmVzZXJ2ZWRcIlxuICAgIH1cbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfUmVnRXhwID0gREVGTk9ERShcIlJlZ0V4cFwiLCBcInZhbHVlXCIsIGZ1bmN0aW9uIEFTVF9SZWdFeHAocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgcmVnZXhwIGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbUmVnRXhwXSB0aGUgYWN0dWFsIHJlZ2V4cFwiLFxuICAgIH1cbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfQXRvbSA9IERFRk5PREUoXCJBdG9tXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9BdG9tKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYXRvbXNcIixcbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfTnVsbCA9IERFRk5PREUoXCJOdWxsXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9OdWxsKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBwcm9wcy5lbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IDA7XG59LCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGBudWxsYCBhdG9tXCIsXG4gICAgdmFsdWU6IG51bGxcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9OYU4gPSBERUZOT0RFKFwiTmFOXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9OYU4ocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgaW1wb3NzaWJsZSB2YWx1ZVwiLFxuICAgIHZhbHVlOiAwLzBcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9VbmRlZmluZWQgPSBERUZOT0RFKFwiVW5kZWZpbmVkXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9VbmRlZmluZWQocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYHVuZGVmaW5lZGAgdmFsdWVcIixcbiAgICB2YWx1ZTogKGZ1bmN0aW9uKCkge30oKSlcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9Ib2xlID0gREVGTk9ERShcIkhvbGVcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX0hvbGUocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGhvbGUgaW4gYW4gYXJyYXlcIixcbiAgICB2YWx1ZTogKGZ1bmN0aW9uKCkge30oKSlcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9JbmZpbml0eSA9IERFRk5PREUoXCJJbmZpbml0eVwiLCBudWxsLCBmdW5jdGlvbiBBU1RfSW5maW5pdHkocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYEluZmluaXR5YCB2YWx1ZVwiLFxuICAgIHZhbHVlOiAxLzBcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9Cb29sZWFuID0gREVGTk9ERShcIkJvb2xlYW5cIiwgbnVsbCwgZnVuY3Rpb24gQVNUX0Jvb2xlYW4ocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBib29sZWFuc1wiLFxufSwgQVNUX0F0b20pO1xuXG52YXIgQVNUX0ZhbHNlID0gREVGTk9ERShcIkZhbHNlXCIsIG51bGwsIGZ1bmN0aW9uIEFTVF9GYWxzZShwcm9wcykge1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gcHJvcHMuc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gcHJvcHMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSAwO1xufSwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgZmFsc2VgIGF0b21cIixcbiAgICB2YWx1ZTogZmFsc2Vcbn0sIEFTVF9Cb29sZWFuKTtcblxudmFyIEFTVF9UcnVlID0gREVGTk9ERShcIlRydWVcIiwgbnVsbCwgZnVuY3Rpb24gQVNUX1RydWUocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHByb3BzLnN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IHByb3BzLmVuZDtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gMDtcbn0sIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYHRydWVgIGF0b21cIixcbiAgICB2YWx1ZTogdHJ1ZVxufSwgQVNUX0Jvb2xlYW4pO1xuXG4vKiAtLS0tLVsgV2FsayBmdW5jdGlvbiBdLS0tLSAqL1xuXG4vKipcbiAqIFdhbGsgbm9kZXMgaW4gZGVwdGgtZmlyc3Qgc2VhcmNoIGZhc2hpb24uXG4gKiBDYWxsYmFjayBjYW4gcmV0dXJuIGB3YWxrX2Fib3J0YCBzeW1ib2wgdG8gc3RvcCBpdGVyYXRpb24uXG4gKiBJdCBjYW4gYWxzbyByZXR1cm4gYHRydWVgIHRvIHN0b3AgaXRlcmF0aW9uIGp1c3QgZm9yIGNoaWxkIG5vZGVzLlxuICogSXRlcmF0aW9uIGNhbiBiZSBzdG9wcGVkIGFuZCBjb250aW51ZWQgYnkgcGFzc2luZyB0aGUgYHRvX3Zpc2l0YCBhcmd1bWVudCxcbiAqIHdoaWNoIGlzIGdpdmVuIHRvIHRoZSBjYWxsYmFjayBpbiB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICoqL1xuZnVuY3Rpb24gd2Fsayhub2RlLCBjYiwgdG9fdmlzaXQgPSBbbm9kZV0pIHtcbiAgICBjb25zdCBwdXNoID0gdG9fdmlzaXQucHVzaC5iaW5kKHRvX3Zpc2l0KTtcbiAgICB3aGlsZSAodG9fdmlzaXQubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0b192aXNpdC5wb3AoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gY2Iobm9kZSwgdG9fdmlzaXQpO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgIGlmIChyZXQgPT09IHdhbGtfYWJvcnQpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLl9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBXYWxrcyBhbiBBU1Qgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICpcbiAqIHtjYn0gY2FuIHJldHVybiBgd2Fsa19hYm9ydGAgdG8gaW50ZXJydXB0IHRoZSB3YWxrLlxuICpcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY2Igeyhub2RlLCBpbmZvOiB7IHBhcmVudDogKG50aCkgPT4gYW55IH0pID0+IChib29sZWFuIHwgdW5kZWZpbmVkKX1cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgd2FsayB3YXMgYWJvcnRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBmb3VuZF9zb21lX2NvbmQgPSB3YWxrX3BhcmVudChteV9hc3Rfbm9kZSwgKG5vZGUsIHsgcGFyZW50IH0pID0+IHtcbiAqICAgaWYgKHNvbWVfY29uZChub2RlLCBwYXJlbnQoKSkpIHJldHVybiB3YWxrX2Fib3J0XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gd2Fsa19wYXJlbnQobm9kZSwgY2IsIGluaXRpYWxfc3RhY2spIHtcbiAgICBjb25zdCB0b192aXNpdCA9IFtub2RlXTtcbiAgICBjb25zdCBwdXNoID0gdG9fdmlzaXQucHVzaC5iaW5kKHRvX3Zpc2l0KTtcbiAgICBjb25zdCBzdGFjayA9IGluaXRpYWxfc3RhY2sgPyBpbml0aWFsX3N0YWNrLnNsaWNlKCkgOiBbXTtcbiAgICBjb25zdCBwYXJlbnRfcG9wX2luZGljZXMgPSBbXTtcblxuICAgIGxldCBjdXJyZW50O1xuXG4gICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgcGFyZW50OiAobiA9IDApID0+IHtcbiAgICAgICAgICAgIGlmIChuID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBbIHAxIHAwIF0gWyAxIDAgXVxuICAgICAgICAgICAgaWYgKGluaXRpYWxfc3RhY2sgJiYgbiA+PSBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuIC09IHN0YWNrLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhbF9zdGFja1tcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbF9zdGFjay5sZW5ndGggLSAobiArIDEpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtICgxICsgbildO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICB3aGlsZSAodG9fdmlzaXQubGVuZ3RoKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0b192aXNpdC5wb3AoKTtcblxuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICBwYXJlbnRfcG9wX2luZGljZXMubGVuZ3RoICYmXG4gICAgICAgICAgICB0b192aXNpdC5sZW5ndGggPT0gcGFyZW50X3BvcF9pbmRpY2VzW3BhcmVudF9wb3BfaW5kaWNlcy5sZW5ndGggLSAxXVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcGFyZW50X3BvcF9pbmRpY2VzLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmV0ID0gY2IoY3VycmVudCwgaW5mbyk7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gd2Fsa19hYm9ydCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZpc2l0X2xlbmd0aCA9IHRvX3Zpc2l0Lmxlbmd0aDtcblxuICAgICAgICBjdXJyZW50Ll9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCk7XG5cbiAgICAgICAgLy8gUHVzaCBvbmx5IGlmIHdlJ3JlIGdvaW5nIHRvIHRyYXZlcnNlIHRoZSBjaGlsZHJlblxuICAgICAgICBpZiAodG9fdmlzaXQubGVuZ3RoID4gdmlzaXRfbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgcGFyZW50X3BvcF9pbmRpY2VzLnB1c2godmlzaXRfbGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IHdhbGtfYWJvcnQgPSBTeW1ib2woXCJhYm9ydCB3YWxrXCIpO1xuXG4vKiAtLS0tLVsgVHJlZVdhbGtlciBdLS0tLS0gKi9cblxuY2xhc3MgVHJlZVdhbGtlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy52aXNpdCA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuXG4gICAgX3Zpc2l0KG5vZGUsIGRlc2NlbmQpIHtcbiAgICAgICAgdGhpcy5wdXNoKG5vZGUpO1xuICAgICAgICB2YXIgcmV0ID0gdGhpcy52aXNpdChub2RlLCBkZXNjZW5kID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZXNjZW5kLmNhbGwobm9kZSk7XG4gICAgICAgIH0gOiBub29wKTtcbiAgICAgICAgaWYgKCFyZXQgJiYgZGVzY2VuZCkge1xuICAgICAgICAgICAgZGVzY2VuZC5jYWxsKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcGFyZW50KG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyIC0gKG4gfHwgMCldO1xuICAgIH1cblxuICAgIHB1c2gobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IE9iamVjdC5jcmVhdGUodGhpcy5kaXJlY3RpdmVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RpcmVjdGl2ZSAmJiAhdGhpcy5kaXJlY3RpdmVzW25vZGUudmFsdWVdKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXNbbm9kZS52YWx1ZV0gPSBub2RlO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IE9iamVjdC5jcmVhdGUodGhpcy5kaXJlY3RpdmVzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXJlY3RpdmVzW1widXNlIHN0cmljdFwiXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlc1tcInVzZSBzdHJpY3RcIl0gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICBwb3AoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLmRpcmVjdGl2ZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBmaW5kX3BhcmVudCh0eXBlKSB7XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgdmFyIHggPSBzdGFja1tpXTtcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgdHlwZSkgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc193aXRoaW5fbG9vcCgpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXMuc3RhY2tbaV07XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW2ldO1xuXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX0l0ZXJhdGlvblN0YXRlbWVudFxuICAgICAgICAgICAgICAgIC8vIGV4Y2x1ZGUgZm9yLWxvb3AgYml0cyB0aGF0IG9ubHkgcnVuIG9uY2VcbiAgICAgICAgICAgICAgICAmJiAhKChub2RlIGluc3RhbmNlb2YgQVNUX0ZvcikgJiYgY2hpbGQgPT09IG5vZGUuaW5pdClcbiAgICAgICAgICAgICAgICAmJiAhKChub2RlIGluc3RhbmNlb2YgQVNUX0ZvckluIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRm9yT2YpICYmIGNoaWxkID09PSBub2RlLm9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZCA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZmluZF9zY29wZSgpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICBjb25zdCBwID0gc3RhY2tbaV07XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Ub3BsZXZlbCkgcmV0dXJuIHA7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHJldHVybiBwO1xuICAgICAgICAgICAgaWYgKHAuYmxvY2tfc2NvcGUpIHJldHVybiBwLmJsb2NrX3Njb3BlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzX2RpcmVjdGl2ZSh0eXBlKSB7XG4gICAgICAgIHZhciBkaXIgPSB0aGlzLmRpcmVjdGl2ZXNbdHlwZV07XG4gICAgICAgIGlmIChkaXIpIHJldHVybiBkaXI7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSAmJiBub2RlLmJvZHkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5ib2R5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ID0gbm9kZS5ib2R5W2ldO1xuICAgICAgICAgICAgICAgIGlmICghKHN0IGluc3RhbmNlb2YgQVNUX0RpcmVjdGl2ZSkpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChzdC52YWx1ZSA9PSB0eXBlKSByZXR1cm4gc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb29wY29udHJvbF90YXJnZXQobm9kZSkge1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICBpZiAobm9kZS5sYWJlbCkgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBBU1RfTGFiZWxlZFN0YXRlbWVudCAmJiB4LmxhYmVsLm5hbWUgPT0gbm9kZS5sYWJlbC5uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiB4LmJvZHk7XG4gICAgICAgIH0gZWxzZSBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIHZhciB4ID0gc3RhY2tbaV07XG4gICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0JyZWFrICYmIHggaW5zdGFuY2VvZiBBU1RfU3dpdGNoKVxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUcmVlIHRyYW5zZm9ybWVyIGhlbHBlcnMuXG5jbGFzcyBUcmVlVHJhbnNmb3JtZXIgZXh0ZW5kcyBUcmVlV2Fsa2VyIHtcbiAgICBjb25zdHJ1Y3RvcihiZWZvcmUsIGFmdGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmVmb3JlID0gYmVmb3JlO1xuICAgICAgICB0aGlzLmFmdGVyID0gYWZ0ZXI7XG4gICAgfVxufVxuXG5jb25zdCBfUFVSRSAgICAgICA9IDBiMDAwMDAwMDE7XG5jb25zdCBfSU5MSU5FICAgICA9IDBiMDAwMDAwMTA7XG5jb25zdCBfTk9JTkxJTkUgICA9IDBiMDAwMDAxMDA7XG5jb25zdCBfS0VZICAgICAgICA9IDBiMDAwMDEwMDA7XG5jb25zdCBfTUFOR0xFUFJPUCA9IDBiMDAwMTAwMDA7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gZGVmX3RyYW5zZm9ybShub2RlLCBkZXNjZW5kKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24odHcsIGluX2xpc3QpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkID0gdW5kZWZpbmVkO1xuICAgICAgICB0dy5wdXNoKHRoaXMpO1xuICAgICAgICBpZiAodHcuYmVmb3JlKSB0cmFuc2Zvcm1lZCA9IHR3LmJlZm9yZSh0aGlzLCBkZXNjZW5kLCBpbl9saXN0KTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gdGhpcztcbiAgICAgICAgICAgIGRlc2NlbmQodHJhbnNmb3JtZWQsIHR3KTtcbiAgICAgICAgICAgIGlmICh0dy5hZnRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyX3JldCA9IHR3LmFmdGVyKHRyYW5zZm9ybWVkLCBpbl9saXN0KTtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXJfcmV0ICE9PSB1bmRlZmluZWQpIHRyYW5zZm9ybWVkID0gYWZ0ZXJfcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHR3LnBvcCgpO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgfSk7XG59XG5cbmRlZl90cmFuc2Zvcm0oQVNUX05vZGUsIG5vb3ApO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9MYWJlbGVkU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYubGFiZWwgPSBzZWxmLmxhYmVsLnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0Jsb2NrLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuYm9keSA9IE1BUChzZWxmLmJvZHksIHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9EbywgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfV2hpbGUsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5jb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbi50cmFuc2Zvcm0odHcpO1xuICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0ZvciwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBpZiAoc2VsZi5pbml0KSBzZWxmLmluaXQgPSBzZWxmLmluaXQudHJhbnNmb3JtKHR3KTtcbiAgICBpZiAoc2VsZi5jb25kaXRpb24pIHNlbGYuY29uZGl0aW9uID0gc2VsZi5jb25kaXRpb24udHJhbnNmb3JtKHR3KTtcbiAgICBpZiAoc2VsZi5zdGVwKSBzZWxmLnN0ZXAgPSBzZWxmLnN0ZXAudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9Gb3JJbiwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLmluaXQgPSBzZWxmLmluaXQudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLm9iamVjdCA9IHNlbGYub2JqZWN0LnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfV2l0aCwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9FeGl0LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIGlmIChzZWxmLnZhbHVlKSBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0xvb3BDb250cm9sLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIGlmIChzZWxmLmxhYmVsKSBzZWxmLmxhYmVsID0gc2VsZi5sYWJlbC50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0lmLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuY29uZGl0aW9uID0gc2VsZi5jb25kaXRpb24udHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkgc2VsZi5hbHRlcm5hdGl2ZSA9IHNlbGYuYWx0ZXJuYXRpdmUudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9Td2l0Y2gsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5ib2R5ID0gTUFQKHNlbGYuYm9keSwgdHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0Nhc2UsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5ib2R5ID0gTUFQKHNlbGYuYm9keSwgdHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX1RyeSwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICBpZiAoc2VsZi5iY2F0Y2gpIHNlbGYuYmNhdGNoID0gc2VsZi5iY2F0Y2gudHJhbnNmb3JtKHR3KTtcbiAgICBpZiAoc2VsZi5iZmluYWxseSkgc2VsZi5iZmluYWxseSA9IHNlbGYuYmZpbmFsbHkudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9DYXRjaCwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBpZiAoc2VsZi5hcmduYW1lKSBzZWxmLmFyZ25hbWUgPSBzZWxmLmFyZ25hbWUudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmJvZHkgPSBNQVAoc2VsZi5ib2R5LCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfRGVmaW5pdGlvbnNMaWtlLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZGVmaW5pdGlvbnMgPSBNQVAoc2VsZi5kZWZpbml0aW9ucywgdHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX1ZhckRlZkxpa2UsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5uYW1lID0gc2VsZi5uYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgaWYgKHNlbGYudmFsdWUpIHNlbGYudmFsdWUgPSBzZWxmLnZhbHVlLnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfRGVzdHJ1Y3R1cmluZywgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLm5hbWVzID0gTUFQKHNlbGYubmFtZXMsIHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9MYW1iZGEsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgaWYgKHNlbGYubmFtZSkgc2VsZi5uYW1lID0gc2VsZi5uYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5hcmduYW1lcyA9IE1BUChzZWxmLmFyZ25hbWVzLCB0dywgLyogYWxsb3dfc3BsaWNpbmcgKi8gZmFsc2UpO1xuICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfTm9kZSkge1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmJvZHkgPSBNQVAoc2VsZi5ib2R5LCB0dyk7XG4gICAgfVxufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0NhbGwsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5hcmdzID0gTUFQKHNlbGYuYXJncywgdHcsIC8qIGFsbG93X3NwbGljaW5nICovIGZhbHNlKTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9TZXF1ZW5jZSwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBjb25zdCByZXN1bHQgPSBNQVAoc2VsZi5leHByZXNzaW9ucywgdHcpO1xuICAgIHNlbGYuZXhwcmVzc2lvbnMgPSByZXN1bHQubGVuZ3RoXG4gICAgICAgID8gcmVzdWx0XG4gICAgICAgIDogW25ldyBBU1RfTnVtYmVyKHsgdmFsdWU6IDAgfSldO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX1Byb3BBY2Nlc3MsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfU3ViLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgIHNlbGYucHJvcGVydHkgPSBzZWxmLnByb3BlcnR5LnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfQ2hhaW4sIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfWWllbGQsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgaWYgKHNlbGYuZXhwcmVzc2lvbikgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfQXdhaXQsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfVW5hcnksIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfQmluYXJ5LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYubGVmdCA9IHNlbGYubGVmdC50cmFuc2Zvcm0odHcpO1xuICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0LnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfUHJpdmF0ZUluLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYua2V5ID0gc2VsZi5rZXkudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuY29uZGl0aW9uID0gc2VsZi5jb25kaXRpb24udHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmNvbnNlcXVlbnQgPSBzZWxmLmNvbnNlcXVlbnQudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmFsdGVybmF0aXZlID0gc2VsZi5hbHRlcm5hdGl2ZS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0FycmF5LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZWxlbWVudHMgPSBNQVAoc2VsZi5lbGVtZW50cywgdHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX09iamVjdCwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLnByb3BlcnRpZXMgPSBNQVAoc2VsZi5wcm9wZXJ0aWVzLCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgaWYgKHNlbGYua2V5IGluc3RhbmNlb2YgQVNUX05vZGUpIHtcbiAgICAgICAgc2VsZi5rZXkgPSBzZWxmLmtleS50cmFuc2Zvcm0odHcpO1xuICAgIH1cbiAgICBpZiAoc2VsZi52YWx1ZSkgc2VsZi52YWx1ZSA9IHNlbGYudmFsdWUudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9DbGFzcywgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBpZiAoc2VsZi5uYW1lKSBzZWxmLm5hbWUgPSBzZWxmLm5hbWUudHJhbnNmb3JtKHR3KTtcbiAgICBpZiAoc2VsZi5leHRlbmRzKSBzZWxmLmV4dGVuZHMgPSBzZWxmLmV4dGVuZHMudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLnByb3BlcnRpZXMgPSBNQVAoc2VsZi5wcm9wZXJ0aWVzLCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfQ2xhc3NTdGF0aWNCbG9jaywgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLmJvZHkgPSBNQVAoc2VsZi5ib2R5LCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfRXhwYW5zaW9uLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX05hbWVNYXBwaW5nLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZm9yZWlnbl9uYW1lID0gc2VsZi5mb3JlaWduX25hbWUudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLm5hbWUgPSBzZWxmLm5hbWUudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9JbXBvcnQsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgaWYgKHNlbGYuaW1wb3J0ZWRfbmFtZSkgc2VsZi5pbXBvcnRlZF9uYW1lID0gc2VsZi5pbXBvcnRlZF9uYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgaWYgKHNlbGYuaW1wb3J0ZWRfbmFtZXMpIE1BUChzZWxmLmltcG9ydGVkX25hbWVzLCB0dyk7XG4gICAgc2VsZi5tb2R1bGVfbmFtZSA9IHNlbGYubW9kdWxlX25hbWUudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9FeHBvcnQsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgaWYgKHNlbGYuZXhwb3J0ZWRfZGVmaW5pdGlvbikgc2VsZi5leHBvcnRlZF9kZWZpbml0aW9uID0gc2VsZi5leHBvcnRlZF9kZWZpbml0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgaWYgKHNlbGYuZXhwb3J0ZWRfdmFsdWUpIHNlbGYuZXhwb3J0ZWRfdmFsdWUgPSBzZWxmLmV4cG9ydGVkX3ZhbHVlLnRyYW5zZm9ybSh0dyk7XG4gICAgaWYgKHNlbGYuZXhwb3J0ZWRfbmFtZXMpIE1BUChzZWxmLmV4cG9ydGVkX25hbWVzLCB0dyk7XG4gICAgaWYgKHNlbGYubW9kdWxlX25hbWUpIHNlbGYubW9kdWxlX25hbWUgPSBzZWxmLm1vZHVsZV9uYW1lLnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfVGVtcGxhdGVTdHJpbmcsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5zZWdtZW50cyA9IE1BUChzZWxmLnNlZ21lbnRzLCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZywgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLnByZWZpeCA9IHNlbGYucHJlZml4LnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi50ZW1wbGF0ZV9zdHJpbmcgPSBzZWxmLnRlbXBsYXRlX3N0cmluZy50cmFuc2Zvcm0odHcpO1xufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIG5vcm1hbGl6ZV9kaXJlY3RpdmVzID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChib2R5W2ldIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudCAmJiBib2R5W2ldLmJvZHkgaW5zdGFuY2VvZiBBU1RfU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgYm9keVtpXSA9IG5ldyBBU1RfRGlyZWN0aXZlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGJvZHlbaV0uc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogYm9keVtpXS5lbmQsXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlOiAnXCInLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYm9keVtpXS5ib2R5LnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGltcG9ydF9hdHRyaWJ1dGVzX2Zyb21fbW96KGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3Qoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihhdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihhdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBhdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT5cbiAgICAgICAgICAgICAgICAgICAgbmV3IEFTVF9PYmplY3RLZXlWYWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKGF0dHIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oYXR0ciksXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGF0dHIua2V5Lm5hbWUgfHwgYXR0ci5rZXkudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnJvbV9tb3ooYXR0ci52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgTU9aX1RPX01FID0ge1xuICAgICAgICBQcm9ncmFtOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Ub3BsZXZlbCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGJvZHk6IG5vcm1hbGl6ZV9kaXJlY3RpdmVzKE0uYm9keS5tYXAoZnJvbV9tb3opKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXJyYXlQYXR0ZXJuOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9EZXN0cnVjdHVyaW5nKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgbmFtZXM6IE0uZWxlbWVudHMubWFwKGZ1bmN0aW9uKGVsbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Ib2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21fbW96KGVsbSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIE9iamVjdFBhdHRlcm46IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Rlc3RydWN0dXJpbmcoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBuYW1lczogTS5wcm9wZXJ0aWVzLm1hcChmcm9tX21veiksXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBBc3NpZ25tZW50UGF0dGVybjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVmYXVsdEFzc2lnbih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZyb21fbW96KE0ubGVmdCksXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBmcm9tX21veihNLnJpZ2h0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3ByZWFkRWxlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRXhwYW5zaW9uKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZnJvbV9tb3ooTS5hcmd1bWVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIFJlc3RFbGVtZW50OiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9FeHBhbnNpb24oe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmcm9tX21veihNLmFyZ3VtZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGVtcGxhdGVFbGVtZW50OiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9UZW1wbGF0ZVNlZ21lbnQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogTS52YWx1ZS5jb29rZWQsXG4gICAgICAgICAgICAgICAgcmF3OiBNLnZhbHVlLnJhd1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGVtcGxhdGVMaXRlcmFsOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTS5xdWFzaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKGZyb21fbW96KE0ucXVhc2lzW2ldKSk7XG4gICAgICAgICAgICAgICAgaWYgKE0uZXhwcmVzc2lvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChmcm9tX21veihNLmV4cHJlc3Npb25zW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVGVtcGxhdGVTdHJpbmcoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBzZWdtZW50czogc2VnbWVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlX3N0cmluZzogZnJvbV9tb3ooTS5xdWFzaSksXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmcm9tX21veihNLnRhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0RlZnVuKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgbmFtZTogTS5pZCAmJiBmcm9tX21vel9zeW1ib2woQVNUX1N5bWJvbERlZnVuLCBNLmlkKSxcbiAgICAgICAgICAgICAgICBhcmduYW1lczogTS5wYXJhbXMubWFwKE0gPT4gZnJvbV9tb3pfcGF0dGVybihNLCBBU1RfU3ltYm9sRnVuYXJnKSksXG4gICAgICAgICAgICAgICAgaXNfZ2VuZXJhdG9yOiBNLmdlbmVyYXRvcixcbiAgICAgICAgICAgICAgICBhc3luYzogTS5hc3luYyxcbiAgICAgICAgICAgICAgICBib2R5OiBub3JtYWxpemVfZGlyZWN0aXZlcyhmcm9tX21veihNLmJvZHkpLmJvZHkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tX21vel9sYW1iZGEoTSwgLyppc19tZXRob2Q9Ki9mYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBNLmJvZHkudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiXG4gICAgICAgICAgICAgICAgPyBmcm9tX21veihNLmJvZHkpLmJvZHlcbiAgICAgICAgICAgICAgICA6IFttYWtlX25vZGUoQVNUX1JldHVybiwge30sIHsgdmFsdWU6IGZyb21fbW96KE0uYm9keSkgfSldO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQXJyb3coe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBhcmduYW1lczogTS5wYXJhbXMubWFwKHAgPT4gZnJvbV9tb3pfcGF0dGVybihwLCBBU1RfU3ltYm9sRnVuYXJnKSksXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBhc3luYzogTS5hc3luYyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1NpbXBsZVN0YXRlbWVudCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGJvZHk6IGZyb21fbW96KE0uZXhwcmVzc2lvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRyeVN0YXRlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gTS5oYW5kbGVycyB8fCBbTS5oYW5kbGVyXTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPiAxIHx8IE0uZ3VhcmRlZEhhbmRsZXJzICYmIE0uZ3VhcmRlZEhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIGNhdGNoIGNsYXVzZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVHJ5KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGJvZHkgICAgIDogbmV3IEFTVF9UcnlCbG9jayhmcm9tX21veihNLmJsb2NrKSksXG4gICAgICAgICAgICAgICAgYmNhdGNoICAgOiBmcm9tX21veihoYW5kbGVyc1swXSksXG4gICAgICAgICAgICAgICAgYmZpbmFsbHkgOiBNLmZpbmFsaXplciA/IG5ldyBBU1RfRmluYWxseShmcm9tX21veihNLmZpbmFsaXplcikpIDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUHJvcGVydHk6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIGlmIChNLmtpbmQgPT0gXCJpbml0XCIgJiYgIU0ubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogbXlfc3RhcnRfdG9rZW4oTS5rZXkgfHwgTS52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKE0udmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBrZXkgICAgICA6IE0uY29tcHV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmcm9tX21veihNLmtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBNLmtleS5uYW1lIHx8IFN0cmluZyhNLmtleS52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlICAgIDogZnJvbV9tb3pfcXVvdGUoTS5rZXksIE0uY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWMgICA6IGZhbHNlLCAvLyBhbHdheXMgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogZnJvbV9tb3ooTS52YWx1ZSlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0S2V5VmFsKGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmcm9tX21vel9sYW1iZGEoTS52YWx1ZSwgLyppc19tZXRob2Q9Ki90cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgICAgOiBteV9zdGFydF90b2tlbihNLmtleSB8fCBNLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgICAgOiBteV9lbmRfdG9rZW4oTS52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIGtleSAgICAgIDogTS5jb21wdXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZyb21fbW96KE0ua2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZyb21fbW96X3N5bWJvbChBU1RfU3ltYm9sTWV0aG9kLCBNLmtleSksXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlICAgIDogZnJvbV9tb3pfcXVvdGUoTS5rZXksIE0uY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWMgICA6IGZhbHNlLCAvLyBhbHdheXMgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoTS5raW5kID09IFwiZ2V0XCIpIHJldHVybiBuZXcgQVNUX09iamVjdEdldHRlcihhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoTS5raW5kID09IFwic2V0XCIpIHJldHVybiBuZXcgQVNUX09iamVjdFNldHRlcihhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoTS5tZXRob2QpIHJldHVybiBuZXcgQVNUX0NvbmNpc2VNZXRob2QoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgY29uc3QgaXNfcHJpdmF0ZSA9IE0ua2V5LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIjtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IE0uY29tcHV0ZWQgPyBmcm9tX21veihNLmtleSkgOiBuZXcgQVNUX1N5bWJvbE1ldGhvZCh7IG5hbWU6IE0ua2V5Lm5hbWUgfHwgU3RyaW5nKE0ua2V5LnZhbHVlKSB9KTtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgcXVvdGUgICAgOiBmcm9tX21vel9xdW90ZShNLmtleSwgTS5jb21wdXRlZCksXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgOiBmcm9tX21vel9sYW1iZGEoTS52YWx1ZSwgLyppc19tZXRob2Q9Ki90cnVlKSxcbiAgICAgICAgICAgICAgICBzdGF0aWMgICA6IE0uc3RhdGljLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChNLmtpbmQgPT0gXCJnZXRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKGlzX3ByaXZhdGUgPyBBU1RfUHJpdmF0ZUdldHRlciA6IEFTVF9PYmplY3RHZXR0ZXIpKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE0ua2luZCA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAoaXNfcHJpdmF0ZSA/IEFTVF9Qcml2YXRlU2V0dGVyIDogQVNUX09iamVjdFNldHRlcikoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IChpc19wcml2YXRlID8gQVNUX1ByaXZhdGVNZXRob2QgOiBBU1RfQ29uY2lzZU1ldGhvZCkoYXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRmllbGREZWZpbml0aW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgaWYgKE0uY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBmcm9tX21veihNLmtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChNLmtleS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiTm9uLUlkZW50aWZpZXIga2V5IGluIEZpZWxkRGVmaW5pdGlvblwiKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBmcm9tX21veihNLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9DbGFzc1Byb3BlcnR5KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIHF1b3RlICAgIDogZnJvbV9tb3pfcXVvdGUoTS5rZXksIE0uY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IGZyb21fbW96KE0udmFsdWUpLFxuICAgICAgICAgICAgICAgIHN0YXRpYyAgIDogTS5zdGF0aWMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBQcm9wZXJ0eURlZmluaXRpb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICBpZiAoTS5jb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIGtleSA9IGZyb21fbW96KE0ua2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTS5rZXkudHlwZSA9PT0gXCJQcml2YXRlSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ2xhc3NQcml2YXRlUHJvcGVydHkoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICBlbmQgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAga2V5ICAgICAgOiBmcm9tX21veihNLmtleSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogZnJvbV9tb3ooTS52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpYyAgIDogTS5zdGF0aWMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleSA9IGZyb21fbW96X3N5bWJvbChBU1RfU3ltYm9sQ2xhc3NQcm9wZXJ0eSwgTS5rZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9DbGFzc1Byb3BlcnR5KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIHF1b3RlICAgIDogZnJvbV9tb3pfcXVvdGUoTS5rZXksIE0uY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IGZyb21fbW96KE0udmFsdWUpLFxuICAgICAgICAgICAgICAgIHN0YXRpYyAgIDogTS5zdGF0aWMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBQcml2YXRlSWRlbnRpZmllcjogZnVuY3Rpb24gKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1N5bWJvbFByaXZhdGVQcm9wZXJ0eSh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIG5hbWU6IE0ubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3RhdGljQmxvY2s6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0NsYXNzU3RhdGljQmxvY2soe1xuICAgICAgICAgICAgICAgIHN0YXJ0IDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgYm9keSAgOiBNLmJvZHkubWFwKGZyb21fbW96KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQXJyYXkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgOiBNLmVsZW1lbnRzLm1hcChmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBudWxsID8gbmV3IEFTVF9Ib2xlKCkgOiBmcm9tX21veihlbGVtKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzIDogTS5wcm9wZXJ0aWVzLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbV9tb3oocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcC50eXBlID0gXCJQcm9wZXJ0eVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbV9tb3oocHJvcCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfU2VxdWVuY2Uoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBNLmV4cHJlc3Npb25zLm1hcChmcm9tX21veilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIGlmIChNLnByb3BlcnR5LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0RvdEhhc2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ICAgOiBNLnByb3BlcnR5Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLm9iamVjdCksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsICAgOiBNLm9wdGlvbmFsIHx8IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IChNLmNvbXB1dGVkID8gQVNUX1N1YiA6IEFTVF9Eb3QpKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgIDogTS5jb21wdXRlZCA/IGZyb21fbW96KE0ucHJvcGVydHkpIDogTS5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLm9iamVjdCksXG4gICAgICAgICAgICAgICAgb3B0aW9uYWwgICA6IE0ub3B0aW9uYWwgfHwgZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIENoYWluRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ2hhaW4oe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLmV4cHJlc3Npb24pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBTd2l0Y2hDYXNlOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IChNLnRlc3QgPyBBU1RfQ2FzZSA6IEFTVF9EZWZhdWx0KSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGZyb21fbW96KE0udGVzdCksXG4gICAgICAgICAgICAgICAgYm9keSAgICAgICA6IE0uY29uc2VxdWVudC5tYXAoZnJvbV9tb3opXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICBsZXQgZGVjbF90eXBlO1xuICAgICAgICAgICAgbGV0IGRlZnNfdHlwZSA9IEFTVF9WYXJEZWY7XG4gICAgICAgICAgICBsZXQgc3ltX3R5cGU7XG4gICAgICAgICAgICBsZXQgYXdhaXRfdXNpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChNLmtpbmQgPT09IFwiY29uc3RcIikge1xuICAgICAgICAgICAgICAgIGRlY2xfdHlwZSA9IEFTVF9Db25zdDtcbiAgICAgICAgICAgICAgICBzeW1fdHlwZSA9IEFTVF9TeW1ib2xDb25zdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTS5raW5kID09PSBcImxldFwiKSB7XG4gICAgICAgICAgICAgICAgZGVjbF90eXBlID0gQVNUX0xldDtcbiAgICAgICAgICAgICAgICBzeW1fdHlwZSA9IEFTVF9TeW1ib2xMZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE0ua2luZCA9PT0gXCJ1c2luZ1wiKSB7XG4gICAgICAgICAgICAgICAgZGVjbF90eXBlID0gQVNUX1VzaW5nO1xuICAgICAgICAgICAgICAgIGRlZnNfdHlwZSA9IEFTVF9Vc2luZ0RlZjtcbiAgICAgICAgICAgICAgICBzeW1fdHlwZSA9IEFTVF9TeW1ib2xVc2luZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTS5raW5kID09PSBcImF3YWl0IHVzaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBkZWNsX3R5cGUgPSBBU1RfVXNpbmc7XG4gICAgICAgICAgICAgICAgZGVmc190eXBlID0gQVNUX1VzaW5nRGVmO1xuICAgICAgICAgICAgICAgIHN5bV90eXBlID0gQVNUX1N5bWJvbFVzaW5nO1xuICAgICAgICAgICAgICAgIGF3YWl0X3VzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVjbF90eXBlID0gQVNUX1ZhcjtcbiAgICAgICAgICAgICAgICBzeW1fdHlwZSA9IEFTVF9TeW1ib2xWYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9ucyA9IE0uZGVjbGFyYXRpb25zLm1hcChNID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGRlZnNfdHlwZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGZyb21fbW96X3BhdHRlcm4oTS5pZCwgc3ltX3R5cGUpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnJvbV9tb3ooTS5pbml0KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBkZWNsX3R5cGUoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbnMgOiBkZWZpbml0aW9ucyxcbiAgICAgICAgICAgICAgICBhd2FpdCAgICAgICA6IGF3YWl0X3VzaW5nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHZhciBpbXBvcnRlZF9uYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBpbXBvcnRlZF9uYW1lcyA9IG51bGw7XG4gICAgICAgICAgICBNLnNwZWNpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoc3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpZmllci50eXBlID09PSBcIkltcG9ydFNwZWNpZmllclwiIHx8IHNwZWNpZmllci50eXBlID09PSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1wb3J0ZWRfbmFtZXMpIHsgaW1wb3J0ZWRfbmFtZXMgPSBbXTsgfVxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZF9uYW1lcy5wdXNoKGZyb21fbW96KHNwZWNpZmllcikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lmaWVyLnR5cGUgPT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkX25hbWUgPSBmcm9tX21veihzcGVjaWZpZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfSW1wb3J0KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGltcG9ydGVkX25hbWU6IGltcG9ydGVkX25hbWUsXG4gICAgICAgICAgICAgICAgaW1wb3J0ZWRfbmFtZXMgOiBpbXBvcnRlZF9uYW1lcyxcbiAgICAgICAgICAgICAgICBtb2R1bGVfbmFtZSA6IGZyb21fbW96KE0uc291cmNlKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBpbXBvcnRfYXR0cmlidXRlc19mcm9tX21veihNLmF0dHJpYnV0ZXMgfHwgTS5hc3NlcnRpb25zKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9OYW1lTWFwcGluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGZvcmVpZ25fbmFtZTogZnJvbV9tb3pfc3ltYm9sKEFTVF9TeW1ib2xJbXBvcnRGb3JlaWduLCBNLmltcG9ydGVkLCBNLmltcG9ydGVkLnR5cGUgPT09IFwiTGl0ZXJhbFwiKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBmcm9tX21vel9zeW1ib2woQVNUX1N5bWJvbEltcG9ydCwgTS5sb2NhbClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tX21vel9zeW1ib2woQVNUX1N5bWJvbEltcG9ydCwgTS5sb2NhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9OYW1lTWFwcGluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGZvcmVpZ25fbmFtZTogbmV3IEFTVF9TeW1ib2xJbXBvcnRGb3JlaWduKHsgbmFtZTogXCIqXCIgfSksXG4gICAgICAgICAgICAgICAgbmFtZTogZnJvbV9tb3pfc3ltYm9sKEFTVF9TeW1ib2xJbXBvcnQsIE0ubG9jYWwpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnRFeHByZXNzaW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gW2Zyb21fbW96KE0uc291cmNlKV07XG4gICAgICAgICAgICBpZiAoTS5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGZyb21fbW96KE0ub3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ2FsbCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGZyb21fbW96KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaW1wb3J0XCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHZhciBmb3JlaWduX25hbWUgPSBNLmV4cG9ydGVkID09IG51bGwgP1xuICAgICAgICAgICAgICAgIG5ldyBBU1RfU3ltYm9sRXhwb3J0Rm9yZWlnbih7IG5hbWU6IFwiKlwiIH0pIDpcbiAgICAgICAgICAgICAgICBmcm9tX21vel9zeW1ib2woQVNUX1N5bWJvbEV4cG9ydEZvcmVpZ24sIE0uZXhwb3J0ZWQsIE0uZXhwb3J0ZWQudHlwZSA9PT0gXCJMaXRlcmFsXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRXhwb3J0KHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZXhwb3J0ZWRfbmFtZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEFTVF9OYW1lTWFwcGluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5ldyBBU1RfU3ltYm9sRXhwb3J0KHsgbmFtZTogXCIqXCIgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JlaWduX25hbWU6IGZvcmVpZ25fbmFtZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgbW9kdWxlX25hbWU6IGZyb21fbW96KE0uc291cmNlKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBpbXBvcnRfYXR0cmlidXRlc19mcm9tX21veihNLmF0dHJpYnV0ZXMgfHwgTS5hc3NlcnRpb25zKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgaWYgKE0uZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBleHBvcnQgY29uc3QsIGV4cG9ydCBmdW5jdGlvbiwgLi4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRXhwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRfZGVmaW5pdGlvbjogZnJvbV9tb3ooTS5kZWNsYXJhdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkX25hbWVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVfbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRXhwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRfZGVmaW5pdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRfbmFtZXM6IE0uc3BlY2lmaWVycyAmJiBNLnNwZWNpZmllcnMubGVuZ3RoID8gTS5zcGVjaWZpZXJzLm1hcChmcm9tX21veikgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlX25hbWU6IGZyb21fbW96KE0uc291cmNlKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogaW1wb3J0X2F0dHJpYnV0ZXNfZnJvbV9tb3ooTS5hdHRyaWJ1dGVzIHx8IE0uYXNzZXJ0aW9ucyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9FeHBvcnQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHBvcnRlZF92YWx1ZTogZnJvbV9tb3ooTS5kZWNsYXJhdGlvbiksXG4gICAgICAgICAgICAgICAgaXNfZGVmYXVsdDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwb3J0U3BlY2lmaWVyOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9OYW1lTWFwcGluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGZvcmVpZ25fbmFtZTogZnJvbV9tb3pfc3ltYm9sKEFTVF9TeW1ib2xFeHBvcnRGb3JlaWduLCBNLmV4cG9ydGVkLCBNLmV4cG9ydGVkLnR5cGUgPT09IFwiTGl0ZXJhbFwiKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBmcm9tX21vel9zeW1ib2woQVNUX1N5bWJvbEV4cG9ydCwgTS5sb2NhbCwgTS5sb2NhbC50eXBlID09PSBcIkxpdGVyYWxcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBMaXRlcmFsOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gTS52YWx1ZSwgYXJncyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydCAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgOiBteV9lbmRfdG9rZW4oTSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcnggPSBNLnJlZ2V4O1xuICAgICAgICAgICAgaWYgKHJ4ICYmIHJ4LnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAvLyBSZWdFeHBMaXRlcmFsIGFzIHBlciBFU1RyZWUgQVNUIHNwZWNcbiAgICAgICAgICAgICAgICBhcmdzLnZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHJ4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiByeC5mbGFnc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfUmVnRXhwKGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyeCkge1xuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgbGVnYWN5IFJlZ0V4cFxuICAgICAgICAgICAgICAgIGNvbnN0IHJ4X3NvdXJjZSA9IE0ucmF3IHx8IHZhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJ4X3NvdXJjZS5tYXRjaCgvXlxcLyguKilcXC8oXFx3KikkLyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZWdleCBzb3VyY2UgXCIgKyByeF9zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtfLCBzb3VyY2UsIGZsYWdzXSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgIGFyZ3MudmFsdWUgPSB7IHNvdXJjZSwgZmxhZ3MgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9SZWdFeHAoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiBNLnZhbHVlID09PSBcImJpZ2ludFwiID8gTS52YWx1ZS50b1N0cmluZygpIDogTS5iaWdpbnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYXJncy52YWx1ZSA9IGJpO1xuICAgICAgICAgICAgICAgIGFyZ3MucmF3ID0gTS5yYXc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQmlnSW50KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIG5ldyBBU1RfTnVsbChhcmdzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgYXJncy5xdW90ZSA9IFwiXFxcIlwiO1xuICAgICAgICAgICAgICAgIGFyZ3MudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfU3RyaW5nKGFyZ3MpO1xuICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgYXJncy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICBhcmdzLnJhdyA9IE0ucmF3IHx8IHZhbC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX051bWJlcihhcmdzKTtcbiAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh2YWwgPyBBU1RfVHJ1ZSA6IEFTVF9GYWxzZSkoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWV0YVByb3BlcnR5OiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICBpZiAoTS5tZXRhLm5hbWUgPT09IFwibmV3XCIgJiYgTS5wcm9wZXJ0eS5uYW1lID09PSBcInRhcmdldFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfTmV3VGFyZ2V0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChNLm1ldGEubmFtZSA9PT0gXCJpbXBvcnRcIiAmJiBNLnByb3BlcnR5Lm5hbWUgPT09IFwibWV0YVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfSW1wb3J0TWV0YSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBJZGVudGlmaWVyOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9TeW1ib2xSZWYoe1xuICAgICAgICAgICAgICAgIHN0YXJ0IDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgbmFtZSAgOiBNLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9FbXB0eVN0YXRlbWVudCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQmxvY2tTdGF0ZW1lbnQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBib2R5OiBNLmJvZHkubWFwKGZyb21fbW96KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSWZTdGF0ZW1lbnQ6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0lmKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBmcm9tX21veihNLnRlc3QpLFxuICAgICAgICAgICAgICAgIGJvZHk6IGZyb21fbW96KE0uY29uc2VxdWVudCksXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IGZyb21fbW96KE0uYWx0ZXJuYXRlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGZyb21fbW96X3N5bWJvbChBU1RfTGFiZWwsIE0ubGFiZWwpO1xuICAgICAgICAgICAgICAgIEZST01fTU9aX0xBQkVMUy5wdXNoKGxhYmVsKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBuZXcgQVNUX0xhYmVsZWRTdGF0ZW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogZnJvbV9tb3ooTS5ib2R5KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXQ7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIEZST01fTU9aX0xBQkVMUy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBCcmVha1N0YXRlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQnJlYWsoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogZnJvbV9tb3pfbGFiZWxfcmVmKE0ubGFiZWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0NvbnRpbnVlKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgbGFiZWw6IGZyb21fbW96X2xhYmVsX3JlZihNLmxhYmVsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1dpdGgoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmcm9tX21veihNLm9iamVjdCksXG4gICAgICAgICAgICAgICAgYm9keTogZnJvbV9tb3ooTS5ib2R5KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Td2l0Y2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmcm9tX21veihNLmRpc2NyaW1pbmFudCksXG4gICAgICAgICAgICAgICAgYm9keTogTS5jYXNlcy5tYXAoZnJvbV9tb3opXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1JldHVybih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmcm9tX21veihNLmFyZ3VtZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1Rocm93KHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZyb21fbW96KE0uYXJndW1lbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBXaGlsZVN0YXRlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfV2hpbGUoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IGZyb21fbW96KE0udGVzdCksXG4gICAgICAgICAgICAgICAgYm9keTogZnJvbV9tb3ooTS5ib2R5KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRG8oe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IGZyb21fbW96KE0udGVzdCksXG4gICAgICAgICAgICAgICAgYm9keTogZnJvbV9tb3ooTS5ib2R5KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRm9yU3RhdGVtZW50OiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Gb3Ioe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBpbml0OiBmcm9tX21veihNLmluaXQpLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogZnJvbV9tb3ooTS50ZXN0KSxcbiAgICAgICAgICAgICAgICBzdGVwOiBmcm9tX21veihNLnVwZGF0ZSksXG4gICAgICAgICAgICAgICAgYm9keTogZnJvbV9tb3ooTS5ib2R5KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0ZvckluKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgaW5pdDogZnJvbV9tb3ooTS5sZWZ0KSxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IGZyb21fbW96KE0ucmlnaHQpLFxuICAgICAgICAgICAgICAgIGJvZHk6IGZyb21fbW96KE0uYm9keSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Gb3JPZih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGluaXQ6IGZyb21fbW96KE0ubGVmdCksXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBmcm9tX21veihNLnJpZ2h0KSxcbiAgICAgICAgICAgICAgICBib2R5OiBmcm9tX21veihNLmJvZHkpLFxuICAgICAgICAgICAgICAgIGF3YWl0OiBNLmF3YWl0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBBd2FpdEV4cHJlc3Npb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0F3YWl0KHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZnJvbV9tb3ooTS5hcmd1bWVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIFlpZWxkRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfWWllbGQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmcm9tX21veihNLmFyZ3VtZW50KSxcbiAgICAgICAgICAgICAgICBpc19zdGFyOiBNLmRlbGVnYXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVidWdnZXIoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ2F0Y2hDbGF1c2U6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0NhdGNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgYXJnbmFtZTogTS5wYXJhbSA/IGZyb21fbW96X3BhdHRlcm4oTS5wYXJhbSwgQVNUX1N5bWJvbENhdGNoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgYm9keTogZnJvbV9tb3ooTS5ib2R5KS5ib2R5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVGhpcyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidGhpc1wiLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBTdXBlcjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfU3VwZXIoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInN1cGVyXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICBpZiAoTS5sZWZ0LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1ByaXZhdGVJbih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgICAgIGtleTogbmV3IEFTVF9TeW1ib2xQcml2YXRlUHJvcGVydHkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0ubGVmdCksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNLmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogTS5sZWZ0Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmcm9tX21veihNLnJpZ2h0KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0JpbmFyeSh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBNLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZyb21fbW96KE0ubGVmdCksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGZyb21fbW96KE0ucmlnaHQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQmluYXJ5KHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IE0ub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgbGVmdDogZnJvbV9tb3ooTS5sZWZ0KSxcbiAgICAgICAgICAgICAgICByaWdodDogZnJvbV9tb3ooTS5yaWdodClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Bc3NpZ24oe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogTS5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICBsb2dpY2FsOiBNLm9wZXJhdG9yID09PSBcIj8/PVwiIHx8IE0ub3BlcmF0b3IgPT09IFwiJiY9XCIgfHwgTS5vcGVyYXRvciA9PT0gXCJ8fD1cIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBmcm9tX21veihNLmxlZnQpLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBmcm9tX21veihNLnJpZ2h0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Db25kaXRpb25hbCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogZnJvbV9tb3ooTS50ZXN0KSxcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiBmcm9tX21veihNLmNvbnNlcXVlbnQpLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBmcm9tX21veihNLmFsdGVybmF0ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIE5ld0V4cHJlc3Npb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX05ldyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGZyb21fbW96KE0uY2FsbGVlKSxcbiAgICAgICAgICAgICAgICBhcmdzOiBNLmFyZ3VtZW50cy5tYXAoZnJvbV9tb3opXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ2FsbCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGZyb21fbW96KE0uY2FsbGVlKSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogTS5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICBhcmdzOiBNLmFyZ3VtZW50cy5tYXAoZnJvbV9tb3opXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBNT1pfVE9fTUUuVXBkYXRlRXhwcmVzc2lvbiA9XG4gICAgTU9aX1RPX01FLlVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIFRvX01vel9VbmFyeShNKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBcInByZWZpeFwiIGluIE0gPyBNLnByZWZpeFxuICAgICAgICAgICAgOiBNLnR5cGUgPT0gXCJVbmFyeUV4cHJlc3Npb25cIiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ldyAocHJlZml4ID8gQVNUX1VuYXJ5UHJlZml4IDogQVNUX1VuYXJ5UG9zdGZpeCkoe1xuICAgICAgICAgICAgc3RhcnQgICAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgIG9wZXJhdG9yICAgOiBNLm9wZXJhdG9yLFxuICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGZyb21fbW96KE0uYXJndW1lbnQpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNT1pfVE9fTUUuQ2xhc3NEZWNsYXJhdGlvbiA9XG4gICAgTU9aX1RPX01FLkNsYXNzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIEZyb21fTW96X0NsYXNzKE0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoTS50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiA/IEFTVF9EZWZDbGFzcyA6IEFTVF9DbGFzc0V4cHJlc3Npb24pKHtcbiAgICAgICAgICAgIHN0YXJ0ICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICBlbmQgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgIG5hbWUgICAgIDogTS5pZCAmJiBmcm9tX21vel9zeW1ib2woTS50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiA/IEFTVF9TeW1ib2xEZWZDbGFzcyA6IEFTVF9TeW1ib2xDbGFzcywgTS5pZCksXG4gICAgICAgICAgICBleHRlbmRzICA6IGZyb21fbW96KE0uc3VwZXJDbGFzcyksXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBNLmJvZHkuYm9keS5tYXAoZnJvbV9tb3opXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBkZWZfdG9fbW96KEFTVF9FbXB0eVN0YXRlbWVudCwgZnVuY3Rpb24gVG9fTW96X0VtcHR5U3RhdGVtZW50KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJFbXB0eVN0YXRlbWVudFwiXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgZGVmX3RvX21veihBU1RfQmxvY2tTdGF0ZW1lbnQsIGZ1bmN0aW9uIFRvX01vel9CbG9ja1N0YXRlbWVudChNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkJsb2NrU3RhdGVtZW50XCIsXG4gICAgICAgICAgICBib2R5OiBNLmJvZHkubWFwKHRvX21veilcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBkZWZfdG9fbW96KEFTVF9JZiwgZnVuY3Rpb24gVG9fTW96X0lmU3RhdGVtZW50KE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiSWZTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIHRlc3Q6IHRvX21veihNLmNvbmRpdGlvbiksXG4gICAgICAgICAgICBjb25zZXF1ZW50OiB0b19tb3ooTS5ib2R5KSxcbiAgICAgICAgICAgIGFsdGVybmF0ZTogdG9fbW96KE0uYWx0ZXJuYXRpdmUpXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgZGVmX3RvX21veihBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24gVG9fTW96X0xhYmVsZWRTdGF0ZW1lbnQoTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJMYWJlbGVkU3RhdGVtZW50XCIsXG4gICAgICAgICAgICBsYWJlbDogdG9fbW96KE0ubGFiZWwpLFxuICAgICAgICAgICAgYm9keTogdG9fbW96KE0uYm9keSlcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBkZWZfdG9fbW96KEFTVF9CcmVhaywgZnVuY3Rpb24gVG9fTW96X0JyZWFrU3RhdGVtZW50KE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQnJlYWtTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIGxhYmVsOiB0b19tb3ooTS5sYWJlbClcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBkZWZfdG9fbW96KEFTVF9Db250aW51ZSwgZnVuY3Rpb24gVG9fTW96X0NvbnRpbnVlU3RhdGVtZW50KE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQ29udGludWVTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIGxhYmVsOiB0b19tb3ooTS5sYWJlbClcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBkZWZfdG9fbW96KEFTVF9XaXRoLCBmdW5jdGlvbiBUb19Nb3pfV2l0aFN0YXRlbWVudChNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIldpdGhTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIG9iamVjdDogdG9fbW96KE0uZXhwcmVzc2lvbiksXG4gICAgICAgICAgICBib2R5OiB0b19tb3ooTS5ib2R5KVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGRlZl90b19tb3ooQVNUX1N3aXRjaCwgZnVuY3Rpb24gVG9fTW96X1N3aXRjaFN0YXRlbWVudChNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlN3aXRjaFN0YXRlbWVudFwiLFxuICAgICAgICAgICAgZGlzY3JpbWluYW50OiB0b19tb3ooTS5leHByZXNzaW9uKSxcbiAgICAgICAgICAgIGNhc2VzOiBNLmJvZHkubWFwKHRvX21veilcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBkZWZfdG9fbW96KEFTVF9SZXR1cm4sIGZ1bmN0aW9uIFRvX01vel9SZXR1cm5TdGF0ZW1lbnQoTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJSZXR1cm5TdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIGFyZ3VtZW50OiB0b19tb3ooTS52YWx1ZSlcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBkZWZfdG9fbW96KEFTVF9UaHJvdywgZnVuY3Rpb24gVG9fTW96X1Rocm93U3RhdGVtZW50KE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiVGhyb3dTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIGFyZ3VtZW50OiB0b19tb3ooTS52YWx1ZSlcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBkZWZfdG9fbW96KEFTVF9XaGlsZSwgZnVuY3Rpb24gVG9fTW96X1doaWxlU3RhdGVtZW50KE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiV2hpbGVTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIHRlc3Q6IHRvX21veihNLmNvbmRpdGlvbiksXG4gICAgICAgICAgICBib2R5OiB0b19tb3ooTS5ib2R5KVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGRlZl90b19tb3ooQVNUX0RvLCBmdW5jdGlvbiBUb19Nb3pfRG9XaGlsZVN0YXRlbWVudChNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkRvV2hpbGVTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIHRlc3Q6IHRvX21veihNLmNvbmRpdGlvbiksXG4gICAgICAgICAgICBib2R5OiB0b19tb3ooTS5ib2R5KVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGRlZl90b19tb3ooQVNUX0ZvciwgZnVuY3Rpb24gVG9fTW96X0ZvclN0YXRlbWVudChNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkZvclN0YXRlbWVudFwiLFxuICAgICAgICAgICAgaW5pdDogdG9fbW96KE0uaW5pdCksXG4gICAgICAgICAgICB0ZXN0OiB0b19tb3ooTS5jb25kaXRpb24pLFxuICAgICAgICAgICAgdXBkYXRlOiB0b19tb3ooTS5zdGVwKSxcbiAgICAgICAgICAgIGJvZHk6IHRvX21veihNLmJvZHkpXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgZGVmX3RvX21veihBU1RfRm9ySW4sIGZ1bmN0aW9uIFRvX01vel9Gb3JJblN0YXRlbWVudChNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkZvckluU3RhdGVtZW50XCIsXG4gICAgICAgICAgICBsZWZ0OiB0b19tb3ooTS5pbml0KSxcbiAgICAgICAgICAgIHJpZ2h0OiB0b19tb3ooTS5vYmplY3QpLFxuICAgICAgICAgICAgYm9keTogdG9fbW96KE0uYm9keSlcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBkZWZfdG9fbW96KEFTVF9Gb3JPZiwgZnVuY3Rpb24gVG9fTW96X0Zvck9mU3RhdGVtZW50KE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRm9yT2ZTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIGxlZnQ6IHRvX21veihNLmluaXQpLFxuICAgICAgICAgICAgcmlnaHQ6IHRvX21veihNLm9iamVjdCksXG4gICAgICAgICAgICBib2R5OiB0b19tb3ooTS5ib2R5KSxcbiAgICAgICAgICAgIGF3YWl0OiBNLmF3YWl0XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgZGVmX3RvX21veihBU1RfQXdhaXQsIGZ1bmN0aW9uIFRvX01vel9Bd2FpdEV4cHJlc3Npb24oTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJBd2FpdEV4cHJlc3Npb25cIixcbiAgICAgICAgICAgIGFyZ3VtZW50OiB0b19tb3ooTS5leHByZXNzaW9uKVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGRlZl90b19tb3ooQVNUX1lpZWxkLCBmdW5jdGlvbiBUb19Nb3pfWWllbGRFeHByZXNzaW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiWWllbGRFeHByZXNzaW9uXCIsXG4gICAgICAgICAgICBhcmd1bWVudDogdG9fbW96KE0uZXhwcmVzc2lvbiksXG4gICAgICAgICAgICBkZWxlZ2F0ZTogTS5pc19zdGFyXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgZGVmX3RvX21veihBU1RfRGVidWdnZXIsIGZ1bmN0aW9uIFRvX01vel9EZWJ1Z2dlclN0YXRlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRGVidWdnZXJTdGF0ZW1lbnRcIlxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGRlZl90b19tb3ooQVNUX1ZhckRlZkxpa2UsIGZ1bmN0aW9uIFRvX01vel9WYXJpYWJsZURlY2xhcmF0b3IoTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0b3JcIixcbiAgICAgICAgICAgIGlkOiB0b19tb3ooTS5uYW1lKSxcbiAgICAgICAgICAgIGluaXQ6IHRvX21veihNLnZhbHVlKVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfVGhpcywgZnVuY3Rpb24gVG9fTW96X1RoaXNFeHByZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJUaGlzRXhwcmVzc2lvblwiXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgZGVmX3RvX21veihBU1RfU3VwZXIsIGZ1bmN0aW9uIFRvX01vel9TdXBlcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiU3VwZXJcIlxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGRlZl90b19tb3ooQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbiBUb19Nb3pfQ29uZGl0aW9uYWxFeHByZXNzaW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsXG4gICAgICAgICAgICB0ZXN0OiB0b19tb3ooTS5jb25kaXRpb24pLFxuICAgICAgICAgICAgY29uc2VxdWVudDogdG9fbW96KE0uY29uc2VxdWVudCksXG4gICAgICAgICAgICBhbHRlcm5hdGU6IHRvX21veihNLmFsdGVybmF0aXZlKVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGRlZl90b19tb3ooQVNUX05ldywgZnVuY3Rpb24gVG9fTW96X05ld0V4cHJlc3Npb24oTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJOZXdFeHByZXNzaW9uXCIsXG4gICAgICAgICAgICBjYWxsZWU6IHRvX21veihNLmV4cHJlc3Npb24pLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBNLmFyZ3MubWFwKHRvX21veilcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBkZWZfdG9fbW96KEFTVF9DYWxsLCBmdW5jdGlvbiBUb19Nb3pfQ2FsbEV4cHJlc3Npb24oTSkge1xuICAgICAgICBpZiAoTS5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiAmJiBNLmV4cHJlc3Npb24ubmFtZSA9PT0gXCJpbXBvcnRcIikge1xuICAgICAgICAgICAgY29uc3QgW3NvdXJjZSwgb3B0aW9uc10gPSBNLmFyZ3MubWFwKHRvX21veik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiSW1wb3J0RXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zIHx8IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJDYWxsRXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgY2FsbGVlOiB0b19tb3ooTS5leHByZXNzaW9uKSxcbiAgICAgICAgICAgIG9wdGlvbmFsOiBNLm9wdGlvbmFsLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBNLmFyZ3MubWFwKHRvX21veilcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX1RvcGxldmVsLCBmdW5jdGlvbiBUb19Nb3pfUHJvZ3JhbShNKSB7XG4gICAgICAgIHJldHVybiB0b19tb3pfc2NvcGUoXCJQcm9ncmFtXCIsIE0pO1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfRXhwYW5zaW9uLCBmdW5jdGlvbiBUb19Nb3pfU3ByZWFkKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRvX21vel9pbl9kZXN0cnVjdHVyaW5nKCkgPyBcIlJlc3RFbGVtZW50XCIgOiBcIlNwcmVhZEVsZW1lbnRcIixcbiAgICAgICAgICAgIGFyZ3VtZW50OiB0b19tb3ooTS5leHByZXNzaW9uKVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZywgZnVuY3Rpb24gVG9fTW96X1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgdGFnOiB0b19tb3ooTS5wcmVmaXgpLFxuICAgICAgICAgICAgcXVhc2k6IHRvX21veihNLnRlbXBsYXRlX3N0cmluZylcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX1RlbXBsYXRlU3RyaW5nLCBmdW5jdGlvbiBUb19Nb3pfVGVtcGxhdGVMaXRlcmFsKE0pIHtcbiAgICAgICAgdmFyIHF1YXNpcyA9IFtdO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRvX21veihNLnNlZ21lbnRzW2ldKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1YXNpcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJUZW1wbGF0ZUVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogTS5zZWdtZW50c1tpXS5yYXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQ6IE0uc2VnbWVudHNbaV0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGFpbDogaSA9PT0gTS5zZWdtZW50cy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiVGVtcGxhdGVMaXRlcmFsXCIsXG4gICAgICAgICAgICBxdWFzaXM6IHF1YXNpcyxcbiAgICAgICAgICAgIGV4cHJlc3Npb25zOiBleHByZXNzaW9uc1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfRGVmdW4sIGZ1bmN0aW9uIFRvX01vel9GdW5jdGlvbkRlY2xhcmF0aW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLFxuICAgICAgICAgICAgaWQ6IHRvX21veihNLm5hbWUpLFxuICAgICAgICAgICAgcGFyYW1zOiBNLmFyZ25hbWVzLm1hcCh0b19tb3pfcGF0dGVybiksXG4gICAgICAgICAgICBnZW5lcmF0b3I6IE0uaXNfZ2VuZXJhdG9yLFxuICAgICAgICAgICAgYXN5bmM6IE0uYXN5bmMsXG4gICAgICAgICAgICBib2R5OiB0b19tb3pfc2NvcGUoXCJCbG9ja1N0YXRlbWVudFwiLCBNKVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uIFRvX01vel9GdW5jdGlvbkV4cHJlc3Npb24oTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJGdW5jdGlvbkV4cHJlc3Npb25cIixcbiAgICAgICAgICAgIGlkOiB0b19tb3ooTS5uYW1lKSxcbiAgICAgICAgICAgIHBhcmFtczogTS5hcmduYW1lcy5tYXAodG9fbW96X3BhdHRlcm4pLFxuICAgICAgICAgICAgZ2VuZXJhdG9yOiBNLmlzX2dlbmVyYXRvciB8fCBmYWxzZSxcbiAgICAgICAgICAgIGFzeW5jOiBNLmFzeW5jIHx8IGZhbHNlLFxuICAgICAgICAgICAgYm9keTogdG9fbW96X3Njb3BlKFwiQmxvY2tTdGF0ZW1lbnRcIiwgTSlcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0Fycm93LCBmdW5jdGlvbiBUb19Nb3pfQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oTSkge1xuICAgICAgICB2YXIgYm9keSA9IE0uYm9keS5sZW5ndGggPT09IDEgJiYgTS5ib2R5WzBdIGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiBNLmJvZHlbMF0udmFsdWVcbiAgICAgICAgICAgID8gdG9fbW96KE0uYm9keVswXS52YWx1ZSlcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQmxvY2tTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgICAgICBib2R5OiBNLmJvZHkubWFwKHRvX21veilcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsXG4gICAgICAgICAgICBwYXJhbXM6IE0uYXJnbmFtZXMubWFwKHRvX21vel9wYXR0ZXJuKSxcbiAgICAgICAgICAgIGFzeW5jOiBNLmFzeW5jLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0Rlc3RydWN0dXJpbmcsIGZ1bmN0aW9uIFRvX01vel9PYmplY3RQYXR0ZXJuKE0pIHtcbiAgICAgICAgaWYgKE0uaXNfYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJBcnJheVBhdHRlcm5cIixcbiAgICAgICAgICAgICAgICBlbGVtZW50czogTS5uYW1lcy5tYXAoXG4gICAgICAgICAgICAgICAgICAgIE0gPT4gTSBpbnN0YW5jZW9mIEFTVF9Ib2xlID8gbnVsbCA6IHRvX21vel9wYXR0ZXJuKE0pXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiT2JqZWN0UGF0dGVyblwiLFxuICAgICAgICAgICAgcHJvcGVydGllczogTS5uYW1lcy5tYXAoTSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE0gaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wdXRlZCA9IE0uY29tcHV0ZWRfa2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzaG9ydGhhbmQsIGtleV0gPSB0b19tb3pfcHJvcGVydHlfa2V5KE0ua2V5LCBjb21wdXRlZCwgTS5xdW90ZSwgTS52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJpbml0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG9ydGhhbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9fbW96X3BhdHRlcm4oTS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9fbW96X3BhdHRlcm4oTSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9EZWZhdWx0QXNzaWduLCBmdW5jdGlvbiBUb19Nb3pfQXNzaWdubWVudEV4cHJlc3Npb24oTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJBc3NpZ25tZW50UGF0dGVyblwiLFxuICAgICAgICAgICAgbGVmdDogdG9fbW96X3BhdHRlcm4oTS5sZWZ0KSxcbiAgICAgICAgICAgIHJpZ2h0OiB0b19tb3ooTS5yaWdodCksXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9EaXJlY3RpdmUsIGZ1bmN0aW9uIFRvX01vel9EaXJlY3RpdmUoTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJMaXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IE0udmFsdWUsXG4gICAgICAgICAgICAgICAgcmF3OiBNLnByaW50X3RvX3N0cmluZygpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlyZWN0aXZlOiBNLnZhbHVlXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGZ1bmN0aW9uIFRvX01vel9FeHByZXNzaW9uU3RhdGVtZW50KE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogdG9fbW96KE0uYm9keSlcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX1N3aXRjaEJyYW5jaCwgZnVuY3Rpb24gVG9fTW96X1N3aXRjaENhc2UoTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJTd2l0Y2hDYXNlXCIsXG4gICAgICAgICAgICB0ZXN0OiB0b19tb3ooTS5leHByZXNzaW9uKSxcbiAgICAgICAgICAgIGNvbnNlcXVlbnQ6IE0uYm9keS5tYXAodG9fbW96KVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfVHJ5LCBmdW5jdGlvbiBUb19Nb3pfVHJ5U3RhdGVtZW50KE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiVHJ5U3RhdGVtZW50XCIsXG4gICAgICAgICAgICBibG9jazogdG9fbW96X2Jsb2NrKE0uYm9keSksXG4gICAgICAgICAgICBoYW5kbGVyOiB0b19tb3ooTS5iY2F0Y2gpLFxuICAgICAgICAgICAgZ3VhcmRlZEhhbmRsZXJzOiBbXSxcbiAgICAgICAgICAgIGZpbmFsaXplcjogdG9fbW96KE0uYmZpbmFsbHkpXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9DYXRjaCwgZnVuY3Rpb24gVG9fTW96X0NhdGNoQ2xhdXNlKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQ2F0Y2hDbGF1c2VcIixcbiAgICAgICAgICAgIHBhcmFtOiBNLmFyZ25hbWUgIT0gbnVsbCA/IHRvX21vel9wYXR0ZXJuKE0uYXJnbmFtZSkgOiBudWxsLFxuICAgICAgICAgICAgYm9keTogdG9fbW96X2Jsb2NrKE0pXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9EZWZpbml0aW9uc0xpa2UsIGZ1bmN0aW9uIFRvX01vel9WYXJpYWJsZURlY2xhcmF0aW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFxuICAgICAgICAgICAga2luZDpcbiAgICAgICAgICAgICAgICBNIGluc3RhbmNlb2YgQVNUX0NvbnN0ID8gXCJjb25zdFwiIDpcbiAgICAgICAgICAgICAgICBNIGluc3RhbmNlb2YgQVNUX0xldCA/IFwibGV0XCIgOlxuICAgICAgICAgICAgICAgIE0gaW5zdGFuY2VvZiBBU1RfVXNpbmcgPyAoTS5hd2FpdCA/IFwiYXdhaXQgdXNpbmdcIiA6IFwidXNpbmdcIikgOlxuICAgICAgICAgICAgICAgIFwidmFyXCIsXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IE0uZGVmaW5pdGlvbnMubWFwKHRvX21veilcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGltcG9ydF9hdHRyaWJ1dGVzX3RvX21veihhdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc3QgaW1wb3J0X2F0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGtleSwgdmFsdWUgfSBvZiBhdHRyaWJ1dGUucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleV9tb3ogPSBpc19iYXNpY19pZGVudGlmaWVyX3N0cmluZyhrZXkpXG4gICAgICAgICAgICAgICAgICAgID8geyB0eXBlOiBcIklkZW50aWZpZXJcIiwgbmFtZToga2V5IH1cbiAgICAgICAgICAgICAgICAgICAgOiB7IHR5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZToga2V5LCByYXc6IEpTT04uc3RyaW5naWZ5KGtleSkgfTtcbiAgICAgICAgICAgICAgICBpbXBvcnRfYXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJJbXBvcnRBdHRyaWJ1dGVcIixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXlfbW96LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9fbW96KHZhbHVlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBvcnRfYXR0cmlidXRlcztcbiAgICB9XG5cbiAgICBkZWZfdG9fbW96KEFTVF9FeHBvcnQsIGZ1bmN0aW9uIFRvX01vel9FeHBvcnREZWNsYXJhdGlvbihNKSB7XG4gICAgICAgIGlmIChNLmV4cG9ydGVkX25hbWVzKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RfZXhwb3J0ZWQgPSBNLmV4cG9ydGVkX25hbWVzWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0X2V4cG9ydGVkICYmIGZpcnN0X2V4cG9ydGVkLm5hbWUubmFtZSA9PT0gXCIqXCIgJiYgIWZpcnN0X2V4cG9ydGVkLm5hbWUucXVvdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9yZWlnbl9uYW1lID0gZmlyc3RfZXhwb3J0ZWQuZm9yZWlnbl9uYW1lO1xuICAgICAgICAgICAgICAgIHZhciBleHBvcnRlZCA9IGZvcmVpZ25fbmFtZS5uYW1lID09PSBcIipcIiAmJiAhZm9yZWlnbl9uYW1lLnF1b3RlXG4gICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHRvX21veihmb3JlaWduX25hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiB0b19tb3ooTS5tb2R1bGVfbmFtZSksXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkOiBleHBvcnRlZCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogaW1wb3J0X2F0dHJpYnV0ZXNfdG9fbW96KE0uYXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIixcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXJzOiBNLmV4cG9ydGVkX25hbWVzLm1hcChmdW5jdGlvbiAobmFtZV9tYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkV4cG9ydFNwZWNpZmllclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWQ6IHRvX21veihuYW1lX21hcHBpbmcuZm9yZWlnbl9uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsOiB0b19tb3oobmFtZV9tYXBwaW5nLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb246IHRvX21veihNLmV4cG9ydGVkX2RlZmluaXRpb24pLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdG9fbW96KE0ubW9kdWxlX25hbWUpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGltcG9ydF9hdHRyaWJ1dGVzX3RvX21veihNLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE0uaXNfZGVmYXVsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB0b19tb3ooTS5leHBvcnRlZF92YWx1ZSB8fCBNLmV4cG9ydGVkX2RlZmluaXRpb24pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb246IHRvX21veihNLmV4cG9ydGVkX3ZhbHVlIHx8IE0uZXhwb3J0ZWRfZGVmaW5pdGlvbiksXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyczogW10sXG4gICAgICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfSW1wb3J0LCBmdW5jdGlvbiBUb19Nb3pfSW1wb3J0RGVjbGFyYXRpb24oTSkge1xuICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xuICAgICAgICBpZiAoTS5pbXBvcnRlZF9uYW1lKSB7XG4gICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiLFxuICAgICAgICAgICAgICAgIGxvY2FsOiB0b19tb3ooTS5pbXBvcnRlZF9uYW1lKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE0uaW1wb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdF9pbXBvcnRlZF9mb3JlaWduX25hbWUgPSBNLmltcG9ydGVkX25hbWVzWzBdLmZvcmVpZ25fbmFtZTtcbiAgICAgICAgICAgIGlmIChmaXJzdF9pbXBvcnRlZF9mb3JlaWduX25hbWUubmFtZSA9PT0gXCIqXCIgJiYgIWZpcnN0X2ltcG9ydGVkX2ZvcmVpZ25fbmFtZS5xdW90ZSkge1xuICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsOiB0b19tb3ooTS5pbXBvcnRlZF9uYW1lc1swXS5uYW1lKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBNLmltcG9ydGVkX25hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZV9tYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkltcG9ydFNwZWNpZmllclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWw6IHRvX21veihuYW1lX21hcHBpbmcubmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZDogdG9fbW96KG5hbWVfbWFwcGluZy5mb3JlaWduX25hbWUpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkltcG9ydERlY2xhcmF0aW9uXCIsXG4gICAgICAgICAgICBzcGVjaWZpZXJzOiBzcGVjaWZpZXJzLFxuICAgICAgICAgICAgc291cmNlOiB0b19tb3ooTS5tb2R1bGVfbmFtZSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBpbXBvcnRfYXR0cmlidXRlc190b19tb3ooTS5hdHRyaWJ1dGVzKVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfSW1wb3J0TWV0YSwgZnVuY3Rpb24gVG9fTW96X01ldGFQcm9wZXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiTWV0YVByb3BlcnR5XCIsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJpbXBvcnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJtZXRhXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX1NlcXVlbmNlLCBmdW5jdGlvbiBUb19Nb3pfU2VxdWVuY2VFeHByZXNzaW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uczogTS5leHByZXNzaW9ucy5tYXAodG9fbW96KVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfRG90SGFzaCwgZnVuY3Rpb24gVG9fTW96X1ByaXZhdGVNZW1iZXJFeHByZXNzaW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgb2JqZWN0OiB0b19tb3ooTS5leHByZXNzaW9uKSxcbiAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQcml2YXRlSWRlbnRpZmllclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IE0ucHJvcGVydHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25hbDogTS5vcHRpb25hbFxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfUHJvcEFjY2VzcywgZnVuY3Rpb24gVG9fTW96X01lbWJlckV4cHJlc3Npb24oTSkge1xuICAgICAgICB2YXIgaXNDb21wdXRlZCA9IE0gaW5zdGFuY2VvZiBBU1RfU3ViO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJNZW1iZXJFeHByZXNzaW9uXCIsXG4gICAgICAgICAgICBvYmplY3Q6IHRvX21veihNLmV4cHJlc3Npb24pLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGlzQ29tcHV0ZWQsXG4gICAgICAgICAgICBwcm9wZXJ0eTogaXNDb21wdXRlZCA/IHRvX21veihNLnByb3BlcnR5KSA6IHt0eXBlOiBcIklkZW50aWZpZXJcIiwgbmFtZTogTS5wcm9wZXJ0eX0sXG4gICAgICAgICAgICBvcHRpb25hbDogTS5vcHRpb25hbFxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfQ2hhaW4sIGZ1bmN0aW9uIFRvX01vel9DaGFpbkV4cHJlc3Npb24oTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJDaGFpbkV4cHJlc3Npb25cIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHRvX21veihNLmV4cHJlc3Npb24pXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9VbmFyeSwgZnVuY3Rpb24gVG9fTW96X1VuYXJ5KE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IE0ub3BlcmF0b3IgPT0gXCIrK1wiIHx8IE0ub3BlcmF0b3IgPT0gXCItLVwiID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgb3BlcmF0b3I6IE0ub3BlcmF0b3IsXG4gICAgICAgICAgICBwcmVmaXg6IE0gaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXgsXG4gICAgICAgICAgICBhcmd1bWVudDogdG9fbW96KE0uZXhwcmVzc2lvbilcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0JpbmFyeSwgZnVuY3Rpb24gVG9fTW96X0JpbmFyeUV4cHJlc3Npb24oTSkge1xuICAgICAgICBpZiAoTS5vcGVyYXRvciA9PSBcIj1cIiAmJiB0b19tb3pfaW5fZGVzdHJ1Y3R1cmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQXNzaWdubWVudFBhdHRlcm5cIixcbiAgICAgICAgICAgICAgICBsZWZ0OiB0b19tb3ooTS5sZWZ0KSxcbiAgICAgICAgICAgICAgICByaWdodDogdG9fbW96KE0ucmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IE0ub3BlcmF0b3IgPT0gXCImJlwiIHx8IE0ub3BlcmF0b3IgPT0gXCJ8fFwiIHx8IE0ub3BlcmF0b3IgPT09IFwiPz9cIlxuICAgICAgICAgICAgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCJcbiAgICAgICAgICAgIDogXCJCaW5hcnlFeHByZXNzaW9uXCI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBsZWZ0OiB0b19tb3ooTS5sZWZ0KSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBNLm9wZXJhdG9yLFxuICAgICAgICAgICAgcmlnaHQ6IHRvX21veihNLnJpZ2h0KVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfQXNzaWduLCBmdW5jdGlvbiBUb19Nb3pfQXNzaWdubWVudEV4cHJlc3Npb24oTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgb3BlcmF0b3I6IE0ub3BlcmF0b3IsXG4gICAgICAgICAgICBsZWZ0OiB0b19tb3ooTS5sZWZ0KSxcbiAgICAgICAgICAgIHJpZ2h0OiB0b19tb3ooTS5yaWdodClcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX1ByaXZhdGVJbiwgZnVuY3Rpb24gVG9fTW96X0JpbmFyeUV4cHJlc3Npb25fUHJpdmF0ZUluKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQmluYXJ5RXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgbGVmdDogeyB0eXBlOiBcIlByaXZhdGVJZGVudGlmaWVyXCIsIG5hbWU6IE0ua2V5Lm5hbWUgfSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcImluXCIsXG4gICAgICAgICAgICByaWdodDogdG9fbW96KE0udmFsdWUpLFxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfQXJyYXksIGZ1bmN0aW9uIFRvX01vel9BcnJheUV4cHJlc3Npb24oTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJBcnJheUV4cHJlc3Npb25cIixcbiAgICAgICAgICAgIGVsZW1lbnRzOiBNLmVsZW1lbnRzLm1hcCh0b19tb3opXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9PYmplY3QsIGZ1bmN0aW9uIFRvX01vel9PYmplY3RFeHByZXNzaW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiT2JqZWN0RXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgcHJvcGVydGllczogTS5wcm9wZXJ0aWVzLm1hcCh0b19tb3opXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9PYmplY3RQcm9wZXJ0eSwgZnVuY3Rpb24gVG9fTW96X1Byb3BlcnR5KE0sIHBhcmVudCkge1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBNLmNvbXB1dGVkX2tleSgpO1xuICAgICAgICBjb25zdCBbc2hvcnRoYW5kLCBrZXldID0gdG9fbW96X3Byb3BlcnR5X2tleShNLmtleSwgY29tcHV0ZWQsIE0ucXVvdGUsIE0udmFsdWUpO1xuXG4gICAgICAgIHZhciBraW5kO1xuICAgICAgICBpZiAoTSBpbnN0YW5jZW9mIEFTVF9PYmplY3RHZXR0ZXIpIHtcbiAgICAgICAgICAgIGtpbmQgPSBcImdldFwiO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgaWYgKE0gaW5zdGFuY2VvZiBBU1RfT2JqZWN0U2V0dGVyKSB7XG4gICAgICAgICAgICBraW5kID0gXCJzZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTSBpbnN0YW5jZW9mIEFTVF9Qcml2YXRlR2V0dGVyIHx8IE0gaW5zdGFuY2VvZiBBU1RfUHJpdmF0ZVNldHRlcikge1xuICAgICAgICAgICAgY29uc3Qga2luZCA9IE0gaW5zdGFuY2VvZiBBU1RfUHJpdmF0ZUdldHRlciA/IFwiZ2V0XCIgOiBcInNldFwiO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIk1ldGhvZERlZmluaXRpb25cIixcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgICAgICBzdGF0aWM6IE0uc3RhdGljLFxuICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlByaXZhdGVJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IE0ua2V5Lm5hbWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0b19tb3ooTS52YWx1ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE0gaW5zdGFuY2VvZiBBU1RfQ2xhc3NQcml2YXRlUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQcm9wZXJ0eURlZmluaXRpb25cIixcbiAgICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJQcml2YXRlSWRlbnRpZmllclwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBNLmtleS5uYW1lXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdG9fbW96KE0udmFsdWUpLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdGF0aWM6IE0uc3RhdGljXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChNIGluc3RhbmNlb2YgQVNUX0NsYXNzUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQcm9wZXJ0eURlZmluaXRpb25cIixcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRvX21veihNLnZhbHVlKSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZCxcbiAgICAgICAgICAgICAgICBzdGF0aWM6IE0uc3RhdGljXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJNZXRob2REZWZpbml0aW9uXCIsXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGNvbXB1dGVkLFxuICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgc3RhdGljOiBNLnN0YXRpYyxcbiAgICAgICAgICAgICAgICBrZXk6IHRvX21veihNLmtleSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRvX21veihNLnZhbHVlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJQcm9wZXJ0eVwiLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGNvbXB1dGVkLFxuICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3J0aGFuZCxcbiAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB0b19tb3ooTS52YWx1ZSlcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX09iamVjdEtleVZhbCwgZnVuY3Rpb24gVG9fTW96X1Byb3BlcnR5KE0pIHtcbiAgICAgICAgdmFyIGNvbXB1dGVkID0gTS5jb21wdXRlZF9rZXkoKTtcbiAgICAgICAgY29uc3QgW3Nob3J0aGFuZCwga2V5XSA9IHRvX21vel9wcm9wZXJ0eV9rZXkoTS5rZXksIGNvbXB1dGVkLCBNLnF1b3RlLCBNLnZhbHVlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJQcm9wZXJ0eVwiLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGNvbXB1dGVkLFxuICAgICAgICAgICAgc2hvcnRoYW5kOiBzaG9ydGhhbmQsXG4gICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAga2luZDogXCJpbml0XCIsXG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB0b19tb3ooTS52YWx1ZSlcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0NvbmNpc2VNZXRob2QsIGZ1bmN0aW9uIFRvX01vel9NZXRob2REZWZpbml0aW9uKE0sIHBhcmVudCkge1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IE0uY29tcHV0ZWRfa2V5KCk7XG4gICAgICAgIGNvbnN0IFtfYWx3YXlzX2ZhbHNlLCBrZXldID0gdG9fbW96X3Byb3BlcnR5X2tleShNLmtleSwgY29tcHV0ZWQsIE0ucXVvdGUsIE0udmFsdWUpO1xuXG4gICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiUHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICBraW5kOiBcImluaXRcIixcbiAgICAgICAgICAgICAgICBjb21wdXRlZCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRvX21veihNLnZhbHVlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJNZXRob2REZWZpbml0aW9uXCIsXG4gICAgICAgICAgICBraW5kOiAhY29tcHV0ZWQgJiYgTS5rZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiID8gXCJjb25zdHJ1Y3RvclwiIDogXCJtZXRob2RcIixcbiAgICAgICAgICAgIGNvbXB1dGVkLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHRvX21veihNLnZhbHVlKSxcbiAgICAgICAgICAgIHN0YXRpYzogTS5zdGF0aWMsXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9Qcml2YXRlTWV0aG9kLCBmdW5jdGlvbiBUb19Nb3pfTWV0aG9kRGVmaW5pdGlvbihNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIk1ldGhvZERlZmluaXRpb25cIixcbiAgICAgICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgICAgICBrZXk6IHsgdHlwZTogXCJQcml2YXRlSWRlbnRpZmllclwiLCBuYW1lOiBNLmtleS5uYW1lIH0sXG4gICAgICAgICAgICB2YWx1ZTogdG9fbW96KE0udmFsdWUpLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdGljOiBNLnN0YXRpYyxcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0NsYXNzLCBmdW5jdGlvbiBUb19Nb3pfQ2xhc3MoTSkge1xuICAgICAgICB2YXIgdHlwZSA9IE0gaW5zdGFuY2VvZiBBU1RfQ2xhc3NFeHByZXNzaW9uID8gXCJDbGFzc0V4cHJlc3Npb25cIiA6IFwiQ2xhc3NEZWNsYXJhdGlvblwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHN1cGVyQ2xhc3M6IHRvX21veihNLmV4dGVuZHMpLFxuICAgICAgICAgICAgaWQ6IE0ubmFtZSA/IHRvX21veihNLm5hbWUpIDogbnVsbCxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkNsYXNzQm9keVwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IE0ucHJvcGVydGllcy5tYXAodG9fbW96KVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfQ2xhc3NTdGF0aWNCbG9jaywgZnVuY3Rpb24gVG9fTW96X1N0YXRpY0Jsb2NrKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiU3RhdGljQmxvY2tcIixcbiAgICAgICAgICAgIGJvZHk6IE0uYm9keS5tYXAodG9fbW96KSxcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX05ld1RhcmdldCwgZnVuY3Rpb24gVG9fTW96X01ldGFQcm9wZXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiTWV0YVByb3BlcnR5XCIsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJuZXdcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0YXJnZXRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfU3ltYm9sLCBmdW5jdGlvbiBUb19Nb3pfSWRlbnRpZmllcihNLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKE0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kICYmIHBhcmVudC5xdW90ZSkgfHxcbiAgICAgICAgICAgICgoXG4gICAgICAgICAgICAgICAgTSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xJbXBvcnRGb3JlaWduIHx8XG4gICAgICAgICAgICAgICAgTSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xFeHBvcnRGb3JlaWduIHx8XG4gICAgICAgICAgICAgICAgTSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xFeHBvcnRcbiAgICAgICAgICAgICAgICApICYmIE0ucXVvdGUpXG4gICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJMaXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IE0ubmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmID0gTS5kZWZpbml0aW9uKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIklkZW50aWZpZXJcIixcbiAgICAgICAgICAgIG5hbWU6IGRlZiA/IGRlZi5tYW5nbGVkX25hbWUgfHwgZGVmLm5hbWUgOiBNLm5hbWVcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX1JlZ0V4cCwgZnVuY3Rpb24gVG9fTW96X1JlZ0V4cExpdGVyYWwoTSkge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gTS52YWx1ZS5zb3VyY2U7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gTS52YWx1ZS5mbGFncztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiTGl0ZXJhbFwiLFxuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICByYXc6IE0ucHJpbnRfdG9fc3RyaW5nKCksXG4gICAgICAgICAgICByZWdleDogeyBwYXR0ZXJuLCBmbGFncyB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9Db25zdGFudCwgZnVuY3Rpb24gVG9fTW96X0xpdGVyYWwoTSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBNLnZhbHVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJMaXRlcmFsXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICByYXc6IE0ucmF3IHx8IE0ucHJpbnRfdG9fc3RyaW5nKClcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0F0b20sIGZ1bmN0aW9uIFRvX01vel9BdG9tKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiSWRlbnRpZmllclwiLFxuICAgICAgICAgICAgbmFtZTogU3RyaW5nKE0udmFsdWUpXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9CaWdJbnQsIE0gPT4gKHtcbiAgICAgICAgdHlwZTogXCJMaXRlcmFsXCIsXG4gICAgICAgIC8vIHZhbHVlIGNhbm5vdCBiZSByZXByZXNlbnRlZCBuYXRpdmVseVxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVlL2Jsb2IvbWFzdGVyL2VzMjAyMC5tZCNiaWdpbnRsaXRlcmFsXG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAvLyBgTS52YWx1ZWAgaXMgYSBzdHJpbmcgdGhhdCBtYXkgYmUgYSBoZXggbnVtYmVyIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAvLyBidXQgXCJiaWdpbnRcIiBwcm9wZXJ0eSBzaG91bGQgaGF2ZSBvbmx5IGRlY2ltYWwgZGlnaXRzXG4gICAgICAgIGJpZ2ludDogdHlwZW9mIEJpZ0ludCA9PT0gXCJmdW5jdGlvblwiID8gQmlnSW50KE0udmFsdWUpLnRvU3RyaW5nKCkgOiBNLnZhbHVlLFxuICAgICAgICByYXc6IE0ucmF3LFxuICAgIH0pKTtcblxuICAgIEFTVF9Cb29sZWFuLkRFRk1FVEhPRChcInRvX21vemlsbGFfYXN0XCIsIEFTVF9Db25zdGFudC5wcm90b3R5cGUudG9fbW96aWxsYV9hc3QpO1xuICAgIEFTVF9OdWxsLkRFRk1FVEhPRChcInRvX21vemlsbGFfYXN0XCIsIEFTVF9Db25zdGFudC5wcm90b3R5cGUudG9fbW96aWxsYV9hc3QpO1xuICAgIEFTVF9Ib2xlLkRFRk1FVEhPRChcInRvX21vemlsbGFfYXN0XCIsIGZ1bmN0aW9uIFRvX01vel9BcnJheUhvbGUoKSB7IHJldHVybiBudWxsOyB9KTtcblxuICAgIEFTVF9CbG9jay5ERUZNRVRIT0QoXCJ0b19tb3ppbGxhX2FzdFwiLCBBU1RfQmxvY2tTdGF0ZW1lbnQucHJvdG90eXBlLnRvX21vemlsbGFfYXN0KTtcbiAgICBBU1RfTGFtYmRhLkRFRk1FVEhPRChcInRvX21vemlsbGFfYXN0XCIsIEFTVF9GdW5jdGlvbi5wcm90b3R5cGUudG9fbW96aWxsYV9hc3QpO1xuXG4gICAgLyogLS0tLS1bIHRvb2xzIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gbXlfc3RhcnRfdG9rZW4obW96bm9kZSkge1xuICAgICAgICB2YXIgbG9jID0gbW96bm9kZS5sb2MsIHN0YXJ0ID0gbG9jICYmIGxvYy5zdGFydDtcbiAgICAgICAgdmFyIHJhbmdlID0gbW96bm9kZS5yYW5nZTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVG9rZW4oXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIHN0YXJ0ICYmIHN0YXJ0LmxpbmUgfHwgMCxcbiAgICAgICAgICAgIHN0YXJ0ICYmIHN0YXJ0LmNvbHVtbiB8fCAwLFxuICAgICAgICAgICAgcmFuZ2UgPyByYW5nZSBbMF0gOiBtb3pub2RlLnN0YXJ0LFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBbXSxcbiAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgbG9jICYmIGxvYy5zb3VyY2UsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXlfZW5kX3Rva2VuKG1vem5vZGUpIHtcbiAgICAgICAgdmFyIGxvYyA9IG1vem5vZGUubG9jLCBlbmQgPSBsb2MgJiYgbG9jLmVuZDtcbiAgICAgICAgdmFyIHJhbmdlID0gbW96bm9kZS5yYW5nZTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVG9rZW4oXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIGVuZCAmJiBlbmQubGluZSB8fCAwLFxuICAgICAgICAgICAgZW5kICYmIGVuZC5jb2x1bW4gfHwgMCxcbiAgICAgICAgICAgIHJhbmdlID8gcmFuZ2UgWzBdIDogbW96bm9kZS5lbmQsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgW10sXG4gICAgICAgICAgICBsb2MgJiYgbG9jLnNvdXJjZSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgRlJPTV9NT1pfTEFCRUxTID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGZyb21fbW96KG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBNT1pfVE9fTUVbbm9kZS50eXBlXShub2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tX21vel9xdW90ZShtb3pfa2V5LCBjb21wdXRlZCkge1xuICAgICAgICBpZiAoIWNvbXB1dGVkICYmIG1vel9rZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgdHlwZW9mIG1vel9rZXkudmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tX21vel9zeW1ib2woc3ltYm9sX3R5cGUsIE0sIGhhc19xdW90ZSkge1xuICAgICAgICByZXR1cm4gbmV3IHN5bWJvbF90eXBlKHtcbiAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgIHF1b3RlOiBoYXNfcXVvdGUgPyAnXCInIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbmFtZTogTS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IE0ubmFtZSA6IFN0cmluZyhNLnZhbHVlKSxcbiAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tX21vel9sYW1iZGEoTSwgaXNfbWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBuZXcgKGlzX21ldGhvZCA/IEFTVF9BY2Nlc3NvciA6IEFTVF9GdW5jdGlvbikoe1xuICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICBuYW1lOiBNLmlkICYmIGZyb21fbW96X3N5bWJvbChpc19tZXRob2QgPyBBU1RfU3ltYm9sTWV0aG9kIDogQVNUX1N5bWJvbExhbWJkYSwgTS5pZCksXG4gICAgICAgICAgICBhcmduYW1lczogTS5wYXJhbXMubWFwKE0gPT4gZnJvbV9tb3pfcGF0dGVybihNLCBBU1RfU3ltYm9sRnVuYXJnKSksXG4gICAgICAgICAgICBpc19nZW5lcmF0b3I6IE0uZ2VuZXJhdG9yLFxuICAgICAgICAgICAgYXN5bmM6IE0uYXN5bmMsXG4gICAgICAgICAgICBib2R5OiBub3JtYWxpemVfZGlyZWN0aXZlcyhmcm9tX21veihNLmJvZHkpLmJvZHkpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21fbW96X3BhdHRlcm4oTSwgc3ltX3R5cGUpIHtcbiAgICAgICAgc3dpdGNoIChNLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVzdHJ1Y3R1cmluZyh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzOiBNLnByb3BlcnRpZXMubWFwKHAgPT4gZnJvbV9tb3pfcGF0dGVybihwLCBzeW1fdHlwZSkpLFxuICAgICAgICAgICAgICAgICAgICBpc19hcnJheTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IE0ua2V5O1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKGtleSB8fCBNLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgICAgOiBteV9lbmRfdG9rZW4oTS52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIGtleSAgICAgIDoga2V5LnR5cGUgPT0gXCJJZGVudGlmaWVyXCIgPyBrZXkubmFtZSA6IFN0cmluZyhrZXkudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBxdW90ZSAgICA6ICFNLmNvbXB1dGVkICYmIGtleS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiB0eXBlb2Yga2V5LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ1wiJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogZnJvbV9tb3pfcGF0dGVybihNLnZhbHVlLCBzeW1fdHlwZSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChNLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3Mua2V5ID0gZnJvbV9tb3ooTS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3RLZXlWYWwoYXJncyk7XG5cbiAgICAgICAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9EZXN0cnVjdHVyaW5nKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXM6IE0uZWxlbWVudHMubWFwKGZ1bmN0aW9uKGVsbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0hvbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tX21vel9wYXR0ZXJuKGVsbSwgc3ltX3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaXNfYXJyYXk6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0V4cGFuc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGZyb21fbW96X3BhdHRlcm4oTS5hcmd1bWVudCwgc3ltX3R5cGUpLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9EZWZhdWx0QXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgIDogZnJvbV9tb3pfcGF0dGVybihNLmxlZnQsIHN5bV90eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgICAgICAgICByaWdodCA6IGZyb21fbW96KE0ucmlnaHQpLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3ltX3R5cGUoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgICAgICBlbmQgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSAgOiBNLm5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub2RlIHR5cGUgZm9yIGRlc3RydWN0dXJpbmc6IFwiICsgTS50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21fbW96X2xhYmVsX3JlZihtX2xhYmVsKSB7XG4gICAgICAgIGlmICghbV9sYWJlbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgbGFiZWwgPSBmcm9tX21vel9zeW1ib2woQVNUX0xhYmVsUmVmLCBtX2xhYmVsKTtcblxuICAgICAgICBsZXQgaSA9IEZST01fTU9aX0xBQkVMUy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsX29yaWdpbiA9IEZST01fTU9aX0xBQkVMU1tpXTtcblxuICAgICAgICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IGxhYmVsX29yaWdpbi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwudGhlZGVmID0gbGFiZWxfb3JpZ2luO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH1cblxuICAgIEFTVF9Ob2RlLmZyb21fbW96aWxsYV9hc3QgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBzYXZlX2xhYmVscyA9IEZST01fTU9aX0xBQkVMUztcbiAgICAgICAgRlJPTV9NT1pfTEFCRUxTID0gW107XG4gICAgICAgIHZhciBhc3QgPSBmcm9tX21veihub2RlKTtcbiAgICAgICAgRlJPTV9NT1pfTEFCRUxTID0gc2F2ZV9sYWJlbHM7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNldF9tb3pfbG9jKG15bm9kZSwgbW96bm9kZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBteW5vZGUuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSBteW5vZGUuZW5kO1xuICAgICAgICBpZiAoIShzdGFydCAmJiBlbmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW96bm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQucG9zICE9IG51bGwgJiYgZW5kLmVuZHBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBtb3pub2RlLnJhbmdlID0gW3N0YXJ0LnBvcywgZW5kLmVuZHBvc107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0LmxpbmUpIHtcbiAgICAgICAgICAgIG1vem5vZGUubG9jID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogc3RhcnQubGluZSwgY29sdW1uOiBzdGFydC5jb2x9LFxuICAgICAgICAgICAgICAgIGVuZDogZW5kLmVuZGxpbmUgPyB7bGluZTogZW5kLmVuZGxpbmUsIGNvbHVtbjogZW5kLmVuZGNvbH0gOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0YXJ0LmZpbGUpIHtcbiAgICAgICAgICAgICAgICBtb3pub2RlLmxvYy5zb3VyY2UgPSBzdGFydC5maWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3pub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZl90b19tb3oobXl0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIG15dHlwZS5ERUZNRVRIT0QoXCJ0b19tb3ppbGxhX2FzdFwiLCBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRfbW96X2xvYyh0aGlzLCBoYW5kbGVyKHRoaXMsIHBhcmVudCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgVE9fTU9aX1NUQUNLID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHRvX21veihub2RlKSB7XG4gICAgICAgIGlmIChUT19NT1pfU1RBQ0sgPT09IG51bGwpIHsgVE9fTU9aX1NUQUNLID0gW107IH1cbiAgICAgICAgVE9fTU9aX1NUQUNLLnB1c2gobm9kZSk7XG4gICAgICAgIHZhciBhc3QgPSBub2RlICE9IG51bGwgPyBub2RlLnRvX21vemlsbGFfYXN0KFRPX01PWl9TVEFDS1tUT19NT1pfU1RBQ0subGVuZ3RoIC0gMl0pIDogbnVsbDtcbiAgICAgICAgVE9fTU9aX1NUQUNLLnBvcCgpO1xuICAgICAgICBpZiAoVE9fTU9aX1NUQUNLLmxlbmd0aCA9PT0gMCkgeyBUT19NT1pfU1RBQ0sgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuXG4gICAgLyoqIE9iamVjdCBwcm9wZXJ0eSBrZXlzIGNhbiBiZSBudW1iZXIgbGl0ZXJhbHMsIHN0cmluZyBsaXRlcmFscywgb3IgcmF3IG5hbWVzLiBBZGRpdGlvbmFsbHkgdGhleSBjYW4gYmUgc2hvcnRoYW5kLiBXZSBkZWNpZGUgdGhhdCBoZXJlLiAqL1xuICAgIGZ1bmN0aW9uIHRvX21vel9wcm9wZXJ0eV9rZXkoa2V5LCBjb21wdXRlZCA9IGZhbHNlLCBxdW90ZSA9IGZhbHNlLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCB0b19tb3ooa2V5KV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBrZXlfbmFtZSA9IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkubmFtZTtcbiAgICAgICAgbGV0IG1vel9rZXk7XG4gICAgICAgIGlmIChxdW90ZSkge1xuICAgICAgICAgICAgbW96X2tleSA9IHsgdHlwZTogXCJMaXRlcmFsXCIsIHZhbHVlOiBrZXlfbmFtZSwgcmF3OiBKU09OLnN0cmluZ2lmeShrZXlfbmFtZSkgfTtcbiAgICAgICAgfSBlbHNlIGlmIChcIlwiICsgK2tleV9uYW1lID09PSBrZXlfbmFtZSAmJiAra2V5X25hbWUgPj0gMCkge1xuICAgICAgICAgICAgLy8gcmVwcmVzZW50YWJsZSBhcyBhIG51bWJlclxuICAgICAgICAgICAgbW96X2tleSA9IHsgdHlwZTogXCJMaXRlcmFsXCIsIHZhbHVlOiAra2V5X25hbWUsIHJhdzogSlNPTi5zdHJpbmdpZnkoK2tleV9uYW1lKSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW96X2tleSA9IHsgdHlwZTogXCJJZGVudGlmaWVyXCIsIG5hbWU6IGtleV9uYW1lIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaG9ydGhhbmQgPVxuICAgICAgICAgICAgbW96X2tleS50eXBlID09PSBcIklkZW50aWZpZXJcIlxuICAgICAgICAgICAgJiYgbW96X2tleS5uYW1lID09PSBrZXlfbmFtZVxuICAgICAgICAgICAgJiYgKHZhbHVlIGluc3RhbmNlb2YgQVNUX1N5bWJvbCAmJiB2YWx1ZS5uYW1lID09PSBrZXlfbmFtZVxuICAgICAgICAgICAgICAgIHx8IHZhbHVlIGluc3RhbmNlb2YgQVNUX0RlZmF1bHRBc3NpZ24gJiYgdmFsdWUubGVmdC5uYW1lID09PSBrZXlfbmFtZSk7XG4gICAgICAgIHJldHVybiBbc2hvcnRoYW5kLCBtb3pfa2V5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b19tb3pfcGF0dGVybihub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlJlc3RFbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IHRvX21vel9wYXR0ZXJuKG5vZGUuZXhwcmVzc2lvbiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sXG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmdcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmYXVsdEFzc2lnblxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzXG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIC8vIFBsYWluIHRyYW5zbGF0aW9uXG4gICAgICAgICAgICByZXR1cm4gdG9fbW96KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5vZGUuVFlQRSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9fbW96X2luX2Rlc3RydWN0dXJpbmcoKSB7XG4gICAgICAgIHZhciBpID0gVE9fTU9aX1NUQUNLLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYgKFRPX01PWl9TVEFDS1tpXSBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX21vel9ibG9jayhub2RlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkJsb2NrU3RhdGVtZW50XCIsXG4gICAgICAgICAgICBib2R5OiBub2RlLmJvZHkubWFwKHRvX21veilcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b19tb3pfc2NvcGUodHlwZSwgbm9kZSkge1xuICAgICAgICB2YXIgYm9keSA9IG5vZGUuYm9keS5tYXAodG9fbW96KTtcbiAgICAgICAgaWYgKG5vZGUuYm9keVswXSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQgJiYgbm9kZS5ib2R5WzBdLmJvZHkgaW5zdGFuY2VvZiBBU1RfU3RyaW5nKSB7XG4gICAgICAgICAgICBib2R5LnVuc2hpZnQodG9fbW96KG5ldyBBU1RfRW1wdHlTdGF0ZW1lbnQobm9kZS5ib2R5WzBdKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbi8vIHJldHVybiB0cnVlIGlmIHRoZSBub2RlIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrICh0aGF0IG1lYW5zIHRoZVxuLy8gaW5uZXJtb3N0IG5vZGUgaW4gdGhlIGN1cnJlbnQgb3V0cHV0KSBpcyBsZXhpY2FsbHkgdGhlIGZpcnN0IGluXG4vLyBhIHN0YXRlbWVudC5cbmZ1bmN0aW9uIGZpcnN0X2luX3N0YXRlbWVudChzdGFjaykge1xuICAgIGxldCBub2RlID0gc3RhY2sucGFyZW50KC0xKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcDsgcCA9IHN0YWNrLnBhcmVudChpKTsgaSsrKSB7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudCAmJiBwLmJvZHkgPT09IG5vZGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKChwIGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlICYmIHAuZXhwcmVzc2lvbnNbMF0gPT09IG5vZGUpIHx8XG4gICAgICAgICAgICAocC5UWVBFID09PSBcIkNhbGxcIiAmJiBwLmV4cHJlc3Npb24gPT09IG5vZGUpIHx8XG4gICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9QcmVmaXhlZFRlbXBsYXRlU3RyaW5nICYmIHAucHJlZml4ID09PSBub2RlKSB8fFxuICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfRG90ICYmIHAuZXhwcmVzc2lvbiA9PT0gbm9kZSkgfHxcbiAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX1N1YiAmJiBwLmV4cHJlc3Npb24gPT09IG5vZGUpIHx8XG4gICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9DaGFpbiAmJiBwLmV4cHJlc3Npb24gPT09IG5vZGUpIHx8XG4gICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAmJiBwLmNvbmRpdGlvbiA9PT0gbm9kZSkgfHxcbiAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiBwLmxlZnQgPT09IG5vZGUpIHx8XG4gICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeVBvc3RmaXggJiYgcC5leHByZXNzaW9uID09PSBub2RlKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG5vZGUgPSBwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBSZXR1cm5zIHdoZXRoZXIgdGhlIGxlZnRtb3N0IGl0ZW0gaW4gdGhlIGV4cHJlc3Npb24gaXMgYW4gb2JqZWN0XG5mdW5jdGlvbiBsZWZ0X2lzX29iamVjdChub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkgcmV0dXJuIGxlZnRfaXNfb2JqZWN0KG5vZGUuZXhwcmVzc2lvbnNbMF0pO1xuICAgIGlmIChub2RlLlRZUEUgPT09IFwiQ2FsbFwiKSByZXR1cm4gbGVmdF9pc19vYmplY3Qobm9kZS5leHByZXNzaW9uKTtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9QcmVmaXhlZFRlbXBsYXRlU3RyaW5nKSByZXR1cm4gbGVmdF9pc19vYmplY3Qobm9kZS5wcmVmaXgpO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RvdCB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1N1YikgcmV0dXJuIGxlZnRfaXNfb2JqZWN0KG5vZGUuZXhwcmVzc2lvbik7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2hhaW4pIHJldHVybiBsZWZ0X2lzX29iamVjdChub2RlLmV4cHJlc3Npb24pO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsKSByZXR1cm4gbGVmdF9pc19vYmplY3Qobm9kZS5jb25kaXRpb24pO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0JpbmFyeSkgcmV0dXJuIGxlZnRfaXNfb2JqZWN0KG5vZGUubGVmdCk7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVW5hcnlQb3N0Zml4KSByZXR1cm4gbGVmdF9pc19vYmplY3Qobm9kZS5leHByZXNzaW9uKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY29uc3QgQ09ERV9MSU5FX0JSRUFLID0gMTA7XG5jb25zdCBDT0RFX1NQQUNFID0gMzI7XG5cbmNvbnN0IHJfYW5ub3RhdGlvbiA9IC9bQCNdX18oUFVSRXxJTkxJTkV8Tk9JTkxJTkUpX18vO1xuXG5mdW5jdGlvbiBpc19zb21lX2NvbW1lbnRzKGNvbW1lbnQpIHtcbiAgICAvLyBtdWx0aWxpbmUgY29tbWVudFxuICAgIHJldHVybiAoXG4gICAgICAgIChjb21tZW50LnR5cGUgPT09IFwiY29tbWVudDJcIiB8fCBjb21tZW50LnR5cGUgPT09IFwiY29tbWVudDFcIilcbiAgICAgICAgJiYgL0BwcmVzZXJ2ZXxAY29weXJpZ2h0fEBsaWN8QGNjX29ufF5cXCoqIS9pLnRlc3QoY29tbWVudC52YWx1ZSlcbiAgICApO1xufVxuXG5jb25zdCBST1BFX0NPTU1JVF9XSEVOID0gOCAqIDEwMDA7XG5jbGFzcyBSb3BlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBcIlwiO1xuICAgIH1cblxuICAgIGFwcGVuZChzdHIpIHtcbiAgICAgICAgLyoqIFdoZW4gYHRoaXMuY3VycmVudGAgaXMgdG9vIGxvbmcsIGNvbW1pdCBpdC4gKi9cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5sZW5ndGggPiBST1BFX0NPTU1JVF9XSEVOKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdHRlZCArPSB0aGlzLmN1cnJlbnQgKyBzdHI7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ICs9IHN0cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluc2VydEF0KGNoYXIsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgY29tbWl0dGVkLCBjdXJyZW50IH0gPSB0aGlzO1xuICAgICAgICBpZiAoaW5kZXggPCBjb21taXR0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IGNvbW1pdHRlZC5zbGljZSgwLCBpbmRleCkgKyBjaGFyICsgY29tbWl0dGVkLnNsaWNlKGluZGV4KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gY29tbWl0dGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jb21taXR0ZWQgKz0gY2hhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4IC09IGNvbW1pdHRlZC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdHRlZCArPSBjdXJyZW50LnNsaWNlKDAsIGluZGV4KSArIGNoYXI7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50LnNsaWNlKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoYXJBdChpbmRleCkge1xuICAgICAgICBjb25zdCB7IGNvbW1pdHRlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKGluZGV4IDwgY29tbWl0dGVkLmxlbmd0aCkgcmV0dXJuIGNvbW1pdHRlZFtpbmRleF07XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRbaW5kZXggLSBjb21taXR0ZWQubGVuZ3RoXTtcbiAgICB9XG5cbiAgICBjaGFyQ29kZUF0KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgY29tbWl0dGVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaW5kZXggPCBjb21taXR0ZWQubGVuZ3RoKSByZXR1cm4gY29tbWl0dGVkLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50LmNoYXJDb2RlQXQoaW5kZXggLSBjb21taXR0ZWQubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1pdHRlZC5sZW5ndGggKyB0aGlzLmN1cnJlbnQubGVuZ3RoO1xuICAgIH1cblxuICAgIGV4cGVjdERpcmVjdGl2ZSgpIHtcbiAgICAgICAgLy8gL14kfFs7e11bXFxzXFxuXSokL1xuXG4gICAgICAgIGxldCBjaCwgbiA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKG4gPD0gMCkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gU2tpcCBOIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kXG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgIChjaCA9IHRoaXMuY2hhckNvZGVBdCgtLW4pKVxuICAgICAgICAgICAgJiYgKGNoID09IENPREVfU1BBQ0UgfHwgY2ggPT0gQ09ERV9MSU5FX0JSRUFLKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGVpdGhlciBcIjtcIiwgb3IgXCJ7XCIsIG9yIHRoZSBzdHJpbmcgZW5kZWRcbiAgICAgICAgcmV0dXJuICFjaCB8fCBjaCA9PT0gNTkgfHwgY2ggPT09IDEyMztcbiAgICB9XG5cbiAgICBoYXNOTEIoKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5sZW5ndGgoKSAtIDE7XG4gICAgICAgIHdoaWxlIChuID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLmNoYXJDb2RlQXQobi0tKTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENPREVfTElORV9CUkVBSykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gQ09ERV9TUEFDRSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1pdHRlZCArIHRoaXMuY3VycmVudDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIE91dHB1dFN0cmVhbShvcHRpb25zKSB7XG5cbiAgICB2YXIgcmVhZG9ubHkgPSAhb3B0aW9ucztcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBhc2NpaV9vbmx5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBiZWF1dGlmeSAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBicmFjZXMgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBjb21tZW50cyAgICAgICAgICAgICA6IFwic29tZVwiLFxuICAgICAgICBlY21hICAgICAgICAgICAgICAgICA6IDUsXG4gICAgICAgIGllOCAgICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGluZGVudF9sZXZlbCAgICAgICAgIDogNCxcbiAgICAgICAgaW5kZW50X3N0YXJ0ICAgICAgICAgOiAwLFxuICAgICAgICBpbmxpbmVfc2NyaXB0ICAgICAgICA6IHRydWUsXG4gICAgICAgIGtlZXBfbnVtYmVycyAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGtlZXBfcXVvdGVkX3Byb3BzICAgIDogZmFsc2UsXG4gICAgICAgIG1heF9saW5lX2xlbiAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHByZWFtYmxlICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgcHJlc2VydmVfYW5ub3RhdGlvbnMgOiBmYWxzZSxcbiAgICAgICAgcXVvdGVfa2V5cyAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgcXVvdGVfc3R5bGUgICAgICAgICAgOiAwLFxuICAgICAgICBzYWZhcmkxMCAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBzZW1pY29sb25zICAgICAgICAgICA6IHRydWUsXG4gICAgICAgIHNoZWJhbmcgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgc2hvcnRoYW5kICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIHNvdXJjZV9tYXAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgd2Via2l0ICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgd2lkdGggICAgICAgICAgICAgICAgOiA4MCxcbiAgICAgICAgd3JhcF9paWZlICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgd3JhcF9mdW5jX2FyZ3MgICAgICAgOiBmYWxzZSxcblxuICAgICAgICBfZGVzdHJveV9hc3QgICAgICAgICA6IGZhbHNlXG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBpZiAob3B0aW9ucy5zaG9ydGhhbmQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgb3B0aW9ucy5zaG9ydGhhbmQgPSBvcHRpb25zLmVjbWEgPiA1O1xuXG4gICAgLy8gQ29udmVydCBjb21tZW50IG9wdGlvbiB0byBSZWdFeHAgaWYgbmVjZXNzYXJ5IGFuZCBzZXQgdXAgY29tbWVudHMgZmlsdGVyXG4gICAgdmFyIGNvbW1lbnRfZmlsdGVyID0gcmV0dXJuX2ZhbHNlOyAvLyBEZWZhdWx0IGNhc2UsIHRocm93IGFsbCBjb21tZW50cyBhd2F5XG4gICAgaWYgKG9wdGlvbnMuY29tbWVudHMpIHtcbiAgICAgICAgbGV0IGNvbW1lbnRzID0gb3B0aW9ucy5jb21tZW50cztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbW1lbnRzID09PSBcInN0cmluZ1wiICYmIC9eXFwvLipcXC9bYS16QS1aXSokLy50ZXN0KG9wdGlvbnMuY29tbWVudHMpKSB7XG4gICAgICAgICAgICB2YXIgcmVnZXhfcG9zID0gb3B0aW9ucy5jb21tZW50cy5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICAgICAgICBjb21tZW50cyA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50cy5zdWJzdHIoMSwgcmVnZXhfcG9zIC0gMSksXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50cy5zdWJzdHIocmVnZXhfcG9zICsgMSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnRzIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICBjb21tZW50X2ZpbHRlciA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudC50eXBlICE9IFwiY29tbWVudDVcIiAmJiBjb21tZW50cy50ZXN0KGNvbW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29tbWVudHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29tbWVudF9maWx0ZXIgPSBmdW5jdGlvbihjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQudHlwZSAhPSBcImNvbW1lbnQ1XCIgJiYgY29tbWVudHModGhpcywgY29tbWVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbW1lbnRzID09PSBcInNvbWVcIikge1xuICAgICAgICAgICAgY29tbWVudF9maWx0ZXIgPSBpc19zb21lX2NvbW1lbnRzO1xuICAgICAgICB9IGVsc2UgeyAvLyBOT1RFIGluY2x1ZGVzIFwiYWxsXCIgb3B0aW9uXG4gICAgICAgICAgICBjb21tZW50X2ZpbHRlciA9IHJldHVybl90cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucHJlc2VydmVfYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgbGV0IHByZXZfY29tbWVudF9maWx0ZXIgPSBjb21tZW50X2ZpbHRlcjtcbiAgICAgICAgY29tbWVudF9maWx0ZXIgPSBmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHJfYW5ub3RhdGlvbi50ZXN0KGNvbW1lbnQudmFsdWUpIHx8IHByZXZfY29tbWVudF9maWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50YXRpb24gPSAwO1xuICAgIHZhciBjdXJyZW50X2NvbCA9IDA7XG4gICAgdmFyIGN1cnJlbnRfbGluZSA9IDE7XG4gICAgdmFyIGN1cnJlbnRfcG9zID0gMDtcbiAgICB2YXIgT1VUUFVUID0gbmV3IFJvcGUoKTtcbiAgICBsZXQgcHJpbnRlZF9jb21tZW50cyA9IG5ldyBTZXQoKTtcblxuICAgIHZhciB0b191dGY4ID0gb3B0aW9ucy5hc2NpaV9vbmx5ID8gZnVuY3Rpb24oc3RyLCBpZGVudGlmaWVyID0gZmFsc2UsIHJlZ2V4cCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmVjbWEgPj0gMjAxNSAmJiAhb3B0aW9ucy5zYWZhcmkxMCAmJiAhcmVnZXhwKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvW1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gZ2V0X2Z1bGxfY2hhcl9jb2RlKGNoLCAwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHV7XCIgKyBjb2RlICsgXCJ9XCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdWZmZmZdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoIDw9IDIgJiYgIWlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5sZW5ndGggPCAyKSBjb2RlID0gXCIwXCIgKyBjb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx4XCIgKyBjb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5sZW5ndGggPCA0KSBjb2RlID0gXCIwXCIgKyBjb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1XCIgKyBjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXwoW1xcdWQ4MDAtXFx1ZGJmZl18W1xcdWRjMDAtXFx1ZGZmZl0pL2csIGZ1bmN0aW9uKG1hdGNoLCBsb25lKSB7XG4gICAgICAgICAgICBpZiAobG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1XCIgKyBsb25lLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9zdHJpbmcoc3RyLCBxdW90ZSkge1xuICAgICAgICB2YXIgZHEgPSAwLCBzcSA9IDA7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9bXFxcXFxcYlxcZlxcblxcclxcdlxcdFxceDIyXFx4MjdcXHUyMDI4XFx1MjAyOVxcMFxcdWZlZmZdL2csXG4gICAgICAgICAgZnVuY3Rpb24ocywgaSkge1xuICAgICAgICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ1wiJzogKytkcTsgcmV0dXJuICdcIic7XG4gICAgICAgICAgICAgIGNhc2UgXCInXCI6ICsrc3E7IHJldHVybiBcIidcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjogcmV0dXJuIFwiXFxcXFxcXFxcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOiByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6IHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHRcIjogcmV0dXJuIFwiXFxcXHRcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcYlwiOiByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFxmXCI6IHJldHVybiBcIlxcXFxmXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHgwQlwiOiByZXR1cm4gb3B0aW9ucy5pZTggPyBcIlxcXFx4MEJcIiA6IFwiXFxcXHZcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjogcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6IHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1ZmVmZlwiOiByZXR1cm4gXCJcXFxcdWZlZmZcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcMFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIC9bMC05XS8udGVzdChnZXRfZnVsbF9jaGFyKHN0ciwgaSsxKSkgPyBcIlxcXFx4MDBcIiA6IFwiXFxcXDBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gcXVvdGVfc2luZ2xlKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyLnJlcGxhY2UoL1xceDI3L2csIFwiXFxcXCdcIikgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBxdW90ZV9kb3VibGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKC9cXHgyMi9nLCAnXFxcXFwiJykgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHF1b3RlX3RlbXBsYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYFwiICsgc3RyLnJlcGxhY2UoL2AvZywgXCJcXFxcYFwiKSArIFwiYFwiO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHRvX3V0Zjgoc3RyKTtcbiAgICAgICAgaWYgKHF1b3RlID09PSBcImBcIikgcmV0dXJuIHF1b3RlX3RlbXBsYXRlKCk7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5xdW90ZV9zdHlsZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZV9zaW5nbGUoKTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGVfZG91YmxlKCk7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlID09IFwiJ1wiID8gcXVvdGVfc2luZ2xlKCkgOiBxdW90ZV9kb3VibGUoKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGRxID4gc3EgPyBxdW90ZV9zaW5nbGUoKSA6IHF1b3RlX2RvdWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5jb2RlX3N0cmluZyhzdHIsIHF1b3RlKSB7XG4gICAgICAgIHZhciByZXQgPSBtYWtlX3N0cmluZyhzdHIsIHF1b3RlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5saW5lX3NjcmlwdCkge1xuICAgICAgICAgICAgcmV0ID0gcmV0LnJlcGxhY2UoLzxcXHgyZihzY3JpcHQpKFs+XFwvXFx0XFxuXFxmXFxyIF0pL2dpLCBcIjxcXFxcLyQxJDJcIik7XG4gICAgICAgICAgICByZXQgPSByZXQucmVwbGFjZSgvXFx4M2MhLS0vZywgXCJcXFxceDNjIS0tXCIpO1xuICAgICAgICAgICAgcmV0ID0gcmV0LnJlcGxhY2UoLy0tXFx4M2UvZywgXCItLVxcXFx4M2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlX25hbWUobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b1N0cmluZygpO1xuICAgICAgICBuYW1lID0gdG9fdXRmOChuYW1lLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZV9pbmRlbnQoYmFjaykge1xuICAgICAgICByZXR1cm4gXCIgXCIucmVwZWF0KG9wdGlvbnMuaW5kZW50X3N0YXJ0ICsgaW5kZW50YXRpb24gLSBiYWNrICogb3B0aW9ucy5pbmRlbnRfbGV2ZWwpO1xuICAgIH1cblxuICAgIC8qIC0tLS0tWyBiZWF1dGlmaWNhdGlvbi9taW5pZmljYXRpb24gXS0tLS0tICovXG5cbiAgICB2YXIgaGFzX3BhcmVucyA9IGZhbHNlO1xuICAgIHZhciBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgdmFyIG1pZ2h0X25lZWRfc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgdmFyIG1pZ2h0X2FkZF9uZXdsaW5lID0gMDtcbiAgICB2YXIgbmVlZF9uZXdsaW5lX2luZGVudGVkID0gZmFsc2U7XG4gICAgdmFyIG5lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICB2YXIgbmV3bGluZV9pbnNlcnQgPSAtMTtcbiAgICB2YXIgbGFzdCA9IFwiXCI7XG4gICAgdmFyIG1hcHBpbmdfdG9rZW4sIG1hcHBpbmdfbmFtZSwgbWFwcGluZ3MgPSBvcHRpb25zLnNvdXJjZV9tYXAgJiYgW107XG5cbiAgICB2YXIgZG9fYWRkX21hcHBpbmcgPSBtYXBwaW5ncyA/IGZ1bmN0aW9uKCkge1xuICAgICAgICBtYXBwaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKG1hcHBpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbmFtZSwgdG9rZW4gfSA9IG1hcHBpbmc7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09IFwibmFtZVwiIHx8IHRva2VuLnR5cGUgPT09IFwicHJpdmF0ZW5hbWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gdG9rZW4udHlwZSA9PT0gXCJzdHJpbmdcIiA/IHRva2VuLnZhbHVlIDogbmFtZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc291cmNlX21hcC5hZGQoXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcudG9rZW4uZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5saW5lLCBtYXBwaW5nLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy50b2tlbi5saW5lLCBtYXBwaW5nLnRva2VuLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgaXNfYmFzaWNfaWRlbnRpZmllcl9zdHJpbmcobmFtZSkgPyBuYW1lIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYmFkIG1hcHBpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1hcHBpbmdzID0gW107XG4gICAgfSA6IG5vb3A7XG5cbiAgICB2YXIgZW5zdXJlX2xpbmVfbGVuID0gb3B0aW9ucy5tYXhfbGluZV9sZW4gPyBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRfY29sID4gb3B0aW9ucy5tYXhfbGluZV9sZW4pIHtcbiAgICAgICAgICAgIGlmIChtaWdodF9hZGRfbmV3bGluZSkge1xuICAgICAgICAgICAgICAgIE9VVFBVVC5pbnNlcnRBdChcIlxcblwiLCBtaWdodF9hZGRfbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuX2FmdGVyX25ld2xpbmUgPSBPVVRQVVQubGVuZ3RoKCkgLSBtaWdodF9hZGRfbmV3bGluZSAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IGxlbl9hZnRlcl9uZXdsaW5lIC0gY3VycmVudF9jb2w7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmdzLmZvckVhY2goZnVuY3Rpb24obWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5saW5lKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmNvbCArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRfbGluZSsrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfcG9zKys7XG4gICAgICAgICAgICAgICAgY3VycmVudF9jb2wgPSBsZW5fYWZ0ZXJfbmV3bGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWlnaHRfYWRkX25ld2xpbmUpIHtcbiAgICAgICAgICAgIG1pZ2h0X2FkZF9uZXdsaW5lID0gMDtcbiAgICAgICAgICAgIGRvX2FkZF9tYXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICB9IDogbm9vcDtcblxuICAgIHZhciByZXF1aXJlU2VtaWNvbG9uQ2hhcnMgPSBtYWtlUHJlZGljYXRlKFwiKCBbICsgKiAvIC0gLCAuIGBcIik7XG5cbiAgICBmdW5jdGlvbiBwcmludChzdHIpIHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHZhciBjaCA9IGdldF9mdWxsX2NoYXIoc3RyLCAwKTtcbiAgICAgICAgaWYgKG5lZWRfbmV3bGluZV9pbmRlbnRlZCAmJiBjaCkge1xuICAgICAgICAgICAgbmVlZF9uZXdsaW5lX2luZGVudGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2ggIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBwcmludChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZF9zcGFjZSAmJiBjaCkge1xuICAgICAgICAgICAgbmVlZF9zcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCEvW1xcczt9KV0vLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAgICAgc3BhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdsaW5lX2luc2VydCA9IC0xO1xuICAgICAgICB2YXIgcHJldiA9IGxhc3QuY2hhckF0KGxhc3QubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChtaWdodF9uZWVkX3NlbWljb2xvbikge1xuICAgICAgICAgICAgbWlnaHRfbmVlZF9zZW1pY29sb24gPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHByZXYgPT09IFwiOlwiICYmIGNoID09PSBcIn1cIiB8fCAoIWNoIHx8ICFcIjt9XCIuaW5jbHVkZXMoY2gpKSAmJiBwcmV2ICE9PSBcIjtcIikge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNlbWljb2xvbnMgfHwgcmVxdWlyZVNlbWljb2xvbkNoYXJzLmhhcyhjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgT1VUUFVULmFwcGVuZChcIjtcIik7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sKys7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfcG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlX2xpbmVfbGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X2NvbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9VVFBVVC5hcHBlbmQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3BvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9saW5lKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X2NvbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoL15cXHMrJC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgc2VtaWNvbG9uIGZsYWcsIHNpbmNlIHdlIGRpZG4ndCBwcmludCBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyBhbmQgbWlnaHQgc3RpbGwgaGF2ZSB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlnaHRfbmVlZF9zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmJlYXV0aWZ5KVxuICAgICAgICAgICAgICAgICAgICBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWlnaHRfbmVlZF9zcGFjZSkge1xuICAgICAgICAgICAgaWYgKChpc19pZGVudGlmaWVyX2NoYXIocHJldilcbiAgICAgICAgICAgICAgICAgICAgJiYgKGlzX2lkZW50aWZpZXJfY2hhcihjaCkgfHwgY2ggPT0gXCJcXFxcXCIpKVxuICAgICAgICAgICAgICAgIHx8IChjaCA9PSBcIi9cIiAmJiBjaCA9PSBwcmV2KVxuICAgICAgICAgICAgICAgIHx8ICgoY2ggPT0gXCIrXCIgfHwgY2ggPT0gXCItXCIpICYmIGNoID09IGxhc3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBPVVRQVVQuYXBwZW5kKFwiIFwiKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50X2NvbCsrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFwcGluZ190b2tlbikge1xuICAgICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IG1hcHBpbmdfdG9rZW4sXG4gICAgICAgICAgICAgICAgbmFtZTogbWFwcGluZ19uYW1lLFxuICAgICAgICAgICAgICAgIGxpbmU6IGN1cnJlbnRfbGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IGN1cnJlbnRfY29sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcHBpbmdfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghbWlnaHRfYWRkX25ld2xpbmUpIGRvX2FkZF9tYXBwaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBPVVRQVVQuYXBwZW5kKHN0cik7XG4gICAgICAgIGhhc19wYXJlbnMgPSBzdHJbc3RyLmxlbmd0aCAtIDFdID09IFwiKFwiO1xuICAgICAgICBjdXJyZW50X3BvcyArPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgYSA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pLCBuID0gYS5sZW5ndGggLSAxO1xuICAgICAgICBjdXJyZW50X2xpbmUgKz0gbjtcbiAgICAgICAgY3VycmVudF9jb2wgKz0gYVswXS5sZW5ndGg7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgZW5zdXJlX2xpbmVfbGVuKCk7XG4gICAgICAgICAgICBjdXJyZW50X2NvbCA9IGFbbl0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QgPSBzdHI7XG4gICAgfVxuXG4gICAgdmFyIHN0YXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJpbnQoXCIqXCIpO1xuICAgIH07XG5cbiAgICB2YXIgc3BhY2UgPSBvcHRpb25zLmJlYXV0aWZ5ID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByaW50KFwiIFwiKTtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgaW5kZW50ID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKGhhbGYpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYmVhdXRpZnkpIHtcbiAgICAgICAgICAgIHByaW50KG1ha2VfaW5kZW50KGhhbGYgPyAwLjUgOiAwKSk7XG4gICAgICAgIH1cbiAgICB9IDogbm9vcDtcblxuICAgIHZhciB3aXRoX2luZGVudCA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbihjb2wsIGNvbnQpIHtcbiAgICAgICAgaWYgKGNvbCA9PT0gdHJ1ZSkgY29sID0gbmV4dF9pbmRlbnQoKTtcbiAgICAgICAgdmFyIHNhdmVfaW5kZW50YXRpb24gPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgaW5kZW50YXRpb24gPSBjb2w7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIGluZGVudGF0aW9uID0gc2F2ZV9pbmRlbnRhdGlvbjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9IDogZnVuY3Rpb24oY29sLCBjb250KSB7IHJldHVybiBjb250KCk7IH07XG5cbiAgICB2YXIgbmV3bGluZSA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG5ld2xpbmVfaW5zZXJ0IDwgMCkgcmV0dXJuIHByaW50KFwiXFxuXCIpO1xuICAgICAgICBpZiAoT1VUUFVULmNoYXJBdChuZXdsaW5lX2luc2VydCkgIT0gXCJcXG5cIikge1xuICAgICAgICAgICAgT1VUUFVULmluc2VydEF0KFwiXFxuXCIsIG5ld2xpbmVfaW5zZXJ0KTtcbiAgICAgICAgICAgIGN1cnJlbnRfcG9zKys7XG4gICAgICAgICAgICBjdXJyZW50X2xpbmUrKztcbiAgICAgICAgfVxuICAgICAgICBuZXdsaW5lX2luc2VydCsrO1xuICAgIH0gOiBvcHRpb25zLm1heF9saW5lX2xlbiA/IGZ1bmN0aW9uKCkge1xuICAgICAgICBlbnN1cmVfbGluZV9sZW4oKTtcbiAgICAgICAgbWlnaHRfYWRkX25ld2xpbmUgPSBPVVRQVVQubGVuZ3RoKCk7XG4gICAgfSA6IG5vb3A7XG5cbiAgICB2YXIgc2VtaWNvbG9uID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICBwcmludChcIjtcIik7XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaWdodF9uZWVkX3NlbWljb2xvbiA9IHRydWU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZvcmNlX3NlbWljb2xvbigpIHtcbiAgICAgICAgbWlnaHRfbmVlZF9zZW1pY29sb24gPSBmYWxzZTtcbiAgICAgICAgcHJpbnQoXCI7XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHRfaW5kZW50KCkge1xuICAgICAgICByZXR1cm4gaW5kZW50YXRpb24gKyBvcHRpb25zLmluZGVudF9sZXZlbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aXRoX2Jsb2NrKGNvbnQpIHtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgcHJpbnQoXCJ7XCIpO1xuICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIHdpdGhfaW5kZW50KG5leHRfaW5kZW50KCksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0ID0gY29udCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5kZW50KCk7XG4gICAgICAgIHByaW50KFwifVwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aXRoX3BhcmVucyhjb250KSB7XG4gICAgICAgIHByaW50KFwiKFwiKTtcbiAgICAgICAgLy9YWFg6IHN0aWxsIG5pY2UgdG8gaGF2ZSB0aGF0IGZvciBhcmd1bWVudCBsaXN0c1xuICAgICAgICAvL3ZhciByZXQgPSB3aXRoX2luZGVudChjdXJyZW50X2NvbCwgY29udCk7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIHByaW50KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aXRoX3NxdWFyZShjb250KSB7XG4gICAgICAgIHByaW50KFwiW1wiKTtcbiAgICAgICAgLy92YXIgcmV0ID0gd2l0aF9pbmRlbnQoY3VycmVudF9jb2wsIGNvbnQpO1xuICAgICAgICB2YXIgcmV0ID0gY29udCgpO1xuICAgICAgICBwcmludChcIl1cIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tbWEoKSB7XG4gICAgICAgIHByaW50KFwiLFwiKTtcbiAgICAgICAgc3BhY2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xvbigpIHtcbiAgICAgICAgcHJpbnQoXCI6XCIpO1xuICAgICAgICBzcGFjZSgpO1xuICAgIH1cblxuICAgIHZhciBhZGRfbWFwcGluZyA9IG1hcHBpbmdzID8gZnVuY3Rpb24odG9rZW4sIG5hbWUpIHtcbiAgICAgICAgbWFwcGluZ190b2tlbiA9IHRva2VuO1xuICAgICAgICBtYXBwaW5nX25hbWUgPSBuYW1lO1xuICAgIH0gOiBub29wO1xuXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAobWlnaHRfYWRkX25ld2xpbmUpIHtcbiAgICAgICAgICAgIGVuc3VyZV9saW5lX2xlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPVVRQVVQudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJfY29tbWVudChjb21tZW50KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5wcmVzZXJ2ZV9hbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZShyX2Fubm90YXRpb24sIFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL15cXHMqJC8udGVzdChjb21tZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1lbnQucmVwbGFjZSgvKDxcXHMqXFwvXFxzKikoc2NyaXB0KS9pLCBcIjxcXFxcLyQyXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBlbmRfY29tbWVudHMobm9kZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdGFydCA9IG5vZGUuc3RhcnQ7XG4gICAgICAgIGlmICghc3RhcnQpIHJldHVybjtcbiAgICAgICAgdmFyIHByaW50ZWRfY29tbWVudHMgPSBzZWxmLnByaW50ZWRfY29tbWVudHM7XG5cbiAgICAgICAgLy8gVGhlcmUgY2Fubm90IGJlIGEgbmV3bGluZSBiZXR3ZWVuIHJldHVybi95aWVsZCBhbmQgaXRzIHZhbHVlLlxuICAgICAgICBjb25zdCBrZXl3b3JkX3dpdGhfdmFsdWUgPSBcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfRXhpdCAmJiBub2RlLnZhbHVlXG4gICAgICAgICAgICB8fCAobm9kZSBpbnN0YW5jZW9mIEFTVF9Bd2FpdCB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1lpZWxkKVxuICAgICAgICAgICAgICAgICYmIG5vZGUuZXhwcmVzc2lvbjtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdGFydC5jb21tZW50c19iZWZvcmVcbiAgICAgICAgICAgICYmIHByaW50ZWRfY29tbWVudHMuaGFzKHN0YXJ0LmNvbW1lbnRzX2JlZm9yZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoa2V5d29yZF93aXRoX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQuY29tbWVudHNfYmVmb3JlID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21tZW50cyA9IHN0YXJ0LmNvbW1lbnRzX2JlZm9yZTtcbiAgICAgICAgaWYgKCFjb21tZW50cykge1xuICAgICAgICAgICAgY29tbWVudHMgPSBzdGFydC5jb21tZW50c19iZWZvcmUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBwcmludGVkX2NvbW1lbnRzLmFkZChjb21tZW50cyk7XG5cbiAgICAgICAgaWYgKGtleXdvcmRfd2l0aF92YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0dy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX0V4aXRcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0F3YWl0XG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9ZaWVsZFxuICAgICAgICAgICAgICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIHBhcmVudC5sZWZ0ID09PSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudC5UWVBFID09IFwiQ2FsbFwiICYmIHBhcmVudC5leHByZXNzaW9uID09PSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAmJiBwYXJlbnQuY29uZGl0aW9uID09PSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Eb3QgJiYgcGFyZW50LmV4cHJlc3Npb24gPT09IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlICYmIHBhcmVudC5leHByZXNzaW9uc1swXSA9PT0gbm9kZVxuICAgICAgICAgICAgICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfU3ViICYmIHBhcmVudC5leHByZXNzaW9uID09PSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9VbmFyeVBvc3RmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnN0YXJ0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbm9kZS5zdGFydC5jb21tZW50c19iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0ICYmICFwcmludGVkX2NvbW1lbnRzLmhhcyh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRlZF9jb21tZW50cy5hZGQodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHcucHVzaChub2RlKTtcbiAgICAgICAgICAgIGtleXdvcmRfd2l0aF92YWx1ZS53YWxrKHR3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50X3BvcyA9PSAwKSB7XG4gICAgICAgICAgICBpZiAoY29tbWVudHMubGVuZ3RoID4gMCAmJiBvcHRpb25zLnNoZWJhbmcgJiYgY29tbWVudHNbMF0udHlwZSA9PT0gXCJjb21tZW50NVwiXG4gICAgICAgICAgICAgICAgJiYgIXByaW50ZWRfY29tbWVudHMuaGFzKGNvbW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHByaW50KFwiIyFcIiArIGNvbW1lbnRzLnNoaWZ0KCkudmFsdWUgKyBcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmVhbWJsZSA9IG9wdGlvbnMucHJlYW1ibGU7XG4gICAgICAgICAgICBpZiAocHJlYW1ibGUpIHtcbiAgICAgICAgICAgICAgICBwcmludChwcmVhbWJsZS5yZXBsYWNlKC9cXHJcXG4/fFtcXG5cXHUyMDI4XFx1MjAyOV18XFxzKiQvZywgXCJcXG5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5maWx0ZXIoY29tbWVudF9maWx0ZXIsIG5vZGUpLmZpbHRlcihjID0+ICFwcmludGVkX2NvbW1lbnRzLmhhcyhjKSk7XG4gICAgICAgIGlmIChjb21tZW50cy5sZW5ndGggPT0gMCkgcmV0dXJuO1xuICAgICAgICB2YXIgbGFzdF9ubGIgPSBPVVRQVVQuaGFzTkxCKCk7XG4gICAgICAgIGNvbW1lbnRzLmZvckVhY2goZnVuY3Rpb24oYywgaSkge1xuICAgICAgICAgICAgcHJpbnRlZF9jb21tZW50cy5hZGQoYyk7XG4gICAgICAgICAgICBpZiAoIWxhc3RfbmxiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMubmxiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9ubGIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgvY29tbWVudFsxMzRdLy50ZXN0KGMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmaWx0ZXJfY29tbWVudChjLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQoXCIvL1wiICsgdmFsdWUgKyBcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RfbmxiID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09IFwiY29tbWVudDJcIikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZpbHRlcl9jb21tZW50KGMudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmludChcIi8qXCIgKyB2YWx1ZSArIFwiKi9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RfbmxiID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWxhc3RfbmxiKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQubmxiKSB7XG4gICAgICAgICAgICAgICAgcHJpbnQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgaW5kZW50KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBlbmRfY29tbWVudHMobm9kZSwgdGFpbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB0b2tlbiA9IG5vZGUuZW5kO1xuICAgICAgICBpZiAoIXRva2VuKSByZXR1cm47XG4gICAgICAgIHZhciBwcmludGVkX2NvbW1lbnRzID0gc2VsZi5wcmludGVkX2NvbW1lbnRzO1xuICAgICAgICB2YXIgY29tbWVudHMgPSB0b2tlblt0YWlsID8gXCJjb21tZW50c19iZWZvcmVcIiA6IFwiY29tbWVudHNfYWZ0ZXJcIl07XG4gICAgICAgIGlmICghY29tbWVudHMgfHwgcHJpbnRlZF9jb21tZW50cy5oYXMoY29tbWVudHMpKSByZXR1cm47XG4gICAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50IHx8IGNvbW1lbnRzLmV2ZXJ5KChjKSA9PlxuICAgICAgICAgICAgIS9jb21tZW50WzEzNF0vLnRlc3QoYy50eXBlKVxuICAgICAgICApKSkgcmV0dXJuO1xuICAgICAgICBwcmludGVkX2NvbW1lbnRzLmFkZChjb21tZW50cyk7XG4gICAgICAgIHZhciBpbnNlcnQgPSBPVVRQVVQubGVuZ3RoKCk7XG4gICAgICAgIGNvbW1lbnRzLmZpbHRlcihjb21tZW50X2ZpbHRlciwgbm9kZSkuZm9yRWFjaChmdW5jdGlvbihjLCBpKSB7XG4gICAgICAgICAgICBpZiAocHJpbnRlZF9jb21tZW50cy5oYXMoYykpIHJldHVybjtcbiAgICAgICAgICAgIHByaW50ZWRfY29tbWVudHMuYWRkKGMpO1xuICAgICAgICAgICAgbmVlZF9zcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5lZWRfbmV3bGluZV9pbmRlbnRlZCkge1xuICAgICAgICAgICAgICAgIHByaW50KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgICAgIG5lZWRfbmV3bGluZV9pbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjLm5sYiAmJiAoaSA+IDAgfHwgIU9VVFBVVC5oYXNOTEIoKSkpIHtcbiAgICAgICAgICAgICAgICBwcmludChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDAgfHwgIXRhaWwpIHtcbiAgICAgICAgICAgICAgICBzcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9jb21tZW50WzEzNF0vLnRlc3QoYy50eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmlsdGVyX2NvbW1lbnQoYy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50KFwiLy9cIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmVlZF9uZXdsaW5lX2luZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09IFwiY29tbWVudDJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmlsdGVyX2NvbW1lbnQoYy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50KFwiLypcIiArIHZhbHVlICsgXCIqL1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmVlZF9zcGFjZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoT1VUUFVULmxlbmd0aCgpID4gaW5zZXJ0KSBuZXdsaW5lX2luc2VydCA9IGluc2VydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIG91dHB1dC5vcHRpb24oXCJfZGVzdHJveV9hc3RcIikgaXMgZW5hYmxlZCwgZGVzdHJveSB0aGUgZnVuY3Rpb24uXG4gICAgICogQ2FsbCB0aGlzIGFmdGVyIHByaW50aW5nIGl0LlxuICAgICAqL1xuICAgIGNvbnN0IGdjX3Njb3BlID1cbiAgICAgIG9wdGlvbnNbXCJfZGVzdHJveV9hc3RcIl1cbiAgICAgICAgPyBmdW5jdGlvbiBnY19zY29wZShzY29wZSkge1xuICAgICAgICAgICAgc2NvcGUuYm9keS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgc2NvcGUuYXJnbmFtZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICA6IG5vb3A7XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgICAgICAgICAgICAgOiBnZXQsXG4gICAgICAgIHRvU3RyaW5nICAgICAgICA6IGdldCxcbiAgICAgICAgaW5kZW50ICAgICAgICAgIDogaW5kZW50LFxuICAgICAgICBpbl9kaXJlY3RpdmUgICAgOiBmYWxzZSxcbiAgICAgICAgdXNlX2FzbSAgICAgICAgIDogbnVsbCxcbiAgICAgICAgYWN0aXZlX3Njb3BlICAgIDogbnVsbCxcbiAgICAgICAgaW5kZW50YXRpb24gICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBpbmRlbnRhdGlvbjsgfSxcbiAgICAgICAgY3VycmVudF93aWR0aCAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50X2NvbCAtIGluZGVudGF0aW9uOyB9LFxuICAgICAgICBzaG91bGRfYnJlYWsgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIG9wdGlvbnMud2lkdGggJiYgdGhpcy5jdXJyZW50X3dpZHRoKCkgPj0gb3B0aW9ucy53aWR0aDsgfSxcbiAgICAgICAgaGFzX3BhcmVucyAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBoYXNfcGFyZW5zOyB9LFxuICAgICAgICBuZXdsaW5lICAgICAgICAgOiBuZXdsaW5lLFxuICAgICAgICBwcmludCAgICAgICAgICAgOiBwcmludCxcbiAgICAgICAgc3RhciAgICAgICAgICAgIDogc3RhcixcbiAgICAgICAgc3BhY2UgICAgICAgICAgIDogc3BhY2UsXG4gICAgICAgIGNvbW1hICAgICAgICAgICA6IGNvbW1hLFxuICAgICAgICBjb2xvbiAgICAgICAgICAgOiBjb2xvbixcbiAgICAgICAgbGFzdCAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBsYXN0OyB9LFxuICAgICAgICBzZW1pY29sb24gICAgICAgOiBzZW1pY29sb24sXG4gICAgICAgIGZvcmNlX3NlbWljb2xvbiA6IGZvcmNlX3NlbWljb2xvbixcbiAgICAgICAgdG9fdXRmOCAgICAgICAgIDogdG9fdXRmOCxcbiAgICAgICAgcHJpbnRfbmFtZSAgICAgIDogZnVuY3Rpb24obmFtZSkgeyBwcmludChtYWtlX25hbWUobmFtZSkpOyB9LFxuICAgICAgICBwcmludF9zdHJpbmcgICAgOiBmdW5jdGlvbihzdHIsIHF1b3RlLCBlc2NhcGVfZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB2YXIgZW5jb2RlZCA9IGVuY29kZV9zdHJpbmcoc3RyLCBxdW90ZSk7XG4gICAgICAgICAgICBpZiAoZXNjYXBlX2RpcmVjdGl2ZSA9PT0gdHJ1ZSAmJiAhZW5jb2RlZC5pbmNsdWRlcyhcIlxcXFxcIikpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgc2VtaWNvbG9ucyB0byBicmVhayBkaXJlY3RpdmUgcHJvbG9ndWVcbiAgICAgICAgICAgICAgICBpZiAoIU9VVFBVVC5leHBlY3REaXJlY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZV9zZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yY2Vfc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmludChlbmNvZGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJpbnRfdGVtcGxhdGVfc3RyaW5nX2NoYXJzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciBlbmNvZGVkID0gZW5jb2RlX3N0cmluZyhzdHIsIFwiYFwiKS5yZXBsYWNlKC9cXCR7L2csIFwiXFxcXCR7XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHByaW50KGVuY29kZWQuc3Vic3RyKDEsIGVuY29kZWQubGVuZ3RoIC0gMikpO1xuICAgICAgICB9LFxuICAgICAgICBlbmNvZGVfc3RyaW5nICAgOiBlbmNvZGVfc3RyaW5nLFxuICAgICAgICBuZXh0X2luZGVudCAgICAgOiBuZXh0X2luZGVudCxcbiAgICAgICAgd2l0aF9pbmRlbnQgICAgIDogd2l0aF9pbmRlbnQsXG4gICAgICAgIHdpdGhfYmxvY2sgICAgICA6IHdpdGhfYmxvY2ssXG4gICAgICAgIHdpdGhfcGFyZW5zICAgICA6IHdpdGhfcGFyZW5zLFxuICAgICAgICB3aXRoX3NxdWFyZSAgICAgOiB3aXRoX3NxdWFyZSxcbiAgICAgICAgYWRkX21hcHBpbmcgICAgIDogYWRkX21hcHBpbmcsXG4gICAgICAgIG9wdGlvbiAgICAgICAgICA6IGZ1bmN0aW9uKG9wdCkgeyByZXR1cm4gb3B0aW9uc1tvcHRdOyB9LFxuICAgICAgICBnY19zY29wZSxcbiAgICAgICAgcHJpbnRlZF9jb21tZW50czogcHJpbnRlZF9jb21tZW50cyxcbiAgICAgICAgcHJlcGVuZF9jb21tZW50czogcmVhZG9ubHkgPyBub29wIDogcHJlcGVuZF9jb21tZW50cyxcbiAgICAgICAgYXBwZW5kX2NvbW1lbnRzIDogcmVhZG9ubHkgfHwgY29tbWVudF9maWx0ZXIgPT09IHJldHVybl9mYWxzZSA/IG5vb3AgOiBhcHBlbmRfY29tbWVudHMsXG4gICAgICAgIGxpbmUgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VycmVudF9saW5lOyB9LFxuICAgICAgICBjb2wgICAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRfY29sOyB9LFxuICAgICAgICBwb3MgICAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRfcG9zOyB9LFxuICAgICAgICBwdXNoX25vZGUgICAgICAgOiBmdW5jdGlvbihub2RlKSB7IHN0YWNrLnB1c2gobm9kZSk7IH0sXG4gICAgICAgIHBvcF9ub2RlICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhY2sucG9wKCk7IH0sXG4gICAgICAgIHBhcmVudCAgICAgICAgICA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAyIC0gKG4gfHwgMCldO1xuICAgICAgICB9XG4gICAgfTtcblxufVxuXG4vKiAtLS0tLVsgY29kZSBnZW5lcmF0b3JzIF0tLS0tLSAqL1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKiAtLS0tLVsgdXRpbHMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBERUZQUklOVChub2RldHlwZSwgZ2VuZXJhdG9yKSB7XG4gICAgICAgIG5vZGV0eXBlLkRFRk1FVEhPRChcIl9jb2RlZ2VuXCIsIGdlbmVyYXRvcik7XG4gICAgfVxuXG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwicHJpbnRcIiwgZnVuY3Rpb24ob3V0cHV0LCBmb3JjZV9wYXJlbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBnZW5lcmF0b3IgPSBzZWxmLl9jb2RlZ2VuO1xuICAgICAgICBpZiAoc2VsZiBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgb3V0cHV0LmFjdGl2ZV9zY29wZSA9IHNlbGY7XG4gICAgICAgIH0gZWxzZSBpZiAoIW91dHB1dC51c2VfYXNtICYmIHNlbGYgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlICYmIHNlbGYudmFsdWUgPT0gXCJ1c2UgYXNtXCIpIHtcbiAgICAgICAgICAgIG91dHB1dC51c2VfYXNtID0gb3V0cHV0LmFjdGl2ZV9zY29wZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkb2l0KCkge1xuICAgICAgICAgICAgb3V0cHV0LnByZXBlbmRfY29tbWVudHMoc2VsZik7XG4gICAgICAgICAgICBzZWxmLmFkZF9zb3VyY2VfbWFwKG91dHB1dCk7XG4gICAgICAgICAgICBnZW5lcmF0b3Ioc2VsZiwgb3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5hcHBlbmRfY29tbWVudHMoc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2hfbm9kZShzZWxmKTtcbiAgICAgICAgaWYgKGZvcmNlX3BhcmVucyB8fCBzZWxmLm5lZWRzX3BhcmVucyhvdXRwdXQpKSB7XG4gICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZG9pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2l0KCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnBvcF9ub2RlKCk7XG4gICAgICAgIGlmIChzZWxmID09PSBvdXRwdXQudXNlX2FzbSkge1xuICAgICAgICAgICAgb3V0cHV0LnVzZV9hc20gPSBudWxsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwiX3ByaW50XCIsIEFTVF9Ob2RlLnByb3RvdHlwZS5wcmludCk7XG5cbiAgICBBU1RfTm9kZS5ERUZNRVRIT0QoXCJwcmludF90b19zdHJpbmdcIiwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gT3V0cHV0U3RyZWFtKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByaW50KG91dHB1dCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQuZ2V0KCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgUEFSRU5USEVTRVMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBQQVJFTlMobm9kZXR5cGUsIGZ1bmMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXR5cGUpKSB7XG4gICAgICAgICAgICBub2RldHlwZS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGV0eXBlKSB7XG4gICAgICAgICAgICAgICAgUEFSRU5TKG5vZGV0eXBlLCBmdW5jKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZXR5cGUuREVGTUVUSE9EKFwibmVlZHNfcGFyZW5zXCIsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgUEFSRU5TKEFTVF9Ob2RlLCByZXR1cm5fZmFsc2UpO1xuXG4gICAgLy8gYSBmdW5jdGlvbiBleHByZXNzaW9uIG5lZWRzIHBhcmVucyBhcm91bmQgaXQgd2hlbiBpdCdzIHByb3ZhYmx5XG4gICAgLy8gdGhlIGZpcnN0IHRva2VuIHRvIGFwcGVhciBpbiBhIHN0YXRlbWVudC5cbiAgICBQQVJFTlMoQVNUX0Z1bmN0aW9uLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgaWYgKCFvdXRwdXQuaGFzX3BhcmVucygpICYmIGZpcnN0X2luX3N0YXRlbWVudChvdXRwdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwid2Via2l0XCIpKSB7XG4gICAgICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcIndyYXBfaWlmZVwiKSkge1xuICAgICAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJ3cmFwX2Z1bmNfYXJnc1wiKSkge1xuICAgICAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuYXJncy5pbmNsdWRlcyh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9BcnJvdywgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG91dHB1dC5vcHRpb24oXCJ3cmFwX2Z1bmNfYXJnc1wiKVxuICAgICAgICAgICAgJiYgcCBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAmJiBwLmFyZ3MuaW5jbHVkZXModGhpcylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpc1xuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAmJiBwLmNvbmRpdGlvbiA9PT0gdGhpcztcbiAgICB9KTtcblxuICAgIC8vIHNhbWUgZ29lcyBmb3IgYW4gb2JqZWN0IGxpdGVyYWwgKGFzIGluIEFTVF9GdW5jdGlvbiksIGJlY2F1c2VcbiAgICAvLyBvdGhlcndpc2Ugey4uLn0gd291bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBibG9jayBvZiBjb2RlLlxuICAgIFBBUkVOUyhBU1RfT2JqZWN0LCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgcmV0dXJuICFvdXRwdXQuaGFzX3BhcmVucygpICYmIGZpcnN0X2luX3N0YXRlbWVudChvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9DbGFzc0V4cHJlc3Npb24sIGZpcnN0X2luX3N0YXRlbWVudCk7XG5cbiAgICBQQVJFTlMoQVNUX1VuYXJ5LCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIHJldHVybiBwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgcC5leHByZXNzaW9uID09PSB0aGlzXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICYmIHAub3BlcmF0b3IgPT09IFwiKipcIlxuICAgICAgICAgICAgICAgICYmIHRoaXMgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICAgICAmJiBwLmxlZnQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wZXJhdG9yICE9PSBcIisrXCJcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wZXJhdG9yICE9PSBcIi0tXCI7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX0F3YWl0LCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIHJldHVybiBwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgcC5leHByZXNzaW9uID09PSB0aGlzXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiBwLm9wZXJhdG9yID09PSBcIioqXCIgJiYgcC5sZWZ0ID09PSB0aGlzXG4gICAgICAgICAgICB8fCBvdXRwdXQub3B0aW9uKFwic2FmYXJpMTBcIikgJiYgcCBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeDtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfU2VxdWVuY2UsIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgcmV0dXJuIHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGZvbywgYmFyKSgpIG9yIGZvbygxLCAoMiwgMyksIDQpXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX1VuYXJ5ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICEoZm9vLCBiYXIsIGJheilcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSArICgyLCAzKSArIDQgPT0+IDhcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfVmFyRGVmTGlrZSAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGEgPSAoMSwgMiksIGIgPSBhICsgYTsgPT0+IGIgPT0gNFxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICAgICAgICAgICAgICAgICAgICAvLyAoMSwge2ZvbzoyfSkuZm9vIG9yICgxLCB7Zm9vOjJ9KVtcImZvb1wiXSA9PT4gMlxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9BcnJheSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbIDEsICgyLCAzKSwgNCBdID09PiBbIDEsIDMsIDQgXVxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9PYmplY3RQcm9wZXJ0eSAgICAgICAgICAgICAgICAvLyB7IGZvbzogKDEsIDIpIH0uZm9vID09PiAyXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICAgICAgICAgICAgICAgICAgIC8qIChmYWxzZSwgdHJ1ZSkgPyAoYSA9IDEwLCBiID0gMjApIDogKGMgPSAzMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogPT0+IDIwIChzaWRlIGVmZmVjdCwgc2V0IGEgOj0gMTAgYW5kIGIgOj0gMjApICovXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0Fycm93ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHggPT4gKHgsIHgpXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0RlZmF1bHRBc3NpZ24gICAgICAgICAgICAgICAgIC8vIHggPT4gKHggPSAoMCwgZnVuY3Rpb24oKXt9KSlcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uICAgICAgICAgICAgICAgICAgICAgLy8gWy4uLihhLCBiKV1cbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfRm9yT2YgJiYgdGhpcyA9PT0gcC5vYmplY3QgICAgLy8gZm9yIChlIG9mIChmb28sIGJhcikpIHt9XG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX1lpZWxkICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHlpZWxkIChmb28sIGJhcilcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfRXhwb3J0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgKGZvbywgYmFyKVxuICAgICAgICA7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX0JpbmFyeSwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAvLyAoZm9vICYmIGJhcikoKVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyB0eXBlb2YgKGZvbyAmJiBiYXIpXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1VuYXJ5KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIChmb28gJiYgYmFyKVtcInByb3BcIl0sIChmb28gJiYgYmFyKS5wcm9wXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIHRoaXMgZGVhbHMgd2l0aCBwcmVjZWRlbmNlOiAzICogKDIgKyAxKVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudF9vcCA9IHAub3BlcmF0b3I7XG4gICAgICAgICAgICBjb25zdCBvcCA9IHRoaXMub3BlcmF0b3I7XG5cbiAgICAgICAgICAgIC8vIEl0IGlzIGZvcmJpZGRlbiBmb3IgPz8gdG8gYmUgdXNlZCB3aXRoIHx8IG9yICYmIHdpdGhvdXQgcGFyZW5zLlxuICAgICAgICAgICAgaWYgKG9wID09PSBcIj8/XCIgJiYgKHBhcmVudF9vcCA9PT0gXCJ8fFwiIHx8IHBhcmVudF9vcCA9PT0gXCImJlwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudF9vcCA9PT0gXCI/P1wiICYmIChvcCA9PT0gXCJ8fFwiIHx8IG9wID09PSBcIiYmXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBwID0gUFJFQ0VERU5DRVtwYXJlbnRfb3BdO1xuICAgICAgICAgICAgY29uc3Qgc3AgPSBQUkVDRURFTkNFW29wXTtcbiAgICAgICAgICAgIGlmIChwcCA+IHNwXG4gICAgICAgICAgICAgICAgfHwgKHBwID09IHNwXG4gICAgICAgICAgICAgICAgICAgICYmICh0aGlzID09PSBwLnJpZ2h0IHx8IHBhcmVudF9vcCA9PSBcIioqXCIpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1ByaXZhdGVJbikge1xuICAgICAgICAgICAgY29uc3Qgb3AgPSB0aGlzLm9wZXJhdG9yO1xuXG4gICAgICAgICAgICBjb25zdCBwcCA9IFBSRUNFREVOQ0VbXCJpblwiXTtcbiAgICAgICAgICAgIGNvbnN0IHNwID0gUFJFQ0VERU5DRVtvcF07XG4gICAgICAgICAgICBpZiAocHAgPiBzcCB8fCAocHAgPT0gc3AgJiYgdGhpcyA9PT0gcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9Qcml2YXRlSW4sIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgLy8gKCN4IGluIHRoaXMpKClcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHR5cGVvZiAoI3ggaW4gdGhpcylcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfVW5hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vICgjeCBpbiB0aGlzKVtcInByb3BcIl0sICgjeCBpbiB0aGlzKS5wcm9wXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzYW1lIHByZWNlZGVuY2UgYXMgcmVndWxhciBpbiBvcGVyYXRvclxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudF9vcCA9IHAub3BlcmF0b3I7XG5cbiAgICAgICAgICAgIGNvbnN0IHBwID0gUFJFQ0VERU5DRVtwYXJlbnRfb3BdO1xuICAgICAgICAgICAgY29uc3Qgc3AgPSBQUkVDRURFTkNFW1wiaW5cIl07XG4gICAgICAgICAgICBpZiAocHAgPiBzcFxuICAgICAgICAgICAgICAgIHx8IChwcCA9PSBzcFxuICAgICAgICAgICAgICAgICAgICAmJiAodGhpcyA9PT0gcC5yaWdodCB8fCBwYXJlbnRfb3AgPT0gXCIqKlwiKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBydWxlcyBhcmUgdGhlIHNhbWUgYXMgYmluYXJ5IGluLCBidXQgdGhlIGNsYXNzIGRpZmZlcnNcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfUHJpdmF0ZUluICYmIHRoaXMgPT09IHAudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX1lpZWxkLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIC8vICh5aWVsZCAxKSArICh5aWVsZCAyKVxuICAgICAgICAvLyBhID0geWllbGQgM1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgcC5vcGVyYXRvciAhPT0gXCI9XCIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKHlpZWxkIDEpKClcbiAgICAgICAgLy8gbmV3ICh5aWVsZCAxKSgpXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vICh5aWVsZCAxKSA/IHlpZWxkIDIgOiB5aWVsZCAzXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICYmIHAuY29uZGl0aW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIC0oeWllbGQgNClcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfVW5hcnkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKHlpZWxkIHgpLmZvb1xuICAgICAgICAvLyAoeWllbGQgeClbJ2ZvbyddXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX0NoYWluLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCB8fCBwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBwLmV4cHJlc3Npb24gPT09IHRoaXM7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX1Byb3BBY2Nlc3MsIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfTmV3ICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcykge1xuICAgICAgICAgICAgLy8gaS5lLiBuZXcgKGZvby5iYXIoKS5iYXopXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBvbmUgY2FsbCBpbnRvIHRoaXMgc3VidHJlZSwgdGhlbiB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBwYXJlbnMgYXJvdW5kIGl0IHRvbywgb3RoZXJ3aXNlIHRoZSBjYWxsIHdpbGwgYmVcbiAgICAgICAgICAgIC8vIGludGVycHJldGVkIGFzIHBhc3NpbmcgdGhlIGFyZ3VtZW50cyB0byB0aGUgdXBwZXIgTmV3XG4gICAgICAgICAgICAvLyBleHByZXNzaW9uLlxuICAgICAgICAgICAgcmV0dXJuIHdhbGsodGhpcywgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGtfYWJvcnQ7ICAvLyBtYWtlcyB3YWxrKCkgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfQ2FsbCwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpLCBwMTtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfTmV3ICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpc1xuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9FeHBvcnQgJiYgcC5pc19kZWZhdWx0ICYmIHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIHdvcmthcm91bmQgZm9yIFNhZmFyaSBidWcuXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjM1MDZcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvblxuICAgICAgICAgICAgJiYgcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzXG4gICAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXNcbiAgICAgICAgICAgICYmIChwMSA9IG91dHB1dC5wYXJlbnQoMSkpIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgJiYgcDEubGVmdCA9PT0gcDtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfTmV3LCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIGlmICh0aGlzLmFyZ3MubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAmJiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIC8vIChuZXcgRGF0ZSkuZ2V0VGltZSgpLCAobmV3IERhdGUpW1wiZ2V0VGltZVwiXSgpXG4gICAgICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpc1xuICAgICAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZyAmJiBwLnByZWZpeCA9PT0gdGhpcykpIC8vIChuZXcgZm9vKShiYXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfTnVtYmVyLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwIHx8IC9eMC8udGVzdChtYWtlX251bSh2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfQmlnSW50LCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcC5leHByZXNzaW9uID09PSB0aGlzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChcIi1cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgUEFSRU5TKFsgQVNUX0Fzc2lnbiwgQVNUX0NvbmRpdGlvbmFsIF0sIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgLy8gIShhID0gZmFsc2UpIOKGkiB0cnVlXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1VuYXJ5KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIDEgKyAoYSA9IDIpICsgMyDihpIgNiwgc2lkZSBlZmZlY3Qgc2V0dGluZyBhID0gMlxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgIShwIGluc3RhbmNlb2YgQVNUX0Fzc2lnbikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKGEgPSBmdW5jKSgpIOKAlG9y4oCUIG5ldyAoYSA9IE9iamVjdCkoKVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAoYSA9IGZvbykgPyBiYXIgOiBiYXpcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwgJiYgcC5jb25kaXRpb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKGEgPSBmb28pW1wicHJvcFwiXSDigJRvcuKAlCAoYSA9IGZvbykucHJvcFxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAoe2EsIGJ9ID0ge2E6IDEsIGI6IDJ9KSwgYSBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnRcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBBU1RfQXNzaWduICYmIHRoaXMubGVmdCBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nICYmIHRoaXMubGVmdC5pc19hcnJheSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBQUklOVEVSUyBdLS0tLS0gKi9cblxuICAgIERFRlBSSU5UKEFTVF9EaXJlY3RpdmUsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKHNlbGYudmFsdWUsIHNlbGYucXVvdGUpO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG5cbiAgICBERUZQUklOVChBU1RfRXhwYW5zaW9uLCBmdW5jdGlvbiAoc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcIi4uLlwiKTtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICBERUZQUklOVChBU1RfRGVzdHJ1Y3R1cmluZywgZnVuY3Rpb24gKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoc2VsZi5pc19hcnJheSA/IFwiW1wiIDogXCJ7XCIpO1xuICAgICAgICB2YXIgbGVuID0gc2VsZi5uYW1lcy5sZW5ndGg7XG4gICAgICAgIHNlbGYubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgaSkge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgIG5hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaW5hbCBlbGVtZW50IGlzIGEgaG9sZSwgd2UgbmVlZCB0byBtYWtlIHN1cmUgaXRcbiAgICAgICAgICAgIC8vIGRvZXNuJ3QgbG9vayBsaWtlIGEgdHJhaWxpbmcgY29tbWEsIGJ5IGluc2VydGluZyBhbiBhY3R1YWxcbiAgICAgICAgICAgIC8vIHRyYWlsaW5nIGNvbW1hLlxuICAgICAgICAgICAgaWYgKGkgPT0gbGVuIC0gMSAmJiBuYW1lIGluc3RhbmNlb2YgQVNUX0hvbGUpIG91dHB1dC5jb21tYSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnByaW50KHNlbGYuaXNfYXJyYXkgPyBcIl1cIiA6IFwifVwiKTtcbiAgICB9KTtcblxuICAgIERFRlBSSU5UKEFTVF9EZWJ1Z2dlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcImRlYnVnZ2VyXCIpO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgc3RhdGVtZW50cyBdLS0tLS0gKi9cblxuICAgIGZ1bmN0aW9uIGRpc3BsYXlfYm9keShib2R5LCBpc190b3BsZXZlbCwgb3V0cHV0LCBhbGxvd19kaXJlY3RpdmVzKSB7XG4gICAgICAgIHZhciBsYXN0ID0gYm9keS5sZW5ndGggLSAxO1xuICAgICAgICBvdXRwdXQuaW5fZGlyZWN0aXZlID0gYWxsb3dfZGlyZWN0aXZlcztcbiAgICAgICAgYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0bXQsIGkpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQuaW5fZGlyZWN0aXZlID09PSB0cnVlICYmICEoc3RtdCBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUgfHxcbiAgICAgICAgICAgICAgICBzdG10IGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50IHx8XG4gICAgICAgICAgICAgICAgKHN0bXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50ICYmIHN0bXQuYm9keSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluX2RpcmVjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoc3RtdCBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgc3RtdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIGlmICghKGkgPT0gbGFzdCAmJiBpc190b3BsZXZlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX3RvcGxldmVsKSBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRwdXQuaW5fZGlyZWN0aXZlID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgc3RtdCBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQgJiZcbiAgICAgICAgICAgICAgICBzdG10LmJvZHkgaW5zdGFuY2VvZiBBU1RfU3RyaW5nXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5fZGlyZWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuaW5fZGlyZWN0aXZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgQVNUX1N0YXRlbWVudFdpdGhCb2R5LkRFRk1FVEhPRChcIl9kb19wcmludF9ib2R5XCIsIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICBwcmludF9tYXliZV9icmFjZWRfYm9keSh0aGlzLmJvZHksIG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICBERUZQUklOVChBU1RfU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5ib2R5LnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVG9wbGV2ZWwsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBkaXNwbGF5X2JvZHkoc2VsZi5ib2R5LCB0cnVlLCBvdXRwdXQsIHRydWUpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLmxhYmVsLnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5jb2xvbigpO1xuICAgICAgICBzZWxmLmJvZHkucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5ib2R5LnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBwcmludF9icmFjZWRfZW1wdHkoc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcIntcIik7XG4gICAgICAgIG91dHB1dC53aXRoX2luZGVudChvdXRwdXQubmV4dF9pbmRlbnQoKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBvdXRwdXQuYXBwZW5kX2NvbW1lbnRzKHNlbGYsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LmFkZF9tYXBwaW5nKHNlbGYuZW5kKTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwifVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJpbnRfYnJhY2VkKHNlbGYsIG91dHB1dCwgYWxsb3dfZGlyZWN0aXZlcykge1xuICAgICAgICBpZiAoc2VsZi5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlfYm9keShzZWxmLmJvZHksIGZhbHNlLCBvdXRwdXQsIGFsbG93X2RpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5hZGRfbWFwcGluZyhzZWxmLmVuZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHByaW50X2JyYWNlZF9lbXB0eShzZWxmLCBvdXRwdXQpO1xuICAgIH1cbiAgICBERUZQUklOVChBU1RfQmxvY2tTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBwcmludF9icmFjZWQoc2VsZiwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRW1wdHlTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0RvLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZG9cIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBtYWtlX2Jsb2NrKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC5wcmludChcIndoaWxlXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfV2hpbGUsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ3aGlsZVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Gb3IsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJmb3JcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pbml0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5pdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9uc0xpa2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbml0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50aGVzaXplX2Zvcl9ub2luKHNlbGYuaW5pdCwgb3V0cHV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiO1wiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiO1wiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBzZWxmLnN0ZXAucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0ZvckluLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZm9yXCIpO1xuICAgICAgICBpZiAoc2VsZi5hd2FpdCkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJhd2FpdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5pbml0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChzZWxmIGluc3RhbmNlb2YgQVNUX0Zvck9mID8gXCJvZlwiIDogXCJpblwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5vYmplY3QucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1dpdGgsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ3aXRoXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGZ1bmN0aW9ucyBdLS0tLS0gKi9cbiAgICBBU1RfTGFtYmRhLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIG5va2V5d29yZCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghbm9rZXl3b3JkKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hc3luYykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcImFzeW5jXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZnVuY3Rpb25cIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc19nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3RhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYubmFtZSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSB7XG4gICAgICAgICAgICBzZWxmLm5hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2tleXdvcmQgJiYgc2VsZi5uYW1lIGluc3RhbmNlb2YgQVNUX05vZGUpIHtcbiAgICAgICAgICAgIG91dHB1dC53aXRoX3NxdWFyZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm5hbWUucHJpbnQob3V0cHV0KTsgLy8gQ29tcHV0ZWQgbWV0aG9kIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuYXJnbmFtZXMuZm9yRWFjaChmdW5jdGlvbihhcmcsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgYXJnLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFjZWQoc2VsZiwgb3V0cHV0LCB0cnVlKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTGFtYmRhLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LmdjX3Njb3BlKHNlbGYpO1xuICAgIH0pO1xuXG4gICAgREVGUFJJTlQoQVNUX1ByZWZpeGVkVGVtcGxhdGVTdHJpbmcsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICB2YXIgdGFnID0gc2VsZi5wcmVmaXg7XG4gICAgICAgIHZhciBwYXJlbnRoZXNpemVfdGFnID0gdGFnIGluc3RhbmNlb2YgQVNUX0xhbWJkYVxuICAgICAgICAgICAgfHwgdGFnIGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgfHwgdGFnIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsXG4gICAgICAgICAgICB8fCB0YWcgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2VcbiAgICAgICAgICAgIHx8IHRhZyBpbnN0YW5jZW9mIEFTVF9VbmFyeVxuICAgICAgICAgICAgfHwgdGFnIGluc3RhbmNlb2YgQVNUX0RvdCAmJiB0YWcuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9PYmplY3Q7XG4gICAgICAgIGlmIChwYXJlbnRoZXNpemVfdGFnKSBvdXRwdXQucHJpbnQoXCIoXCIpO1xuICAgICAgICBzZWxmLnByZWZpeC5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAocGFyZW50aGVzaXplX3RhZykgb3V0cHV0LnByaW50KFwiKVwiKTtcbiAgICAgICAgc2VsZi50ZW1wbGF0ZV9zdHJpbmcucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVGVtcGxhdGVTdHJpbmcsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICB2YXIgaXNfdGFnZ2VkID0gb3V0cHV0LnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX1ByZWZpeGVkVGVtcGxhdGVTdHJpbmc7XG5cbiAgICAgICAgb3V0cHV0LnByaW50KFwiYFwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIShzZWxmLnNlZ21lbnRzW2ldIGluc3RhbmNlb2YgQVNUX1RlbXBsYXRlU2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIke1wiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlZ21lbnRzW2ldLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwifVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNfdGFnZ2VkKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KHNlbGYuc2VnbWVudHNbaV0ucmF3KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50X3RlbXBsYXRlX3N0cmluZ19jaGFycyhzZWxmLnNlZ21lbnRzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucHJpbnQoXCJgXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9UZW1wbGF0ZVNlZ21lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnRfdGVtcGxhdGVfc3RyaW5nX2NoYXJzKHNlbGYudmFsdWUpO1xuICAgIH0pO1xuXG4gICAgQVNUX0Fycm93LkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGFyZW50ID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICB2YXIgbmVlZHNfcGFyZW5zID0gKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiZcbiAgICAgICAgICAgICAgICAhKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pICYmXG4gICAgICAgICAgICAgICAgIShwYXJlbnQgaW5zdGFuY2VvZiBBU1RfRGVmYXVsdEFzc2lnbikpIHx8XG4gICAgICAgICAgICBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfVW5hcnkgfHxcbiAgICAgICAgICAgIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBzZWxmID09PSBwYXJlbnQuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChuZWVkc19wYXJlbnMpIHsgb3V0cHV0LnByaW50KFwiKFwiKTsgfVxuICAgICAgICBpZiAoc2VsZi5hc3luYykge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiYXN5bmNcIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5hcmduYW1lcy5sZW5ndGggPT09IDEgJiYgc2VsZi5hcmduYW1lc1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2wpIHtcbiAgICAgICAgICAgIHNlbGYuYXJnbmFtZXNbMF0ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFyZ25hbWVzLmZvckVhY2goZnVuY3Rpb24oYXJnLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgYXJnLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiPT5cIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBjb25zdCBmaXJzdF9zdGF0ZW1lbnQgPSBzZWxmLmJvZHlbMF07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNlbGYuYm9keS5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICYmIGZpcnN0X3N0YXRlbWVudCBpbnN0YW5jZW9mIEFTVF9SZXR1cm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCByZXR1cm5lZCA9IGZpcnN0X3N0YXRlbWVudC52YWx1ZTtcbiAgICAgICAgICAgIGlmICghcmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdF9pc19vYmplY3QocmV0dXJuZWQpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiKFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm5lZC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIilcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybmVkLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmludF9icmFjZWQoc2VsZiwgb3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZHNfcGFyZW5zKSB7IG91dHB1dC5wcmludChcIilcIik7IH1cbiAgICAgICAgb3V0cHV0LmdjX3Njb3BlKHNlbGYpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGV4aXRzIF0tLS0tLSAqL1xuICAgIEFTVF9FeGl0LkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIGtpbmQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KGtpbmQpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50cyA9IHRoaXMudmFsdWUuc3RhcnQuY29tbWVudHNfYmVmb3JlO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnRzICYmIGNvbW1lbnRzLmxlbmd0aCAmJiAhb3V0cHV0LnByaW50ZWRfY29tbWVudHMuaGFzKGNvbW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIihcIik7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIilcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1JldHVybiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJyZXR1cm5cIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1Rocm93LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInRocm93XCIpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIHlpZWxkIF0tLS0tLSAqL1xuXG4gICAgREVGUFJJTlQoQVNUX1lpZWxkLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIHN0YXIgPSBzZWxmLmlzX3N0YXIgPyBcIipcIiA6IFwiXCI7XG4gICAgICAgIG91dHB1dC5wcmludChcInlpZWxkXCIgKyBzdGFyKTtcbiAgICAgICAgaWYgKHNlbGYuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgREVGUFJJTlQoQVNUX0F3YWl0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiYXdhaXRcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB2YXIgZSA9IHNlbGYuZXhwcmVzc2lvbjtcbiAgICAgICAgdmFyIHBhcmVucyA9ICEoXG4gICAgICAgICAgICAgICBlIGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICB8fCBlIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3NcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfVW5hcnlcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfQXdhaXRcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0XG4gICAgICAgICk7XG4gICAgICAgIGlmIChwYXJlbnMpIG91dHB1dC5wcmludChcIihcIik7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAocGFyZW5zKSBvdXRwdXQucHJpbnQoXCIpXCIpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGxvb3AgY29udHJvbCBdLS0tLS0gKi9cbiAgICBBU1RfTG9vcENvbnRyb2wuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwga2luZCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoa2luZCk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHRoaXMubGFiZWwucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0JyZWFrLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcImJyZWFrXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Db250aW51ZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJjb250aW51ZVwiKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBpZiBdLS0tLS0gKi9cbiAgICBmdW5jdGlvbiBtYWtlX3RoZW4oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBiID0gc2VsZi5ib2R5O1xuICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImJyYWNlc1wiKVxuICAgICAgICAgICAgfHwgb3V0cHV0Lm9wdGlvbihcImllOFwiKSAmJiBiIGluc3RhbmNlb2YgQVNUX0RvKVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VfYmxvY2soYiwgb3V0cHV0KTtcbiAgICAgICAgLy8gVGhlIHNxdWVlemVyIHJlcGxhY2VzIFwiYmxvY2tcIi1zIHRoYXQgY29udGFpbiBvbmx5IGEgc2luZ2xlXG4gICAgICAgIC8vIHN0YXRlbWVudCB3aXRoIHRoZSBzdGF0ZW1lbnQgaXRzZWxmOyB0ZWNobmljYWxseSwgdGhlIEFTVFxuICAgICAgICAvLyBpcyBjb3JyZWN0LCBidXQgdGhpcyBjYW4gY3JlYXRlIHByb2JsZW1zIHdoZW4gd2Ugb3V0cHV0IGFuXG4gICAgICAgIC8vIElGIGhhdmluZyBhbiBFTFNFIGNsYXVzZSB3aGVyZSB0aGUgVEhFTiBjbGF1c2UgZW5kcyBpbiBhblxuICAgICAgICAvLyBJRiAqd2l0aG91dCogYW4gRUxTRSBibG9jayAodGhlbiB0aGUgb3V0ZXIgRUxTRSB3b3VsZCByZWZlclxuICAgICAgICAvLyB0byB0aGUgaW5uZXIgSUYpLiAgVGhpcyBmdW5jdGlvbiBjaGVja3MgZm9yIHRoaXMgY2FzZSBhbmRcbiAgICAgICAgLy8gYWRkcyB0aGUgYmxvY2sgYnJhY2VzIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKCFiKSByZXR1cm4gb3V0cHV0LmZvcmNlX3NlbWljb2xvbigpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWIuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9ibG9jayhzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IGIuYWx0ZXJuYXRpdmU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50V2l0aEJvZHkpIHtcbiAgICAgICAgICAgICAgICBiID0gYi5ib2R5O1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByaW50X21heWJlX2JyYWNlZF9ib2R5KHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9XG4gICAgREVGUFJJTlQoQVNUX0lmLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiaWZcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmNvbmRpdGlvbi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICBtYWtlX3RoZW4oc2VsZiwgb3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZWxzZVwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfSWYpXG4gICAgICAgICAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHByaW50X21heWJlX2JyYWNlZF9ib2R5KHNlbGYuYWx0ZXJuYXRpdmUsIG91dHB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBzd2l0Y2ggXS0tLS0tICovXG4gICAgREVGUFJJTlQoQVNUX1N3aXRjaCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcInN3aXRjaFwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHZhciBsYXN0ID0gc2VsZi5ib2R5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCkgcHJpbnRfYnJhY2VkX2VtcHR5KHNlbGYsIG91dHB1dCk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmJvZHkuZm9yRWFjaChmdW5jdGlvbihicmFuY2gsIGkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KHRydWUpO1xuICAgICAgICAgICAgICAgIGJyYW5jaC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgbGFzdCAmJiBicmFuY2guYm9keS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIEFTVF9Td2l0Y2hCcmFuY2guREVGTUVUSE9EKFwiX2RvX3ByaW50X2JvZHlcIiwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgIHRoaXMuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0bXQpIHtcbiAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9EZWZhdWx0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZGVmYXVsdDpcIik7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2FzZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcImNhc2VcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiOlwiKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGV4Y2VwdGlvbnMgXS0tLS0tICovXG4gICAgREVGUFJJTlQoQVNUX1RyeSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcInRyeVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAoc2VsZi5iY2F0Y2gpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5iY2F0Y2gucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5iZmluYWxseSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLmJmaW5hbGx5LnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVHJ5QmxvY2ssIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBwcmludF9icmFjZWQoc2VsZiwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2F0Y2gsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJjYXRjaFwiKTtcbiAgICAgICAgaWYgKHNlbGYuYXJnbmFtZSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hcmduYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgcHJpbnRfYnJhY2VkKHNlbGYsIG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0ZpbmFsbHksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJmaW5hbGx5XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgcHJpbnRfYnJhY2VkKHNlbGYsIG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgdmFyL2NvbnN0IF0tLS0tLSAqL1xuICAgIEFTVF9EZWZpbml0aW9uc0xpa2UuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwga2luZCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoa2luZCk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmLCBpKSB7XG4gICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICBkZWYucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICB2YXIgaW5fZm9yID0gcCBpbnN0YW5jZW9mIEFTVF9Gb3IgfHwgcCBpbnN0YW5jZW9mIEFTVF9Gb3JJbjtcbiAgICAgICAgdmFyIG91dHB1dF9zZW1pY29sb24gPSAhaW5fZm9yIHx8IHAgJiYgcC5pbml0ICE9PSB0aGlzO1xuICAgICAgICBpZiAob3V0cHV0X3NlbWljb2xvbilcbiAgICAgICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTGV0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcImxldFwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVmFyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInZhclwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ29uc3QsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwiY29uc3RcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1VzaW5nLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBzZWxmLmF3YWl0ID8gXCJhd2FpdCB1c2luZ1wiIDogXCJ1c2luZ1wiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfSW1wb3J0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiaW1wb3J0XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgaWYgKHNlbGYuaW1wb3J0ZWRfbmFtZSkge1xuICAgICAgICAgICAgc2VsZi5pbXBvcnRlZF9uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuaW1wb3J0ZWRfbmFtZSAmJiBzZWxmLmltcG9ydGVkX25hbWVzKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIsXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuaW1wb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmltcG9ydGVkX25hbWVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIHNlbGYuaW1wb3J0ZWRfbmFtZXNbMF0uZm9yZWlnbl9uYW1lLm5hbWUgPT09IFwiKlwiICYmXG4gICAgICAgICAgICAgICAgIXNlbGYuaW1wb3J0ZWRfbmFtZXNbMF0uZm9yZWlnbl9uYW1lLnF1b3RlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbXBvcnRlZF9uYW1lc1swXS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW1wb3J0ZWRfbmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZV9pbXBvcnQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVfaW1wb3J0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgc2VsZi5pbXBvcnRlZF9uYW1lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwifVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5pbXBvcnRlZF9uYW1lIHx8IHNlbGYuaW1wb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZnJvbVwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYubW9kdWxlX25hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwid2l0aFwiKTtcbiAgICAgICAgICAgIHNlbGYuYXR0cmlidXRlcy5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfSW1wb3J0TWV0YSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcImltcG9ydC5tZXRhXCIpO1xuICAgIH0pO1xuXG4gICAgREVGUFJJTlQoQVNUX05hbWVNYXBwaW5nLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGlzX2ltcG9ydCA9IG91dHB1dC5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9JbXBvcnQ7XG4gICAgICAgIHZhciBkZWZpbml0aW9uID0gc2VsZi5uYW1lLmRlZmluaXRpb24oKTtcbiAgICAgICAgdmFyIGZvcmVpZ25fbmFtZSA9IHNlbGYuZm9yZWlnbl9uYW1lO1xuICAgICAgICB2YXIgbmFtZXNfYXJlX2RpZmZlcmVudCA9XG4gICAgICAgICAgICAoZGVmaW5pdGlvbiAmJiBkZWZpbml0aW9uLm1hbmdsZWRfbmFtZSB8fCBzZWxmLm5hbWUubmFtZSkgIT09XG4gICAgICAgICAgICBmb3JlaWduX25hbWUubmFtZTtcbiAgICAgICAgaWYgKCFuYW1lc19hcmVfZGlmZmVyZW50ICYmXG4gICAgICAgICAgICBmb3JlaWduX25hbWUubmFtZSA9PT0gXCIqXCIgJiZcbiAgICAgICAgICAgICEhZm9yZWlnbl9uYW1lLnF1b3RlICE9ICEhc2VsZi5uYW1lLnF1b3RlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwb3J0ICogYXMgXCIqXCJcbiAgICAgICAgICAgIG5hbWVzX2FyZV9kaWZmZXJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JlaWduX25hbWVfaXNfbmFtZSA9ICFmb3JlaWduX25hbWUucXVvdGU7XG4gICAgICAgIGlmIChuYW1lc19hcmVfZGlmZmVyZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNfaW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmVpZ25fbmFtZV9pc19uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChmb3JlaWduX25hbWUubmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50X3N0cmluZyhmb3JlaWduX25hbWUubmFtZSwgZm9yZWlnbl9uYW1lLnF1b3RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5uYW1lLnF1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoc2VsZi5uYW1lLm5hbWUsIHNlbGYubmFtZS5xdW90ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJhc1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgaWYgKGlzX2ltcG9ydCkge1xuICAgICAgICAgICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yZWlnbl9uYW1lX2lzX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KGZvcmVpZ25fbmFtZS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKGZvcmVpZ25fbmFtZS5uYW1lLCBmb3JlaWduX25hbWUucXVvdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5uYW1lLnF1b3RlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoc2VsZi5uYW1lLm5hbWUsIHNlbGYubmFtZS5xdW90ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIERFRlBSSU5UKEFTVF9FeHBvcnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJleHBvcnRcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBpZiAoc2VsZi5pc19kZWZhdWx0KSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJkZWZhdWx0XCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuZXhwb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmV4cG9ydGVkX25hbWVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIHNlbGYuZXhwb3J0ZWRfbmFtZXNbMF0ubmFtZS5uYW1lID09PSBcIipcIiAmJlxuICAgICAgICAgICAgICAgICFzZWxmLmV4cG9ydGVkX25hbWVzWzBdLm5hbWUucXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5leHBvcnRlZF9uYW1lc1swXS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuZXhwb3J0ZWRfbmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lX2V4cG9ydCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZV9leHBvcnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBzZWxmLmV4cG9ydGVkX25hbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuZXhwb3J0ZWRfdmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGYuZXhwb3J0ZWRfdmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmV4cG9ydGVkX2RlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHNlbGYuZXhwb3J0ZWRfZGVmaW5pdGlvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuZXhwb3J0ZWRfZGVmaW5pdGlvbiBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm1vZHVsZV9uYW1lKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImZyb21cIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHNlbGYubW9kdWxlX25hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ3aXRoXCIpO1xuICAgICAgICAgICAgc2VsZi5hdHRyaWJ1dGVzLnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuZXhwb3J0ZWRfdmFsdWVcbiAgICAgICAgICAgICAgICAmJiAhKHNlbGYuZXhwb3J0ZWRfdmFsdWUgaW5zdGFuY2VvZiBBU1RfRGVmdW4gfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5leHBvcnRlZF92YWx1ZSBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmV4cG9ydGVkX3ZhbHVlIGluc3RhbmNlb2YgQVNUX0NsYXNzKVxuICAgICAgICAgICAgfHwgc2VsZi5tb2R1bGVfbmFtZVxuICAgICAgICAgICAgfHwgc2VsZi5leHBvcnRlZF9uYW1lc1xuICAgICAgICApIHtcbiAgICAgICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcGFyZW50aGVzaXplX2Zvcl9ub2luKG5vZGUsIG91dHB1dCwgbm9pbikge1xuICAgICAgICB2YXIgcGFyZW5zID0gZmFsc2U7XG4gICAgICAgIC8vIG5lZWQgdG8gdGFrZSBzb21lIHByZWNhdXRpb25zIGhlcmU6XG4gICAgICAgIC8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2lzc3Vlcy82MFxuICAgICAgICBpZiAobm9pbikge1xuICAgICAgICAgICAgcGFyZW5zID0gd2Fsayhub2RlLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBnbyBpbnRvIHNjb3BlcyAtLSBleGNlcHQgYXJyb3cgZnVuY3Rpb25zOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZXJzZXIvdGVyc2VyL2lzc3Vlcy8xMDE5I2lzc3VlY29tbWVudC04Nzc2NDI2MDdcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXJyb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIG5vZGUub3BlcmF0b3IgPT0gXCJpblwiXG4gICAgICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfUHJpdmF0ZUluXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxrX2Fib3J0OyAgLy8gbWFrZXMgd2FsaygpIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wcmludChvdXRwdXQsIHBhcmVucyk7XG4gICAgfVxuXG4gICAgREVGUFJJTlQoQVNUX1ZhckRlZkxpa2UsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLm5hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKHNlbGYudmFsdWUpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiPVwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KDEpO1xuICAgICAgICAgICAgdmFyIG5vaW4gPSBwIGluc3RhbmNlb2YgQVNUX0ZvciB8fCBwIGluc3RhbmNlb2YgQVNUX0ZvckluO1xuICAgICAgICAgICAgcGFyZW50aGVzaXplX2Zvcl9ub2luKHNlbGYudmFsdWUsIG91dHB1dCwgbm9pbik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBvdGhlciBleHByZXNzaW9ucyBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfQ2FsbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAoc2VsZiBpbnN0YW5jZW9mIEFTVF9OZXcgJiYgc2VsZi5hcmdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHNlbGYuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9DYWxsIHx8IHNlbGYuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHtcbiAgICAgICAgICAgIG91dHB1dC5hZGRfbWFwcGluZyhzZWxmLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5vcHRpb25hbCkgb3V0cHV0LnByaW50KFwiPy5cIik7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGV4cHIsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgZXhwci5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9OZXcsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJuZXdcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBBU1RfQ2FsbC5wcm90b3R5cGUuX2NvZGVnZW4oc2VsZiwgb3V0cHV0KTtcbiAgICB9KTtcblxuICAgIEFTVF9TZXF1ZW5jZS5ERUZNRVRIT0QoXCJfZG9fcHJpbnRcIiwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbihub2RlLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuc2hvdWxkX2JyZWFrKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1NlcXVlbmNlLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0KTtcbiAgICAgICAgLy8gdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIC8vIGlmIChwIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudCkge1xuICAgICAgICAvLyAgICAgb3V0cHV0LndpdGhfaW5kZW50KG91dHB1dC5uZXh0X2luZGVudCgpLCBmdW5jdGlvbigpe1xuICAgICAgICAvLyAgICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCk7XG4gICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCk7XG4gICAgICAgIC8vIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRG90LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgIGV4cHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnR5O1xuICAgICAgICB2YXIgcHJpbnRfY29tcHV0ZWQgPSBBTExfUkVTRVJWRURfV09SRFMuaGFzKHByb3ApXG4gICAgICAgICAgICA/IG91dHB1dC5vcHRpb24oXCJpZThcIilcbiAgICAgICAgICAgIDogIWlzX2lkZW50aWZpZXJfc3RyaW5nKFxuICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgb3V0cHV0Lm9wdGlvbihcImVjbWFcIikgPj0gMjAxNSAmJiAhb3V0cHV0Lm9wdGlvbihcInNhZmFyaTEwXCIpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbmFsKSBvdXRwdXQucHJpbnQoXCI/LlwiKTtcblxuICAgICAgICBpZiAocHJpbnRfY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIltcIik7XG4gICAgICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcoc2VsZi5lbmQpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50X3N0cmluZyhwcm9wKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIl1cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9OdW1iZXIgJiYgZXhwci5nZXRWYWx1ZSgpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9beGEtZi4pXS9pLnRlc3Qob3V0cHV0Lmxhc3QoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYub3B0aW9uYWwpIG91dHB1dC5wcmludChcIi5cIik7XG4gICAgICAgICAgICAvLyB0aGUgbmFtZSBhZnRlciBkb3Qgd291bGQgYmUgbWFwcGVkIGFib3V0IGhlcmUuXG4gICAgICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcoc2VsZi5lbmQpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50X25hbWUocHJvcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRG90SGFzaCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBleHByID0gc2VsZi5leHByZXNzaW9uO1xuICAgICAgICBleHByLnByaW50KG91dHB1dCk7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0eTtcblxuICAgICAgICBpZiAoc2VsZi5vcHRpb25hbCkgb3V0cHV0LnByaW50KFwiP1wiKTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiLiNcIik7XG4gICAgICAgIG91dHB1dC5hZGRfbWFwcGluZyhzZWxmLmVuZCk7XG4gICAgICAgIG91dHB1dC5wcmludF9uYW1lKHByb3ApO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TdWIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKHNlbGYub3B0aW9uYWwpIG91dHB1dC5wcmludChcIj8uXCIpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJbXCIpO1xuICAgICAgICBzZWxmLnByb3BlcnR5LnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5wcmludChcIl1cIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NoYWluLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIG9wID0gc2VsZi5vcGVyYXRvcjtcbiAgICAgICAgaWYgKG9wID09PSBcIi0tXCIgJiYgb3V0cHV0Lmxhc3QoKS5lbmRzV2l0aChcIiFcIikpIHtcbiAgICAgICAgICAgIC8vIGF2b2lkIHByaW50aW5nIFwiPCEtLVwiXG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wcmludChvcCk7XG4gICAgICAgIGlmICgvXlthLXpdL2kudGVzdChvcClcbiAgICAgICAgICAgIHx8ICgvWystXSQvLnRlc3Qob3ApXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAgICAgJiYgL15bKy1dLy50ZXN0KHNlbGYuZXhwcmVzc2lvbi5vcGVyYXRvcikpKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVW5hcnlQb3N0Zml4LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5wcmludChzZWxmLm9wZXJhdG9yKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQmluYXJ5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIG9wID0gc2VsZi5vcGVyYXRvcjtcbiAgICAgICAgc2VsZi5sZWZ0LnByaW50KG91dHB1dCk7XG4gICAgICAgIGlmIChvcFswXSA9PSBcIj5cIiAvKiBcIj4+XCIgXCI+Pj5cIiBcIj5cIiBcIj49XCIgKi9cbiAgICAgICAgICAgICYmIG91dHB1dC5sYXN0KCkuZW5kc1dpdGgoXCItLVwiKSkge1xuICAgICAgICAgICAgLy8gc3BhY2UgaXMgbWFuZGF0b3J5IHRvIGF2b2lkIG91dHB1dHRpbmcgLS0+XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIgXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlIHNwYWNlIGlzIG9wdGlvbmFsIGRlcGVuZGluZyBvbiBcImJlYXV0aWZ5XCJcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wcmludChvcCk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLnJpZ2h0LnByaW50KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC5wcmludChcIj9cIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLmNvbnNlcXVlbnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC5jb2xvbigpO1xuICAgICAgICBzZWxmLmFsdGVybmF0aXZlLnByaW50KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgbGl0ZXJhbHMgXS0tLS0tICovXG4gICAgREVGUFJJTlQoQVNUX0FycmF5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LndpdGhfc3F1YXJlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBzZWxmLmVsZW1lbnRzLCBsZW4gPSBhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPiAwKSBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbihleHAsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgZXhwLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpbmFsIGVsZW1lbnQgaXMgYSBob2xlLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBpdFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbG9vayBsaWtlIGEgdHJhaWxpbmcgY29tbWEsIGJ5IGluc2VydGluZyBhbiBhY3R1YWxcbiAgICAgICAgICAgICAgICAvLyB0cmFpbGluZyBjb21tYS5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuIC0gMSAmJiBleHAgaW5zdGFuY2VvZiBBU1RfSG9sZSlcbiAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobGVuID4gMCkgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9PYmplY3QsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aCA+IDApIG91dHB1dC53aXRoX2Jsb2NrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBwcm9wLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbHNlIHByaW50X2JyYWNlZF9lbXB0eShzZWxmLCBvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9DbGFzcywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcImNsYXNzXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgaWYgKHNlbGYubmFtZSkge1xuICAgICAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5leHRlbmRzKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW5zID0gKFxuICAgICAgICAgICAgICAgICAgICEoc2VsZi5leHRlbmRzIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZilcbiAgICAgICAgICAgICAgICAmJiAhKHNlbGYuZXh0ZW5kcyBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzKVxuICAgICAgICAgICAgICAgICYmICEoc2VsZi5leHRlbmRzIGluc3RhbmNlb2YgQVNUX0NsYXNzRXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICAmJiAhKHNlbGYuZXh0ZW5kcyBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJleHRlbmRzXCIpO1xuICAgICAgICAgICAgaWYgKHBhcmVucykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIihcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5leHRlbmRzLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBpZiAocGFyZW5zKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiKVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYucHJvcGVydGllcy5sZW5ndGggPiAwKSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3AsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgcHJvcC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTmV3VGFyZ2V0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwibmV3LnRhcmdldFwiKTtcbiAgICB9KTtcblxuICAgIC8qKiBQcmludHMgYSBwcm9wIG5hbWUuIFJldHVybnMgd2hldGhlciBpdCBjYW4gYmUgdXNlZCBhcyBhIHNob3J0aGFuZC4gKi9cbiAgICBmdW5jdGlvbiBwcmludF9wcm9wZXJ0eV9uYW1lKGtleSwgcXVvdGUsIG91dHB1dCkge1xuICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcInF1b3RlX2tleXNcIikpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJcIiArICtrZXkgPT0ga2V5ICYmIGtleSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImtlZXBfbnVtYmVyc1wiKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dC5wcmludChtYWtlX251bShrZXkpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJpbnRfc3RyaW5nID0gQUxMX1JFU0VSVkVEX1dPUkRTLmhhcyhrZXkpXG4gICAgICAgICAgICA/IG91dHB1dC5vcHRpb24oXCJpZThcIilcbiAgICAgICAgICAgIDogKFxuICAgICAgICAgICAgICAgIG91dHB1dC5vcHRpb24oXCJlY21hXCIpIDwgMjAxNSB8fCBvdXRwdXQub3B0aW9uKFwic2FmYXJpMTBcIilcbiAgICAgICAgICAgICAgICAgICAgPyAhaXNfYmFzaWNfaWRlbnRpZmllcl9zdHJpbmcoa2V5KVxuICAgICAgICAgICAgICAgICAgICA6ICFpc19pZGVudGlmaWVyX3N0cmluZyhrZXksIHRydWUpXG4gICAgICAgICAgICApO1xuICAgICAgICBpZiAocHJpbnRfc3RyaW5nIHx8IChxdW90ZSAmJiBvdXRwdXQub3B0aW9uKFwia2VlcF9xdW90ZWRfcHJvcHNcIikpKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKGtleSwgcXVvdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wcmludF9uYW1lKGtleSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIERFRlBSSU5UKEFTVF9PYmplY3RLZXlWYWwsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBmdW5jdGlvbiBnZXRfbmFtZShzZWxmKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gc2VsZi5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmID8gZGVmLm1hbmdsZWRfbmFtZSB8fCBkZWYubmFtZSA6IHNlbGYubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRyeV9zaG9ydGhhbmQgPSBvdXRwdXQub3B0aW9uKFwic2hvcnRoYW5kXCIpICYmICEoc2VsZi5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRyeV9zaG9ydGhhbmRcbiAgICAgICAgICAgICYmIHNlbGYudmFsdWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sXG4gICAgICAgICAgICAmJiBnZXRfbmFtZShzZWxmLnZhbHVlKSA9PT0gc2VsZi5rZXlcbiAgICAgICAgICAgICYmICFBTExfUkVTRVJWRURfV09SRFMuaGFzKHNlbGYua2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHdhc19zaG9ydGhhbmQgPSBwcmludF9wcm9wZXJ0eV9uYW1lKHNlbGYua2V5LCBzZWxmLnF1b3RlLCBvdXRwdXQpO1xuICAgICAgICAgICAgaWYgKCF3YXNfc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgICAgICAgICAgc2VsZi52YWx1ZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHJ5X3Nob3J0aGFuZFxuICAgICAgICAgICAgJiYgc2VsZi52YWx1ZSBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0QXNzaWduXG4gICAgICAgICAgICAmJiBzZWxmLnZhbHVlLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sXG4gICAgICAgICAgICAmJiBnZXRfbmFtZShzZWxmLnZhbHVlLmxlZnQpID09PSBzZWxmLmtleVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHdhc19zaG9ydGhhbmQgPSBwcmludF9wcm9wZXJ0eV9uYW1lKHNlbGYua2V5LCBzZWxmLnF1b3RlLCBvdXRwdXQpO1xuICAgICAgICAgICAgaWYgKCF3YXNfc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgICAgICAgICAgc2VsZi52YWx1ZS5sZWZ0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIj1cIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHNlbGYudmFsdWUucmlnaHQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKHNlbGYua2V5IGluc3RhbmNlb2YgQVNUX05vZGUpKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfcHJvcGVydHlfbmFtZShzZWxmLmtleSwgc2VsZi5xdW90ZSwgb3V0cHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LndpdGhfc3F1YXJlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmtleS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgICAgICBzZWxmLnZhbHVlLnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2xhc3NQcml2YXRlUHJvcGVydHksIChzZWxmLCBvdXRwdXQpID0+IHtcbiAgICAgICAgaWYgKHNlbGYuc3RhdGljKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJzdGF0aWNcIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wcmludChcIiNcIik7XG4gICAgICAgIFxuICAgICAgICBwcmludF9wcm9wZXJ0eV9uYW1lKHNlbGYua2V5Lm5hbWUsIHVuZGVmaW5lZCwgb3V0cHV0KTtcblxuICAgICAgICBpZiAoc2VsZi52YWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiPVwiKTtcbiAgICAgICAgICAgIHNlbGYudmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2xhc3NQcm9wZXJ0eSwgKHNlbGYsIG91dHB1dCkgPT4ge1xuICAgICAgICBpZiAoc2VsZi5zdGF0aWMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcInN0YXRpY1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYua2V5IGluc3RhbmNlb2YgQVNUX1N5bWJvbENsYXNzUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHByaW50X3Byb3BlcnR5X25hbWUoc2VsZi5rZXkubmFtZSwgc2VsZi5xdW90ZSwgb3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIltcIik7XG4gICAgICAgICAgICBzZWxmLmtleS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiXVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnZhbHVlKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI9XCIpO1xuICAgICAgICAgICAgc2VsZi52YWx1ZS5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIEFTVF9PYmplY3RQcm9wZXJ0eS5ERUZNRVRIT0QoXCJfcHJpbnRfZ2V0dGVyX3NldHRlclwiLCBmdW5jdGlvbih0eXBlLCBpc19wcml2YXRlLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5zdGF0aWMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcInN0YXRpY1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQodHlwZSk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5rZXkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAoaXNfcHJpdmF0ZSkgb3V0cHV0LnByaW50KFwiI1wiKTtcbiAgICAgICAgICAgIHByaW50X3Byb3BlcnR5X25hbWUoc2VsZi5rZXkubmFtZSwgc2VsZi5xdW90ZSwgb3V0cHV0KTtcbiAgICAgICAgICAgIHNlbGYua2V5LmFkZF9zb3VyY2VfbWFwKG91dHB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQud2l0aF9zcXVhcmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5rZXkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYudmFsdWUuX2RvX3ByaW50KG91dHB1dCwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX09iamVjdFNldHRlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX3ByaW50X2dldHRlcl9zZXR0ZXIoXCJzZXRcIiwgZmFsc2UsIG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX09iamVjdEdldHRlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX3ByaW50X2dldHRlcl9zZXR0ZXIoXCJnZXRcIiwgZmFsc2UsIG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1ByaXZhdGVTZXR0ZXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLl9wcmludF9nZXR0ZXJfc2V0dGVyKFwic2V0XCIsIHRydWUsIG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1ByaXZhdGVHZXR0ZXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLl9wcmludF9nZXR0ZXJfc2V0dGVyKFwiZ2V0XCIsIHRydWUsIG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NvbmNpc2VNZXRob2QsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgaWYgKHNlbGYudmFsdWUuaXNfZ2VuZXJhdG9yICYmIHNlbGYudmFsdWUuYXN5bmMpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcImFzeW5jKlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYudmFsdWUuaXNfZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICB0eXBlID0gXCIqXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi52YWx1ZS5hc3luYykge1xuICAgICAgICAgICAgdHlwZSA9IFwiYXN5bmNcIjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9wcmludF9nZXR0ZXJfc2V0dGVyKHR5cGUsIGZhbHNlLCBvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Qcml2YXRlTWV0aG9kLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIGlmIChzZWxmLnZhbHVlLmlzX2dlbmVyYXRvciAmJiBzZWxmLnZhbHVlLmFzeW5jKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJhc3luYypcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLnZhbHVlLmlzX2dlbmVyYXRvcikge1xuICAgICAgICAgICAgdHlwZSA9IFwiKlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYudmFsdWUuYXN5bmMpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcImFzeW5jXCI7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fcHJpbnRfZ2V0dGVyX3NldHRlcih0eXBlLCB0cnVlLCBvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Qcml2YXRlSW4sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLmtleS5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiaW5cIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLnZhbHVlLnByaW50KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N5bWJvbFByaXZhdGVQcm9wZXJ0eSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcIiNcIiArIHNlbGYubmFtZSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NsYXNzU3RhdGljQmxvY2ssIGZ1bmN0aW9uIChzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwic3RhdGljXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgcHJpbnRfYnJhY2VkKHNlbGYsIG91dHB1dCk7XG4gICAgfSk7XG4gICAgQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJfZG9fcHJpbnRcIiwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBkZWYgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICAgICAgb3V0cHV0LnByaW50X25hbWUoZGVmID8gZGVmLm1hbmdsZWRfbmFtZSB8fCBkZWYubmFtZSA6IHRoaXMubmFtZSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N5bWJvbCwgZnVuY3Rpb24gKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Ib2xlLCBub29wKTtcbiAgICBERUZQUklOVChBU1RfVGhpcywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcInRoaXNcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N1cGVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwic3VwZXJcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NvbnN0YW50LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N0cmluZywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoc2VsZi5nZXRWYWx1ZSgpLCBzZWxmLnF1b3RlLCBvdXRwdXQuaW5fZGlyZWN0aXZlKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTnVtYmVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKChvdXRwdXQub3B0aW9uKFwia2VlcF9udW1iZXJzXCIpIHx8IG91dHB1dC51c2VfYXNtKSAmJiBzZWxmLnJhdykge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KHNlbGYucmF3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChtYWtlX251bShzZWxmLmdldFZhbHVlKCkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9CaWdJbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImtlZXBfbnVtYmVyc1wiKSAmJiBzZWxmLnJhdykge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KHNlbGYucmF3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChzZWxmLmdldFZhbHVlKCkgKyBcIm5cIik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHJfc2xhc2hfc2NyaXB0ID0gLyg8XFxzKlxcL1xccypzY3JpcHQpL2k7XG4gICAgY29uc3Qgcl9zdGFydHNfd2l0aF9zY3JpcHQgPSAvXlxccypzY3JpcHQvaTtcbiAgICBjb25zdCBzbGFzaF9zY3JpcHRfcmVwbGFjZSA9IChfLCAkMSkgPT4gJDEucmVwbGFjZShcIi9cIiwgXCJcXFxcL1wiKTtcbiAgICBERUZQUklOVChBU1RfUmVnRXhwLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgbGV0IHsgc291cmNlLCBmbGFncyB9ID0gc2VsZi5nZXRWYWx1ZSgpO1xuICAgICAgICBzb3VyY2UgPSByZWdleHBfc291cmNlX2ZpeChzb3VyY2UpO1xuICAgICAgICBmbGFncyA9IGZsYWdzID8gc29ydF9yZWdleHBfZmxhZ3MoZmxhZ3MpIDogXCJcIjtcblxuICAgICAgICAvLyBBdm9pZCBvdXRwdXR0aW5nIGVuZCBvZiBzY3JpcHQgdGFnXG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKHJfc2xhc2hfc2NyaXB0LCBzbGFzaF9zY3JpcHRfcmVwbGFjZSk7XG4gICAgICAgIGlmIChyX3N0YXJ0c193aXRoX3NjcmlwdC50ZXN0KHNvdXJjZSkgJiYgb3V0cHV0Lmxhc3QoKS5lbmRzV2l0aChcIjxcIikpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIiBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQucHJpbnQob3V0cHV0LnRvX3V0ZjgoYC8ke3NvdXJjZX0vJHtmbGFnc31gLCBmYWxzZSwgdHJ1ZSkpO1xuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGFyZW50IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgL15cXHcvLnRlc3QocGFyZW50Lm9wZXJhdG9yKVxuICAgICAgICAgICAgJiYgcGFyZW50LmxlZnQgPT09IHNlbGZcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIgXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKiogaWYsIGZvciwgd2hpbGUsIG1heSBvciBtYXkgbm90IGhhdmUgYnJhY2VzIHN1cnJvdW5kaW5nIGl0cyBib2R5ICovXG4gICAgZnVuY3Rpb24gcHJpbnRfbWF5YmVfYnJhY2VkX2JvZHkoc3RhdCwgb3V0cHV0KSB7XG4gICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwiYnJhY2VzXCIpKSB7XG4gICAgICAgICAgICBtYWtlX2Jsb2NrKHN0YXQsIG91dHB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXN0YXQgfHwgc3RhdCBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudClcbiAgICAgICAgICAgICAgICBvdXRwdXQuZm9yY2Vfc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICBlbHNlIGlmICgoc3RhdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9uc0xpa2UgJiYgIShzdGF0IGluc3RhbmNlb2YgQVNUX1ZhcikpIHx8IHN0YXQgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpXG4gICAgICAgICAgICAgICAgbWFrZV9ibG9jayhzdGF0LCBvdXRwdXQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHN0YXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJlc3Rfb2YoYSkge1xuICAgICAgICB2YXIgYmVzdCA9IGFbMF0sIGxlbiA9IGJlc3QubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChhW2ldLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBhW2ldO1xuICAgICAgICAgICAgICAgIGxlbiA9IGJlc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VfbnVtKG51bSkge1xuICAgICAgICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDEwKS5yZXBsYWNlKC9eMFxcLi8sIFwiLlwiKS5yZXBsYWNlKFwiZStcIiwgXCJlXCIpO1xuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IFsgc3RyIF07XG4gICAgICAgIGlmIChNYXRoLmZsb29yKG51bSkgPT09IG51bSkge1xuICAgICAgICAgICAgaWYgKG51bSA8IDApIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goXCItMHhcIiArICgtbnVtKS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChcIjB4XCIgKyBudW0udG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCwgbGVuLCBkaWdpdHM7XG4gICAgICAgIGlmIChtYXRjaCA9IC9eXFwuMCsvLmV4ZWMoc3RyKSkge1xuICAgICAgICAgICAgbGVuID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZGlnaXRzID0gc3RyLnNsaWNlKGxlbik7XG4gICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goZGlnaXRzICsgXCJlLVwiICsgKGRpZ2l0cy5sZW5ndGggKyBsZW4gLSAxKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSAvMCskLy5leGVjKHN0cikpIHtcbiAgICAgICAgICAgIGxlbiA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChzdHIuc2xpY2UoMCwgLWxlbikgKyBcImVcIiArIGxlbik7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSAvXihcXGQpXFwuKFxcZCspZSgtP1xcZCspJC8uZXhlYyhzdHIpKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2gobWF0Y2hbMV0gKyBtYXRjaFsyXSArIFwiZVwiICsgKG1hdGNoWzNdIC0gbWF0Y2hbMl0ubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3Rfb2YoY2FuZGlkYXRlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZV9ibG9jayhzdG10LCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKCFzdG10IHx8IHN0bXQgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpXG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICAgICAgZWxzZSBpZiAoc3RtdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudClcbiAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgZWxzZSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIC0tLS0tWyBzb3VyY2UgbWFwIGdlbmVyYXRvcnMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBERUZNQVAobm9kZXR5cGUsIGdlbmVyYXRvcikge1xuICAgICAgICBub2RldHlwZS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGV0eXBlKSB7XG4gICAgICAgICAgICBub2RldHlwZS5ERUZNRVRIT0QoXCJhZGRfc291cmNlX21hcFwiLCBnZW5lcmF0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBERUZNQVAoW1xuICAgICAgICAvLyBXZSBjb3VsZCBlYXNpbHkgYWRkIGluZm8gZm9yIEFMTCBub2RlcywgYnV0IGl0IHNlZW1zIHRvIG1lIHRoYXRcbiAgICAgICAgLy8gd291bGQgYmUgcXVpdGUgd2FzdGVmdWwsIGhlbmNlIHRoaXMgbm9vcCBpbiB0aGUgYmFzZSBjbGFzcy5cbiAgICAgICAgQVNUX05vZGUsXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsYWJlbCBzeW1ib2wgd2lsbCBtYXJrIGl0XG4gICAgICAgIEFTVF9MYWJlbGVkU3RhdGVtZW50LFxuICAgICAgICBBU1RfVG9wbGV2ZWwsXG4gICAgXSwgbm9vcCk7XG5cbiAgICAvLyBYWFg6IEknbSBub3QgZXhhY3RseSBzdXJlIGlmIHdlIG5lZWQgaXQgZm9yIGFsbCBvZiB0aGVzZSBub2RlcyxcbiAgICAvLyBvciBpZiB3ZSBzaG91bGQgYWRkIGV2ZW4gbW9yZS5cbiAgICBERUZNQVAoW1xuICAgICAgICBBU1RfQXJyYXksXG4gICAgICAgIEFTVF9CbG9ja1N0YXRlbWVudCxcbiAgICAgICAgQVNUX0NhdGNoLFxuICAgICAgICBBU1RfQ2xhc3MsXG4gICAgICAgIEFTVF9Db25zdGFudCxcbiAgICAgICAgQVNUX0RlYnVnZ2VyLFxuICAgICAgICBBU1RfRGVmaW5pdGlvbnNMaWtlLFxuICAgICAgICBBU1RfRGlyZWN0aXZlLFxuICAgICAgICBBU1RfRmluYWxseSxcbiAgICAgICAgQVNUX0p1bXAsXG4gICAgICAgIEFTVF9MYW1iZGEsXG4gICAgICAgIEFTVF9OZXcsXG4gICAgICAgIEFTVF9PYmplY3QsXG4gICAgICAgIEFTVF9TdGF0ZW1lbnRXaXRoQm9keSxcbiAgICAgICAgQVNUX1N5bWJvbCxcbiAgICAgICAgQVNUX1N3aXRjaCxcbiAgICAgICAgQVNUX1N3aXRjaEJyYW5jaCxcbiAgICAgICAgQVNUX1RlbXBsYXRlU3RyaW5nLFxuICAgICAgICBBU1RfVGVtcGxhdGVTZWdtZW50LFxuICAgICAgICBBU1RfVHJ5LFxuICAgIF0sIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcodGhpcy5zdGFydCk7XG4gICAgfSk7XG5cbiAgICBERUZNQVAoW1xuICAgICAgICBBU1RfT2JqZWN0R2V0dGVyLFxuICAgICAgICBBU1RfT2JqZWN0U2V0dGVyLFxuICAgICAgICBBU1RfUHJpdmF0ZUdldHRlcixcbiAgICAgICAgQVNUX1ByaXZhdGVTZXR0ZXIsXG4gICAgICAgIEFTVF9Db25jaXNlTWV0aG9kLFxuICAgICAgICBBU1RfUHJpdmF0ZU1ldGhvZCxcbiAgICBdLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LmFkZF9tYXBwaW5nKHRoaXMuc3RhcnQsIGZhbHNlIC8qbmFtZSBoYW5kbGVkIGJlbG93Ki8pO1xuICAgIH0pO1xuXG4gICAgREVGTUFQKFtcbiAgICAgICAgQVNUX1N5bWJvbE1ldGhvZCxcbiAgICAgICAgQVNUX1N5bWJvbFByaXZhdGVQcm9wZXJ0eVxuICAgIF0sIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICBjb25zdCB0b2tfdHlwZSA9IHRoaXMuZW5kICYmIHRoaXMuZW5kLnR5cGU7XG4gICAgICAgIGlmICh0b2tfdHlwZSA9PT0gXCJuYW1lXCIgfHwgdG9rX3R5cGUgPT09IFwicHJpdmF0ZW5hbWVcIikge1xuICAgICAgICAgICAgb3V0cHV0LmFkZF9tYXBwaW5nKHRoaXMuZW5kLCB0aGlzLm5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LmFkZF9tYXBwaW5nKHRoaXMuZW5kKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgREVGTUFQKFsgQVNUX09iamVjdFByb3BlcnR5IF0sIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcodGhpcy5zdGFydCwgdGhpcy5rZXkpO1xuICAgIH0pO1xufSkoKTtcblxuY29uc3Qgc2hhbGxvd19jbXAgPSAobm9kZTEsIG5vZGUyKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgbm9kZTEgPT09IG51bGwgJiYgbm9kZTIgPT09IG51bGxcbiAgICAgICAgfHwgbm9kZTEuVFlQRSA9PT0gbm9kZTIuVFlQRSAmJiBub2RlMS5zaGFsbG93X2NtcChub2RlMilcbiAgICApO1xufTtcblxuY29uc3QgZXF1aXZhbGVudF90byA9ICh0cmVlMSwgdHJlZTIpID0+IHtcbiAgICBpZiAoIXNoYWxsb3dfY21wKHRyZWUxLCB0cmVlMikpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB3YWxrXzFfc3RhdGUgPSBbdHJlZTFdO1xuICAgIGNvbnN0IHdhbGtfMl9zdGF0ZSA9IFt0cmVlMl07XG5cbiAgICBjb25zdCB3YWxrXzFfcHVzaCA9IHdhbGtfMV9zdGF0ZS5wdXNoLmJpbmQod2Fsa18xX3N0YXRlKTtcbiAgICBjb25zdCB3YWxrXzJfcHVzaCA9IHdhbGtfMl9zdGF0ZS5wdXNoLmJpbmQod2Fsa18yX3N0YXRlKTtcblxuICAgIHdoaWxlICh3YWxrXzFfc3RhdGUubGVuZ3RoICYmIHdhbGtfMl9zdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgbm9kZV8xID0gd2Fsa18xX3N0YXRlLnBvcCgpO1xuICAgICAgICBjb25zdCBub2RlXzIgPSB3YWxrXzJfc3RhdGUucG9wKCk7XG5cbiAgICAgICAgaWYgKCFzaGFsbG93X2NtcChub2RlXzEsIG5vZGVfMikpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBub2RlXzEuX2NoaWxkcmVuX2JhY2t3YXJkcyh3YWxrXzFfcHVzaCk7XG4gICAgICAgIG5vZGVfMi5fY2hpbGRyZW5fYmFja3dhcmRzKHdhbGtfMl9wdXNoKTtcblxuICAgICAgICBpZiAod2Fsa18xX3N0YXRlLmxlbmd0aCAhPT0gd2Fsa18yX3N0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRGlmZmVyZW50IG51bWJlciBvZiBjaGlsZHJlblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdhbGtfMV9zdGF0ZS5sZW5ndGggPT0gMCAmJiB3YWxrXzJfc3RhdGUubGVuZ3RoID09IDA7XG59O1xuXG5jb25zdCBwYXNzX3Rocm91Z2ggPSAoKSA9PiB0cnVlO1xuXG5BU1RfTm9kZS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlkIG5vdCBmaW5kIGEgc2hhbGxvd19jbXAgZnVuY3Rpb24gZm9yIFwiICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbn07XG5cbkFTVF9EZWJ1Z2dlci5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9EaXJlY3RpdmUucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWU7XG59O1xuXG5BU1RfU2ltcGxlU3RhdGVtZW50LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0Jsb2NrLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0VtcHR5U3RhdGVtZW50LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0xhYmVsZWRTdGF0ZW1lbnQucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5sYWJlbC5uYW1lID09PSBvdGhlci5sYWJlbC5uYW1lO1xufTtcblxuQVNUX0RvLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX1doaWxlLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0Zvci5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiAodGhpcy5pbml0ID09IG51bGwgPyBvdGhlci5pbml0ID09IG51bGwgOiB0aGlzLmluaXQgPT09IG90aGVyLmluaXQpICYmICh0aGlzLmNvbmRpdGlvbiA9PSBudWxsID8gb3RoZXIuY29uZGl0aW9uID09IG51bGwgOiB0aGlzLmNvbmRpdGlvbiA9PT0gb3RoZXIuY29uZGl0aW9uKSAmJiAodGhpcy5zdGVwID09IG51bGwgPyBvdGhlci5zdGVwID09IG51bGwgOiB0aGlzLnN0ZXAgPT09IG90aGVyLnN0ZXApO1xufTtcblxuQVNUX0ZvckluLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0Zvck9mLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX1dpdGgucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfVG9wbGV2ZWwucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfRXhwYW5zaW9uLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0xhbWJkYS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmlzX2dlbmVyYXRvciA9PT0gb3RoZXIuaXNfZ2VuZXJhdG9yICYmIHRoaXMuYXN5bmMgPT09IG90aGVyLmFzeW5jO1xufTtcblxuQVNUX0Rlc3RydWN0dXJpbmcucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5pc19hcnJheSA9PT0gb3RoZXIuaXNfYXJyYXk7XG59O1xuXG5BU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZy5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9UZW1wbGF0ZVN0cmluZy5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9UZW1wbGF0ZVNlZ21lbnQucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWU7XG59O1xuXG5BU1RfSnVtcC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9Mb29wQ29udHJvbC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9Bd2FpdC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9ZaWVsZC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmlzX3N0YXIgPT09IG90aGVyLmlzX3N0YXI7XG59O1xuXG5BU1RfSWYucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5hbHRlcm5hdGl2ZSA9PSBudWxsID8gb3RoZXIuYWx0ZXJuYXRpdmUgPT0gbnVsbCA6IHRoaXMuYWx0ZXJuYXRpdmUgPT09IG90aGVyLmFsdGVybmF0aXZlO1xufTtcblxuQVNUX1N3aXRjaC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9Td2l0Y2hCcmFuY2gucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfVHJ5LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuICh0aGlzLmJvZHkgPT09IG90aGVyLmJvZHkpICYmICh0aGlzLmJjYXRjaCA9PSBudWxsID8gb3RoZXIuYmNhdGNoID09IG51bGwgOiB0aGlzLmJjYXRjaCA9PT0gb3RoZXIuYmNhdGNoKSAmJiAodGhpcy5iZmluYWxseSA9PSBudWxsID8gb3RoZXIuYmZpbmFsbHkgPT0gbnVsbCA6IHRoaXMuYmZpbmFsbHkgPT09IG90aGVyLmJmaW5hbGx5KTtcbn07XG5cbkFTVF9DYXRjaC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmFyZ25hbWUgPT0gbnVsbCA/IG90aGVyLmFyZ25hbWUgPT0gbnVsbCA6IHRoaXMuYXJnbmFtZSA9PT0gb3RoZXIuYXJnbmFtZTtcbn07XG5cbkFTVF9GaW5hbGx5LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0RlZmluaXRpb25zTGlrZS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9WYXJEZWZMaWtlLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPT0gbnVsbCA/IG90aGVyLnZhbHVlID09IG51bGwgOiB0aGlzLnZhbHVlID09PSBvdGhlci52YWx1ZTtcbn07XG5cbkFTVF9OYW1lTWFwcGluZy5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9JbXBvcnQucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gKHRoaXMuaW1wb3J0ZWRfbmFtZSA9PSBudWxsID8gb3RoZXIuaW1wb3J0ZWRfbmFtZSA9PSBudWxsIDogdGhpcy5pbXBvcnRlZF9uYW1lID09PSBvdGhlci5pbXBvcnRlZF9uYW1lKSAmJiAodGhpcy5pbXBvcnRlZF9uYW1lcyA9PSBudWxsID8gb3RoZXIuaW1wb3J0ZWRfbmFtZXMgPT0gbnVsbCA6IHRoaXMuaW1wb3J0ZWRfbmFtZXMgPT09IG90aGVyLmltcG9ydGVkX25hbWVzKSAmJiAodGhpcy5hdHRyaWJ1dGVzID09IG51bGwgPyBvdGhlci5hdHRyaWJ1dGVzID09IG51bGwgOiB0aGlzLmF0dHJpYnV0ZXMgPT09IG90aGVyLmF0dHJpYnV0ZXMpO1xufTtcblxuQVNUX0ltcG9ydE1ldGEucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfRXhwb3J0LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuICh0aGlzLmV4cG9ydGVkX2RlZmluaXRpb24gPT0gbnVsbCA/IG90aGVyLmV4cG9ydGVkX2RlZmluaXRpb24gPT0gbnVsbCA6IHRoaXMuZXhwb3J0ZWRfZGVmaW5pdGlvbiA9PT0gb3RoZXIuZXhwb3J0ZWRfZGVmaW5pdGlvbikgJiYgKHRoaXMuZXhwb3J0ZWRfdmFsdWUgPT0gbnVsbCA/IG90aGVyLmV4cG9ydGVkX3ZhbHVlID09IG51bGwgOiB0aGlzLmV4cG9ydGVkX3ZhbHVlID09PSBvdGhlci5leHBvcnRlZF92YWx1ZSkgJiYgKHRoaXMuZXhwb3J0ZWRfbmFtZXMgPT0gbnVsbCA/IG90aGVyLmV4cG9ydGVkX25hbWVzID09IG51bGwgOiB0aGlzLmV4cG9ydGVkX25hbWVzID09PSBvdGhlci5leHBvcnRlZF9uYW1lcykgJiYgKHRoaXMuYXR0cmlidXRlcyA9PSBudWxsID8gb3RoZXIuYXR0cmlidXRlcyA9PSBudWxsIDogdGhpcy5hdHRyaWJ1dGVzID09PSBvdGhlci5hdHRyaWJ1dGVzKSAmJiB0aGlzLm1vZHVsZV9uYW1lID09PSBvdGhlci5tb2R1bGVfbmFtZSAmJiB0aGlzLmlzX2RlZmF1bHQgPT09IG90aGVyLmlzX2RlZmF1bHQ7XG59O1xuXG5BU1RfQ2FsbC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9TZXF1ZW5jZS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9Qcm9wQWNjZXNzLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0NoYWluLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0RvdC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnR5ID09PSBvdGhlci5wcm9wZXJ0eTtcbn07XG5cbkFTVF9Eb3RIYXNoLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydHkgPT09IG90aGVyLnByb3BlcnR5O1xufTtcblxuQVNUX1VuYXJ5LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT09IG90aGVyLm9wZXJhdG9yO1xufTtcblxuQVNUX0JpbmFyeS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdG9yID09PSBvdGhlci5vcGVyYXRvcjtcbn07XG5cbkFTVF9Qcml2YXRlSW4ucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfQ29uZGl0aW9uYWwucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfQXJyYXkucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfT2JqZWN0LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX09iamVjdFByb3BlcnR5LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX09iamVjdEtleVZhbC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmtleSA9PT0gb3RoZXIua2V5ICYmIHRoaXMucXVvdGUgPT09IG90aGVyLnF1b3RlO1xufTtcblxuQVNUX09iamVjdFNldHRlci5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnN0YXRpYyA9PT0gb3RoZXIuc3RhdGljO1xufTtcblxuQVNUX09iamVjdEdldHRlci5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnN0YXRpYyA9PT0gb3RoZXIuc3RhdGljO1xufTtcblxuQVNUX0NvbmNpc2VNZXRob2QucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0aWMgPT09IG90aGVyLnN0YXRpYztcbn07XG5cbkFTVF9Qcml2YXRlTWV0aG9kLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGljID09PSBvdGhlci5zdGF0aWM7XG59O1xuXG5BU1RfQ2xhc3MucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gKHRoaXMubmFtZSA9PSBudWxsID8gb3RoZXIubmFtZSA9PSBudWxsIDogdGhpcy5uYW1lID09PSBvdGhlci5uYW1lKSAmJiAodGhpcy5leHRlbmRzID09IG51bGwgPyBvdGhlci5leHRlbmRzID09IG51bGwgOiB0aGlzLmV4dGVuZHMgPT09IG90aGVyLmV4dGVuZHMpO1xufTtcblxuQVNUX0NsYXNzUHJvcGVydHkucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0aWMgPT09IG90aGVyLnN0YXRpY1xuICAgICAgICAmJiAodHlwZW9mIHRoaXMua2V5ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHRoaXMua2V5ID09PSBvdGhlci5rZXlcbiAgICAgICAgICAgIDogdHJ1ZSAvKiBBU1RfTm9kZSBoYW5kbGVkIGVsc2V3aGVyZSAqLyk7XG59O1xuXG5BU1RfQ2xhc3NQcml2YXRlUHJvcGVydHkucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0aWMgPT09IG90aGVyLnN0YXRpYztcbn07XG5cbkFTVF9TeW1ib2wucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lID09PSBvdGhlci5uYW1lO1xufTtcblxuQVNUX05ld1RhcmdldC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9UaGlzLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX1N1cGVyLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX1N0cmluZy5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBvdGhlci52YWx1ZTtcbn07XG5cbkFTVF9OdW1iZXIucHJvdG90eXBlLnNoYWxsb3dfY21wID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWU7XG59O1xuXG5BU1RfQmlnSW50LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG90aGVyLnZhbHVlO1xufTtcblxuQVNUX1JlZ0V4cC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnZhbHVlLmZsYWdzID09PSBvdGhlci52YWx1ZS5mbGFnc1xuICAgICAgICAmJiB0aGlzLnZhbHVlLnNvdXJjZSA9PT0gb3RoZXIudmFsdWUuc291cmNlXG4gICAgKTtcbn07XG5cbkFTVF9BdG9tLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jb25zdCBNQVNLX0VYUE9SVF9ET05UX01BTkdMRSA9IDEgPDwgMDtcbmNvbnN0IE1BU0tfRVhQT1JUX1dBTlRfTUFOR0xFID0gMSA8PCAxO1xuXG5sZXQgZnVuY3Rpb25fZGVmcyA9IG51bGw7XG5sZXQgdW5tYW5nbGVhYmxlX25hbWVzID0gbnVsbDtcbi8qKlxuICogV2hlbiBkZWZpbmVkLCB0aGVyZSBpcyBhIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIHNvbWV3aGVyZSB0aGF0J3MgaW5zaWRlIG9mIGEgYmxvY2suXG4gKiBTZWUgaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvbXVsdGlwYWdlL2FkZGl0aW9uYWwtZWNtYXNjcmlwdC1mZWF0dXJlcy1mb3Itd2ViLWJyb3dzZXJzLmh0bWwjc2VjLWJsb2NrLWxldmVsLWZ1bmN0aW9uLWRlY2xhcmF0aW9ucy13ZWItbGVnYWN5LWNvbXBhdGliaWxpdHktc2VtYW50aWNzXG4qL1xubGV0IHNjb3Blc193aXRoX2Jsb2NrX2RlZnVucyA9IG51bGw7XG5cbmNsYXNzIFN5bWJvbERlZiB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUsIG9yaWcsIGluaXQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gb3JpZy5uYW1lO1xuICAgICAgICB0aGlzLm9yaWcgPSBbIG9yaWcgXTtcbiAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICAgICAgdGhpcy5lbGltaW5hdGVkID0gMDtcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50cyA9IDA7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5yZXBsYWNlZCA9IDA7XG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXhwb3J0ID0gMDtcbiAgICAgICAgdGhpcy5tYW5nbGVkX25hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnVuZGVjbGFyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZCA9IFN5bWJvbERlZi5uZXh0X2lkKys7XG4gICAgICAgIHRoaXMuY2hhaW5lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcmVjdF9hY2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lc2NhcGVkID0gMDtcbiAgICAgICAgdGhpcy5yZWN1cnNpdmVfcmVmcyA9IDA7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLnNob3VsZF9yZXBsYWNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNpbmdsZV91c2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maXhlZCA9IGZhbHNlO1xuICAgICAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICB9XG4gICAgZml4ZWRfdmFsdWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5maXhlZCB8fCB0aGlzLmZpeGVkIGluc3RhbmNlb2YgQVNUX05vZGUpIHJldHVybiB0aGlzLmZpeGVkO1xuICAgICAgICByZXR1cm4gdGhpcy5maXhlZCgpO1xuICAgIH1cbiAgICB1bm1hbmdsZWFibGUob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBmdW5jdGlvbl9kZWZzICYmXG4gICAgICAgICAgICBmdW5jdGlvbl9kZWZzLmhhcyh0aGlzLmlkKSAmJlxuICAgICAgICAgICAga2VlcF9uYW1lKG9wdGlvbnMua2VlcF9mbmFtZXMsIHRoaXMub3JpZ1swXS5uYW1lKVxuICAgICAgICApIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdsb2JhbCAmJiAhb3B0aW9ucy50b3BsZXZlbFxuICAgICAgICAgICAgfHwgKHRoaXMuZXhwb3J0ICYgTUFTS19FWFBPUlRfRE9OVF9NQU5HTEUpXG4gICAgICAgICAgICB8fCB0aGlzLnVuZGVjbGFyZWRcbiAgICAgICAgICAgIHx8ICFvcHRpb25zLmV2YWwgJiYgdGhpcy5zY29wZS5waW5uZWQoKVxuICAgICAgICAgICAgfHwgKHRoaXMub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xMYW1iZGFcbiAgICAgICAgICAgICAgICAgIHx8IHRoaXMub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWZ1bikgJiYga2VlcF9uYW1lKG9wdGlvbnMua2VlcF9mbmFtZXMsIHRoaXMub3JpZ1swXS5uYW1lKVxuICAgICAgICAgICAgfHwgdGhpcy5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbE1ldGhvZFxuICAgICAgICAgICAgfHwgKHRoaXMub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xDbGFzc1xuICAgICAgICAgICAgICAgICAgfHwgdGhpcy5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlZkNsYXNzKSAmJiBrZWVwX25hbWUob3B0aW9ucy5rZWVwX2NsYXNzbmFtZXMsIHRoaXMub3JpZ1swXS5uYW1lKTtcbiAgICB9XG4gICAgbWFuZ2xlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBvcHRpb25zLmNhY2hlICYmIG9wdGlvbnMuY2FjaGUucHJvcHM7XG4gICAgICAgIGlmICh0aGlzLmdsb2JhbCAmJiBjYWNoZSAmJiBjYWNoZS5oYXModGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5tYW5nbGVkX25hbWUgPSBjYWNoZS5nZXQodGhpcy5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5tYW5nbGVkX25hbWUgJiYgIXRoaXMudW5tYW5nbGVhYmxlKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuc2NvcGU7XG4gICAgICAgICAgICB2YXIgc3ltID0gdGhpcy5vcmlnWzBdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaWU4ICYmIHN5bSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xMYW1iZGEpXG4gICAgICAgICAgICAgICAgcyA9IHMucGFyZW50X3Njb3BlO1xuICAgICAgICAgICAgY29uc3QgcmVkZWZpbml0aW9uID0gcmVkZWZpbmVkX2NhdGNoX2RlZih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubWFuZ2xlZF9uYW1lID0gcmVkZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgPyByZWRlZmluaXRpb24ubWFuZ2xlZF9uYW1lIHx8IHJlZGVmaW5pdGlvbi5uYW1lXG4gICAgICAgICAgICAgICAgOiBzLm5leHRfbWFuZ2xlZChvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdsb2JhbCAmJiBjYWNoZSkge1xuICAgICAgICAgICAgICAgIGNhY2hlLnNldCh0aGlzLm5hbWUsIHRoaXMubWFuZ2xlZF9uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuU3ltYm9sRGVmLm5leHRfaWQgPSAxO1xuXG5mdW5jdGlvbiByZWRlZmluZWRfY2F0Y2hfZGVmKGRlZikge1xuICAgIGlmIChkZWYub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xDYXRjaFxuICAgICAgICAmJiBkZWYuc2NvcGUuaXNfYmxvY2tfc2NvcGUoKVxuICAgICkge1xuICAgICAgICByZXR1cm4gZGVmLnNjb3BlLmdldF9kZWZ1bl9zY29wZSgpLnZhcmlhYmxlcy5nZXQoZGVmLm5hbWUpO1xuICAgIH1cbn1cblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcImZpZ3VyZV9vdXRfc2NvcGVcIiwgZnVuY3Rpb24ob3B0aW9ucywgeyBwYXJlbnRfc2NvcGUgPSB1bmRlZmluZWQsIHRvcGxldmVsID0gdGhpcyB9ID0ge30pIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBjYWNoZTogbnVsbCxcbiAgICAgICAgaWU4OiBmYWxzZSxcbiAgICAgICAgc2FmYXJpMTA6IGZhbHNlLFxuICAgICAgICBtb2R1bGU6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgaWYgKCEodG9wbGV2ZWwgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdG9wbGV2ZWwgc2NvcGVcIik7XG4gICAgfVxuXG4gICAgLy8gcGFzcyAxOiBzZXR1cCBzY29wZSBjaGFpbmluZyBhbmQgaGFuZGxlIGRlZmluaXRpb25zXG4gICAgdmFyIHNjb3BlID0gdGhpcy5wYXJlbnRfc2NvcGUgPSBwYXJlbnRfc2NvcGU7XG4gICAgdmFyIGxhYmVscyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgZGVmdW4gPSBudWxsO1xuICAgIHZhciBpbl9kZXN0cnVjdHVyaW5nID0gbnVsbDtcbiAgICB2YXIgZm9yX3Njb3BlcyA9IFtdO1xuICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKChub2RlLCBkZXNjZW5kKSA9PiB7XG4gICAgICAgIGlmIChub2RlLmlzX2Jsb2NrX3Njb3BlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhdmVfc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgIG5vZGUuYmxvY2tfc2NvcGUgPSBzY29wZSA9IG5ldyBBU1RfU2NvcGUobm9kZSk7XG4gICAgICAgICAgICBzY29wZS5fYmxvY2tfc2NvcGUgPSB0cnVlO1xuICAgICAgICAgICAgc2NvcGUuaW5pdF9zY29wZV92YXJzKHNhdmVfc2NvcGUpO1xuICAgICAgICAgICAgc2NvcGUudXNlc193aXRoID0gc2F2ZV9zY29wZS51c2VzX3dpdGg7XG4gICAgICAgICAgICBzY29wZS51c2VzX2V2YWwgPSBzYXZlX3Njb3BlLnVzZXNfZXZhbDtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2FmYXJpMTApIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Gb3IgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Gb3JJbiB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0Zvck9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcl9zY29wZXMucHVzaChzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBYWFg6IEhBQ0shIEVuc3VyZSB0aGUgc3dpdGNoIGV4cHJlc3Npb24gZ2V0cyB0aGUgY29ycmVjdCBzY29wZSAodGhlIHBhcmVudCBzY29wZSkgYW5kIHRoZSBib2R5IGdldHMgdGhlIGNvbnRhaW5lZCBzY29wZVxuICAgICAgICAgICAgICAgIC8vIEFTVF9Td2l0Y2ggaGFzIGEgc2NvcGUgd2l0aGluIHRoZSBib2R5LCBidXQgaXQgaXRzZWxmIFwiaXMgYSBibG9jayBzY29wZVwiXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGUgc3dpdGNoZWQgZXhwcmVzc2lvbiBoYXMgdG8gYmVsb25nIHRvIHRoZSBvdXRlciBzY29wZVxuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHRoZSBib2R5IGluc2lkZSBiZWxvbmdzIHRvIHRoZSBzd2l0Y2ggaXRzZWxmLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcHJldHR5IG5hc3R5IGFuZCB3YXJyYW50cyBhbiBBU1QgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29uc3QgdGhlX2Jsb2NrX3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzYXZlX3Njb3BlO1xuICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbi53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICBzY29wZSA9IHRoZV9ibG9ja19zY29wZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmJvZHlbaV0ud2Fsayh0dyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY29wZSA9IHNhdmVfc2NvcGU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBzYXZlX2Rlc3RydWN0dXJpbmcgPSBpbl9kZXN0cnVjdHVyaW5nO1xuICAgICAgICAgICAgaW5fZGVzdHJ1Y3R1cmluZyA9IG5vZGU7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBpbl9kZXN0cnVjdHVyaW5nID0gc2F2ZV9kZXN0cnVjdHVyaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgIG5vZGUuaW5pdF9zY29wZV92YXJzKHNjb3BlKTtcbiAgICAgICAgICAgIHZhciBzYXZlX3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICB2YXIgc2F2ZV9kZWZ1biA9IGRlZnVuO1xuICAgICAgICAgICAgdmFyIHNhdmVfbGFiZWxzID0gbGFiZWxzO1xuICAgICAgICAgICAgZGVmdW4gPSBzY29wZSA9IG5vZGU7XG4gICAgICAgICAgICBsYWJlbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBzY29wZSA9IHNhdmVfc2NvcGU7XG4gICAgICAgICAgICBkZWZ1biA9IHNhdmVfZGVmdW47XG4gICAgICAgICAgICBsYWJlbHMgPSBzYXZlX2xhYmVscztcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgLy8gZG9uJ3QgZGVzY2VuZCBhZ2FpbiBpbiBUcmVlV2Fsa2VyXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWxlZFN0YXRlbWVudCkge1xuICAgICAgICAgICAgdmFyIGwgPSBub2RlLmxhYmVsO1xuICAgICAgICAgICAgaWYgKGxhYmVscy5oYXMobC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJpbmdfdGVtcGxhdGUoXCJMYWJlbCB7bmFtZX0gZGVmaW5lZCB0d2ljZVwiLCBsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYWJlbHMuc2V0KGwubmFtZSwgbCk7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBsYWJlbHMuZGVsZXRlKGwubmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgIC8vIG5vIGRlc2NlbmQgYWdhaW5cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9XaXRoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gc2NvcGU7IHM7IHMgPSBzLnBhcmVudF9zY29wZSlcbiAgICAgICAgICAgICAgICBzLnVzZXNfd2l0aCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSB7XG4gICAgICAgICAgICBub2RlLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWwpIHtcbiAgICAgICAgICAgIG5vZGUudGhlZGVmID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUucmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbExhbWJkYSkge1xuICAgICAgICAgICAgZGVmdW4uZGVmX2Z1bmN0aW9uKG5vZGUsIG5vZGUubmFtZSA9PSBcImFyZ3VtZW50c1wiID8gdW5kZWZpbmVkIDogZGVmdW4pO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVmdW4pIHtcbiAgICAgICAgICAgIC8vIENhcmVmdWwgaGVyZSwgdGhlIHNjb3BlIHdoZXJlIHRoaXMgc2hvdWxkIGJlIGRlZmluZWQgaXNcbiAgICAgICAgICAgIC8vIHRoZSBwYXJlbnQgc2NvcGUuICBUaGUgcmVhc29uIGlzIHRoYXQgd2UgZW50ZXIgYSBuZXdcbiAgICAgICAgICAgIC8vIHNjb3BlIHdoZW4gd2UgZW5jb3VudGVyIHRoZSBBU1RfRGVmdW4gbm9kZSAod2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGluc3RhbmNlb2YgQVNUX1Njb3BlKSBidXQgd2UgZ2V0IHRvIHRoZSBzeW1ib2wgYSBiaXRcbiAgICAgICAgICAgIC8vIGxhdGVyLlxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdF9zY29wZSA9IGRlZnVuLnBhcmVudF9zY29wZTtcblxuICAgICAgICAgICAgLy8gSW4gc3RyaWN0IG1vZGUsIGZ1bmN0aW9uIGRlZmluaXRpb25zIGFyZSBibG9jay1zY29wZWRcbiAgICAgICAgICAgIG5vZGUuc2NvcGUgPSB0dy5kaXJlY3RpdmVzW1widXNlIHN0cmljdFwiXVxuICAgICAgICAgICAgICAgID8gY2xvc2VzdF9zY29wZVxuICAgICAgICAgICAgICAgIDogY2xvc2VzdF9zY29wZS5nZXRfZGVmdW5fc2NvcGUoKTtcblxuICAgICAgICAgICAgbWFya19leHBvcnQobm9kZS5zY29wZS5kZWZfZnVuY3Rpb24obm9kZSwgZGVmdW4pLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENsYXNzKSB7XG4gICAgICAgICAgICBtYXJrX2V4cG9ydChkZWZ1bi5kZWZfdmFyaWFibGUobm9kZSwgZGVmdW4pLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbEltcG9ydCkge1xuICAgICAgICAgICAgc2NvcGUuZGVmX3ZhcmlhYmxlKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVmQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZGVhbHMgd2l0aCB0aGUgbmFtZSBvZiB0aGUgY2xhc3MgYmVpbmcgYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBpbnNpZGUgdGhlIGNsYXNzLlxuICAgICAgICAgICAgbWFya19leHBvcnQoKG5vZGUuc2NvcGUgPSBkZWZ1bi5wYXJlbnRfc2NvcGUpLmRlZl9mdW5jdGlvbihub2RlLCBkZWZ1biksIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xWYXJcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGV0XG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENvbnN0XG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFVzaW5nXG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENhdGNoXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGRlZjtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbEJsb2NrRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkZWYgPSBzY29wZS5kZWZfdmFyaWFibGUobm9kZSwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZiA9IGRlZnVuLmRlZl92YXJpYWJsZShub2RlLCBub2RlLlRZUEUgPT0gXCJTeW1ib2xWYXJcIiA/IG51bGwgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZWYub3JpZy5ldmVyeSgoc3ltKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN5bSA9PT0gbm9kZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltIGluc3RhbmNlb2YgQVNUX1N5bWJvbExhbWJkYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoc3ltIGluc3RhbmNlb2YgQVNUX1N5bWJvbExldCB8fCBzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ29uc3QgfHwgc3ltIGluc3RhbmNlb2YgQVNUX1N5bWJvbFVzaW5nKTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAganNfZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBcIiR7bm9kZS5uYW1lfVwiIGlzIHJlZGVjbGFyZWRgLFxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGFydC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhcnQucG9zXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRnVuYXJnKSkgbWFya19leHBvcnQoZGVmLCAyKTtcbiAgICAgICAgICAgIGlmIChkZWZ1biAhPT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLm1hcmtfZW5jbG9zZWQoKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmID0gc2NvcGUuZmluZF92YXJpYWJsZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50aGVkZWYgIT09IGRlZikge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnRoZWRlZiA9IGRlZjtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWZlcmVuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYWJlbFJlZikge1xuICAgICAgICAgICAgdmFyIHN5bSA9IGxhYmVscy5nZXQobm9kZS5uYW1lKTtcbiAgICAgICAgICAgIGlmICghc3ltKSB0aHJvdyBuZXcgRXJyb3Ioc3RyaW5nX3RlbXBsYXRlKFwiVW5kZWZpbmVkIGxhYmVsIHtuYW1lfSBbe2xpbmV9LHtjb2x9XVwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgIGxpbmU6IG5vZGUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IG5vZGUuc3RhcnQuY29sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBub2RlLnRoZWRlZiA9IHN5bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzY29wZSBpbnN0YW5jZW9mIEFTVF9Ub3BsZXZlbCkgJiYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRXhwb3J0IHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfSW1wb3J0KSkge1xuICAgICAgICAgICAganNfZXJyb3IoXG4gICAgICAgICAgICAgICAgYFwiJHtub2RlLlRZUEV9XCIgc3RhdGVtZW50IG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsYCxcbiAgICAgICAgICAgICAgICBub2RlLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgbm9kZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgIG5vZGUuc3RhcnQuY29sLFxuICAgICAgICAgICAgICAgIG5vZGUuc3RhcnQucG9zXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5tb2R1bGUpIHtcbiAgICAgICAgdHcuZGlyZWN0aXZlc1tcInVzZSBzdHJpY3RcIl0gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMud2Fsayh0dyk7XG5cbiAgICBmdW5jdGlvbiBtYXJrX2V4cG9ydChkZWYsIGxldmVsKSB7XG4gICAgICAgIGlmIChpbl9kZXN0cnVjdHVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICAgIH0gd2hpbGUgKHR3LnBhcmVudChpKyspICE9PSBpbl9kZXN0cnVjdHVyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IHR3LnBhcmVudChsZXZlbCk7XG4gICAgICAgIGlmIChkZWYuZXhwb3J0ID0gbm9kZSBpbnN0YW5jZW9mIEFTVF9FeHBvcnQgPyBNQVNLX0VYUE9SVF9ET05UX01BTkdMRSA6IDApIHtcbiAgICAgICAgICAgIHZhciBleHBvcnRlZCA9IG5vZGUuZXhwb3J0ZWRfZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmICgoZXhwb3J0ZWQgaW5zdGFuY2VvZiBBU1RfRGVmdW4gfHwgZXhwb3J0ZWQgaW5zdGFuY2VvZiBBU1RfRGVmQ2xhc3MpICYmIG5vZGUuaXNfZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGRlZi5leHBvcnQgPSBNQVNLX0VYUE9SVF9XQU5UX01BTkdMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhc3MgMjogZmluZCBiYWNrIHJlZmVyZW5jZXMgYW5kIGV2YWxcbiAgICBjb25zdCBpc190b3BsZXZlbCA9IHRoaXMgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWw7XG4gICAgaWYgKGlzX3RvcGxldmVsKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2wgJiYgbm9kZS5sYWJlbCkge1xuICAgICAgICAgICAgbm9kZS5sYWJlbC50aGVkZWYucmVmZXJlbmNlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiZXZhbFwiICYmIHR3LnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0NhbGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gbm9kZS5zY29wZTsgcyAmJiAhcy51c2VzX2V2YWw7IHMgPSBzLnBhcmVudF9zY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBzLnVzZXNfZXZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN5bTtcbiAgICAgICAgICAgIGlmICh0dy5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9OYW1lTWFwcGluZyAmJiB0dy5wYXJlbnQoMSkubW9kdWxlX25hbWVcbiAgICAgICAgICAgICAgICB8fCAhKHN5bSA9IG5vZGUuc2NvcGUuZmluZF92YXJpYWJsZShuYW1lKSkpIHtcblxuICAgICAgICAgICAgICAgIHN5bSA9IHRvcGxldmVsLmRlZl9nbG9iYWwobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRXhwb3J0KSBzeW0uZXhwb3J0ID0gTUFTS19FWFBPUlRfRE9OVF9NQU5HTEU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN5bS5zY29wZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgJiYgbmFtZSA9PSBcImFyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgc3ltLnNjb3BlLmdldF9kZWZ1bl9zY29wZSgpLnVzZXNfYXJndW1lbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUudGhlZGVmID0gc3ltO1xuICAgICAgICAgICAgbm9kZS5yZWZlcmVuY2UoKTtcbiAgICAgICAgICAgIGlmIChub2RlLnNjb3BlLmlzX2Jsb2NrX3Njb3BlKClcbiAgICAgICAgICAgICAgICAmJiAhKHN5bS5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbEJsb2NrRGVjbGFyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zY29wZSA9IG5vZGUuc2NvcGUuZ2V0X2RlZnVuX3Njb3BlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgbWFuZ2xpbmcgd29ya3MgaWYgY2F0Y2ggcmV1c2VzIGEgc2NvcGUgdmFyaWFibGVcbiAgICAgICAgdmFyIGRlZjtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2ggJiYgKGRlZiA9IHJlZGVmaW5lZF9jYXRjaF9kZWYobm9kZS5kZWZpbml0aW9uKCkpKSkge1xuICAgICAgICAgICAgdmFyIHMgPSBub2RlLnNjb3BlO1xuICAgICAgICAgICAgd2hpbGUgKHMpIHtcbiAgICAgICAgICAgICAgICBwdXNoX3VuaXEocy5lbmNsb3NlZCwgZGVmKTtcbiAgICAgICAgICAgICAgICBpZiAocyA9PT0gZGVmLnNjb3BlKSBicmVhaztcbiAgICAgICAgICAgICAgICBzID0gcy5wYXJlbnRfc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndhbGsodHcpO1xuXG4gICAgLy8gcGFzcyAzOiB3b3JrIGFyb3VuZCBJRTggYW5kIFNhZmFyaSBjYXRjaCBzY29wZSBidWdzXG4gICAgaWYgKG9wdGlvbnMuaWU4IHx8IG9wdGlvbnMuc2FmYXJpMTApIHtcbiAgICAgICAgd2Fsayh0aGlzLCBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENhdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHJlZnMgPSBub2RlLnRoZWRlZi5yZWZlcmVuY2VzO1xuICAgICAgICAgICAgICAgIHZhciBzY29wZSA9IG5vZGUuc2NvcGUuZ2V0X2RlZnVuX3Njb3BlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IHNjb3BlLmZpbmRfdmFyaWFibGUobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgdG9wbGV2ZWwuZ2xvYmFscy5nZXQobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgc2NvcGUuZGVmX3ZhcmlhYmxlKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJlZnMuZm9yRWFjaChmdW5jdGlvbihyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLnRoZWRlZiA9IGRlZjtcbiAgICAgICAgICAgICAgICAgICAgcmVmLnJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5vZGUudGhlZGVmID0gZGVmO1xuICAgICAgICAgICAgICAgIG5vZGUucmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHBhc3MgNDogYWRkIHN5bWJvbCBkZWZpbml0aW9ucyB0byBsb29wIHNjb3Blc1xuICAgIC8vIFNhZmFyaS9XZWJraXQgYnVnIHdvcmthcm91bmQgLSBsb29wIGluaXQgbGV0IHZhcmlhYmxlIHNoYWRvd2luZyBhcmd1bWVudC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvMTc1M1xuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzEwNDFcbiAgICBpZiAob3B0aW9ucy5zYWZhcmkxMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIGZvcl9zY29wZXMpIHtcbiAgICAgICAgICAgIHNjb3BlLnBhcmVudF9zY29wZS52YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgICAgICAgICBwdXNoX3VuaXEoc2NvcGUuZW5jbG9zZWQsIGRlZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiZGVmX2dsb2JhbFwiLCBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGdsb2JhbHMgPSB0aGlzLmdsb2JhbHMsIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgaWYgKGdsb2JhbHMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxzLmdldChuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZyA9IG5ldyBTeW1ib2xEZWYodGhpcywgbm9kZSk7XG4gICAgICAgIGcudW5kZWNsYXJlZCA9IHRydWU7XG4gICAgICAgIGcuZ2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgZ2xvYmFscy5zZXQobmFtZSwgZyk7XG4gICAgICAgIHJldHVybiBnO1xuICAgIH1cbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiaW5pdF9zY29wZV92YXJzXCIsIGZ1bmN0aW9uKHBhcmVudF9zY29wZSkge1xuICAgIHRoaXMudmFyaWFibGVzID0gbmV3IE1hcCgpOyAgICAgICAgIC8vIG1hcCBuYW1lIHRvIEFTVF9TeW1ib2xWYXIgKHZhcmlhYmxlcyBkZWZpbmVkIGluIHRoaXMgc2NvcGU7IGluY2x1ZGVzIGZ1bmN0aW9ucylcbiAgICB0aGlzLnVzZXNfd2l0aCA9IGZhbHNlOyAgICAgICAgICAgICAvLyB3aWxsIGJlIHNldCB0byB0cnVlIGlmIHRoaXMgb3Igc29tZSBuZXN0ZWQgc2NvcGUgdXNlcyB0aGUgYHdpdGhgIHN0YXRlbWVudFxuICAgIHRoaXMudXNlc19ldmFsID0gZmFsc2U7ICAgICAgICAgICAgIC8vIHdpbGwgYmUgc2V0IHRvIHRydWUgaWYgdGhpcyBvciBuZXN0ZWQgc2NvcGUgdXNlcyB0aGUgZ2xvYmFsIGBldmFsYFxuICAgIHRoaXMucGFyZW50X3Njb3BlID0gcGFyZW50X3Njb3BlOyAgIC8vIHRoZSBwYXJlbnQgc2NvcGVcbiAgICB0aGlzLmVuY2xvc2VkID0gW107ICAgICAgICAgICAgICAgICAvLyBhIGxpc3Qgb2YgdmFyaWFibGVzIGZyb20gdGhpcyBvciBvdXRlciBzY29wZShzKSB0aGF0IGFyZSByZWZlcmVuY2VkIGZyb20gdGhpcyBvciBpbm5lciBzY29wZXNcbiAgICB0aGlzLmNuYW1lID0gLTE7ICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBpbmRleCBmb3IgbWFuZ2xpbmcgZnVuY3Rpb25zL3ZhcmlhYmxlc1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJjb25mbGljdGluZ19kZWZcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLmVuY2xvc2VkLmZpbmQoZGVmID0+IGRlZi5uYW1lID09PSBuYW1lKVxuICAgICAgICB8fCB0aGlzLnZhcmlhYmxlcy5oYXMobmFtZSlcbiAgICAgICAgfHwgKHRoaXMucGFyZW50X3Njb3BlICYmIHRoaXMucGFyZW50X3Njb3BlLmNvbmZsaWN0aW5nX2RlZihuYW1lKSlcbiAgICApO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJjb25mbGljdGluZ19kZWZfc2hhbGxvd1wiLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuZW5jbG9zZWQuZmluZChkZWYgPT4gZGVmLm5hbWUgPT09IG5hbWUpXG4gICAgICAgIHx8IHRoaXMudmFyaWFibGVzLmhhcyhuYW1lKVxuICAgICk7XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcImFkZF9jaGlsZF9zY29wZVwiLCBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAvLyBgc2NvcGVgIGlzIGdvaW5nIHRvIGJlIG1vdmVkIGludG8gYHRoaXNgIHJpZ2h0IG5vdy5cbiAgICAvLyBVcGRhdGUgdGhlIHJlcXVpcmVkIHNjb3BlcycgaW5mb3JtYXRpb25cblxuICAgIGlmIChzY29wZS5wYXJlbnRfc2NvcGUgPT09IHRoaXMpIHJldHVybjtcblxuICAgIHNjb3BlLnBhcmVudF9zY29wZSA9IHRoaXM7XG5cbiAgICAvLyBQcm9wYWdhdGUgdG8gdGhpcy51c2VzX2FyZ3VtZW50cyBmcm9tIGFycm93IGZ1bmN0aW9uc1xuICAgIGlmICgoc2NvcGUgaW5zdGFuY2VvZiBBU1RfQXJyb3cpICYmICh0aGlzIGluc3RhbmNlb2YgQVNUX0xhbWJkYSAmJiAhdGhpcy51c2VzX2FyZ3VtZW50cykpIHtcbiAgICAgICAgdGhpcy51c2VzX2FyZ3VtZW50cyA9IHdhbGsoc2NvcGUsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAgICAgJiYgbm9kZS5zY29wZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGFcbiAgICAgICAgICAgICAgICAmJiBub2RlLm5hbWUgPT09IFwiYXJndW1lbnRzXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxrX2Fib3J0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgJiYgIShub2RlIGluc3RhbmNlb2YgQVNUX0Fycm93KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnVzZXNfd2l0aCA9IHRoaXMudXNlc193aXRoIHx8IHNjb3BlLnVzZXNfd2l0aDtcbiAgICB0aGlzLnVzZXNfZXZhbCA9IHRoaXMudXNlc19ldmFsIHx8IHNjb3BlLnVzZXNfZXZhbDtcblxuICAgIGNvbnN0IHNjb3BlX2FuY2VzdHJ5ID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgYW5jZXN0cnkgPSBbXTtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGFuY2VzdHJ5LnB1c2goY3VyKTtcbiAgICAgICAgfSB3aGlsZSAoKGN1ciA9IGN1ci5wYXJlbnRfc2NvcGUpKTtcbiAgICAgICAgYW5jZXN0cnkucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gYW5jZXN0cnk7XG4gICAgfSkoKTtcblxuICAgIGNvbnN0IG5ld19zY29wZV9lbmNsb3NlZF9zZXQgPSBuZXcgU2V0KHNjb3BlLmVuY2xvc2VkKTtcbiAgICBjb25zdCB0b19lbmNsb3NlID0gW107XG4gICAgZm9yIChjb25zdCBzY29wZV90b3Bkb3duIG9mIHNjb3BlX2FuY2VzdHJ5KSB7XG4gICAgICAgIHRvX2VuY2xvc2UuZm9yRWFjaChlID0+IHB1c2hfdW5pcShzY29wZV90b3Bkb3duLmVuY2xvc2VkLCBlKSk7XG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIHNjb3BlX3RvcGRvd24udmFyaWFibGVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAobmV3X3Njb3BlX2VuY2xvc2VkX3NldC5oYXMoZGVmKSkge1xuICAgICAgICAgICAgICAgIHB1c2hfdW5pcSh0b19lbmNsb3NlLCBkZWYpO1xuICAgICAgICAgICAgICAgIHB1c2hfdW5pcShzY29wZV90b3Bkb3duLmVuY2xvc2VkLCBkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGZpbmRfc2NvcGVzX3Zpc2libGVfZnJvbShzY29wZXMpIHtcbiAgICBjb25zdCBmb3VuZF9zY29wZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIG5ldyBTZXQoc2NvcGVzKSkge1xuICAgICAgICAoZnVuY3Rpb24gYnViYmxlX3VwKHNjb3BlKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUgPT0gbnVsbCB8fCBmb3VuZF9zY29wZXMuaGFzKHNjb3BlKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBmb3VuZF9zY29wZXMuYWRkKHNjb3BlKTtcblxuICAgICAgICAgICAgYnViYmxlX3VwKHNjb3BlLnBhcmVudF9zY29wZSk7XG4gICAgICAgIH0pKHNjb3BlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWy4uLmZvdW5kX3Njb3Blc107XG59XG5cbi8vIENyZWF0ZXMgYSBzeW1ib2wgZHVyaW5nIGNvbXByZXNzaW9uXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiY3JlYXRlX3N5bWJvbFwiLCBmdW5jdGlvbihTeW1DbGFzcywge1xuICAgIHNvdXJjZSxcbiAgICB0ZW50YXRpdmVfbmFtZSxcbiAgICBzY29wZSxcbiAgICBjb25mbGljdF9zY29wZXMgPSBbc2NvcGVdLFxuICAgIGluaXQgPSBudWxsXG59ID0ge30pIHtcbiAgICBsZXQgc3ltYm9sX25hbWU7XG5cbiAgICBjb25mbGljdF9zY29wZXMgPSBmaW5kX3Njb3Blc192aXNpYmxlX2Zyb20oY29uZmxpY3Rfc2NvcGVzKTtcblxuICAgIGlmICh0ZW50YXRpdmVfbmFtZSkge1xuICAgICAgICAvLyBJbXBsZW1lbnQgaHlnaWVuZSAobm8gbmV3IG5hbWVzIGFyZSBjb25mbGljdGluZyB3aXRoIGV4aXN0aW5nIG5hbWVzKVxuICAgICAgICB0ZW50YXRpdmVfbmFtZSA9XG4gICAgICAgICAgICBzeW1ib2xfbmFtZSA9XG4gICAgICAgICAgICB0ZW50YXRpdmVfbmFtZS5yZXBsYWNlKC8oPzpeW15hLXpfJF18W15hLXowLTlfJF0pL2lnLCBcIl9cIik7XG5cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoY29uZmxpY3Rfc2NvcGVzLmZpbmQocyA9PiBzLmNvbmZsaWN0aW5nX2RlZl9zaGFsbG93KHN5bWJvbF9uYW1lKSkpIHtcbiAgICAgICAgICAgIHN5bWJvbF9uYW1lID0gdGVudGF0aXZlX25hbWUgKyBcIiRcIiArIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc3ltYm9sX25hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3ltYm9sIG5hbWUgY291bGQgYmUgZ2VuZXJhdGVkIGluIGNyZWF0ZV9zeW1ib2woKVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBzeW1ib2wgPSBtYWtlX25vZGUoU3ltQ2xhc3MsIHNvdXJjZSwge1xuICAgICAgICBuYW1lOiBzeW1ib2xfbmFtZSxcbiAgICAgICAgc2NvcGVcbiAgICB9KTtcblxuICAgIHRoaXMuZGVmX3ZhcmlhYmxlKHN5bWJvbCwgaW5pdCB8fCBudWxsKTtcblxuICAgIHN5bWJvbC5tYXJrX2VuY2xvc2VkKCk7XG5cbiAgICByZXR1cm4gc3ltYm9sO1xufSk7XG5cblxuQVNUX05vZGUuREVGTUVUSE9EKFwiaXNfYmxvY2tfc2NvcGVcIiwgcmV0dXJuX2ZhbHNlKTtcbkFTVF9DbGFzcy5ERUZNRVRIT0QoXCJpc19ibG9ja19zY29wZVwiLCByZXR1cm5fZmFsc2UpO1xuQVNUX0xhbWJkYS5ERUZNRVRIT0QoXCJpc19ibG9ja19zY29wZVwiLCByZXR1cm5fZmFsc2UpO1xuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcImlzX2Jsb2NrX3Njb3BlXCIsIHJldHVybl9mYWxzZSk7XG5BU1RfU3dpdGNoQnJhbmNoLkRFRk1FVEhPRChcImlzX2Jsb2NrX3Njb3BlXCIsIHJldHVybl9mYWxzZSk7XG5BU1RfQmxvY2suREVGTUVUSE9EKFwiaXNfYmxvY2tfc2NvcGVcIiwgcmV0dXJuX3RydWUpO1xuQVNUX1Njb3BlLkRFRk1FVEhPRChcImlzX2Jsb2NrX3Njb3BlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tfc2NvcGUgfHwgZmFsc2U7XG59KTtcbkFTVF9JdGVyYXRpb25TdGF0ZW1lbnQuREVGTUVUSE9EKFwiaXNfYmxvY2tfc2NvcGVcIiwgcmV0dXJuX3RydWUpO1xuXG5BU1RfTGFtYmRhLkRFRk1FVEhPRChcImluaXRfc2NvcGVfdmFyc1wiLCBmdW5jdGlvbigpIHtcbiAgICBBU1RfU2NvcGUucHJvdG90eXBlLmluaXRfc2NvcGVfdmFycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudXNlc19hcmd1bWVudHMgPSBmYWxzZTtcbiAgICB0aGlzLmRlZl92YXJpYWJsZShuZXcgQVNUX1N5bWJvbEZ1bmFyZyh7XG4gICAgICAgIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICBlbmQ6IHRoaXMuZW5kXG4gICAgfSkpO1xufSk7XG5cbkFTVF9BcnJvdy5ERUZNRVRIT0QoXCJpbml0X3Njb3BlX3ZhcnNcIiwgZnVuY3Rpb24oKSB7XG4gICAgQVNUX1Njb3BlLnByb3RvdHlwZS5pbml0X3Njb3BlX3ZhcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnVzZXNfYXJndW1lbnRzID0gZmFsc2U7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJtYXJrX2VuY2xvc2VkXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWYgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICB2YXIgcyA9IHRoaXMuc2NvcGU7XG4gICAgd2hpbGUgKHMpIHtcbiAgICAgICAgcHVzaF91bmlxKHMuZW5jbG9zZWQsIGRlZik7XG4gICAgICAgIGlmIChzID09PSBkZWYuc2NvcGUpIGJyZWFrO1xuICAgICAgICBzID0gcy5wYXJlbnRfc2NvcGU7XG4gICAgfVxufSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwicmVmZXJlbmNlXCIsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGVmaW5pdGlvbigpLnJlZmVyZW5jZXMucHVzaCh0aGlzKTtcbiAgICB0aGlzLm1hcmtfZW5jbG9zZWQoKTtcbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiZmluZF92YXJpYWJsZVwiLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSBuYW1lID0gbmFtZS5uYW1lO1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlcy5nZXQobmFtZSlcbiAgICAgICAgfHwgKHRoaXMucGFyZW50X3Njb3BlICYmIHRoaXMucGFyZW50X3Njb3BlLmZpbmRfdmFyaWFibGUobmFtZSkpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJkZWZfZnVuY3Rpb25cIiwgZnVuY3Rpb24oc3ltYm9sLCBpbml0KSB7XG4gICAgdmFyIGRlZiA9IHRoaXMuZGVmX3ZhcmlhYmxlKHN5bWJvbCwgaW5pdCk7XG4gICAgaWYgKCFkZWYuaW5pdCB8fCBkZWYuaW5pdCBpbnN0YW5jZW9mIEFTVF9EZWZ1bikgZGVmLmluaXQgPSBpbml0O1xuICAgIHJldHVybiBkZWY7XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcImRlZl92YXJpYWJsZVwiLCBmdW5jdGlvbihzeW1ib2wsIGluaXQpIHtcbiAgICB2YXIgZGVmID0gdGhpcy52YXJpYWJsZXMuZ2V0KHN5bWJvbC5uYW1lKTtcbiAgICBpZiAoZGVmKSB7XG4gICAgICAgIGRlZi5vcmlnLnB1c2goc3ltYm9sKTtcbiAgICAgICAgaWYgKGRlZi5pbml0ICYmIChkZWYuc2NvcGUgIT09IHN5bWJvbC5zY29wZSB8fCBkZWYuaW5pdCBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbikpIHtcbiAgICAgICAgICAgIGRlZi5pbml0ID0gaW5pdDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZiA9IG5ldyBTeW1ib2xEZWYodGhpcywgc3ltYm9sLCBpbml0KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KHN5bWJvbC5uYW1lLCBkZWYpO1xuICAgICAgICBkZWYuZ2xvYmFsID0gIXRoaXMucGFyZW50X3Njb3BlO1xuICAgIH1cbiAgICByZXR1cm4gc3ltYm9sLnRoZWRlZiA9IGRlZjtcbn0pO1xuXG5mdW5jdGlvbiBuZXh0X21hbmdsZWQoc2NvcGUsIG9wdGlvbnMpIHtcbiAgICBsZXQgZGVmdW5fc2NvcGU7XG4gICAgaWYgKFxuICAgICAgICBzY29wZXNfd2l0aF9ibG9ja19kZWZ1bnNcbiAgICAgICAgJiYgKGRlZnVuX3Njb3BlID0gc2NvcGUuZ2V0X2RlZnVuX3Njb3BlKCkpXG4gICAgICAgICYmIHNjb3Blc193aXRoX2Jsb2NrX2RlZnVucy5oYXMoZGVmdW5fc2NvcGUpXG4gICAgKSB7XG4gICAgICAgIHNjb3BlID0gZGVmdW5fc2NvcGU7XG4gICAgfVxuXG4gICAgdmFyIGV4dCA9IHNjb3BlLmVuY2xvc2VkO1xuICAgIHZhciBudGhfaWRlbnRpZmllciA9IG9wdGlvbnMubnRoX2lkZW50aWZpZXI7XG4gICAgb3V0OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbSA9IG50aF9pZGVudGlmaWVyLmdldCgrK3Njb3BlLmNuYW1lKTtcbiAgICAgICAgaWYgKEFMTF9SRVNFUlZFRF9XT1JEUy5oYXMobSkpIGNvbnRpbnVlOyAvLyBza2lwIG92ZXIgXCJkb1wiXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzI0MiAtLSBkbyBub3RcbiAgICAgICAgLy8gc2hhZG93IGEgbmFtZSByZXNlcnZlZCBmcm9tIG1hbmdsaW5nLlxuICAgICAgICBpZiAob3B0aW9ucy5yZXNlcnZlZC5oYXMobSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIEZ1bmN0aW9ucyB3aXRoIHNob3J0IG5hbWVzIG1pZ2h0IGNvbGxpZGUgd2l0aCBiYXNlNTQgb3V0cHV0XG4gICAgICAgIC8vIGFuZCB0aGVyZWZvcmUgY2F1c2UgY29sbGlzaW9ucyB3aGVuIGtlZXBfZm5hbWVzIGlzIHRydWUuXG4gICAgICAgIGlmICh1bm1hbmdsZWFibGVfbmFtZXMgJiYgdW5tYW5nbGVhYmxlX25hbWVzLmhhcyhtKSkgY29udGludWUgb3V0O1xuXG4gICAgICAgIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgdGhlIG1hbmdsZWQgbmFtZSBkb2VzIG5vdCBzaGFkb3cgYSBuYW1lXG4gICAgICAgIC8vIGZyb20gc29tZSBwYXJlbnQgc2NvcGUgdGhhdCBpcyByZWZlcmVuY2VkIGluIHRoaXMgb3IgaW5cbiAgICAgICAgLy8gaW5uZXIgc2NvcGVzLlxuICAgICAgICBmb3IgKGxldCBpID0gZXh0Lmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICBjb25zdCBkZWYgPSBleHRbaV07XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZGVmLm1hbmdsZWRfbmFtZSB8fCAoZGVmLnVubWFuZ2xlYWJsZShvcHRpb25zKSAmJiBkZWYubmFtZSk7XG4gICAgICAgICAgICBpZiAobSA9PSBuYW1lKSBjb250aW51ZSBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxufVxuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwibmV4dF9tYW5nbGVkXCIsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV4dF9tYW5nbGVkKHRoaXMsIG9wdGlvbnMpO1xufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJuZXh0X21hbmdsZWRcIiwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGxldCBuYW1lO1xuICAgIGNvbnN0IG1hbmdsZWRfbmFtZXMgPSB0aGlzLm1hbmdsZWRfbmFtZXM7XG4gICAgZG8ge1xuICAgICAgICBuYW1lID0gbmV4dF9tYW5nbGVkKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0gd2hpbGUgKG1hbmdsZWRfbmFtZXMuaGFzKG5hbWUpKTtcbiAgICByZXR1cm4gbmFtZTtcbn0pO1xuXG5BU1RfRnVuY3Rpb24uREVGTUVUSE9EKFwibmV4dF9tYW5nbGVkXCIsIGZ1bmN0aW9uKG9wdGlvbnMsIGRlZikge1xuICAgIC8vICMxNzksICMzMjZcbiAgICAvLyBpbiBTYWZhcmkgc3RyaWN0IG1vZGUsIHNvbWV0aGluZyBsaWtlIChmdW5jdGlvbiB4KHgpey4uLn0pIGlzIGEgc3ludGF4IGVycm9yO1xuICAgIC8vIGEgZnVuY3Rpb24gZXhwcmVzc2lvbidzIGFyZ3VtZW50IGNhbm5vdCBzaGFkb3cgdGhlIGZ1bmN0aW9uIGV4cHJlc3Npb24ncyBuYW1lXG5cbiAgICB2YXIgdHJpY2t5X2RlZiA9IGRlZi5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZyAmJiB0aGlzLm5hbWUgJiYgdGhpcy5uYW1lLmRlZmluaXRpb24oKTtcblxuICAgIC8vIHRoZSBmdW5jdGlvbidzIG1hbmdsZWRfbmFtZSBpcyBudWxsIHdoZW4ga2VlcF9mbmFtZXMgaXMgdHJ1ZVxuICAgIHZhciB0cmlja3lfbmFtZSA9IHRyaWNreV9kZWYgPyB0cmlja3lfZGVmLm1hbmdsZWRfbmFtZSB8fCB0cmlja3lfZGVmLm5hbWUgOiBudWxsO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuZXh0X21hbmdsZWQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghdHJpY2t5X25hbWUgfHwgdHJpY2t5X25hbWUgIT0gbmFtZSlcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbn0pO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcInVubWFuZ2xlYWJsZVwiLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRlZiA9IHRoaXMuZGVmaW5pdGlvbigpO1xuICAgIHJldHVybiAhZGVmIHx8IGRlZi51bm1hbmdsZWFibGUob3B0aW9ucyk7XG59KTtcblxuLy8gbGFiZWxzIGFyZSBhbHdheXMgbWFuZ2xlYWJsZVxuQVNUX0xhYmVsLkRFRk1FVEhPRChcInVubWFuZ2xlYWJsZVwiLCByZXR1cm5fZmFsc2UpO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcInVucmVmZXJlbmNlZFwiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMuZGVmaW5pdGlvbigpLnJlZmVyZW5jZXMubGVuZ3RoICYmICF0aGlzLnNjb3BlLnBpbm5lZCgpO1xufSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwiZGVmaW5pdGlvblwiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50aGVkZWY7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJnbG9iYWxcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlZGVmLmdsb2JhbDtcbn0pO1xuXG4vKipcbiAqIEZvcm1hdCB0aGUgbWFuZ2xlciBvcHRpb25zIChpZiBhbnkpIGludG8gdGhlaXIgYXBwcm9wcmlhdGUgdHlwZXNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0X21hbmdsZXJfb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgZXZhbCAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgbnRoX2lkZW50aWZpZXIgOiBiYXNlNTQsXG4gICAgICAgIGllOCAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGtlZXBfY2xhc3NuYW1lczogZmFsc2UsXG4gICAgICAgIGtlZXBfZm5hbWVzIDogZmFsc2UsXG4gICAgICAgIG1vZHVsZSAgICAgIDogZmFsc2UsXG4gICAgICAgIHJlc2VydmVkICAgIDogW10sXG4gICAgICAgIHRvcGxldmVsICAgIDogZmFsc2UsXG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMubW9kdWxlKSBvcHRpb25zLnRvcGxldmVsID0gdHJ1ZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5yZXNlcnZlZClcbiAgICAgICAgJiYgIShvcHRpb25zLnJlc2VydmVkIGluc3RhbmNlb2YgU2V0KVxuICAgICkge1xuICAgICAgICBvcHRpb25zLnJlc2VydmVkID0gW107XG4gICAgfVxuICAgIG9wdGlvbnMucmVzZXJ2ZWQgPSBuZXcgU2V0KG9wdGlvbnMucmVzZXJ2ZWQpO1xuICAgIC8vIE5ldmVyIG1hbmdsZSBhcmd1bWVudHNcbiAgICBvcHRpb25zLnJlc2VydmVkLmFkZChcImFyZ3VtZW50c1wiKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cblxuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcIm1hbmdsZV9uYW1lc1wiLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGZvcm1hdF9tYW5nbGVyX29wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIG50aF9pZGVudGlmaWVyID0gb3B0aW9ucy5udGhfaWRlbnRpZmllcjtcblxuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBtYW5nbGUgZGVjbGFyYXRpb24gbm9kZXMuICBTcGVjaWFsIGxvZ2ljIHdpcmVkXG4gICAgLy8gaW50byB0aGUgY29kZSBnZW5lcmF0b3Igd2lsbCBkaXNwbGF5IHRoZSBtYW5nbGVkIG5hbWUgaWYgaXQnc1xuICAgIC8vIHByZXNlbnQgKGFuZCBmb3IgQVNUX1N5bWJvbFJlZi1zIGl0J2xsIHVzZSB0aGUgbWFuZ2xlZCBuYW1lIG9mXG4gICAgLy8gdGhlIEFTVF9TeW1ib2xEZWNsYXJhdGlvbiB0aGF0IGl0IHBvaW50cyB0bykuXG4gICAgdmFyIGxuYW1lID0gLTE7XG4gICAgdmFyIHRvX21hbmdsZSA9IFtdO1xuXG4gICAgaWYgKG9wdGlvbnMua2VlcF9mbmFtZXMpIHtcbiAgICAgICAgZnVuY3Rpb25fZGVmcyA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYW5nbGVkX25hbWVzID0gdGhpcy5tYW5nbGVkX25hbWVzID0gbmV3IFNldCgpO1xuICAgIHVubWFuZ2xlYWJsZV9uYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChvcHRpb25zLmNhY2hlKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFscy5mb3JFYWNoKGNvbGxlY3QpO1xuICAgICAgICBpZiAob3B0aW9ucy5jYWNoZS5wcm9wcykge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWNoZS5wcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKG1hbmdsZWRfbmFtZSkge1xuICAgICAgICAgICAgICAgIG1hbmdsZWRfbmFtZXMuYWRkKG1hbmdsZWRfbmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWxlZFN0YXRlbWVudCkge1xuICAgICAgICAgICAgLy8gbG5hbWUgaXMgaW5jcmVtZW50ZWQgd2hlbiB3ZSBnZXQgdG8gdGhlIEFTVF9MYWJlbFxuICAgICAgICAgICAgdmFyIHNhdmVfbmVzdGluZyA9IGxuYW1lO1xuICAgICAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICAgICAgbG5hbWUgPSBzYXZlX25lc3Rpbmc7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgIC8vIGRvbid0IGRlc2NlbmQgYWdhaW4gaW4gVHJlZVdhbGtlclxuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW5cbiAgICAgICAgICAgICYmICEodHcucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfU2NvcGUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgc2NvcGVzX3dpdGhfYmxvY2tfZGVmdW5zID0gc2NvcGVzX3dpdGhfYmxvY2tfZGVmdW5zIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHNjb3Blc193aXRoX2Jsb2NrX2RlZnVucy5hZGQobm9kZS5wYXJlbnRfc2NvcGUuZ2V0X2RlZnVuX3Njb3BlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICBub2RlLnZhcmlhYmxlcy5mb3JFYWNoKGNvbGxlY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmlzX2Jsb2NrX3Njb3BlKCkpIHtcbiAgICAgICAgICAgIG5vZGUuYmxvY2tfc2NvcGUudmFyaWFibGVzLmZvckVhY2goY29sbGVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZnVuY3Rpb25fZGVmc1xuICAgICAgICAgICAgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9WYXJEZWZcbiAgICAgICAgICAgICYmIG5vZGUudmFsdWUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhXG4gICAgICAgICAgICAmJiAhbm9kZS52YWx1ZS5uYW1lXG4gICAgICAgICAgICAmJiBrZWVwX25hbWUob3B0aW9ucy5rZWVwX2ZuYW1lcywgbm9kZS5uYW1lLm5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZnVuY3Rpb25fZGVmcy5hZGQobm9kZS5uYW1lLmRlZmluaXRpb24oKS5pZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWwpIHtcbiAgICAgICAgICAgIGxldCBuYW1lO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBudGhfaWRlbnRpZmllci5nZXQoKytsbmFtZSk7XG4gICAgICAgICAgICB9IHdoaWxlIChBTExfUkVTRVJWRURfV09SRFMuaGFzKG5hbWUpKTtcbiAgICAgICAgICAgIG5vZGUubWFuZ2xlZF9uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG9wdGlvbnMuaWU4IHx8IG9wdGlvbnMuc2FmYXJpMTApICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2gpIHtcbiAgICAgICAgICAgIHRvX21hbmdsZS5wdXNoKG5vZGUuZGVmaW5pdGlvbigpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy53YWxrKHR3KTtcblxuICAgIGlmIChvcHRpb25zLmtlZXBfZm5hbWVzIHx8IG9wdGlvbnMua2VlcF9jbGFzc25hbWVzKSB7XG4gICAgICAgIC8vIENvbGxlY3QgYSBzZXQgb2Ygc2hvcnQgbmFtZXMgd2hpY2ggYXJlIHVubWFuZ2xlYWJsZSxcbiAgICAgICAgLy8gZm9yIHVzZSBpbiBhdm9pZGluZyBjb2xsaXNpb25zIGluIG5leHRfbWFuZ2xlZC5cbiAgICAgICAgdG9fbWFuZ2xlLmZvckVhY2goZGVmID0+IHtcbiAgICAgICAgICAgIGlmIChkZWYubmFtZS5sZW5ndGggPCA2ICYmIGRlZi51bm1hbmdsZWFibGUob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICB1bm1hbmdsZWFibGVfbmFtZXMuYWRkKGRlZi5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdG9fbWFuZ2xlLmZvckVhY2goZGVmID0+IHsgZGVmLm1hbmdsZShvcHRpb25zKTsgfSk7XG5cbiAgICBmdW5jdGlvbl9kZWZzID0gbnVsbDtcbiAgICB1bm1hbmdsZWFibGVfbmFtZXMgPSBudWxsO1xuICAgIHNjb3Blc193aXRoX2Jsb2NrX2RlZnVucyA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0KHN5bWJvbCkge1xuICAgICAgICBpZiAoc3ltYm9sLmV4cG9ydCAmIE1BU0tfRVhQT1JUX0RPTlRfTUFOR0xFKSB7XG4gICAgICAgICAgICB1bm1hbmdsZWFibGVfbmFtZXMuYWRkKHN5bWJvbC5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmICghb3B0aW9ucy5yZXNlcnZlZC5oYXMoc3ltYm9sLm5hbWUpKSB7XG4gICAgICAgICAgICB0b19tYW5nbGUucHVzaChzeW1ib2wpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJmaW5kX2NvbGxpZGluZ19uYW1lc1wiLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgY29uc3QgY2FjaGUgPSBvcHRpb25zLmNhY2hlICYmIG9wdGlvbnMuY2FjaGUucHJvcHM7XG4gICAgY29uc3QgYXZvaWQgPSBuZXcgU2V0KCk7XG4gICAgb3B0aW9ucy5yZXNlcnZlZC5mb3JFYWNoKHRvX2F2b2lkKTtcbiAgICB0aGlzLmdsb2JhbHMuZm9yRWFjaChhZGRfZGVmKTtcbiAgICB0aGlzLndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkgbm9kZS52YXJpYWJsZXMuZm9yRWFjaChhZGRfZGVmKTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2gpIGFkZF9kZWYobm9kZS5kZWZpbml0aW9uKCkpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gYXZvaWQ7XG5cbiAgICBmdW5jdGlvbiB0b19hdm9pZChuYW1lKSB7XG4gICAgICAgIGF2b2lkLmFkZChuYW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRfZGVmKGRlZikge1xuICAgICAgICB2YXIgbmFtZSA9IGRlZi5uYW1lO1xuICAgICAgICBpZiAoZGVmLmdsb2JhbCAmJiBjYWNoZSAmJiBjYWNoZS5oYXMobmFtZSkpIG5hbWUgPSBjYWNoZS5nZXQobmFtZSk7XG4gICAgICAgIGVsc2UgaWYgKCFkZWYudW5tYW5nbGVhYmxlKG9wdGlvbnMpKSByZXR1cm47XG4gICAgICAgIHRvX2F2b2lkKG5hbWUpO1xuICAgIH1cbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiZXhwYW5kX25hbWVzXCIsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZm9ybWF0X21hbmdsZXJfb3B0aW9ucyhvcHRpb25zKTtcbiAgICB2YXIgbnRoX2lkZW50aWZpZXIgPSBvcHRpb25zLm50aF9pZGVudGlmaWVyO1xuICAgIGlmIChudGhfaWRlbnRpZmllci5yZXNldCAmJiBudGhfaWRlbnRpZmllci5zb3J0KSB7XG4gICAgICAgIG50aF9pZGVudGlmaWVyLnJlc2V0KCk7XG4gICAgICAgIG50aF9pZGVudGlmaWVyLnNvcnQoKTtcbiAgICB9XG4gICAgdmFyIGF2b2lkID0gdGhpcy5maW5kX2NvbGxpZGluZ19uYW1lcyhvcHRpb25zKTtcbiAgICB2YXIgY25hbWUgPSAwO1xuICAgIHRoaXMuZ2xvYmFscy5mb3JFYWNoKHJlbmFtZSk7XG4gICAgdGhpcy53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIG5vZGUudmFyaWFibGVzLmZvckVhY2gocmVuYW1lKTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2gpIHJlbmFtZShub2RlLmRlZmluaXRpb24oKSk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gbmV4dF9uYW1lKCkge1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbmFtZSA9IG50aF9pZGVudGlmaWVyLmdldChjbmFtZSsrKTtcbiAgICAgICAgfSB3aGlsZSAoYXZvaWQuaGFzKG5hbWUpIHx8IEFMTF9SRVNFUlZFRF9XT1JEUy5oYXMobmFtZSkpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5hbWUoZGVmKSB7XG4gICAgICAgIGlmIChkZWYuZ2xvYmFsICYmIG9wdGlvbnMuY2FjaGUpIHJldHVybjtcbiAgICAgICAgaWYgKGRlZi51bm1hbmdsZWFibGUob3B0aW9ucykpIHJldHVybjtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVzZXJ2ZWQuaGFzKGRlZi5uYW1lKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCByZWRlZmluaXRpb24gPSByZWRlZmluZWRfY2F0Y2hfZGVmKGRlZik7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkZWYubmFtZSA9IHJlZGVmaW5pdGlvbiA/IHJlZGVmaW5pdGlvbi5uYW1lIDogbmV4dF9uYW1lKCk7XG4gICAgICAgIGRlZi5vcmlnLmZvckVhY2goZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICBzeW0ubmFtZSA9IG5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYucmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgc3ltLm5hbWUgPSBuYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuQVNUX05vZGUuREVGTUVUSE9EKFwidGFpbF9ub2RlXCIsIHJldHVybl90aGlzKTtcbkFTVF9TZXF1ZW5jZS5ERUZNRVRIT0QoXCJ0YWlsX25vZGVcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbnNbdGhpcy5leHByZXNzaW9ucy5sZW5ndGggLSAxXTtcbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiY29tcHV0ZV9jaGFyX2ZyZXF1ZW5jeVwiLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGZvcm1hdF9tYW5nbGVyX29wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIG50aF9pZGVudGlmaWVyID0gb3B0aW9ucy5udGhfaWRlbnRpZmllcjtcbiAgICBpZiAoIW50aF9pZGVudGlmaWVyLnJlc2V0IHx8ICFudGhfaWRlbnRpZmllci5jb25zaWRlciB8fCAhbnRoX2lkZW50aWZpZXIuc29ydCkge1xuICAgICAgICAvLyBJZiB0aGUgaWRlbnRpZmllciBtYW5nbGVyIGlzIGludmFyaWFudCwgc2tpcCBjb21wdXRpbmcgY2hhcmFjdGVyIGZyZXF1ZW5jeS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBudGhfaWRlbnRpZmllci5yZXNldCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgQVNUX05vZGUucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24oc3RyZWFtLCBmb3JjZV9wYXJlbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaW50KHN0cmVhbSwgZm9yY2VfcGFyZW5zKTtcbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQVNUX1N5bWJvbCAmJiAhdGhpcy51bm1hbmdsZWFibGUob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBudGhfaWRlbnRpZmllci5jb25zaWRlcih0aGlzLm5hbWUsIC0xKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBBU1RfRG90SGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBudGhfaWRlbnRpZmllci5jb25zaWRlcihcIiNcIiArIHRoaXMucHJvcGVydHksIC0xKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBBU1RfRG90KSB7XG4gICAgICAgICAgICAgICAgICAgIG50aF9pZGVudGlmaWVyLmNvbnNpZGVyKHRoaXMucHJvcGVydHksIC0xKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBBU1RfU3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBfc3RyaW5nKHRoaXMucHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbnRoX2lkZW50aWZpZXIuY29uc2lkZXIodGhpcy5wcmludF90b19zdHJpbmcoKSwgMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgQVNUX05vZGUucHJvdG90eXBlLnByaW50ID0gQVNUX05vZGUucHJvdG90eXBlLl9wcmludDtcbiAgICB9XG4gICAgbnRoX2lkZW50aWZpZXIuc29ydCgpO1xuXG4gICAgZnVuY3Rpb24gc2tpcF9zdHJpbmcobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcpIHtcbiAgICAgICAgICAgIG50aF9pZGVudGlmaWVyLmNvbnNpZGVyKG5vZGUudmFsdWUsIC0xKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICBza2lwX3N0cmluZyhub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICAgICAgc2tpcF9zdHJpbmcobm9kZS5hbHRlcm5hdGl2ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICAgICAgc2tpcF9zdHJpbmcobm9kZS50YWlsX25vZGUoKSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgYmFzZTU0ID0gKCgpID0+IHtcbiAgICBjb25zdCBsZWFkaW5nID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF9cIi5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBkaWdpdHMgPSBcIjAxMjM0NTY3ODlcIi5zcGxpdChcIlwiKTtcbiAgICBsZXQgY2hhcnM7XG4gICAgbGV0IGZyZXF1ZW5jeTtcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgZnJlcXVlbmN5ID0gbmV3IE1hcCgpO1xuICAgICAgICBsZWFkaW5nLmZvckVhY2goZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICAgIGZyZXF1ZW5jeS5zZXQoY2gsIDApO1xuICAgICAgICB9KTtcbiAgICAgICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICAgIGZyZXF1ZW5jeS5zZXQoY2gsIDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc2lkZXIoc3RyLCBkZWx0YSkge1xuICAgICAgICBmb3IgKHZhciBpID0gc3RyLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICBmcmVxdWVuY3kuc2V0KHN0cltpXSwgZnJlcXVlbmN5LmdldChzdHJbaV0pICsgZGVsdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgICByZXR1cm4gZnJlcXVlbmN5LmdldChiKSAtIGZyZXF1ZW5jeS5nZXQoYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgICAgIGNoYXJzID0gbWVyZ2VTb3J0KGxlYWRpbmcsIGNvbXBhcmUpLmNvbmNhdChtZXJnZVNvcnQoZGlnaXRzLCBjb21wYXJlKSk7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGlzIGlzIGluIGEgdXNhYmxlIGluaXRpYWwgc3RhdGUuXG4gICAgcmVzZXQoKTtcbiAgICBzb3J0KCk7XG4gICAgZnVuY3Rpb24gYmFzZTU0KG51bSkge1xuICAgICAgICB2YXIgcmV0ID0gXCJcIiwgYmFzZSA9IDU0O1xuICAgICAgICBudW0rKztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbnVtLS07XG4gICAgICAgICAgICByZXQgKz0gY2hhcnNbbnVtICUgYmFzZV07XG4gICAgICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGJhc2UpO1xuICAgICAgICAgICAgYmFzZSA9IDY0O1xuICAgICAgICB9IHdoaWxlIChudW0gPiAwKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGJhc2U1NCxcbiAgICAgICAgY29uc2lkZXIsXG4gICAgICAgIHJlc2V0LFxuICAgICAgICBzb3J0XG4gICAgfTtcbn0pKCk7XG5cbmxldCBtYW5nbGVfb3B0aW9ucyA9IHVuZGVmaW5lZDtcbkFTVF9Ob2RlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKGNvbXByZXNzb3IsIHN0YWNrKSB7XG4gICAgbWFuZ2xlX29wdGlvbnMgPSBjb21wcmVzc29yICYmIGNvbXByZXNzb3IuX21hbmdsZV9vcHRpb25zO1xuXG4gICAgbGV0IHNpemUgPSAwO1xuICAgIHdhbGtfcGFyZW50KHRoaXMsIChub2RlLCBpbmZvKSA9PiB7XG4gICAgICAgIHNpemUgKz0gbm9kZS5fc2l6ZShpbmZvKTtcblxuICAgICAgICAvLyBCcmFjZWxlc3MgYXJyb3cgZnVuY3Rpb25zIGhhdmUgZmFrZSBcInJldHVyblwiIHN0YXRlbWVudHNcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXJyb3cgJiYgbm9kZS5pc19icmFjZWxlc3MoKSkge1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlLmJvZHlbMF0udmFsdWUuX3NpemUoaW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHN0YWNrIHx8IChjb21wcmVzc29yICYmIGNvbXByZXNzb3Iuc3RhY2spKTtcblxuICAgIC8vIGp1c3QgdG8gc2F2ZSBhIGJpdCBvZiBtZW1vcnlcbiAgICBtYW5nbGVfb3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBzaXplO1xufTtcblxuQVNUX05vZGUucHJvdG90eXBlLl9zaXplID0gKCkgPT4gMDtcblxuQVNUX0RlYnVnZ2VyLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDg7XG5cbkFTVF9EaXJlY3RpdmUucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE8gc3RyaW5nIGVuY29kaW5nIHN0dWZmXG4gICAgcmV0dXJuIDIgKyB0aGlzLnZhbHVlLmxlbmd0aDtcbn07XG5cbi8qKiBDb3VudCBjb21tYXMvc2VtaWNvbG9ucyBuZWNlc3NhcnkgdG8gc2hvdyBhIGxpc3Qgb2YgZXhwcmVzc2lvbnMvc3RhdGVtZW50cyAqL1xuY29uc3QgbGlzdF9vdmVyaGVhZCA9IChhcnJheSkgPT4gYXJyYXkubGVuZ3RoICYmIGFycmF5Lmxlbmd0aCAtIDE7XG5cbkFTVF9CbG9jay5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDIgKyBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSk7XG59O1xuXG5BU1RfVG9wbGV2ZWwucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxpc3Rfb3ZlcmhlYWQodGhpcy5ib2R5KTtcbn07XG5cbkFTVF9FbXB0eVN0YXRlbWVudC5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiAxO1xuXG5BU1RfTGFiZWxlZFN0YXRlbWVudC5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiAyOyAgLy8geDpcblxuQVNUX0RvLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDk7XG5cbkFTVF9XaGlsZS5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA3O1xuXG5BU1RfRm9yLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDg7XG5cbkFTVF9Gb3JJbi5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA4O1xuLy8gQVNUX0Zvck9mIGluaGVyaXRzIF5cblxuQVNUX1dpdGgucHJvdG90eXBlLl9zaXplID0gKCkgPT4gNjtcblxuQVNUX0V4cGFuc2lvbi5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiAzO1xuXG5jb25zdCBsYW1iZGFfbW9kaWZpZXJzID0gZnVuYyA9PlxuICAgIChmdW5jLmlzX2dlbmVyYXRvciA/IDEgOiAwKSArIChmdW5jLmFzeW5jID8gNiA6IDApO1xuXG5BU1RfQWNjZXNzb3IucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsYW1iZGFfbW9kaWZpZXJzKHRoaXMpICsgNCArIGxpc3Rfb3ZlcmhlYWQodGhpcy5hcmduYW1lcykgKyBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSk7XG59O1xuXG5BU1RfRnVuY3Rpb24ucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICBjb25zdCBmaXJzdCA9ICEhZmlyc3RfaW5fc3RhdGVtZW50KGluZm8pO1xuICAgIHJldHVybiAoZmlyc3QgKiAyKSArIGxhbWJkYV9tb2RpZmllcnModGhpcykgKyAxMiArIGxpc3Rfb3ZlcmhlYWQodGhpcy5hcmduYW1lcykgKyBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSk7XG59O1xuXG5BU1RfRGVmdW4ucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsYW1iZGFfbW9kaWZpZXJzKHRoaXMpICsgMTMgKyBsaXN0X292ZXJoZWFkKHRoaXMuYXJnbmFtZXMpICsgbGlzdF9vdmVyaGVhZCh0aGlzLmJvZHkpO1xufTtcblxuQVNUX0Fycm93LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgYXJnc19hbmRfYXJyb3cgPSAyICsgbGlzdF9vdmVyaGVhZCh0aGlzLmFyZ25hbWVzKTtcblxuICAgIGlmIChcbiAgICAgICAgIShcbiAgICAgICAgICAgIHRoaXMuYXJnbmFtZXMubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAmJiB0aGlzLmFyZ25hbWVzWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbFxuICAgICAgICApXG4gICAgKSB7XG4gICAgICAgIGFyZ3NfYW5kX2Fycm93ICs9IDI7IC8vIHBhcmVucyBhcm91bmQgdGhlIGFyZ3NcbiAgICB9XG5cbiAgICBjb25zdCBib2R5X292ZXJoZWFkID0gdGhpcy5pc19icmFjZWxlc3MoKSA/IDAgOiBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSkgKyAyO1xuXG4gICAgcmV0dXJuIGxhbWJkYV9tb2RpZmllcnModGhpcykgKyBhcmdzX2FuZF9hcnJvdyArIGJvZHlfb3ZlcmhlYWQ7XG59O1xuXG5BU1RfRGVzdHJ1Y3R1cmluZy5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiAyO1xuXG5BU1RfVGVtcGxhdGVTdHJpbmcucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAyICsgKE1hdGguZmxvb3IodGhpcy5zZWdtZW50cy5sZW5ndGggLyAyKSAqIDMpOyAgLyogXCIke31cIiAqL1xufTtcblxuQVNUX1RlbXBsYXRlU2VnbWVudC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUubGVuZ3RoO1xufTtcblxuQVNUX1JldHVybi5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPyA3IDogNjtcbn07XG5cbkFTVF9UaHJvdy5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA2O1xuXG5BU1RfQnJlYWsucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsID8gNiA6IDU7XG59O1xuXG5BU1RfQ29udGludWUucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsID8gOSA6IDg7XG59O1xuXG5BU1RfSWYucHJvdG90eXBlLl9zaXplID0gKCkgPT4gNDtcblxuQVNUX1N3aXRjaC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDggKyBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSk7XG59O1xuXG5BU1RfQ2FzZS5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDUgKyBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSk7XG59O1xuXG5BU1RfRGVmYXVsdC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDggKyBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSk7XG59O1xuXG5BU1RfVHJ5LnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDM7XG5cbkFTVF9DYXRjaC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHNpemUgPSA3ICsgbGlzdF9vdmVyaGVhZCh0aGlzLmJvZHkpO1xuICAgIGlmICh0aGlzLmFyZ25hbWUpIHtcbiAgICAgICAgc2l6ZSArPSAyO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn07XG5cbkFTVF9GaW5hbGx5LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gNyArIGxpc3Rfb3ZlcmhlYWQodGhpcy5ib2R5KTtcbn07XG5cbkFTVF9WYXIucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiA0ICsgbGlzdF9vdmVyaGVhZCh0aGlzLmRlZmluaXRpb25zKTtcbn07XG5cbkFTVF9MZXQucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiA0ICsgbGlzdF9vdmVyaGVhZCh0aGlzLmRlZmluaXRpb25zKTtcbn07XG5cbkFTVF9Db25zdC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDYgKyBsaXN0X292ZXJoZWFkKHRoaXMuZGVmaW5pdGlvbnMpO1xufTtcblxuQVNUX1VzaW5nLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhd2FpdF9zaXplID0gdGhpcy5hd2FpdCA/IDYgOiAwO1xuICAgIHJldHVybiBhd2FpdF9zaXplICsgNiArIGxpc3Rfb3ZlcmhlYWQodGhpcy5kZWZpbml0aW9ucyk7XG59O1xuXG5BU1RfVmFyRGVmTGlrZS5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPyAxIDogMDtcbn07XG5cbkFTVF9OYW1lTWFwcGluZy5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZm9yZWlnbiBuYW1lIGlzbid0IG1hbmdsZWRcbiAgICByZXR1cm4gdGhpcy5uYW1lID8gNCA6IDA7XG59O1xuXG5BU1RfSW1wb3J0LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBpbXBvcnRcbiAgICBsZXQgc2l6ZSA9IDY7XG5cbiAgICBpZiAodGhpcy5pbXBvcnRlZF9uYW1lKSBzaXplICs9IDE7XG5cbiAgICAvLyBmcm9tXG4gICAgaWYgKHRoaXMuaW1wb3J0ZWRfbmFtZSB8fCB0aGlzLmltcG9ydGVkX25hbWVzKSBzaXplICs9IDU7XG5cbiAgICAvLyBicmFjZXMsIGFuZCB0aGUgY29tbWFzXG4gICAgaWYgKHRoaXMuaW1wb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgc2l6ZSArPSAyICsgbGlzdF9vdmVyaGVhZCh0aGlzLmltcG9ydGVkX25hbWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZTtcbn07XG5cbkFTVF9JbXBvcnRNZXRhLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDExO1xuXG5BU1RfRXhwb3J0LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgc2l6ZSA9IDcgKyAodGhpcy5pc19kZWZhdWx0ID8gOCA6IDApO1xuXG4gICAgaWYgKHRoaXMuZXhwb3J0ZWRfdmFsdWUpIHtcbiAgICAgICAgc2l6ZSArPSB0aGlzLmV4cG9ydGVkX3ZhbHVlLl9zaXplKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgLy8gQnJhY2VzIGFuZCBjb21tYXNcbiAgICAgICAgc2l6ZSArPSAyICsgbGlzdF9vdmVyaGVhZCh0aGlzLmV4cG9ydGVkX25hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tb2R1bGVfbmFtZSkge1xuICAgICAgICAvLyBcImZyb20gXCJcbiAgICAgICAgc2l6ZSArPSA1O1xuICAgIH1cblxuICAgIHJldHVybiBzaXplO1xufTtcblxuQVNUX0NhbGwucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiA0ICsgbGlzdF9vdmVyaGVhZCh0aGlzLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gMiArIGxpc3Rfb3ZlcmhlYWQodGhpcy5hcmdzKTtcbn07XG5cbkFTVF9OZXcucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiA2ICsgbGlzdF9vdmVyaGVhZCh0aGlzLmFyZ3MpO1xufTtcblxuQVNUX1NlcXVlbmNlLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbGlzdF9vdmVyaGVhZCh0aGlzLmV4cHJlc3Npb25zKTtcbn07XG5cbkFTVF9Eb3QucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5Lmxlbmd0aCArIDI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb3BlcnR5Lmxlbmd0aCArIDE7XG59O1xuXG5BU1RfRG90SGFzaC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkubGVuZ3RoICsgMztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydHkubGVuZ3RoICsgMjtcbn07XG5cbkFTVF9TdWIucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsID8gNCA6IDI7XG59O1xuXG5BU1RfVW5hcnkucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSBcInR5cGVvZlwiKSByZXR1cm4gNztcbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gXCJ2b2lkXCIpIHJldHVybiA1O1xuICAgIHJldHVybiB0aGlzLm9wZXJhdG9yLmxlbmd0aDtcbn07XG5cbkFTVF9CaW5hcnkucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gXCJpblwiKSByZXR1cm4gNDtcblxuICAgIGxldCBzaXplID0gdGhpcy5vcGVyYXRvci5sZW5ndGg7XG5cbiAgICBpZiAoXG4gICAgICAgICh0aGlzLm9wZXJhdG9yID09PSBcIitcIiB8fCB0aGlzLm9wZXJhdG9yID09PSBcIi1cIilcbiAgICAgICAgJiYgdGhpcy5yaWdodCBpbnN0YW5jZW9mIEFTVF9VbmFyeSAmJiB0aGlzLnJpZ2h0Lm9wZXJhdG9yID09PSB0aGlzLm9wZXJhdG9yXG4gICAgKSB7XG4gICAgICAgIC8vIDErICthID4gbmVlZHMgc3BhY2UgYmV0d2VlbiB0aGUgK1xuICAgICAgICBzaXplICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVlZHNfcGFyZW5zKGluZm8pKSB7XG4gICAgICAgIHNpemUgKz0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZTtcbn07XG5cbkFTVF9Db25kaXRpb25hbC5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiAzO1xuXG5BU1RfQXJyYXkucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAyICsgbGlzdF9vdmVyaGVhZCh0aGlzLmVsZW1lbnRzKTtcbn07XG5cbkFTVF9PYmplY3QucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICBsZXQgYmFzZSA9IDI7XG4gICAgaWYgKGZpcnN0X2luX3N0YXRlbWVudChpbmZvKSkge1xuICAgICAgICBiYXNlICs9IDI7IC8vIHBhcmVuc1xuICAgIH1cbiAgICByZXR1cm4gYmFzZSArIGxpc3Rfb3ZlcmhlYWQodGhpcy5wcm9wZXJ0aWVzKTtcbn07XG5cbi8qI19fSU5MSU5FX18qL1xuY29uc3Qga2V5X3NpemUgPSBrZXkgPT5cbiAgICB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiID8ga2V5Lmxlbmd0aCA6IDA7XG5cbkFTVF9PYmplY3RLZXlWYWwucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBrZXlfc2l6ZSh0aGlzLmtleSkgKyAxO1xufTtcblxuLyojX19JTkxJTkVfXyovXG5jb25zdCBzdGF0aWNfc2l6ZSA9IGlzX3N0YXRpYyA9PiBpc19zdGF0aWMgPyA3IDogMDtcblxuQVNUX09iamVjdEdldHRlci5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDUgKyBzdGF0aWNfc2l6ZSh0aGlzLnN0YXRpYykgKyBrZXlfc2l6ZSh0aGlzLmtleSk7XG59O1xuXG5BU1RfT2JqZWN0U2V0dGVyLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gNSArIHN0YXRpY19zaXplKHRoaXMuc3RhdGljKSArIGtleV9zaXplKHRoaXMua2V5KTtcbn07XG5cbkFTVF9Db25jaXNlTWV0aG9kLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RhdGljX3NpemUodGhpcy5zdGF0aWMpICsga2V5X3NpemUodGhpcy5rZXkpO1xufTtcblxuQVNUX1ByaXZhdGVNZXRob2QucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBU1RfQ29uY2lzZU1ldGhvZC5wcm90b3R5cGUuX3NpemUuY2FsbCh0aGlzKSArIDE7XG59O1xuXG5BU1RfUHJpdmF0ZUdldHRlci5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFTVF9Db25jaXNlTWV0aG9kLnByb3RvdHlwZS5fc2l6ZS5jYWxsKHRoaXMpICsgNDtcbn07XG5cbkFTVF9Qcml2YXRlU2V0dGVyLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQVNUX0NvbmNpc2VNZXRob2QucHJvdG90eXBlLl9zaXplLmNhbGwodGhpcykgKyA0O1xufTtcblxuQVNUX1ByaXZhdGVJbi5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDU7IC8vIFwiI1wiLCBhbmQgXCIgaW4gXCJcbn07XG5cbkFTVF9DbGFzcy5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKHRoaXMubmFtZSA/IDggOiA3KVxuICAgICAgICArICh0aGlzLmV4dGVuZHMgPyA4IDogMClcbiAgICApO1xufTtcblxuQVNUX0NsYXNzU3RhdGljQmxvY2sucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFwic3RhdGlje31cIiArIHNlbWljb2xvbnNcbiAgICByZXR1cm4gOCArIGxpc3Rfb3ZlcmhlYWQodGhpcy5ib2R5KTtcbn07XG5cbkFTVF9DbGFzc1Byb3BlcnR5LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBzdGF0aWNfc2l6ZSh0aGlzLnN0YXRpYylcbiAgICAgICAgKyAodHlwZW9mIHRoaXMua2V5ID09PSBcInN0cmluZ1wiID8gdGhpcy5rZXkubGVuZ3RoICsgMiA6IDApXG4gICAgICAgICsgKHRoaXMudmFsdWUgPyAxIDogMClcbiAgICApO1xufTtcblxuQVNUX0NsYXNzUHJpdmF0ZVByb3BlcnR5LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQVNUX0NsYXNzUHJvcGVydHkucHJvdG90eXBlLl9zaXplLmNhbGwodGhpcykgKyAxO1xufTtcblxuQVNUX1N5bWJvbC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCEobWFuZ2xlX29wdGlvbnMgJiYgdGhpcy50aGVkZWYgJiYgIXRoaXMudGhlZGVmLnVubWFuZ2xlYWJsZShtYW5nbGVfb3B0aW9ucykpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbn07XG5cbi8vIFRPRE8gdGFrZSBwcm9wbWFuZ2xlIGludG8gYWNjb3VudFxuQVNUX1N5bWJvbENsYXNzUHJvcGVydHkucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWUubGVuZ3RoO1xufTtcblxuQVNUX1N5bWJvbFJlZi5wcm90b3R5cGUuX3NpemUgPSBBU1RfU3ltYm9sRGVjbGFyYXRpb24ucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm5hbWUgPT09IFwiYXJndW1lbnRzXCIpIHJldHVybiA5O1xuXG4gICAgcmV0dXJuIEFTVF9TeW1ib2wucHJvdG90eXBlLl9zaXplLmNhbGwodGhpcyk7XG59O1xuXG5BU1RfTmV3VGFyZ2V0LnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDEwO1xuXG5BU1RfU3ltYm9sSW1wb3J0Rm9yZWlnbi5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZS5sZW5ndGg7XG59O1xuXG5BU1RfU3ltYm9sRXhwb3J0Rm9yZWlnbi5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZS5sZW5ndGg7XG59O1xuXG5BU1RfVGhpcy5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA0O1xuXG5BU1RfU3VwZXIucHJvdG90eXBlLl9zaXplID0gKCkgPT4gNTtcblxuQVNUX1N0cmluZy5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUubGVuZ3RoICsgMjtcbn07XG5cbkFTVF9OdW1iZXIucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXM7XG4gICAgaWYgKHZhbHVlID09PSAwKSByZXR1cm4gMTtcbiAgICBpZiAodmFsdWUgPiAwICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZzEwKHZhbHVlKSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS5sZW5ndGg7XG59O1xuXG5BU1RfQmlnSW50LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5sZW5ndGg7XG59O1xuXG5BU1RfUmVnRXhwLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn07XG5cbkFTVF9OdWxsLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDQ7XG5cbkFTVF9OYU4ucHJvdG90eXBlLl9zaXplID0gKCkgPT4gMztcblxuQVNUX1VuZGVmaW5lZC5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA2OyAvLyBcInZvaWQgMFwiXG5cbkFTVF9Ib2xlLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDA7ICAvLyBjb21tYSBpcyB0YWtlbiBpbnRvIGFjY291bnQgYnkgbGlzdF9vdmVyaGVhZCgpXG5cbkFTVF9JbmZpbml0eS5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA4O1xuXG5BU1RfVHJ1ZS5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA0O1xuXG5BU1RfRmFsc2UucHJvdG90eXBlLl9zaXplID0gKCkgPT4gNTtcblxuQVNUX0F3YWl0LnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDY7XG5cbkFTVF9ZaWVsZC5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA2O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIGJpdGZpZWxkIGZsYWdzIHRvIGJlIHN0b3JlZCBpbiBub2RlLmZsYWdzLlxuLy8gVGhlc2UgYXJlIHNldCBhbmQgdW5zZXQgZHVyaW5nIGNvbXByZXNzaW9uLCBhbmQgc3RvcmUgaW5mb3JtYXRpb24gaW4gdGhlIG5vZGUgd2l0aG91dCByZXF1aXJpbmcgbXVsdGlwbGUgZmllbGRzLlxuY29uc3QgVU5VU0VEID0gMGIwMDAwMDAwMTtcbmNvbnN0IFRSVVRIWSA9IDBiMDAwMDAwMTA7XG5jb25zdCBGQUxTWSA9IDBiMDAwMDAxMDA7XG5jb25zdCBVTkRFRklORUQgPSAwYjAwMDAxMDAwO1xuY29uc3QgSU5MSU5FRCA9IDBiMDAwMTAwMDA7XG4vLyBOb2RlcyB0byB3aGljaCB2YWx1ZXMgYXJlIGV2ZXIgd3JpdHRlbi4gVXNlZCB3aGVuIGtlZXBfYXNzaWduIGlzIHBhcnQgb2YgdGhlIHVudXNlZCBvcHRpb24gc3RyaW5nLlxuY29uc3QgV1JJVEVfT05MWSA9IDBiMDAxMDAwMDA7XG5cbi8vIGluZm9ybWF0aW9uIHNwZWNpZmljIHRvIGEgc2luZ2xlIGNvbXByZXNzaW9uIHBhc3NcbmNvbnN0IFNRVUVFWkVEID0gMGIwMDAwMDAwMTAwMDAwMDAwO1xuY29uc3QgT1BUSU1JWkVEID0gMGIwMDAwMDAxMDAwMDAwMDAwO1xuY29uc3QgVE9QID0gMGIwMDAwMDEwMDAwMDAwMDAwO1xuY29uc3QgQ0xFQVJfQkVUV0VFTl9QQVNTRVMgPSBTUVVFRVpFRCB8IE9QVElNSVpFRCB8IFRPUDtcblxuY29uc3QgaGFzX2ZsYWcgPSAobm9kZSwgZmxhZykgPT4gbm9kZS5mbGFncyAmIGZsYWc7XG5jb25zdCBzZXRfZmxhZyA9IChub2RlLCBmbGFnKSA9PiB7IG5vZGUuZmxhZ3MgfD0gZmxhZzsgfTtcbmNvbnN0IGNsZWFyX2ZsYWcgPSAobm9kZSwgZmxhZykgPT4geyBub2RlLmZsYWdzICY9IH5mbGFnOyB9O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIG1lcmdlX3NlcXVlbmNlKGFycmF5LCBub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UpIHtcbiAgICAgICAgYXJyYXkucHVzaCguLi5ub2RlLmV4cHJlc3Npb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIG1ha2Vfc2VxdWVuY2Uob3JpZywgZXhwcmVzc2lvbnMpIHtcbiAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09IDEpIHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09IDApIHRocm93IG5ldyBFcnJvcihcInRyeWluZyB0byBjcmVhdGUgYSBzZXF1ZW5jZSB3aXRoIGxlbmd0aCB6ZXJvIVwiKTtcbiAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TZXF1ZW5jZSwgb3JpZywge1xuICAgICAgICBleHByZXNzaW9uczogZXhwcmVzc2lvbnMucmVkdWNlKG1lcmdlX3NlcXVlbmNlLCBbXSlcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZV9lbXB0eV9mdW5jdGlvbihzZWxmKSB7XG4gICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRnVuY3Rpb24sIHNlbGYsIHtcbiAgICAgICAgdXNlc19hcmd1bWVudHM6IGZhbHNlLFxuICAgICAgICBhcmduYW1lczogW10sXG4gICAgICAgIGJvZHk6IFtdLFxuICAgICAgICBpc19nZW5lcmF0b3I6IGZhbHNlLFxuICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgIHZhcmlhYmxlczogbmV3IE1hcCgpLFxuICAgICAgICB1c2VzX3dpdGg6IGZhbHNlLFxuICAgICAgICB1c2VzX2V2YWw6IGZhbHNlLFxuICAgICAgICBwYXJlbnRfc2NvcGU6IG51bGwsXG4gICAgICAgIGVuY2xvc2VkOiBbXSxcbiAgICAgICAgY25hbWU6IDAsXG4gICAgICAgIGJsb2NrX3Njb3BlOiB1bmRlZmluZWQsXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KHZhbCwgb3JpZykge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TdHJpbmcsIG9yaWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWxcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGlmIChpc05hTih2YWwpKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9OYU4sIG9yaWcpO1xuICAgICAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLyB2YWwgPCAwID8gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgb3JpZywge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIi1cIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX051bWJlciwgb3JpZywgeyB2YWx1ZTogLXZhbCB9KVxuICAgICAgICAgICAgfSkgOiBtYWtlX25vZGUoQVNUX051bWJlciwgb3JpZywgeyB2YWx1ZTogdmFsIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWwgPCAwID8gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgb3JpZywge1xuICAgICAgICAgICAgb3BlcmF0b3I6IFwiLVwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogbWFrZV9ub2RlKEFTVF9JbmZpbml0eSwgb3JpZylcbiAgICAgICAgfSkgOiBtYWtlX25vZGUoQVNUX0luZmluaXR5LCBvcmlnKTtcbiAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmlnSW50LCBvcmlnLCB7IHZhbHVlOiB2YWwudG9TdHJpbmcoKSB9KTtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUodmFsID8gQVNUX1RydWUgOiBBU1RfRmFsc2UsIG9yaWcpO1xuICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIG9yaWcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfTnVsbCwgb3JpZywgeyB2YWx1ZTogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9SZWdFeHAsIG9yaWcsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHJlZ2V4cF9zb3VyY2VfZml4KHZhbC5zb3VyY2UpLFxuICAgICAgICAgICAgICAgICAgICBmbGFnczogdmFsLmZsYWdzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ190ZW1wbGF0ZShcIkNhbid0IGhhbmRsZSBjb25zdGFudCBvZiB0eXBlOiB7dHlwZX1cIiwge1xuICAgICAgICAgICAgdHlwZTogdHlwZW9mIHZhbFxuICAgICAgICB9KSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiZXN0X29mX2V4cHJlc3Npb24oYXN0MSwgYXN0Mikge1xuICAgIHJldHVybiBhc3QxLnNpemUoKSA+IGFzdDIuc2l6ZSgpID8gYXN0MiA6IGFzdDE7XG59XG5cbmZ1bmN0aW9uIGJlc3Rfb2Zfc3RhdGVtZW50KGFzdDEsIGFzdDIpIHtcbiAgICByZXR1cm4gYmVzdF9vZl9leHByZXNzaW9uKFxuICAgICAgICBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgYXN0MSwge1xuICAgICAgICAgICAgYm9keTogYXN0MVxuICAgICAgICB9KSxcbiAgICAgICAgbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGFzdDIsIHtcbiAgICAgICAgICAgIGJvZHk6IGFzdDJcbiAgICAgICAgfSlcbiAgICApLmJvZHk7XG59XG5cbi8qKiBGaW5kIHdoaWNoIG5vZGUgaXMgc21hbGxlciwgYW5kIHJldHVybiB0aGF0ICovXG5mdW5jdGlvbiBiZXN0X29mKGNvbXByZXNzb3IsIGFzdDEsIGFzdDIpIHtcbiAgICBpZiAoZmlyc3RfaW5fc3RhdGVtZW50KGNvbXByZXNzb3IpKSB7XG4gICAgICAgIHJldHVybiBiZXN0X29mX3N0YXRlbWVudChhc3QxLCBhc3QyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmVzdF9vZl9leHByZXNzaW9uKGFzdDEsIGFzdDIpO1xuICAgIH1cbn1cblxuLyoqIFNpbXBsaWZ5IGFuIG9iamVjdCBwcm9wZXJ0eSdzIGtleSwgaWYgcG9zc2libGUgKi9cbmZ1bmN0aW9uIGdldF9zaW1wbGVfa2V5KGtleSkge1xuICAgIGlmIChrZXkgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIGtleS5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICBpZiAoa2V5IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICYmIGtleS5vcGVyYXRvciA9PSBcInZvaWRcIlxuICAgICAgICAmJiBrZXkuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiByZWFkX3Byb3BlcnR5KG9iaiwga2V5KSB7XG4gICAga2V5ID0gZ2V0X3NpbXBsZV9rZXkoa2V5KTtcbiAgICBpZiAoa2V5IGluc3RhbmNlb2YgQVNUX05vZGUpIHJldHVybjtcblxuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQVNUX0FycmF5KSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50cztcbiAgICAgICAgaWYgKGtleSA9PSBcImxlbmd0aFwiKSByZXR1cm4gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoZWxlbWVudHMubGVuZ3RoLCBvYmopO1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PSBcIm51bWJlclwiICYmIGtleSBpbiBlbGVtZW50cykgdmFsdWUgPSBlbGVtZW50c1trZXldO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgQVNUX09iamVjdCkge1xuICAgICAgICBrZXkgPSBcIlwiICsga2V5O1xuICAgICAgICB2YXIgcHJvcHMgPSBvYmoucHJvcGVydGllcztcbiAgICAgICAgZm9yICh2YXIgaSA9IHByb3BzLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICAgICAgaWYgKCEocHJvcCBpbnN0YW5jZW9mIEFTVF9PYmplY3RLZXlWYWwpKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXZhbHVlICYmIHByb3BzW2ldLmtleSA9PT0ga2V5KSB2YWx1ZSA9IHByb3BzW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiAmJiB2YWx1ZS5maXhlZF92YWx1ZSgpIHx8IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBoYXNfYnJlYWtfb3JfY29udGludWUobG9vcCwgcGFyZW50KSB7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoZm91bmQgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xvb3BDb250cm9sICYmIHR3Lmxvb3Bjb250cm9sX3RhcmdldChub2RlKSA9PT0gbG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfTGFiZWxlZFN0YXRlbWVudCkgdHcucHVzaChwYXJlbnQpO1xuICAgIHR3LnB1c2gobG9vcCk7XG4gICAgbG9vcC5ib2R5LndhbGsodHcpO1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLy8gd2Ugc2hvdWxkbid0IGNvbXByZXNzICgxLGZ1bmMpKHNvbWV0aGluZykgdG9cbi8vIGZ1bmMoc29tZXRoaW5nKSBiZWNhdXNlIHRoYXQgY2hhbmdlcyB0aGUgbWVhbmluZyBvZlxuLy8gdGhlIGZ1bmMgKGJlY29tZXMgbGV4aWNhbCBpbnN0ZWFkIG9mIGdsb2JhbCkuXG5mdW5jdGlvbiBtYWludGFpbl90aGlzX2JpbmRpbmcocGFyZW50LCBvcmlnLCB2YWwpIHtcbiAgICBpZiAocmVxdWlyZXNfc2VxdWVuY2VfdG9fbWFpbnRhaW5fYmluZGluZyhwYXJlbnQsIG9yaWcsIHZhbCkpIHtcbiAgICAgICAgY29uc3QgemVybyA9IG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBvcmlnLCB7IHZhbHVlOiAwIH0pO1xuICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShvcmlnLCBbIHplcm8sIHZhbCBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbn1cblxuLyoqIERldGVjdCAoMSwgeC5ub1RoaXMpKCksICgwLCBldmFsKSgpLCB3aGljaCBuZWVkIHNlcXVlbmNlcyAqL1xuZnVuY3Rpb24gcmVxdWlyZXNfc2VxdWVuY2VfdG9fbWFpbnRhaW5fYmluZGluZyhwYXJlbnQsIG9yaWcsIHZhbCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHBhcmVudCBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeCAmJiBwYXJlbnQub3BlcmF0b3IgPT0gXCJkZWxldGVcIlxuICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwYXJlbnQuZXhwcmVzc2lvbiA9PT0gb3JpZ1xuICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICAgIHZhbCBpbnN0YW5jZW9mIEFTVF9DaGFpblxuICAgICAgICAgICAgICAgIHx8IHZhbCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzXG4gICAgICAgICAgICAgICAgfHwgdmFsIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiAmJiB2YWwubmFtZSA9PSBcImV2YWxcIlxuICAgICAgICAgICAgKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzX2Z1bmNfZXhwcihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBBU1RfQXJyb3cgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbjtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBub2RlIGNhbiBiZW5lZml0IGZyb20gbmVnYXRpb24uXG4gKiBOb3QgdGhlIGNhc2Ugd2l0aCBhcnJvdyBmdW5jdGlvbnMgKHlvdSBuZWVkIGFuIGV4dHJhIHNldCBvZiBwYXJlbnMpLiAqL1xuZnVuY3Rpb24gaXNfaWlmZV9jYWxsKG5vZGUpIHtcbiAgICBpZiAobm9kZS5UWVBFICE9IFwiQ2FsbFwiKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbiB8fCBpc19paWZlX2NhbGwobm9kZS5leHByZXNzaW9uKTtcbn1cblxuZnVuY3Rpb24gaXNfZW1wdHkodGhpbmcpIHtcbiAgICBpZiAodGhpbmcgPT09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSByZXR1cm4gdGhpbmcuYm9keS5sZW5ndGggPT0gMDtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IGlkZW50aWZpZXJfYXRvbSA9IG1ha2VQcmVkaWNhdGUoXCJJbmZpbml0eSBOYU4gdW5kZWZpbmVkXCIpO1xuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9hdG9tKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEFTVF9JbmZpbml0eVxuICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX05hTlxuICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1VuZGVmaW5lZDtcbn1cblxuLyoqIENoZWNrIGlmIHRoaXMgaXMgYSBTeW1ib2xSZWYgbm9kZSB3aGljaCBoYXMgb25lIGRlZiBvZiBhIGNlcnRhaW4gQVNUIHR5cGUgKi9cbmZ1bmN0aW9uIGlzX3JlZl9vZihyZWYsIHR5cGUpIHtcbiAgICBpZiAoIShyZWYgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBvcmlnID0gcmVmLmRlZmluaXRpb24oKS5vcmlnO1xuICAgIGZvciAodmFyIGkgPSBvcmlnLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgIGlmIChvcmlnW2ldIGluc3RhbmNlb2YgdHlwZSkgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vKipDYW4gd2UgdHVybiB7IGJsb2NrIGNvbnRlbnRzLi4uIH0gaW50byBqdXN0IHRoZSBibG9jayBjb250ZW50cyA/XG4gKiBOb3QgaWYgb25lIG9mIHRoZXNlIGlzIGluc2lkZS5cbiAqKi9cbmZ1bmN0aW9uIGNhbl9iZV9ldmljdGVkX2Zyb21fYmxvY2sobm9kZSkge1xuICAgIHJldHVybiAhKFxuICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX0RlZkNsYXNzIHx8XG4gICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW4gfHxcbiAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9MZXQgfHxcbiAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9Db25zdCB8fFxuICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX1VzaW5nIHx8XG4gICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfRXhwb3J0IHx8XG4gICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfSW1wb3J0XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gYXNfc3RhdGVtZW50X2FycmF5KHRoaW5nKSB7XG4gICAgaWYgKHRoaW5nID09PSBudWxsKSByZXR1cm4gW107XG4gICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSByZXR1cm4gdGhpbmcuYm9keTtcbiAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpIHJldHVybiBbXTtcbiAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KSByZXR1cm4gWyB0aGluZyBdO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgdGhpbmcgdG8gc3RhdGVtZW50IGFycmF5XCIpO1xufVxuXG5mdW5jdGlvbiBpc19yZWFjaGFibGUoc2NvcGVfbm9kZSwgZGVmcykge1xuICAgIGNvbnN0IGZpbmRfcmVmID0gbm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiAmJiBkZWZzLmluY2x1ZGVzKG5vZGUuZGVmaW5pdGlvbigpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGtfYWJvcnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHdhbGtfcGFyZW50KHNjb3BlX25vZGUsIChub2RlLCBpbmZvKSA9PiB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlICYmIG5vZGUgIT09IHNjb3BlX25vZGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBpbmZvLnBhcmVudCgpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGFyZW50IGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgICAgICAgICAmJiBwYXJlbnQuZXhwcmVzc2lvbiA9PT0gbm9kZVxuICAgICAgICAgICAgICAgIC8vIEFzeW5jL0dlbmVyYXRvcnMgYXJlbid0IGd1YXJhbnRlZWQgdG8gc3luYyBldmFsdWF0ZSBhbGwgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGVpciBib2R5IHN0ZXBzLCBzbyBpdCdzIHBvc3NpYmxlIHRoZXkgY2xvc2Ugb3ZlciB0aGUgdmFyaWFibGUuXG4gICAgICAgICAgICAgICAgJiYgIShub2RlLmFzeW5jIHx8IG5vZGUuaXNfZ2VuZXJhdG9yKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod2Fsayhub2RlLCBmaW5kX3JlZikpIHJldHVybiB3YWxrX2Fib3J0O1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKiogQ2hlY2sgaWYgYSByZWYgcmVmZXJzIHRvIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24vY2xhc3MgaXQncyBkZWZpbmVkIHdpdGhpbiAqL1xuZnVuY3Rpb24gaXNfcmVjdXJzaXZlX3JlZih0dywgZGVmKSB7XG4gICAgdmFyIG5vZGU7XG4gICAgZm9yICh2YXIgaSA9IDA7IG5vZGUgPSB0dy5wYXJlbnQoaSk7IGkrKykge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9DbGFzcykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSAmJiBuYW1lLmRlZmluaXRpb24oKSA9PT0gZGVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBUT0RPIHRoaXMgb25seSB3b3JrcyB3aXRoIEFTVF9EZWZ1biwgc2hvdWxkbid0IGl0IHdvcmsgZm9yIG90aGVyIHdheXMgb2YgZGVmaW5pbmcgZnVuY3Rpb25zP1xuZnVuY3Rpb24gcmV0YWluX3RvcF9mdW5jKGZuLCBjb21wcmVzc29yKSB7XG4gICAgcmV0dXJuIGNvbXByZXNzb3IudG9wX3JldGFpblxuICAgICAgICAmJiBmbiBpbnN0YW5jZW9mIEFTVF9EZWZ1blxuICAgICAgICAmJiBoYXNfZmxhZyhmbiwgVE9QKVxuICAgICAgICAmJiBmbi5uYW1lXG4gICAgICAgICYmIGNvbXByZXNzb3IudG9wX3JldGFpbihmbi5uYW1lLmRlZmluaXRpb24oKSk7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gTGlzdHMgb2YgbmF0aXZlIG1ldGhvZHMsIHVzZWZ1bCBmb3IgYHVuc2FmZWAgb3B0aW9uIHdoaWNoIGFzc3VtZXMgdGhleSBleGlzdC5cbi8vIE5vdGU6IExvdHMgb2YgbWV0aG9kcyBhbmQgZnVuY3Rpb25zIGFyZSBtaXNzaW5nIGhlcmUsIGluIGNhc2UgdGhleSBhcmVuJ3QgcHVyZVxuLy8gb3Igbm90IGF2YWlsYWJsZSBpbiBhbGwgSlMgZW52aXJvbm1lbnRzLlxuXG5mdW5jdGlvbiBtYWtlX25lc3RlZF9sb29rdXAob2JqKSB7XG4gICAgY29uc3Qgb3V0ID0gbmV3IE1hcCgpO1xuICAgIGZvciAodmFyIGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgIG91dC5zZXQoa2V5LCBtYWtlUHJlZGljYXRlKG9ialtrZXldKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZG9lc19oYXZlID0gKGdsb2JhbF9uYW1lLCBmbmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBpbm5lcl9tYXAgPSBvdXQuZ2V0KGdsb2JhbF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIGlubmVyX21hcCAhPSBudWxsICYmIGlubmVyX21hcC5oYXMoZm5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIGRvZXNfaGF2ZTtcbn1cblxuLy8gT2JqZWN0cyB3aGljaCBhcmUgc2FmZSB0byBhY2Nlc3Mgd2l0aG91dCB0aHJvd2luZyBvciBjYXVzaW5nIGEgc2lkZSBlZmZlY3QuXG4vLyBVc3VhbGx5IHdlJ2QgY2hlY2sgdGhlIGB1bnNhZmVgIG9wdGlvbiBmaXJzdCBidXQgdGhlc2UgYXJlIHdheSB0b28gY29tbW9uIGZvciB0aGF0XG5jb25zdCBwdXJlX3Byb3BfYWNjZXNzX2dsb2JhbHMgPSBuZXcgU2V0KFtcbiAgICBcIk51bWJlclwiLFxuICAgIFwiU3RyaW5nXCIsXG4gICAgXCJBcnJheVwiLFxuICAgIFwiT2JqZWN0XCIsXG4gICAgXCJGdW5jdGlvblwiLFxuICAgIFwiUHJvbWlzZVwiLFxuXSk7XG5cbmNvbnN0IG9iamVjdF9tZXRob2RzID0gW1xuICAgIFwiY29uc3RydWN0b3JcIixcbiAgICBcInRvU3RyaW5nXCIsXG4gICAgXCJ2YWx1ZU9mXCIsXG5dO1xuXG5jb25zdCBpc19wdXJlX25hdGl2ZV9tZXRob2QgPSBtYWtlX25lc3RlZF9sb29rdXAoe1xuICAgIEFycmF5OiBbXG4gICAgICAgIFwiYXRcIixcbiAgICAgICAgXCJmbGF0XCIsXG4gICAgICAgIFwiaW5jbHVkZXNcIixcbiAgICAgICAgXCJpbmRleE9mXCIsXG4gICAgICAgIFwiam9pblwiLFxuICAgICAgICBcImxhc3RJbmRleE9mXCIsXG4gICAgICAgIFwic2xpY2VcIixcbiAgICAgICAgLi4ub2JqZWN0X21ldGhvZHMsXG4gICAgXSxcbiAgICBCb29sZWFuOiBvYmplY3RfbWV0aG9kcyxcbiAgICBGdW5jdGlvbjogb2JqZWN0X21ldGhvZHMsXG4gICAgTnVtYmVyOiBbXG4gICAgICAgIFwidG9FeHBvbmVudGlhbFwiLFxuICAgICAgICBcInRvRml4ZWRcIixcbiAgICAgICAgXCJ0b1ByZWNpc2lvblwiLFxuICAgICAgICAuLi5vYmplY3RfbWV0aG9kcyxcbiAgICBdLFxuICAgIE9iamVjdDogb2JqZWN0X21ldGhvZHMsXG4gICAgUmVnRXhwOiBbXG4gICAgICAgIFwidGVzdFwiLFxuICAgICAgICAuLi5vYmplY3RfbWV0aG9kcyxcbiAgICBdLFxuICAgIFN0cmluZzogW1xuICAgICAgICBcImF0XCIsXG4gICAgICAgIFwiY2hhckF0XCIsXG4gICAgICAgIFwiY2hhckNvZGVBdFwiLFxuICAgICAgICBcImNoYXJQb2ludEF0XCIsXG4gICAgICAgIFwiY29uY2F0XCIsXG4gICAgICAgIFwiZW5kc1dpdGhcIixcbiAgICAgICAgXCJmcm9tQ2hhckNvZGVcIixcbiAgICAgICAgXCJmcm9tQ29kZVBvaW50XCIsXG4gICAgICAgIFwiaW5jbHVkZXNcIixcbiAgICAgICAgXCJpbmRleE9mXCIsXG4gICAgICAgIFwiaXRhbGljc1wiLFxuICAgICAgICBcImxhc3RJbmRleE9mXCIsXG4gICAgICAgIFwibG9jYWxlQ29tcGFyZVwiLFxuICAgICAgICBcIm1hdGNoXCIsXG4gICAgICAgIFwibWF0Y2hBbGxcIixcbiAgICAgICAgXCJub3JtYWxpemVcIixcbiAgICAgICAgXCJwYWRTdGFydFwiLFxuICAgICAgICBcInBhZEVuZFwiLFxuICAgICAgICBcInJlcGVhdFwiLFxuICAgICAgICBcInJlcGxhY2VcIixcbiAgICAgICAgXCJyZXBsYWNlQWxsXCIsXG4gICAgICAgIFwic2VhcmNoXCIsXG4gICAgICAgIFwic2xpY2VcIixcbiAgICAgICAgXCJzcGxpdFwiLFxuICAgICAgICBcInN0YXJ0c1dpdGhcIixcbiAgICAgICAgXCJzdWJzdHJcIixcbiAgICAgICAgXCJzdWJzdHJpbmdcIixcbiAgICAgICAgXCJyZXBlYXRcIixcbiAgICAgICAgXCJ0b0xvY2FsZUxvd2VyQ2FzZVwiLFxuICAgICAgICBcInRvTG9jYWxlVXBwZXJDYXNlXCIsXG4gICAgICAgIFwidG9Mb3dlckNhc2VcIixcbiAgICAgICAgXCJ0b1VwcGVyQ2FzZVwiLFxuICAgICAgICBcInRyaW1cIixcbiAgICAgICAgXCJ0cmltRW5kXCIsXG4gICAgICAgIFwidHJpbVN0YXJ0XCIsXG4gICAgICAgIC4uLm9iamVjdF9tZXRob2RzLFxuICAgIF0sXG59KTtcblxuY29uc3QgaXNfcHVyZV9uYXRpdmVfZm4gPSBtYWtlX25lc3RlZF9sb29rdXAoe1xuICAgIEFycmF5OiBbXG4gICAgICAgIFwiaXNBcnJheVwiLFxuICAgIF0sXG4gICAgTWF0aDogW1xuICAgICAgICBcImFic1wiLFxuICAgICAgICBcImFjb3NcIixcbiAgICAgICAgXCJhc2luXCIsXG4gICAgICAgIFwiYXRhblwiLFxuICAgICAgICBcImNlaWxcIixcbiAgICAgICAgXCJjb3NcIixcbiAgICAgICAgXCJleHBcIixcbiAgICAgICAgXCJmbG9vclwiLFxuICAgICAgICBcImxvZ1wiLFxuICAgICAgICBcInJvdW5kXCIsXG4gICAgICAgIFwic2luXCIsXG4gICAgICAgIFwic3FydFwiLFxuICAgICAgICBcInRhblwiLFxuICAgICAgICBcImF0YW4yXCIsXG4gICAgICAgIFwicG93XCIsXG4gICAgICAgIFwibWF4XCIsXG4gICAgICAgIFwibWluXCIsXG4gICAgXSxcbiAgICBOdW1iZXI6IFtcbiAgICAgICAgXCJpc0Zpbml0ZVwiLFxuICAgICAgICBcImlzTmFOXCIsXG4gICAgXSxcbiAgICBPYmplY3Q6IFtcbiAgICAgICAgXCJjcmVhdGVcIixcbiAgICAgICAgXCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcIixcbiAgICAgICAgXCJnZXRPd25Qcm9wZXJ0eU5hbWVzXCIsXG4gICAgICAgIFwiZ2V0UHJvdG90eXBlT2ZcIixcbiAgICAgICAgXCJpc0V4dGVuc2libGVcIixcbiAgICAgICAgXCJpc0Zyb3plblwiLFxuICAgICAgICBcImlzU2VhbGVkXCIsXG4gICAgICAgIFwiaGFzT3duXCIsXG4gICAgICAgIFwia2V5c1wiLFxuICAgIF0sXG4gICAgU3RyaW5nOiBbXG4gICAgICAgIFwiZnJvbUNoYXJDb2RlXCIsXG4gICAgXSxcbn0pO1xuXG4vLyBLbm93biBudW1lcmljIHZhbHVlcyB3aGljaCBjb21lIHdpdGggSlMgZW52aXJvbm1lbnRzXG5jb25zdCBpc19wdXJlX25hdGl2ZV92YWx1ZSA9IG1ha2VfbmVzdGVkX2xvb2t1cCh7XG4gICAgTWF0aDogW1xuICAgICAgICBcIkVcIixcbiAgICAgICAgXCJMTjEwXCIsXG4gICAgICAgIFwiTE4yXCIsXG4gICAgICAgIFwiTE9HMkVcIixcbiAgICAgICAgXCJMT0cxMEVcIixcbiAgICAgICAgXCJQSVwiLFxuICAgICAgICBcIlNRUlQxXzJcIixcbiAgICAgICAgXCJTUVJUMlwiLFxuICAgIF0sXG4gICAgTnVtYmVyOiBbXG4gICAgICAgIFwiTUFYX1ZBTFVFXCIsXG4gICAgICAgIFwiTUlOX1ZBTFVFXCIsXG4gICAgICAgIFwiTmFOXCIsXG4gICAgICAgIFwiTkVHQVRJVkVfSU5GSU5JVFlcIixcbiAgICAgICAgXCJQT1NJVElWRV9JTkZJTklUWVwiLFxuICAgIF0sXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBGdW5jdGlvbnMgYW5kIG1ldGhvZHMgdG8gaW5mZXIgY2VydGFpbiBmYWN0cyBhYm91dCBleHByZXNzaW9uc1xuLy8gSXQncyBub3QgYWx3YXlzIHBvc3NpYmxlIHRvIGJlIDEwMCUgc3VyZSBhYm91dCBzb21ldGhpbmcganVzdCBieSBzdGF0aWMgYW5hbHlzaXMsXG4vLyBzbyBgdHJ1ZWAgbWVhbnMgeWVzLCBhbmQgYGZhbHNlYCBtZWFucyBtYXliZVxuXG5jb25zdCBpc191bmRlY2xhcmVkX3JlZiA9IChub2RlKSA9PlxuICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmICYmIG5vZGUuZGVmaW5pdGlvbigpLnVuZGVjbGFyZWQ7XG5cbmNvbnN0IGJpdHdpc2VfYmlub3AgPSBtYWtlUHJlZGljYXRlKFwiPDw8ID4+IDw8ICYgfCBeIH5cIik7XG5jb25zdCBsYXp5X29wID0gbWFrZVByZWRpY2F0ZShcIiYmIHx8ID8/XCIpO1xuY29uc3QgdW5hcnlfc2lkZV9lZmZlY3RzID0gbWFrZVByZWRpY2F0ZShcImRlbGV0ZSArKyAtLVwiKTtcblxuLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBleHByZXNzaW9uIGhhcyBhIGJvb2xlYW4gcmVzdWx0IHR5cGVcbihmdW5jdGlvbihkZWZfaXNfYm9vbGVhbikge1xuICAgIGNvbnN0IHVuYXJ5X2Jvb2wgPSBtYWtlUHJlZGljYXRlKFwiISBkZWxldGVcIik7XG4gICAgY29uc3QgYmluYXJ5X2Jvb2wgPSBtYWtlUHJlZGljYXRlKFwiaW4gaW5zdGFuY2VvZiA9PSAhPSA9PT0gIT09IDwgPD0gPj0gPlwiKTtcbiAgICBkZWZfaXNfYm9vbGVhbihBU1RfTm9kZSwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaXNfYm9vbGVhbihBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdW5hcnlfYm9vbC5oYXModGhpcy5vcGVyYXRvcik7XG4gICAgfSk7XG4gICAgZGVmX2lzX2Jvb2xlYW4oQVNUX0JpbmFyeSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBiaW5hcnlfYm9vbC5oYXModGhpcy5vcGVyYXRvcilcbiAgICAgICAgICAgIHx8IGxhenlfb3AuaGFzKHRoaXMub3BlcmF0b3IpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5sZWZ0LmlzX2Jvb2xlYW4oKVxuICAgICAgICAgICAgICAgICYmIHRoaXMucmlnaHQuaXNfYm9vbGVhbigpO1xuICAgIH0pO1xuICAgIGRlZl9pc19ib29sZWFuKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnNlcXVlbnQuaXNfYm9vbGVhbigpICYmIHRoaXMuYWx0ZXJuYXRpdmUuaXNfYm9vbGVhbigpO1xuICAgIH0pO1xuICAgIGRlZl9pc19ib29sZWFuKEFTVF9Bc3NpZ24sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcIj1cIiAmJiB0aGlzLnJpZ2h0LmlzX2Jvb2xlYW4oKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfYm9vbGVhbihBU1RfU2VxdWVuY2UsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWlsX25vZGUoKS5pc19ib29sZWFuKCk7XG4gICAgfSk7XG4gICAgZGVmX2lzX2Jvb2xlYW4oQVNUX1RydWUsIHJldHVybl90cnVlKTtcbiAgICBkZWZfaXNfYm9vbGVhbihBU1RfRmFsc2UsIHJldHVybl90cnVlKTtcbn0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcImlzX2Jvb2xlYW5cIiwgZnVuYyk7XG59KTtcblxuLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgaWYgYW4gZXhwcmVzc2lvbiBoYXMgYSBudW1lcmljIHJlc3VsdCB0eXBlXG4oZnVuY3Rpb24oZGVmX2lzX251bWJlcikge1xuICAgIGRlZl9pc19udW1iZXIoQVNUX05vZGUsIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX2lzX251bWJlcihBU1RfTnVtYmVyLCByZXR1cm5fdHJ1ZSk7XG4gICAgY29uc3QgdW5hcnkgPSBtYWtlUHJlZGljYXRlKFwiKyAtIH4gKysgLS1cIik7XG4gICAgZGVmX2lzX251bWJlcihBU1RfVW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHVuYXJ5Lmhhcyh0aGlzLm9wZXJhdG9yKSAmJiB0aGlzLmV4cHJlc3Npb24uaXNfbnVtYmVyKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGNvbnN0IG51bWVyaWNfb3BzID0gbWFrZVByZWRpY2F0ZShcIi0gKiAvICUgJiB8IF4gPDwgPj4gPj4+XCIpO1xuICAgIGRlZl9pc19udW1iZXIoQVNUX0JpbmFyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgIC8vIEJvdGggc2lkZXMgbmVlZCB0byBiZSBgbnVtYmVyYC4gT3Igb25lIGlzIGEgYG51bWJlcmAgYW5kIHRoZSBvdGhlciBpcyBudW1iZXItaXNoLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5pc19udW1iZXIoY29tcHJlc3NvcikgJiYgdGhpcy5yaWdodC5pc19udW1iZXJfb3JfYmlnaW50KGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5yaWdodC5pc19udW1iZXIoY29tcHJlc3NvcikgJiYgdGhpcy5sZWZ0LmlzX251bWJlcl9vcl9iaWdpbnQoY29tcHJlc3Nvcik7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtZXJpY19vcHMuaGFzKHRoaXMub3BlcmF0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmlzX251bWJlcihjb21wcmVzc29yKSB8fCB0aGlzLnJpZ2h0LmlzX251bWJlcihjb21wcmVzc29yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRlZl9pc19udW1iZXIoQVNUX0Fzc2lnbiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gKHRoaXMub3BlcmF0b3IgPT09IFwiPVwiIHx8IG51bWVyaWNfb3BzLmhhcyh0aGlzLm9wZXJhdG9yLnNsaWNlKDAsIC0xKSkpXG4gICAgICAgICAgICAmJiB0aGlzLnJpZ2h0LmlzX251bWJlcihjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfbnVtYmVyKEFTVF9TZXF1ZW5jZSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy50YWlsX25vZGUoKS5pc19udW1iZXIoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2lzX251bWJlcihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc2VxdWVudC5pc19udW1iZXIoY29tcHJlc3NvcikgJiYgdGhpcy5hbHRlcm5hdGl2ZS5pc19udW1iZXIoY29tcHJlc3Nvcik7XG4gICAgfSk7XG59KShmdW5jdGlvbihub2RlLCBmdW5jKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJpc19udW1iZXJcIiwgZnVuYyk7XG59KTtcblxuLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgaWYgYW4gZXhwcmVzc2lvbiByZXR1cm5zIGEgQmlnSW50XG4oZnVuY3Rpb24oZGVmX2lzX2JpZ2ludCkge1xuICAgIGRlZl9pc19iaWdpbnQoQVNUX05vZGUsIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX2lzX2JpZ2ludChBU1RfQmlnSW50LCByZXR1cm5fdHJ1ZSk7XG4gICAgY29uc3QgdW5hcnkgPSBtYWtlUHJlZGljYXRlKFwiKyAtIH4gKysgLS1cIik7XG4gICAgZGVmX2lzX2JpZ2ludChBU1RfVW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHVuYXJ5Lmhhcyh0aGlzLm9wZXJhdG9yKSAmJiB0aGlzLmV4cHJlc3Npb24uaXNfYmlnaW50KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGNvbnN0IG51bWVyaWNfb3BzID0gbWFrZVByZWRpY2F0ZShcIi0gKiAvICUgJiB8IF4gPDwgPj5cIik7XG4gICAgZGVmX2lzX2JpZ2ludChBU1RfQmluYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSBcIitcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5pc19iaWdpbnQoY29tcHJlc3NvcikgJiYgdGhpcy5yaWdodC5pc19udW1iZXJfb3JfYmlnaW50KGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5yaWdodC5pc19iaWdpbnQoY29tcHJlc3NvcikgJiYgdGhpcy5sZWZ0LmlzX251bWJlcl9vcl9iaWdpbnQoY29tcHJlc3Nvcik7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtZXJpY19vcHMuaGFzKHRoaXMub3BlcmF0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmlzX2JpZ2ludChjb21wcmVzc29yKSB8fCB0aGlzLnJpZ2h0LmlzX2JpZ2ludChjb21wcmVzc29yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRlZl9pc19iaWdpbnQoQVNUX0Fzc2lnbiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gKG51bWVyaWNfb3BzLmhhcyh0aGlzLm9wZXJhdG9yLnNsaWNlKDAsIC0xKSkgfHwgdGhpcy5vcGVyYXRvciA9PSBcIj1cIilcbiAgICAgICAgICAgICYmIHRoaXMucmlnaHQuaXNfYmlnaW50KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9pc19iaWdpbnQoQVNUX1NlcXVlbmNlLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhaWxfbm9kZSgpLmlzX2JpZ2ludChjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfYmlnaW50KEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zZXF1ZW50LmlzX2JpZ2ludChjb21wcmVzc29yKSAmJiB0aGlzLmFsdGVybmF0aXZlLmlzX2JpZ2ludChjb21wcmVzc29yKTtcbiAgICB9KTtcbn0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcImlzX2JpZ2ludFwiLCBmdW5jKTtcbn0pO1xuXG4vLyBtZXRob2RzIHRvIGRldGVybWluZSBpZiBhbiBleHByZXNzaW9uIGlzIGEgbnVtYmVyIG9yIGEgYmlnaW50XG4oZnVuY3Rpb24oZGVmX2lzX251bWJlcl9vcl9iaWdpbnQpIHtcbiAgICBkZWZfaXNfbnVtYmVyX29yX2JpZ2ludChBU1RfTm9kZSwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaXNfbnVtYmVyX29yX2JpZ2ludChBU1RfTnVtYmVyLCByZXR1cm5fdHJ1ZSk7XG4gICAgZGVmX2lzX251bWJlcl9vcl9iaWdpbnQoQVNUX0JpZ0ludCwgcmV0dXJuX3RydWUpO1xuICAgIGNvbnN0IG51bWVyaWNfdW5hcnlfb3BzID0gbWFrZVByZWRpY2F0ZShcIisgLSB+ICsrIC0tXCIpO1xuICAgIGRlZl9pc19udW1iZXJfb3JfYmlnaW50KEFTVF9VbmFyeSwgZnVuY3Rpb24oX2NvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bWVyaWNfdW5hcnlfb3BzLmhhcyh0aGlzLm9wZXJhdG9yKTtcbiAgICB9KTtcbiAgICBjb25zdCBudW1lcmljX29wcyA9IG1ha2VQcmVkaWNhdGUoXCItICogLyAlICYgfCBeIDw8ID4+XCIpO1xuICAgIGRlZl9pc19udW1iZXJfb3JfYmlnaW50KEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT09IFwiK1wiXG4gICAgICAgICAgICA/IHRoaXMubGVmdC5pc19udW1iZXJfb3JfYmlnaW50KGNvbXByZXNzb3IpICYmIHRoaXMucmlnaHQuaXNfbnVtYmVyX29yX2JpZ2ludChjb21wcmVzc29yKVxuICAgICAgICAgICAgOiBudW1lcmljX29wcy5oYXModGhpcy5vcGVyYXRvcik7XG4gICAgfSk7XG4gICAgZGVmX2lzX251bWJlcl9vcl9iaWdpbnQoQVNUX0Fzc2lnbiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gbnVtZXJpY19vcHMuaGFzKHRoaXMub3BlcmF0b3Iuc2xpY2UoMCwgLTEpKVxuICAgICAgICAgICAgfHwgdGhpcy5vcGVyYXRvciA9PSBcIj1cIiAmJiB0aGlzLnJpZ2h0LmlzX251bWJlcl9vcl9iaWdpbnQoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2lzX251bWJlcl9vcl9iaWdpbnQoQVNUX1NlcXVlbmNlLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhaWxfbm9kZSgpLmlzX251bWJlcl9vcl9iaWdpbnQoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2lzX251bWJlcl9vcl9iaWdpbnQoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnNlcXVlbnQuaXNfbnVtYmVyX29yX2JpZ2ludChjb21wcmVzc29yKSAmJiB0aGlzLmFsdGVybmF0aXZlLmlzX251bWJlcl9vcl9iaWdpbnQoY29tcHJlc3Nvcik7XG4gICAgfSk7XG59KGZ1bmN0aW9uIChub2RlLCBmdW5jKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJpc19udW1iZXJfb3JfYmlnaW50XCIsIGZ1bmMpO1xufSkpO1xuXG5cbi8vIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIGlmIGFuIGV4cHJlc3Npb24gaXMgYSAzMiBiaXQgaW50ZWdlciAoSUUgcmVzdWx0cyBmcm9tIGJpdHdpc2Ugb3BzLCBvciBpcyBhbiBpbnRlZ2VyIGNvbnN0YW50IGZpdHRpbmcgaW4gdGhhdCBzaXplXG4oZnVuY3Rpb24oZGVmX2lzXzMyX2JpdF9pbnRlZ2VyKSB7XG4gICAgZGVmX2lzXzMyX2JpdF9pbnRlZ2VyKEFTVF9Ob2RlLCByZXR1cm5fZmFsc2UpO1xuICAgIGRlZl9pc18zMl9iaXRfaW50ZWdlcihBU1RfTnVtYmVyLCBmdW5jdGlvbihfY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gKHRoaXMudmFsdWUgfCAwKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfMzJfYml0X2ludGVnZXIoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yID09IFwiflwiID8gdGhpcy5leHByZXNzaW9uLmlzX251bWJlcihjb21wcmVzc29yKVxuICAgICAgICAgICAgOiB0aGlzLm9wZXJhdG9yID09PSBcIitcIiA/IHRoaXMuZXhwcmVzc2lvbi5pc18zMl9iaXRfaW50ZWdlcihjb21wcmVzc29yKVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9KTtcbiAgICBkZWZfaXNfMzJfYml0X2ludGVnZXIoQVNUX0JpbmFyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYml0d2lzZV9iaW5vcC5oYXModGhpcy5vcGVyYXRvcilcbiAgICAgICAgICAgICYmICh0aGlzLmxlZnQuaXNfbnVtYmVyKGNvbXByZXNzb3IpIHx8IHRoaXMucmlnaHQuaXNfbnVtYmVyKGNvbXByZXNzb3IpKTtcbiAgICB9KTtcbn0oZnVuY3Rpb24gKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcImlzXzMyX2JpdF9pbnRlZ2VyXCIsIGZ1bmMpO1xufSkpO1xuXG4vLyBtZXRob2RzIHRvIGRldGVybWluZSBpZiBhbiBleHByZXNzaW9uIGhhcyBhIHN0cmluZyByZXN1bHQgdHlwZVxuKGZ1bmN0aW9uKGRlZl9pc19zdHJpbmcpIHtcbiAgICBkZWZfaXNfc3RyaW5nKEFTVF9Ob2RlLCByZXR1cm5fZmFsc2UpO1xuICAgIGRlZl9pc19zdHJpbmcoQVNUX1N0cmluZywgcmV0dXJuX3RydWUpO1xuICAgIGRlZl9pc19zdHJpbmcoQVNUX1RlbXBsYXRlU3RyaW5nLCByZXR1cm5fdHJ1ZSk7XG4gICAgZGVmX2lzX3N0cmluZyhBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcInR5cGVvZlwiO1xuICAgIH0pO1xuICAgIGRlZl9pc19zdHJpbmcoQVNUX0JpbmFyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcIitcIiAmJlxuICAgICAgICAgICAgKHRoaXMubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikgfHwgdGhpcy5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpO1xuICAgIH0pO1xuICAgIGRlZl9pc19zdHJpbmcoQVNUX0Fzc2lnbiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gKHRoaXMub3BlcmF0b3IgPT0gXCI9XCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcIis9XCIpICYmIHRoaXMucmlnaHQuaXNfc3RyaW5nKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9pc19zdHJpbmcoQVNUX1NlcXVlbmNlLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhaWxfbm9kZSgpLmlzX3N0cmluZyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfc3RyaW5nKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zZXF1ZW50LmlzX3N0cmluZyhjb21wcmVzc29yKSAmJiB0aGlzLmFsdGVybmF0aXZlLmlzX3N0cmluZyhjb21wcmVzc29yKTtcbiAgICB9KTtcbn0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcImlzX3N0cmluZ1wiLCBmdW5jKTtcbn0pO1xuXG5mdW5jdGlvbiBpc191bmRlZmluZWQobm9kZSwgY29tcHJlc3Nvcikge1xuICAgIHJldHVybiAoXG4gICAgICAgIGhhc19mbGFnKG5vZGUsIFVOREVGSU5FRClcbiAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9VbmRlZmluZWRcbiAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeFxuICAgICAgICAgICAgJiYgbm9kZS5vcGVyYXRvciA9PSBcInZvaWRcIlxuICAgICAgICAgICAgJiYgIW5vZGUuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgKTtcbn1cblxuLy8gSXMgdGhlIG5vZGUgZXhwbGljaXRseSBudWxsIG9yIHVuZGVmaW5lZC5cbmZ1bmN0aW9uIGlzX251bGxfb3JfdW5kZWZpbmVkKG5vZGUsIGNvbXByZXNzb3IpIHtcbiAgICBsZXQgZml4ZWQ7XG4gICAgcmV0dXJuIChcbiAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9OdWxsXG4gICAgICAgIHx8IGlzX3VuZGVmaW5lZChub2RlLCBjb21wcmVzc29yKVxuICAgICAgICB8fCAoXG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgJiYgKGZpeGVkID0gbm9kZS5kZWZpbml0aW9uKCkuZml4ZWQpIGluc3RhbmNlb2YgQVNUX05vZGVcbiAgICAgICAgICAgICYmIGlzX251bGxpc2goZml4ZWQsIGNvbXByZXNzb3IpXG4gICAgICAgIClcbiAgICApO1xufVxuXG4vLyBGaW5kIG91dCBpZiB0aGlzIGV4cHJlc3Npb24gaXMgb3B0aW9uYWxseSBjaGFpbmVkIGZyb20gYSBiYXNlLXBvaW50IHRoYXQgd2Vcbi8vIGNhbiBzdGF0aWNhbGx5IGFuYWx5emUgYXMgbnVsbCBvciB1bmRlZmluZWQuXG5mdW5jdGlvbiBpc19udWxsaXNoX3Nob3J0Y2lyY3VpdGVkKG5vZGUsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FsbCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5vZGUub3B0aW9uYWwgJiYgaXNfbnVsbF9vcl91bmRlZmluZWQobm9kZS5leHByZXNzaW9uLCBjb21wcmVzc29yKSlcbiAgICAgICAgICAgIHx8IGlzX251bGxpc2hfc2hvcnRjaXJjdWl0ZWQobm9kZS5leHByZXNzaW9uLCBjb21wcmVzc29yKVxuICAgICAgICApO1xuICAgIH1cbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DaGFpbikgcmV0dXJuIGlzX251bGxpc2hfc2hvcnRjaXJjdWl0ZWQobm9kZS5leHByZXNzaW9uLCBjb21wcmVzc29yKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZpbmQgb3V0IGlmIHNvbWV0aGluZyBpcyA9PSBudWxsLCBvciBjYW4gc2hvcnQgY2lyY3VpdCBpbnRvIG51bGxpc2guXG4vLyBVc2VkIHRvIG9wdGltaXplID8uIGFuZCA/P1xuZnVuY3Rpb24gaXNfbnVsbGlzaChub2RlLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKGlzX251bGxfb3JfdW5kZWZpbmVkKG5vZGUsIGNvbXByZXNzb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gaXNfbnVsbGlzaF9zaG9ydGNpcmN1aXRlZChub2RlLCBjb21wcmVzc29yKTtcbn1cblxuLy8gRGV0ZXJtaW5lIGlmIGV4cHJlc3Npb24gbWlnaHQgY2F1c2Ugc2lkZSBlZmZlY3RzXG4vLyBJZiB0aGVyZSdzIGEgcG9zc2liaWxpdHkgdGhhdCBhIG5vZGUgbWF5IGNoYW5nZSBzb21ldGhpbmcgd2hlbiBpdCdzIGV4ZWN1dGVkLCB0aGlzIHJldHVybnMgdHJ1ZVxuKGZ1bmN0aW9uKGRlZl9oYXNfc2lkZV9lZmZlY3RzKSB7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX05vZGUsIHJldHVybl90cnVlKTtcblxuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9FbXB0eVN0YXRlbWVudCwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQ29uc3RhbnQsIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1RoaXMsIHJldHVybl9mYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBhbnkobGlzdCwgY29tcHJlc3Nvcikge1xuICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGg7IC0taSA+PSAwOylcbiAgICAgICAgICAgIGlmIChsaXN0W2ldLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQmxvY2ssIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9DYWxsLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICF0aGlzLmlzX2NhbGxlZV9wdXJlKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAmJiAoIXRoaXMuZXhwcmVzc2lvbi5pc19jYWxsX3B1cmUoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW55KHRoaXMuYXJncywgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1N3aXRjaCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IGFueSh0aGlzLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9DYXNlLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgYW55KHRoaXMuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1RyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuYmNhdGNoICYmIHRoaXMuYmNhdGNoLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuYmZpbmFsbHkgJiYgdGhpcy5iZmluYWxseS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9JZiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5ib2R5ICYmIHRoaXMuYm9keS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLmFsdGVybmF0aXZlICYmIHRoaXMuYWx0ZXJuYXRpdmUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfSW1wb3J0TWV0YSwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1NpbXBsZVN0YXRlbWVudCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX0xhbWJkYSwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQ2xhc3MsIGZ1bmN0aW9uIChjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmV4dGVuZHMgJiYgdGhpcy5leHRlbmRzLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5wcm9wZXJ0aWVzLCBjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQ2xhc3NTdGF0aWNCbG9jaywgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX0JpbmFyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMucmlnaHQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQXNzaWduLCByZXR1cm5fdHJ1ZSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLmNvbnNlcXVlbnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5hbHRlcm5hdGl2ZS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9VbmFyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdW5hcnlfc2lkZV9lZmZlY3RzLmhhcyh0aGlzLm9wZXJhdG9yKVxuICAgICAgICAgICAgfHwgdGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1N5bWJvbFJlZiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNfZGVjbGFyZWQoY29tcHJlc3NvcikgJiYgIXB1cmVfcHJvcF9hY2Nlc3NfZ2xvYmFscy5oYXModGhpcy5uYW1lKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfU3ltYm9sQ2xhc3NQcm9wZXJ0eSwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfU3ltYm9sRGVjbGFyYXRpb24sIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX09iamVjdCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMucHJvcGVydGllcywgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX09iamVjdEtleVZhbCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5jb21wdXRlZF9rZXkoKSAmJiB0aGlzLmtleS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICApO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKFtcbiAgICAgICAgQVNUX0NsYXNzUHJvcGVydHksXG4gICAgICAgIEFTVF9DbGFzc1ByaXZhdGVQcm9wZXJ0eSxcbiAgICBdLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVkX2tleSgpICYmIHRoaXMua2V5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuc3RhdGljICYmIHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoW1xuICAgICAgICBBU1RfUHJpdmF0ZU1ldGhvZCxcbiAgICAgICAgQVNUX1ByaXZhdGVHZXR0ZXIsXG4gICAgICAgIEFTVF9Qcml2YXRlU2V0dGVyLFxuICAgICAgICBBU1RfQ29uY2lzZU1ldGhvZCxcbiAgICAgICAgQVNUX09iamVjdEdldHRlcixcbiAgICAgICAgQVNUX09iamVjdFNldHRlcixcbiAgICBdLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkX2tleSgpICYmIHRoaXMua2V5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX0FycmF5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5lbGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX0RvdCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAoaXNfbnVsbGlzaCh0aGlzLCBjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25hbCAmJiB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2Vzcyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1N1YiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAoaXNfbnVsbGlzaCh0aGlzLCBjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25hbCAmJiB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2Vzcyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnByb3BlcnR5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChwcm9wZXJ0eSAmJiB0aGlzLm9wdGlvbmFsKSByZXR1cm4gdHJ1ZTsgLy8gXCI/LlwiIGlzIGEgY29uZGl0aW9uXG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnR5IHx8IHRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9DaGFpbiwgZnVuY3Rpb24gKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9TZXF1ZW5jZSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuZXhwcmVzc2lvbnMsIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9EZWZpbml0aW9ucywgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuZGVmaW5pdGlvbnMsIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9WYXJEZWYsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAhPSBudWxsO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9UZW1wbGF0ZVNlZ21lbnQsIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1RlbXBsYXRlU3RyaW5nLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5zZWdtZW50cywgY29tcHJlc3Nvcik7XG4gICAgfSk7XG59KShmdW5jdGlvbihub2RlX29yX25vZGVzLCBmdW5jKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIFtdLmNvbmNhdChub2RlX29yX25vZGVzKSkge1xuICAgICAgICBub2RlLkRFRk1FVEhPRChcImhhc19zaWRlX2VmZmVjdHNcIiwgZnVuYyk7XG4gICAgfVxufSk7XG5cbi8vIGRldGVybWluZSBpZiBleHByZXNzaW9uIG1heSB0aHJvd1xuKGZ1bmN0aW9uKGRlZl9tYXlfdGhyb3cpIHtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9Ob2RlLCByZXR1cm5fdHJ1ZSk7XG5cbiAgICBkZWZfbWF5X3Rocm93KEFTVF9Db25zdGFudCwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9FbXB0eVN0YXRlbWVudCwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9MYW1iZGEsIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfU3ltYm9sRGVjbGFyYXRpb24sIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfVGhpcywgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9JbXBvcnRNZXRhLCByZXR1cm5fZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gYW55KGxpc3QsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgICAgICBpZiAobGlzdFtpXS5tYXlfdGhyb3coY29tcHJlc3NvcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkZWZfbWF5X3Rocm93KEFTVF9DbGFzcywgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAodGhpcy5leHRlbmRzICYmIHRoaXMuZXh0ZW5kcy5tYXlfdGhyb3coY29tcHJlc3NvcikpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gYW55KHRoaXMucHJvcGVydGllcywgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfQ2xhc3NTdGF0aWNCbG9jaywgZnVuY3Rpb24gKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuXG4gICAgZGVmX21heV90aHJvdyhBU1RfQXJyYXksIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLmVsZW1lbnRzLCBjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9Bc3NpZ24sIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKHRoaXMucmlnaHQubWF5X3Rocm93KGNvbXByZXNzb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCFjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpXG4gICAgICAgICAgICAmJiB0aGlzLm9wZXJhdG9yID09IFwiPVwiXG4gICAgICAgICAgICAmJiB0aGlzLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfQmluYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQubWF5X3Rocm93KGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLnJpZ2h0Lm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9CbG9jaywgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfQ2FsbCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAoaXNfbnVsbGlzaCh0aGlzLCBjb21wcmVzc29yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYW55KHRoaXMuYXJncywgY29tcHJlc3NvcikpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc19jYWxsZWVfcHVyZShjb21wcmVzc29yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uLm1heV90aHJvdyhjb21wcmVzc29yKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAhKHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpXG4gICAgICAgICAgICB8fCBhbnkodGhpcy5leHByZXNzaW9uLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0Nhc2UsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IGFueSh0aGlzLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbi5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuY29uc2VxdWVudC5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuYWx0ZXJuYXRpdmUubWF5X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0RlZmluaXRpb25zLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5kZWZpbml0aW9ucywgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfSWYsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uLm1heV90aHJvdyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5ib2R5ICYmIHRoaXMuYm9keS5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuYWx0ZXJuYXRpdmUgJiYgdGhpcy5hbHRlcm5hdGl2ZS5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9PYmplY3QsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLnByb3BlcnRpZXMsIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX09iamVjdEtleVZhbCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5jb21wdXRlZF9rZXkoKSAmJiB0aGlzLmtleS5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLm1heV90aHJvdyhjb21wcmVzc29yKSA6IGZhbHNlXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhbXG4gICAgICAgIEFTVF9DbGFzc1Byb3BlcnR5LFxuICAgICAgICBBU1RfQ2xhc3NQcml2YXRlUHJvcGVydHksXG4gICAgXSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5jb21wdXRlZF9rZXkoKSAmJiB0aGlzLmtleS5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuc3RhdGljICYmIHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KFtcbiAgICAgICAgQVNUX0NvbmNpc2VNZXRob2QsXG4gICAgICAgIEFTVF9PYmplY3RHZXR0ZXIsXG4gICAgICAgIEFTVF9PYmplY3RTZXR0ZXIsXG4gICAgXSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZF9rZXkoKSAmJiB0aGlzLmtleS5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhbXG4gICAgICAgIEFTVF9Qcml2YXRlTWV0aG9kLFxuICAgICAgICBBU1RfUHJpdmF0ZUdldHRlcixcbiAgICAgICAgQVNUX1ByaXZhdGVTZXR0ZXIsXG4gICAgXSwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9SZXR1cm4sIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfU2VxdWVuY2UsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLmV4cHJlc3Npb25zLCBjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfRG90LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmIChpc19udWxsaXNoKHRoaXMsIGNvbXByZXNzb3IpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAhdGhpcy5vcHRpb25hbCAmJiB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2Vzcyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5leHByZXNzaW9uLm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9TdWIsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKGlzX251bGxpc2godGhpcywgY29tcHJlc3NvcikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICF0aGlzLm9wdGlvbmFsICYmIHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3dfb25fYWNjZXNzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93KGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLnByb3BlcnR5Lm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9DaGFpbiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9Td2l0Y2gsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IGFueSh0aGlzLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX1N5bWJvbFJlZiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNfZGVjbGFyZWQoY29tcHJlc3NvcikgJiYgIXB1cmVfcHJvcF9hY2Nlc3NfZ2xvYmFscy5oYXModGhpcy5uYW1lKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9TeW1ib2xDbGFzc1Byb3BlcnR5LCByZXR1cm5fZmFsc2UpO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX1RyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5iY2F0Y2ggPyB0aGlzLmJjYXRjaC5tYXlfdGhyb3coY29tcHJlc3NvcikgOiB0aGlzLmJvZHkubWF5X3Rocm93KGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLmJmaW5hbGx5ICYmIHRoaXMuYmZpbmFsbHkubWF5X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX1VuYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09IFwidHlwZW9mXCIgJiYgdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfVmFyRGVmLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG59KShmdW5jdGlvbihub2RlX29yX25vZGVzLCBmdW5jKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIFtdLmNvbmNhdChub2RlX29yX25vZGVzKSkge1xuICAgICAgICBub2RlLkRFRk1FVEhPRChcIm1heV90aHJvd1wiLCBmdW5jKTtcbiAgICB9XG59KTtcblxuLy8gZGV0ZXJtaW5lIGlmIGV4cHJlc3Npb24gaXMgY29uc3RhbnRcbihmdW5jdGlvbihkZWZfaXNfY29uc3RhbnRfZXhwcmVzc2lvbikge1xuICAgIGZ1bmN0aW9uIGFsbF9yZWZzX2xvY2FsKHNjb3BlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgICAgICB3YWxrKHRoaXMsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc19mbGFnKHRoaXMsIElOTElORUQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2Fsa19hYm9ydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IG5vZGUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyKGRlZiwgdGhpcy5lbmNsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgJiYgIXRoaXMudmFyaWFibGVzLmhhcyhkZWYubmFtZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcGVfZGVmID0gc2NvcGUuZmluZF92YXJpYWJsZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYudW5kZWNsYXJlZCA/ICFzY29wZV9kZWYgOiBzY29wZV9kZWYgPT09IGRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFwiZlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2Fsa19hYm9ydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9UaGlzICYmIHRoaXMgaW5zdGFuY2VvZiBBU1RfQXJyb3cpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2Fsa19hYm9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZGVmX2lzX2NvbnN0YW50X2V4cHJlc3Npb24oQVNUX05vZGUsIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX2lzX2NvbnN0YW50X2V4cHJlc3Npb24oQVNUX0NvbnN0YW50LCByZXR1cm5fdHJ1ZSk7XG4gICAgZGVmX2lzX2NvbnN0YW50X2V4cHJlc3Npb24oQVNUX0NsYXNzLCBmdW5jdGlvbihzY29wZSkge1xuICAgICAgICBpZiAodGhpcy5leHRlbmRzICYmICF0aGlzLmV4dGVuZHMuaXNfY29uc3RhbnRfZXhwcmVzc2lvbihzY29wZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wLmNvbXB1dGVkX2tleSgpICYmICFwcm9wLmtleS5pc19jb25zdGFudF9leHByZXNzaW9uKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wLnN0YXRpYyAmJiBwcm9wLnZhbHVlICYmICFwcm9wLnZhbHVlLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfQ2xhc3NTdGF0aWNCbG9jaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbGxfcmVmc19sb2NhbC5jYWxsKHRoaXMsIHNjb3BlKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfY29uc3RhbnRfZXhwcmVzc2lvbihBU1RfTGFtYmRhLCBhbGxfcmVmc19sb2NhbCk7XG4gICAgZGVmX2lzX2NvbnN0YW50X2V4cHJlc3Npb24oQVNUX1VuYXJ5LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5pc19jb25zdGFudF9leHByZXNzaW9uKCk7XG4gICAgfSk7XG4gICAgZGVmX2lzX2NvbnN0YW50X2V4cHJlc3Npb24oQVNUX0JpbmFyeSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuaXNfY29uc3RhbnRfZXhwcmVzc2lvbigpXG4gICAgICAgICAgICAmJiB0aGlzLnJpZ2h0LmlzX2NvbnN0YW50X2V4cHJlc3Npb24oKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfY29uc3RhbnRfZXhwcmVzc2lvbihBU1RfQXJyYXksIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5ldmVyeSgobCkgPT4gbC5pc19jb25zdGFudF9leHByZXNzaW9uKCkpO1xuICAgIH0pO1xuICAgIGRlZl9pc19jb25zdGFudF9leHByZXNzaW9uKEFTVF9PYmplY3QsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmV2ZXJ5KChsKSA9PiBsLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oKSk7XG4gICAgfSk7XG4gICAgZGVmX2lzX2NvbnN0YW50X2V4cHJlc3Npb24oQVNUX09iamVjdFByb3BlcnR5LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhKCEodGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSkgJiYgdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oKSk7XG4gICAgfSk7XG59KShmdW5jdGlvbihub2RlLCBmdW5jKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJpc19jb25zdGFudF9leHByZXNzaW9uXCIsIGZ1bmMpO1xufSk7XG5cblxuLy8gbWF5X3Rocm93X29uX2FjY2VzcygpXG4vLyByZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIG1heSBiZSBudWxsLCB1bmRlZmluZWQgb3IgY29udGFpbiBgQVNUX0FjY2Vzc29yYFxuKGZ1bmN0aW9uKGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKSB7XG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwibWF5X3Rocm93X29uX2FjY2Vzc1wiLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiAhY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIilcbiAgICAgICAgICAgIHx8IHRoaXMuX2RvdF90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzX3N0cmljdChjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiAvc3RyaWN0Ly50ZXN0KGNvbXByZXNzb3Iub3B0aW9uKFwicHVyZV9nZXR0ZXJzXCIpKTtcbiAgICB9XG5cbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfTm9kZSwgaXNfc3RyaWN0KTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfTnVsbCwgcmV0dXJuX3RydWUpO1xuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9VbmRlZmluZWQsIHJldHVybl90cnVlKTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfQ29uc3RhbnQsIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX21heV90aHJvd19vbl9hY2Nlc3MoQVNUX0FycmF5LCByZXR1cm5fZmFsc2UpO1xuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9PYmplY3QsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKCFpc19zdHJpY3QoY29tcHJlc3NvcikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucHJvcGVydGllcy5sZW5ndGg7IC0taSA+PTA7KVxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tpXS5fZG90X3Rocm93KGNvbXByZXNzb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIC8vIERvIG5vdCBiZSBhcyBzdHJpY3Qgd2l0aCBjbGFzc2VzIGFzIHdlIGFyZSB3aXRoIG9iamVjdHMuXG4gICAgLy8gSG9wZWZ1bGx5IHRoZSBjb21tdW5pdHkgaXMgbm90IGdvaW5nIHRvIGFidXNlIHN0YXRpYyBnZXR0ZXJzIGFuZCBzZXR0ZXJzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZXJzZXIvdGVyc2VyL2lzc3Vlcy83MjQjaXNzdWVjb21tZW50LTY0MzY1NTY1NlxuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9DbGFzcywgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfT2JqZWN0UHJvcGVydHksIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX21heV90aHJvd19vbl9hY2Nlc3MoQVNUX09iamVjdEdldHRlciwgcmV0dXJuX3RydWUpO1xuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9FeHBhbnNpb24sIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5fZG90X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9GdW5jdGlvbiwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfQXJyb3csIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX21heV90aHJvd19vbl9hY2Nlc3MoQVNUX1VuYXJ5UG9zdGZpeCwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcInZvaWRcIjtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfQmluYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5vcGVyYXRvciA9PSBcIiYmXCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcInx8XCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcIj8/XCIpXG4gICAgICAgICAgICAmJiAodGhpcy5sZWZ0Ll9kb3RfdGhyb3coY29tcHJlc3NvcikgfHwgdGhpcy5yaWdodC5fZG90X3Rocm93KGNvbXByZXNzb3IpKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfQXNzaWduLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmxvZ2ljYWwpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yID09IFwiPVwiXG4gICAgICAgICAgICAmJiB0aGlzLnJpZ2h0Ll9kb3RfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvd19vbl9hY2Nlc3MoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnNlcXVlbnQuX2RvdF90aHJvdyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5hbHRlcm5hdGl2ZS5fZG90X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9Eb3QsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKCFpc19zdHJpY3QoY29tcHJlc3NvcikpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gIShcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb25cbiAgICAgICAgICAgICAgICB8fCB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfQ2xhc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvd19vbl9hY2Nlc3MoQVNUX0NoYWluLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uX2RvdF90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfU2VxdWVuY2UsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFpbF9ub2RlKCkuX2RvdF90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT09IFwiYXJndW1lbnRzXCIgJiYgdGhpcy5zY29wZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGhhc19mbGFnKHRoaXMsIFVOREVGSU5FRCkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIWlzX3N0cmljdChjb21wcmVzc29yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoaXNfdW5kZWNsYXJlZF9yZWYodGhpcykgJiYgdGhpcy5pc19kZWNsYXJlZChjb21wcmVzc29yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc19pbW11dGFibGUoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZml4ZWQgPSB0aGlzLmZpeGVkX3ZhbHVlKCk7XG4gICAgICAgIHJldHVybiAhZml4ZWQgfHwgZml4ZWQuX2RvdF90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbn0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcIl9kb3RfdGhyb3dcIiwgZnVuYyk7XG59KTtcblxuZnVuY3Rpb24gaXNfbGhzKG5vZGUsIHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfVW5hcnkgJiYgdW5hcnlfc2lkZV9lZmZlY3RzLmhhcyhwYXJlbnQub3BlcmF0b3IpKSByZXR1cm4gcGFyZW50LmV4cHJlc3Npb247XG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24gJiYgcGFyZW50LmxlZnQgPT09IG5vZGUpIHJldHVybiBub2RlO1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfRm9ySW4gJiYgcGFyZW50LmluaXQgPT09IG5vZGUpIHJldHVybiBub2RlO1xufVxuXG4vLyBtZXRob2QgdG8gbmVnYXRlIGFuIGV4cHJlc3Npb25cbihmdW5jdGlvbihkZWZfbmVnYXRlKSB7XG4gICAgZnVuY3Rpb24gYmFzaWNfbmVnYXRpb24oZXhwKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBleHAsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmVzdChvcmlnLCBhbHQsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgICAgICB2YXIgbmVnYXRlZCA9IGJhc2ljX25lZ2F0aW9uKG9yaWcpO1xuICAgICAgICBpZiAoZmlyc3RfaW5fc3RhdGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgc3RhdCA9IG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBhbHQsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBhbHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2ZfZXhwcmVzc2lvbihuZWdhdGVkLCBzdGF0KSA9PT0gc3RhdCA/IGFsdCA6IG5lZ2F0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3Rfb2ZfZXhwcmVzc2lvbihuZWdhdGVkLCBhbHQpO1xuICAgIH1cbiAgICBkZWZfbmVnYXRlKEFTVF9Ob2RlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJhc2ljX25lZ2F0aW9uKHRoaXMpO1xuICAgIH0pO1xuICAgIGRlZl9uZWdhdGUoQVNUX1N0YXRlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBuZWdhdGUgYSBzdGF0ZW1lbnRcIik7XG4gICAgfSk7XG4gICAgZGVmX25lZ2F0ZShBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgfSk7XG4gICAgZGVmX25lZ2F0ZShBU1RfQ2xhc3MsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgfSk7XG4gICAgZGVmX25lZ2F0ZShBU1RfQXJyb3csIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgfSk7XG4gICAgZGVmX25lZ2F0ZShBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRvciA9PSBcIiFcIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiBiYXNpY19uZWdhdGlvbih0aGlzKTtcbiAgICB9KTtcbiAgICBkZWZfbmVnYXRlKEFTVF9TZXF1ZW5jZSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aGlzLmV4cHJlc3Npb25zLnNsaWNlKCk7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbnMucG9wKCkubmVnYXRlKGNvbXByZXNzb3IpKTtcbiAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2UodGhpcywgZXhwcmVzc2lvbnMpO1xuICAgIH0pO1xuICAgIGRlZl9uZWdhdGUoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHNlbGYuY29uc2VxdWVudCA9IHNlbGYuY29uc2VxdWVudC5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIHNlbGYuYWx0ZXJuYXRpdmUgPSBzZWxmLmFsdGVybmF0aXZlLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgcmV0dXJuIGJlc3QodGhpcywgc2VsZiwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICB9KTtcbiAgICBkZWZfbmVnYXRlKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMuY2xvbmUoKSwgb3AgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfY29tcHNcIikpIHtcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgY2FzZSBcIjw9XCIgOiBzZWxmLm9wZXJhdG9yID0gXCI+XCIgIDsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgIGNhc2UgXCI8XCIgIDogc2VsZi5vcGVyYXRvciA9IFwiPj1cIiA7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICBjYXNlIFwiPj1cIiA6IHNlbGYub3BlcmF0b3IgPSBcIjxcIiAgOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgY2FzZSBcIj5cIiAgOiBzZWxmLm9wZXJhdG9yID0gXCI8PVwiIDsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgIGNhc2UgXCI9PVwiIDogc2VsZi5vcGVyYXRvciA9IFwiIT1cIjsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgY2FzZSBcIiE9XCIgOiBzZWxmLm9wZXJhdG9yID0gXCI9PVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICBjYXNlIFwiPT09XCI6IHNlbGYub3BlcmF0b3IgPSBcIiE9PVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICBjYXNlIFwiIT09XCI6IHNlbGYub3BlcmF0b3IgPSBcIj09PVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICBjYXNlIFwiJiZcIjpcbiAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPSBcInx8XCI7XG4gICAgICAgICAgICBzZWxmLmxlZnQgPSBzZWxmLmxlZnQubmVnYXRlKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICByZXR1cm4gYmVzdCh0aGlzLCBzZWxmLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgICAgICAgIGNhc2UgXCJ8fFwiOlxuICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9IFwiJiZcIjtcbiAgICAgICAgICAgIHNlbGYubGVmdCA9IHNlbGYubGVmdC5uZWdhdGUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0Lm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHJldHVybiBiZXN0KHRoaXMsIHNlbGYsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2ljX25lZ2F0aW9uKHRoaXMpO1xuICAgIH0pO1xufSkoZnVuY3Rpb24obm9kZSwgZnVuYykge1xuICAgIG5vZGUuREVGTUVUSE9EKFwibmVnYXRlXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgfSk7XG59KTtcblxuKGZ1bmN0aW9uIChkZWZfYml0d2lzZV9uZWdhdGUpIHtcbiAgICBmdW5jdGlvbiBiYXNpY19iaXR3aXNlX25lZ2F0aW9uKGV4cCkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgZXhwLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCJ+XCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHBcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVmX2JpdHdpc2VfbmVnYXRlKEFTVF9Ob2RlLCBmdW5jdGlvbihfY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYmFzaWNfYml0d2lzZV9uZWdhdGlvbih0aGlzKTtcbiAgICB9KTtcblxuICAgIGRlZl9iaXR3aXNlX25lZ2F0ZShBU1RfTnVtYmVyLCBmdW5jdGlvbihfY29tcHJlc3Nvcikge1xuICAgICAgICBjb25zdCBuZWcgPSB+dGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKG5lZy50b1N0cmluZygpLmxlbmd0aCA+IHRoaXMudmFsdWUudG9TdHJpbmcoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY19iaXR3aXNlX25lZ2F0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX051bWJlciwgdGhpcywgeyB2YWx1ZTogbmVnIH0pO1xuICAgIH0pO1xuXG4gICAgZGVmX2JpdHdpc2VfbmVnYXRlKEFTVF9VbmFyeVByZWZpeCwgZnVuY3Rpb24oY29tcHJlc3NvciwgaW5fMzJfYml0X2NvbnRleHQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9PSBcIn5cIlxuICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5pc18zMl9iaXRfaW50ZWdlcihjb21wcmVzc29yKSB8fFxuICAgICAgICAgICAgICAgIChpbl8zMl9iaXRfY29udGV4dCAhPSBudWxsID8gaW5fMzJfYml0X2NvbnRleHQgOiBjb21wcmVzc29yLmluXzMyX2JpdF9jb250ZXh0KCkpXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY19iaXR3aXNlX25lZ2F0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSk7XG59KShmdW5jdGlvbiAobm9kZSwgZnVuYykge1xuICAgIG5vZGUuREVGTUVUSE9EKFwiYml0d2lzZV9uZWdhdGVcIiwgZnVuYyk7XG59KTtcblxuLy8gSXMgdGhlIGNhbGxlZSBvZiB0aGlzIGZ1bmN0aW9uIHB1cmU/XG52YXIgZ2xvYmFsX3B1cmVfZm5zID0gbWFrZVByZWRpY2F0ZShcIkJvb2xlYW4gZGVjb2RlVVJJIGRlY29kZVVSSUNvbXBvbmVudCBEYXRlIGVuY29kZVVSSSBlbmNvZGVVUklDb21wb25lbnQgRXJyb3IgZXNjYXBlIEV2YWxFcnJvciBpc0Zpbml0ZSBpc05hTiBOdW1iZXIgT2JqZWN0IHBhcnNlRmxvYXQgcGFyc2VJbnQgUmFuZ2VFcnJvciBSZWZlcmVuY2VFcnJvciBTdHJpbmcgU3ludGF4RXJyb3IgVHlwZUVycm9yIHVuZXNjYXBlIFVSSUVycm9yXCIpO1xuQVNUX0NhbGwuREVGTUVUSE9EKFwiaXNfY2FsbGVlX3B1cmVcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZVwiKSkge1xuICAgICAgICB2YXIgZXhwciA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgdmFyIGZpcnN0X2FyZyA9ICh0aGlzLmFyZ3MgJiYgdGhpcy5hcmdzWzBdICYmIHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjb21wcmVzc29yKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGV4cHIuZXhwcmVzc2lvbiAmJiBleHByLmV4cHJlc3Npb24ubmFtZSA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiICYmXG4gICAgICAgICAgICAoZmlyc3RfYXJnID09IG51bGwgfHwgZmlyc3RfYXJnLnRoZWRlZiAmJiBmaXJzdF9hcmcudGhlZGVmLnVuZGVjbGFyZWQpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc191bmRlY2xhcmVkX3JlZihleHByKSAmJiBnbG9iYWxfcHVyZV9mbnMuaGFzKGV4cHIubmFtZSkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBleHByIGluc3RhbmNlb2YgQVNUX0RvdFxuICAgICAgICAgICAgJiYgaXNfdW5kZWNsYXJlZF9yZWYoZXhwci5leHByZXNzaW9uKVxuICAgICAgICAgICAgJiYgaXNfcHVyZV9uYXRpdmVfZm4oZXhwci5leHByZXNzaW9uLm5hbWUsIGV4cHIucHJvcGVydHkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh0aGlzIGluc3RhbmNlb2YgQVNUX05ldykgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX25ld1wiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2lkZV9lZmZlY3RzXCIpICYmIGhhc19hbm5vdGF0aW9uKHRoaXMsIF9QVVJFKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICFjb21wcmVzc29yLnB1cmVfZnVuY3ModGhpcyk7XG59KTtcblxuLy8gSWYgSSBjYWxsIHRoaXMsIGlzIGl0IGEgcHVyZSBmdW5jdGlvbj9cbkFTVF9Ob2RlLkRFRk1FVEhPRChcImlzX2NhbGxfcHVyZVwiLCByZXR1cm5fZmFsc2UpO1xuQVNUX0RvdC5ERUZNRVRIT0QoXCJpc19jYWxsX3B1cmVcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHJldHVybjtcbiAgICBjb25zdCBleHByID0gdGhpcy5leHByZXNzaW9uO1xuXG4gICAgbGV0IG5hdGl2ZV9vYmo7XG4gICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfQXJyYXkpIHtcbiAgICAgICAgbmF0aXZlX29iaiA9IFwiQXJyYXlcIjtcbiAgICB9IGVsc2UgaWYgKGV4cHIuaXNfYm9vbGVhbigpKSB7XG4gICAgICAgIG5hdGl2ZV9vYmogPSBcIkJvb2xlYW5cIjtcbiAgICB9IGVsc2UgaWYgKGV4cHIuaXNfbnVtYmVyKGNvbXByZXNzb3IpKSB7XG4gICAgICAgIG5hdGl2ZV9vYmogPSBcIk51bWJlclwiO1xuICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9SZWdFeHApIHtcbiAgICAgICAgbmF0aXZlX29iaiA9IFwiUmVnRXhwXCI7XG4gICAgfSBlbHNlIGlmIChleHByLmlzX3N0cmluZyhjb21wcmVzc29yKSkge1xuICAgICAgICBuYXRpdmVfb2JqID0gXCJTdHJpbmdcIjtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLm1heV90aHJvd19vbl9hY2Nlc3MoY29tcHJlc3NvcikpIHtcbiAgICAgICAgbmF0aXZlX29iaiA9IFwiT2JqZWN0XCI7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVfb2JqICE9IG51bGwgJiYgaXNfcHVyZV9uYXRpdmVfbWV0aG9kKG5hdGl2ZV9vYmosIHRoaXMucHJvcGVydHkpO1xufSk7XG5cbi8vIHRlbGwgbWUgaWYgYSBzdGF0ZW1lbnQgYWJvcnRzXG5jb25zdCBhYm9ydHMgPSAodGhpbmcpID0+IHRoaW5nICYmIHRoaW5nLmFib3J0cygpO1xuXG4oZnVuY3Rpb24oZGVmX2Fib3J0cykge1xuICAgIGRlZl9hYm9ydHMoQVNUX1N0YXRlbWVudCwgcmV0dXJuX251bGwpO1xuICAgIGRlZl9hYm9ydHMoQVNUX0p1bXAsIHJldHVybl90aGlzKTtcbiAgICBmdW5jdGlvbiBibG9ja19hYm9ydHMoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYWJvcnRzKHRoaXMuYm9keVtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZWZfYWJvcnRzKEFTVF9JbXBvcnQsIHJldHVybl9udWxsKTtcbiAgICBkZWZfYWJvcnRzKEFTVF9CbG9ja1N0YXRlbWVudCwgYmxvY2tfYWJvcnRzKTtcbiAgICBkZWZfYWJvcnRzKEFTVF9Td2l0Y2hCcmFuY2gsIGJsb2NrX2Fib3J0cyk7XG4gICAgZGVmX2Fib3J0cyhBU1RfRGVmQ2xhc3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfQ2xhc3NTdGF0aWNCbG9jaykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLmFib3J0cygpKSByZXR1cm4gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBkZWZfYWJvcnRzKEFTVF9DbGFzc1N0YXRpY0Jsb2NrLCBibG9ja19hYm9ydHMpO1xuICAgIGRlZl9hYm9ydHMoQVNUX0lmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWx0ZXJuYXRpdmUgJiYgYWJvcnRzKHRoaXMuYm9keSkgJiYgYWJvcnRzKHRoaXMuYWx0ZXJuYXRpdmUpICYmIHRoaXM7XG4gICAgfSk7XG59KShmdW5jdGlvbihub2RlLCBmdW5jKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJhYm9ydHNcIiwgZnVuYyk7XG59KTtcblxuQVNUX05vZGUuREVGTUVUSE9EKFwiY29udGFpbnNfdGhpc1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gd2Fsayh0aGlzLCBub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVGhpcykgcmV0dXJuIHdhbGtfYWJvcnQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG5vZGUgIT09IHRoaXNcbiAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGVcbiAgICAgICAgICAgICYmICEobm9kZSBpbnN0YW5jZW9mIEFTVF9BcnJvdylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGlzX21vZGlmaWVkKGNvbXByZXNzb3IsIHR3LCBub2RlLCB2YWx1ZSwgbGV2ZWwsIGltbXV0YWJsZSkge1xuICAgIHZhciBwYXJlbnQgPSB0dy5wYXJlbnQobGV2ZWwpO1xuICAgIHZhciBsaHMgPSBpc19saHMobm9kZSwgcGFyZW50KTtcbiAgICBpZiAobGhzKSByZXR1cm4gbGhzO1xuICAgIGlmICghaW1tdXRhYmxlXG4gICAgICAgICYmIHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICYmIHBhcmVudC5leHByZXNzaW9uID09PSBub2RlXG4gICAgICAgICYmICEodmFsdWUgaW5zdGFuY2VvZiBBU1RfQXJyb3cpXG4gICAgICAgICYmICEodmFsdWUgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpXG4gICAgICAgICYmICFwYXJlbnQuaXNfY2FsbGVlX3B1cmUoY29tcHJlc3NvcilcbiAgICAgICAgJiYgKCEodmFsdWUgaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb24pXG4gICAgICAgICAgICB8fCAhKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9OZXcpICYmIHZhbHVlLmNvbnRhaW5zX3RoaXMoKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGlzX21vZGlmaWVkKGNvbXByZXNzb3IsIHR3LCBwYXJlbnQsIHBhcmVudCwgbGV2ZWwgKyAxKTtcbiAgICB9XG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9PYmplY3RLZXlWYWwgJiYgbm9kZSA9PT0gcGFyZW50LnZhbHVlKSB7XG4gICAgICAgIHZhciBvYmogPSB0dy5wYXJlbnQobGV2ZWwgKyAxKTtcbiAgICAgICAgcmV0dXJuIGlzX21vZGlmaWVkKGNvbXByZXNzb3IsIHR3LCBvYmosIG9iaiwgbGV2ZWwgKyAyKTtcbiAgICB9XG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHBhcmVudC5leHByZXNzaW9uID09PSBub2RlKSB7XG4gICAgICAgIHZhciBwcm9wID0gcmVhZF9wcm9wZXJ0eSh2YWx1ZSwgcGFyZW50LnByb3BlcnR5KTtcbiAgICAgICAgcmV0dXJuICFpbW11dGFibGUgJiYgaXNfbW9kaWZpZWQoY29tcHJlc3NvciwgdHcsIHBhcmVudCwgcHJvcCwgbGV2ZWwgKyAxKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIG1heSBiZSB1c2VkIGJ5IHRoZSBleHByZXNzaW9uIGl0J3MgaW5cbiAqIHZvaWQgKDAsIDEsIHtub2RlfSwgMikgLT4gZmFsc2VcbiAqIGNvbnNvbGUubG9nKDAsIHtub2RlfSkgLT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc191c2VkX2luX2V4cHJlc3Npb24odHcpIHtcbiAgICBmb3IgKGxldCBwID0gLTEsIG5vZGUsIHBhcmVudDsgbm9kZSA9IHR3LnBhcmVudChwKSwgcGFyZW50ID0gdHcucGFyZW50KHAgKyAxKTsgcCsrKSB7XG4gICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG50aF9leHByZXNzaW9uID0gcGFyZW50LmV4cHJlc3Npb25zLmluZGV4T2Yobm9kZSk7XG4gICAgICAgICAgICBpZiAobnRoX2V4cHJlc3Npb24gIT09IHBhcmVudC5leHByZXNzaW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZWN0ICgwLCB4Lm5vVGhpcykoKSBjb25zdHJ1Y3RzXG4gICAgICAgICAgICAgICAgY29uc3QgZ3JhbmRwYXJlbnQgPSB0dy5wYXJlbnQocCArIDIpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmV4cHJlc3Npb25zLmxlbmd0aCA+IDJcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyZW50LmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICB8fCAhcmVxdWlyZXNfc2VxdWVuY2VfdG9fbWFpbnRhaW5fYmluZGluZyhncmFuZHBhcmVudCwgcGFyZW50LCBwYXJlbnQuZXhwcmVzc2lvbnNbMV0pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfVW5hcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wID0gcGFyZW50Lm9wZXJhdG9yO1xuICAgICAgICAgICAgaWYgKG9wID09PSBcInZvaWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJ0eXBlb2ZcIiB8fCBvcCA9PT0gXCIrXCIgfHwgb3AgPT09IFwiLVwiIHx8IG9wID09PSBcIiFcIiB8fCBvcCA9PT0gXCJ+XCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50XG4gICAgICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfTGFiZWxlZFN0YXRlbWVudFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gbWV0aG9kcyB0byBldmFsdWF0ZSBhIGNvbnN0YW50IGV4cHJlc3Npb25cblxuZnVuY3Rpb24gZGVmX2V2YWwobm9kZSwgZnVuYykge1xuICAgIG5vZGUuREVGTUVUSE9EKFwiX2V2YWxcIiwgZnVuYyk7XG59XG5cbi8vIFVzZWQgdG8gcHJvcGFnYXRlIGEgbnVsbGlzaCBzaG9ydC1jaXJjdWl0IHNpZ25hbCB1cHdhcmRzIHRocm91Z2ggdGhlIGNoYWluLlxuY29uc3QgbnVsbGlzaCA9IFN5bWJvbChcIlRoaXMgQVNUX0NoYWluIGlzIG51bGxpc2hcIik7XG5cbi8vIElmIHRoZSBub2RlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSByZWR1Y2VkIHRvIGEgY29uc3RhbnQsXG4vLyB0aGVuIGl0cyB2YWx1ZSBpcyByZXR1cm5lZDsgb3RoZXJ3aXNlIHRoZSBlbGVtZW50IGl0c2VsZlxuLy8gaXMgcmV0dXJuZWQuXG4vLyBUaGV5IGNhbiBiZSBkaXN0aW5ndWlzaGVkIGFzIGNvbnN0YW50IHZhbHVlIGlzIG5ldmVyIGFcbi8vIGRlc2NlbmRhbnQgb2YgQVNUX05vZGUuXG5BU1RfTm9kZS5ERUZNRVRIT0QoXCJldmFsdWF0ZVwiLCBmdW5jdGlvbiAoY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJldmFsdWF0ZVwiKSlcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHZhbCA9IHRoaXMuX2V2YWwoY29tcHJlc3NvciwgMSk7XG4gICAgaWYgKCF2YWwgfHwgdmFsIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIGlmICh0eXBlb2YgdmFsID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgdmFsID09IFwib2JqZWN0XCIgfHwgdmFsID09IG51bGxpc2gpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgLy8gRXZhbHVhdGVkIHN0cmluZ3MgY2FuIGJlIGxhcmdlciB0aGFuIHRoZSBvcmlnaW5hbCBleHByZXNzaW9uXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgdW5ldmFsdWF0ZWRfc2l6ZSA9IHRoaXMuc2l6ZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKHZhbC5sZW5ndGggKyAyID4gdW5ldmFsdWF0ZWRfc2l6ZSkgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbn0pO1xuXG52YXIgdW5hcnlQcmVmaXggPSBtYWtlUHJlZGljYXRlKFwiISB+IC0gKyB2b2lkXCIpO1xuQVNUX05vZGUuREVGTUVUSE9EKFwiaXNfY29uc3RhbnRcIiwgZnVuY3Rpb24gKCkge1xuICAgIC8vIEFjY29tb2RhdGUgd2hlbiBjb21wcmVzcyBvcHRpb24gZXZhbHVhdGU9ZmFsc2VcbiAgICAvLyBhcyB3ZWxsIGFzIHRoZSBjb21tb24gY29uc3RhbnQgZXhwcmVzc2lvbnMgITAgYW5kIC0xXG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcyBpbnN0YW5jZW9mIEFTVF9SZWdFeHApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAmJiB1bmFyeVByZWZpeC5oYXModGhpcy5vcGVyYXRvcilcbiAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAvLyBgdGhpcy5leHByZXNzaW9uYCBtYXkgYmUgYW4gYEFTVF9SZWdFeHBgLFxuICAgICAgICAgICAgICAgIC8vIHNvIG5vdCBvbmx5IGAuaXNfY29uc3RhbnQoKWAuXG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgfHwgdGhpcy5leHByZXNzaW9uLmlzX2NvbnN0YW50KClcbiAgICAgICAgICAgICk7XG4gICAgfVxufSk7XG5cbmRlZl9ldmFsKEFTVF9TdGF0ZW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyaW5nX3RlbXBsYXRlKFwiQ2Fubm90IGV2YWx1YXRlIGEgc3RhdGVtZW50IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB0aGlzLnN0YXJ0KSk7XG59KTtcblxuZGVmX2V2YWwoQVNUX0xhbWJkYSwgcmV0dXJuX3RoaXMpO1xuZGVmX2V2YWwoQVNUX0NsYXNzLCByZXR1cm5fdGhpcyk7XG5kZWZfZXZhbChBU1RfTm9kZSwgcmV0dXJuX3RoaXMpO1xuZGVmX2V2YWwoQVNUX0NvbnN0YW50LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbn0pO1xuXG5jb25zdCBzdXBwb3J0c19iaWdpbnQgPSB0eXBlb2YgQmlnSW50ID09PSBcImZ1bmN0aW9uXCI7XG5kZWZfZXZhbChBU1RfQmlnSW50LCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN1cHBvcnRzX2JpZ2ludCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG5kZWZfZXZhbChBU1RfUmVnRXhwLCBmdW5jdGlvbiAoY29tcHJlc3Nvcikge1xuICAgIGxldCBldmFsdWF0ZWQgPSBjb21wcmVzc29yLmV2YWx1YXRlZF9yZWdleHBzLmdldCh0aGlzLnZhbHVlKTtcbiAgICBpZiAoZXZhbHVhdGVkID09PSB1bmRlZmluZWQgJiYgcmVnZXhwX2lzX3NhZmUodGhpcy52YWx1ZS5zb3VyY2UpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IHNvdXJjZSwgZmxhZ3MgfSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBldmFsdWF0ZWQgPSBuZXcgUmVnRXhwKHNvdXJjZSwgZmxhZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBldmFsdWF0ZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbXByZXNzb3IuZXZhbHVhdGVkX3JlZ2V4cHMuc2V0KHRoaXMudmFsdWUsIGV2YWx1YXRlZCk7XG4gICAgfVxuICAgIHJldHVybiBldmFsdWF0ZWQgfHwgdGhpcztcbn0pO1xuXG5kZWZfZXZhbChBU1RfVGVtcGxhdGVTdHJpbmcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGggIT09IDEpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiB0aGlzLnNlZ21lbnRzWzBdLnZhbHVlO1xufSk7XG5cbmRlZl9ldmFsKEFTVF9GdW5jdGlvbiwgZnVuY3Rpb24gKGNvbXByZXNzb3IpIHtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBmbi5ub2RlID0gdGhpcztcbiAgICAgICAgZm4udG9TdHJpbmcgPSAoKSA9PiB0aGlzLnByaW50X3RvX3N0cmluZygpO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSk7XG5cbmRlZl9ldmFsKEFTVF9BcnJheSwgZnVuY3Rpb24gKGNvbXByZXNzb3IsIGRlcHRoKSB7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZWxlbWVudC5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSk7XG5cbmRlZl9ldmFsKEFTVF9PYmplY3QsIGZ1bmN0aW9uIChjb21wcmVzc29yLCBkZXB0aCkge1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZVwiKSkge1xuICAgICAgICB2YXIgdmFsID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3Aua2V5O1xuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEFTVF9TeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkubmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5IGluc3RhbmNlb2YgQVNUX05vZGUpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkuX2V2YWwoY29tcHJlc3NvciwgZGVwdGgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHByb3Aua2V5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LnByb3RvdHlwZVtrZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wLnZhbHVlIGluc3RhbmNlb2YgQVNUX0Z1bmN0aW9uKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFsW2tleV0gPSBwcm9wLnZhbHVlLl9ldmFsKGNvbXByZXNzb3IsIGRlcHRoKTtcbiAgICAgICAgICAgIGlmICh2YWxba2V5XSA9PT0gcHJvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn0pO1xuXG52YXIgbm9uX2NvbnZlcnRpbmdfdW5hcnkgPSBtYWtlUHJlZGljYXRlKFwiISB0eXBlb2Ygdm9pZFwiKTtcbmRlZl9ldmFsKEFTVF9VbmFyeVByZWZpeCwgZnVuY3Rpb24gKGNvbXByZXNzb3IsIGRlcHRoKSB7XG4gICAgdmFyIGUgPSB0aGlzLmV4cHJlc3Npb247XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidHlwZW9mc1wiKVxuICAgICAgICAmJiB0aGlzLm9wZXJhdG9yID09IFwidHlwZW9mXCIpIHtcbiAgICAgICAgLy8gRnVuY3Rpb24gd291bGQgYmUgZXZhbHVhdGVkIHRvIGFuIGFycmF5IGFuZCBzbyB0eXBlb2Ygd291bGRcbiAgICAgICAgLy8gaW5jb3JyZWN0bHkgcmV0dXJuICdvYmplY3QnLiBIZW5jZSBtYWtpbmcgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX0xhbWJkYVxuICAgICAgICAgICAgfHwgZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICYmIGUuZml4ZWRfdmFsdWUoKSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChlIGluc3RhbmNlb2YgQVNUX09iamVjdFxuICAgICAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfQXJyYXlcbiAgICAgICAgICAgICAgICB8fCAoZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICAgJiYgKGUuZml4ZWRfdmFsdWUoKSBpbnN0YW5jZW9mIEFTVF9PYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGUuZml4ZWRfdmFsdWUoKSBpbnN0YW5jZW9mIEFTVF9BcnJheSkpKVxuICAgICAgICAgICAgJiYgIWUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Yge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFub25fY29udmVydGluZ191bmFyeS5oYXModGhpcy5vcGVyYXRvcikpXG4gICAgICAgIGRlcHRoKys7XG4gICAgZSA9IGUuX2V2YWwoY29tcHJlc3NvciwgZGVwdGgpO1xuICAgIGlmIChlID09PSB0aGlzLmV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIHN3aXRjaCAodGhpcy5vcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiIVwiOiByZXR1cm4gIWU7XG4gICAgICAgIGNhc2UgXCJ0eXBlb2ZcIjpcbiAgICAgICAgICAgIC8vIHR5cGVvZiA8UmVnRXhwPiByZXR1cm5zIFwib2JqZWN0XCIgb3IgXCJmdW5jdGlvblwiIG9uIGRpZmZlcmVudCBwbGF0Zm9ybXNcbiAgICAgICAgICAgIC8vIHNvIGNhbm5vdCBldmFsdWF0ZSByZWxpYWJseVxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGU7XG4gICAgICAgIGNhc2UgXCJ2b2lkXCI6IHJldHVybiB2b2lkIGU7XG4gICAgICAgIGNhc2UgXCJ+XCI6IHJldHVybiB+ZTtcbiAgICAgICAgY2FzZSBcIi1cIjogcmV0dXJuIC1lO1xuICAgICAgICBjYXNlIFwiK1wiOiByZXR1cm4gK2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSk7XG5cbnZhciBub25fY29udmVydGluZ19iaW5hcnkgPSBtYWtlUHJlZGljYXRlKFwiJiYgfHwgPz8gPT09ICE9PVwiKTtcbmNvbnN0IGlkZW50aXR5X2NvbXBhcmlzb24gPSBtYWtlUHJlZGljYXRlKFwiPT0gIT0gPT09ICE9PVwiKTtcbmNvbnN0IGhhc19pZGVudGl0eSA9IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIlxuICAgIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgfHwgdHlwZW9mIHZhbHVlID09PSBcInN5bWJvbFwiO1xuXG5kZWZfZXZhbChBU1RfQmluYXJ5LCBmdW5jdGlvbiAoY29tcHJlc3NvciwgZGVwdGgpIHtcbiAgICBpZiAoIW5vbl9jb252ZXJ0aW5nX2JpbmFyeS5oYXModGhpcy5vcGVyYXRvcikpXG4gICAgICAgIGRlcHRoKys7XG5cbiAgICB2YXIgbGVmdCA9IHRoaXMubGVmdC5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgaWYgKGxlZnQgPT09IHRoaXMubGVmdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHJpZ2h0ID0gdGhpcy5yaWdodC5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgaWYgKHJpZ2h0ID09PSB0aGlzLnJpZ2h0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsZWZ0ICE9IG51bGxcbiAgICAgICAgJiYgcmlnaHQgIT0gbnVsbFxuICAgICAgICAmJiBpZGVudGl0eV9jb21wYXJpc29uLmhhcyh0aGlzLm9wZXJhdG9yKVxuICAgICAgICAmJiBoYXNfaWRlbnRpdHkobGVmdClcbiAgICAgICAgJiYgaGFzX2lkZW50aXR5KHJpZ2h0KVxuICAgICAgICAmJiB0eXBlb2YgbGVmdCA9PT0gdHlwZW9mIHJpZ2h0KSB7XG4gICAgICAgIC8vIERvIG5vdCBjb21wYXJlIGJ5IHJlZmVyZW5jZVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBEbyBub3QgbWl4IEJpZ0ludCBhbmQgTnVtYmVyOyBEb24ndCB1c2UgYD4+PmAgb24gQmlnSW50IG9yIGAvIDBuYFxuICAgIGlmIChcbiAgICAgICAgKHR5cGVvZiBsZWZ0ID09PSBcImJpZ2ludFwiKSAhPT0gKHR5cGVvZiByaWdodCA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgfHwgdHlwZW9mIGxlZnQgPT09IFwiYmlnaW50XCJcbiAgICAgICAgICAgICYmICh0aGlzLm9wZXJhdG9yID09PSBcIj4+PlwiXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5vcGVyYXRvciA9PT0gXCIvXCIgJiYgTnVtYmVyKHJpZ2h0KSA9PT0gMClcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdDtcbiAgICBzd2l0Y2ggKHRoaXMub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIiYmXCI6IHJlc3VsdCA9IGxlZnQgJiYgcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwifHxcIjogcmVzdWx0ID0gbGVmdCB8fCByaWdodDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI/P1wiOiByZXN1bHQgPSBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwifFwiOiByZXN1bHQgPSBsZWZ0IHwgcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiJlwiOiByZXN1bHQgPSBsZWZ0ICYgcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOiByZXN1bHQgPSBsZWZ0IF4gcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiK1wiOiByZXN1bHQgPSBsZWZ0ICsgcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiKlwiOiByZXN1bHQgPSBsZWZ0ICogcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiKipcIjogcmVzdWx0ID0gbGVmdCAqKiByaWdodDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIvXCI6IHJlc3VsdCA9IGxlZnQgLyByaWdodDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIlXCI6IHJlc3VsdCA9IGxlZnQgJSByaWdodDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCItXCI6IHJlc3VsdCA9IGxlZnQgLSByaWdodDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI8PFwiOiByZXN1bHQgPSBsZWZ0IDw8IHJpZ2h0OyBicmVhaztcbiAgICAgICAgY2FzZSBcIj4+XCI6IHJlc3VsdCA9IGxlZnQgPj4gcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPj4+XCI6IHJlc3VsdCA9IGxlZnQgPj4+IHJpZ2h0OyBicmVhaztcbiAgICAgICAgY2FzZSBcIj09XCI6IHJlc3VsdCA9IGxlZnQgPT0gcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPT09XCI6IHJlc3VsdCA9IGxlZnQgPT09IHJpZ2h0OyBicmVhaztcbiAgICAgICAgY2FzZSBcIiE9XCI6IHJlc3VsdCA9IGxlZnQgIT0gcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiIT09XCI6IHJlc3VsdCA9IGxlZnQgIT09IHJpZ2h0OyBicmVhaztcbiAgICAgICAgY2FzZSBcIjxcIjogcmVzdWx0ID0gbGVmdCA8IHJpZ2h0OyBicmVhaztcbiAgICAgICAgY2FzZSBcIjw9XCI6IHJlc3VsdCA9IGxlZnQgPD0gcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPlwiOiByZXN1bHQgPSBsZWZ0ID4gcmlnaHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPj1cIjogcmVzdWx0ID0gbGVmdCA+PSByaWdodDsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4ocmVzdWx0KSAmJiBjb21wcmVzc29yLmZpbmRfcGFyZW50KEFTVF9XaXRoKSkge1xuICAgICAgICAvLyBsZWF2ZSBvcmlnaW5hbCBleHByZXNzaW9uIGFzIGlzXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmRlZl9ldmFsKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24gKGNvbXByZXNzb3IsIGRlcHRoKSB7XG4gICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMuY29uZGl0aW9uLl9ldmFsKGNvbXByZXNzb3IsIGRlcHRoKTtcbiAgICBpZiAoY29uZGl0aW9uID09PSB0aGlzLmNvbmRpdGlvbilcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgdmFyIG5vZGUgPSBjb25kaXRpb24gPyB0aGlzLmNvbnNlcXVlbnQgOiB0aGlzLmFsdGVybmF0aXZlO1xuICAgIHZhciB2YWx1ZSA9IG5vZGUuX2V2YWwoY29tcHJlc3NvciwgZGVwdGgpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbm9kZSA/IHRoaXMgOiB2YWx1ZTtcbn0pO1xuXG4vLyBTZXQgb2YgQVNUX1N5bWJvbFJlZiB3aGljaCBhcmUgY3VycmVudGx5IGJlaW5nIGV2YWx1YXRlZC5cbi8vIEF2b2lkcyBpbmZpbml0ZSByZWN1cnNpb24gb2YgLl9ldmFsKClcbmNvbnN0IHJlZW50cmFudF9yZWZfZXZhbCA9IG5ldyBTZXQoKTtcbmRlZl9ldmFsKEFTVF9TeW1ib2xSZWYsIGZ1bmN0aW9uIChjb21wcmVzc29yLCBkZXB0aCkge1xuICAgIGlmIChyZWVudHJhbnRfcmVmX2V2YWwuaGFzKHRoaXMpKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIHZhciBmaXhlZCA9IHRoaXMuZml4ZWRfdmFsdWUoKTtcbiAgICBpZiAoIWZpeGVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIHJlZW50cmFudF9yZWZfZXZhbC5hZGQodGhpcyk7XG4gICAgY29uc3QgdmFsdWUgPSBmaXhlZC5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgcmVlbnRyYW50X3JlZl9ldmFsLmRlbGV0ZSh0aGlzKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gZml4ZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gdGhpcy5kZWZpbml0aW9uKCkuZXNjYXBlZDtcbiAgICAgICAgaWYgKGVzY2FwZWQgJiYgZGVwdGggPiBlc2NhcGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn0pO1xuXG5jb25zdCBnbG9iYWxfb2JqcyA9IHsgQXJyYXksIE1hdGgsIE51bWJlciwgT2JqZWN0LCBTdHJpbmcgfTtcblxuY29uc3QgcmVnZXhwX2ZsYWdzID0gbmV3IFNldChbXG4gICAgXCJkb3RBbGxcIixcbiAgICBcImdsb2JhbFwiLFxuICAgIFwiaWdub3JlQ2FzZVwiLFxuICAgIFwibXVsdGlsaW5lXCIsXG4gICAgXCJzdGlja3lcIixcbiAgICBcInVuaWNvZGVcIixcbl0pO1xuXG5kZWZfZXZhbChBU1RfUHJvcEFjY2VzcywgZnVuY3Rpb24gKGNvbXByZXNzb3IsIGRlcHRoKSB7XG4gICAgbGV0IG9iaiA9IHRoaXMuZXhwcmVzc2lvbi5fZXZhbChjb21wcmVzc29yLCBkZXB0aCArIDEpO1xuICAgIGlmIChvYmogPT09IG51bGxpc2ggfHwgKHRoaXMub3B0aW9uYWwgJiYgb2JqID09IG51bGwpKSByZXR1cm4gbnVsbGlzaDtcblxuICAgIC8vIGAubGVuZ3RoYCBvZiBzdHJpbmdzIGFuZCBhcnJheXMgaXMgYWx3YXlzIHNhZmVcbiAgICBpZiAodGhpcy5wcm9wZXJ0eSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc19zcHJlYWRsZXNzX2FycmF5ID1cbiAgICAgICAgICAgIG9iaiBpbnN0YW5jZW9mIEFTVF9BcnJheVxuICAgICAgICAgICAgJiYgb2JqLmVsZW1lbnRzLmV2ZXJ5KGVsID0+ICEoZWwgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXNfc3ByZWFkbGVzc19hcnJheVxuICAgICAgICAgICAgJiYgb2JqLmVsZW1lbnRzLmV2ZXJ5KGVsID0+ICFlbC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnByb3BlcnR5O1xuICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgQVNUX05vZGUpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB0aGlzLnByb3BlcnR5KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cCA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKGlzX3VuZGVjbGFyZWRfcmVmKGV4cCkpIHtcbiAgICAgICAgICAgIHZhciBhYTtcbiAgICAgICAgICAgIHZhciBmaXJzdF9hcmcgPSBleHAubmFtZSA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiXG4gICAgICAgICAgICAgICAgJiYga2V5ID09PSBcImNhbGxcIlxuICAgICAgICAgICAgICAgICYmIChhYSA9IGNvbXByZXNzb3IucGFyZW50KCkgJiYgY29tcHJlc3Nvci5wYXJlbnQoKS5hcmdzKVxuICAgICAgICAgICAgICAgICYmIChhYSAmJiBhYVswXVxuICAgICAgICAgICAgICAgICAgICAmJiBhYVswXS5ldmFsdWF0ZShjb21wcmVzc29yKSk7XG5cbiAgICAgICAgICAgIGZpcnN0X2FyZyA9IGZpcnN0X2FyZyBpbnN0YW5jZW9mIEFTVF9Eb3QgPyBmaXJzdF9hcmcuZXhwcmVzc2lvbiA6IGZpcnN0X2FyZztcblxuICAgICAgICAgICAgaWYgKGZpcnN0X2FyZyA9PSBudWxsIHx8IGZpcnN0X2FyZy50aGVkZWYgJiYgZmlyc3RfYXJnLnRoZWRlZi51bmRlY2xhcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNfcHVyZV9uYXRpdmVfdmFsdWUoZXhwLm5hbWUsIGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBvYmogPSBnbG9iYWxfb2Jqc1tleHAubmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PSBcInNvdXJjZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdleHBfc291cmNlX2ZpeChvYmouc291cmNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PSBcImZsYWdzXCIgfHwgcmVnZXhwX2ZsYWdzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9iaiB8fCBvYmogPT09IGV4cCB8fCAhSE9QKG9iaiwga2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLm5vZGUubmFtZSA/IG9iai5ub2RlLm5hbWUubmFtZSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZW5ndGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmoubm9kZS5sZW5ndGhfcHJvcGVydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSk7XG5cbmRlZl9ldmFsKEFTVF9DaGFpbiwgZnVuY3Rpb24gKGNvbXByZXNzb3IsIGRlcHRoKSB7XG4gICAgY29uc3QgZXZhbHVhdGVkID0gdGhpcy5leHByZXNzaW9uLl9ldmFsKGNvbXByZXNzb3IsIGRlcHRoKTtcbiAgICByZXR1cm4gZXZhbHVhdGVkID09PSBudWxsaXNoXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogZXZhbHVhdGVkID09PSB0aGlzLmV4cHJlc3Npb25cbiAgICAgICAgICA/IHRoaXNcbiAgICAgICAgICA6IGV2YWx1YXRlZDtcbn0pO1xuXG5kZWZfZXZhbChBU1RfQ2FsbCwgZnVuY3Rpb24gKGNvbXByZXNzb3IsIGRlcHRoKSB7XG4gICAgdmFyIGV4cCA9IHRoaXMuZXhwcmVzc2lvbjtcblxuICAgIGNvbnN0IGNhbGxlZSA9IGV4cC5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgaWYgKGNhbGxlZSA9PT0gbnVsbGlzaCB8fCAodGhpcy5vcHRpb25hbCAmJiBjYWxsZWUgPT0gbnVsbCkpIHJldHVybiBudWxsaXNoO1xuXG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpICYmIGV4cCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzKSB7XG4gICAgICAgIHZhciBrZXkgPSBleHAucHJvcGVydHk7XG4gICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSkge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9ldmFsKGNvbXByZXNzb3IsIGRlcHRoKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGV4cC5wcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsO1xuICAgICAgICB2YXIgZSA9IGV4cC5leHByZXNzaW9uO1xuICAgICAgICBpZiAoaXNfdW5kZWNsYXJlZF9yZWYoZSkpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdF9hcmcgPSBlLm5hbWUgPT09IFwiaGFzT3duUHJvcGVydHlcIiAmJlxuICAgICAgICAgICAgICAgIGtleSA9PT0gXCJjYWxsXCIgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5hcmdzWzBdICYmIHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjb21wcmVzc29yKSk7XG5cbiAgICAgICAgICAgIGZpcnN0X2FyZyA9IGZpcnN0X2FyZyBpbnN0YW5jZW9mIEFTVF9Eb3QgPyBmaXJzdF9hcmcuZXhwcmVzc2lvbiA6IGZpcnN0X2FyZztcblxuICAgICAgICAgICAgaWYgKChmaXJzdF9hcmcgPT0gbnVsbCB8fCBmaXJzdF9hcmcudGhlZGVmICYmIGZpcnN0X2FyZy50aGVkZWYudW5kZWNsYXJlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc19wdXJlX25hdGl2ZV9mbihlLm5hbWUsIGtleSkpIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgdmFsID0gZ2xvYmFsX29ianNbZS5uYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IGUuX2V2YWwoY29tcHJlc3NvciwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IGUgfHwgIXZhbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGlmICghaXNfcHVyZV9uYXRpdmVfbWV0aG9kKHZhbC5jb25zdHJ1Y3Rvci5uYW1lLCBrZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSB0aGlzLmFyZ3NbaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhcmcuX2V2YWwoY29tcHJlc3NvciwgZGVwdGgpO1xuICAgICAgICAgICAgaWYgKGFyZyA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQVNUX0xhbWJkYSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2YWxba2V5XS5hcHBseSh2YWwsIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgcmVhbGx5IGNhcmVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn0pO1xuXG4vLyBBbHNvIGEgc3ViY2xhc3Mgb2YgQVNUX0NhbGxcbmRlZl9ldmFsKEFTVF9OZXcsIHJldHVybl90aGlzKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBBU1RfTm9kZSNkcm9wX3NpZGVfZWZmZWN0X2ZyZWUoKSBnZXRzIGNhbGxlZCB3aGVuIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIHZhbHVlLFxuLy8gb25seSBhYm91dCBzaWRlIGVmZmVjdHMuIFdlJ2xsIGJlIGRlZmluaW5nIHRoaXMgbWV0aG9kIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGlzIG1vZHVsZVxuLy9cbi8vIEV4YW1wbGVzOlxuLy8gZm9vKysgLT4gZm9vKytcbi8vIDEgKyBmdW5jKCkgLT4gZnVuYygpXG4vLyAxMCAtPiAobm90aGluZylcbi8vIGtub3duUHVyZUZ1bmMoZm9vKyspIC0+IGZvbysrXG5cbmZ1bmN0aW9uIGRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUobm9kZV9vcl9ub2RlcywgZnVuYykge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBbXS5jb25jYXQobm9kZV9vcl9ub2RlcykpIHtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJkcm9wX3NpZGVfZWZmZWN0X2ZyZWVcIiwgZnVuYyk7XG4gICAgfVxufVxuXG4vLyBEcm9wIHNpZGUtZWZmZWN0LWZyZWUgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBvZiBleHByZXNzaW9ucy5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgZXhwcmVzc2lvbnMgd2l0aCBzaWRlLWVmZmVjdHMgb3IgbnVsbFxuLy8gaWYgYWxsIGVsZW1lbnRzIHdlcmUgZHJvcHBlZC4gTm90ZTogb3JpZ2luYWwgYXJyYXkgbWF5IGJlXG4vLyByZXR1cm5lZCBpZiBub3RoaW5nIGNoYW5nZWQuXG5mdW5jdGlvbiB0cmltKG5vZGVzLCBjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICB2YXIgbGVuID0gbm9kZXMubGVuZ3RoO1xuICAgIGlmICghbGVuKSAgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgcmV0ID0gW10sIGNoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV0uZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgICAgIGNoYW5nZWQgfD0gbm9kZSAhPT0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICByZXQucHVzaChub2RlKTtcbiAgICAgICAgICAgIGZpcnN0X2luX3N0YXRlbWVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkID8gcmV0Lmxlbmd0aCA/IHJldCA6IG51bGwgOiBub2Rlcztcbn1cblxuZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfTm9kZSwgcmV0dXJuX3RoaXMpO1xuZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfQ29uc3RhbnQsIHJldHVybl9udWxsKTtcbmRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX1RoaXMsIHJldHVybl9udWxsKTtcblxuZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfQ2FsbCwgZnVuY3Rpb24gKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgIGlmIChpc19udWxsaXNoX3Nob3J0Y2lyY3VpdGVkKHRoaXMsIGNvbXByZXNzb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzX2NhbGxlZV9wdXJlKGNvbXByZXNzb3IpKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb24uaXNfY2FsbF9wdXJlKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICB2YXIgZXhwcnMgPSB0aGlzLmFyZ3Muc2xpY2UoKTtcbiAgICAgICAgICAgIGV4cHJzLnVuc2hpZnQodGhpcy5leHByZXNzaW9uLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgZXhwcnMgPSB0cmltKGV4cHJzLCBjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJzICYmIG1ha2Vfc2VxdWVuY2UodGhpcywgZXhwcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19mdW5jX2V4cHIodGhpcy5leHByZXNzaW9uKVxuICAgICAgICAgICAgJiYgKCF0aGlzLmV4cHJlc3Npb24ubmFtZSB8fCAhdGhpcy5leHByZXNzaW9uLm5hbWUuZGVmaW5pdGlvbigpLnJlZmVyZW5jZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICBub2RlLmV4cHJlc3Npb24ucHJvY2Vzc19leHByZXNzaW9uKGZhbHNlLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gdHJpbSh0aGlzLmFyZ3MsIGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgcmV0dXJuIGFyZ3MgJiYgbWFrZV9zZXF1ZW5jZSh0aGlzLCBhcmdzKTtcbn0pO1xuXG5kZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9BY2Nlc3NvciwgcmV0dXJuX251bGwpO1xuXG5kZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9GdW5jdGlvbiwgcmV0dXJuX251bGwpO1xuXG5kZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9BcnJvdywgcmV0dXJuX251bGwpO1xuXG5kZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9DbGFzcywgZnVuY3Rpb24gKGNvbXByZXNzb3IpIHtcbiAgICBjb25zdCB3aXRoX2VmZmVjdHMgPSBbXTtcblxuICAgIGlmICh0aGlzLmlzX3NlbGZfcmVmZXJlbnRpYWwoKSAmJiB0aGlzLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgdHJpbW1lZF9leHRlbmRzID0gdGhpcy5leHRlbmRzICYmIHRoaXMuZXh0ZW5kcy5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgaWYgKHRyaW1tZWRfZXh0ZW5kcykgd2l0aF9lZmZlY3RzLnB1c2godHJpbW1lZF9leHRlbmRzKTtcblxuICAgIGZvciAoY29uc3QgcHJvcCBvZiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfQ2xhc3NTdGF0aWNCbG9jaykge1xuICAgICAgICAgICAgaWYgKHByb3AuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBCZSBjYXV0aW91cyBhYm91dCB0aGVzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZF9wcm9wID0gcHJvcC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBpZiAodHJpbW1lZF9wcm9wKSB3aXRoX2VmZmVjdHMucHVzaCh0cmltbWVkX3Byb3ApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF3aXRoX2VmZmVjdHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IGV4cHJzID0gbWFrZV9zZXF1ZW5jZSh0aGlzLCB3aXRoX2VmZmVjdHMpO1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQVNUX0RlZkNsYXNzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgYSBzdGF0ZW1lbnRcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCB0aGlzLCB7IGJvZHk6IGV4cHJzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBleHBycztcbiAgICB9XG59KTtcblxuZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShbXG4gICAgQVNUX0NsYXNzUHJvcGVydHksXG4gICAgQVNUX0NsYXNzUHJpdmF0ZVByb3BlcnR5LFxuXSwgZnVuY3Rpb24gKGNvbXByZXNzb3IpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmNvbXB1dGVkX2tleSgpICYmIHRoaXMua2V5LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdGF0aWMgJiYgdGhpcy52YWx1ZVxuICAgICAgICAmJiB0aGlzLnZhbHVlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcblxuICAgIGlmIChrZXkgJiYgdmFsdWUpXG4gICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIFtrZXksIHZhbHVlXSk7XG4gICAgcmV0dXJuIGtleSB8fCB2YWx1ZSB8fCBudWxsO1xufSk7XG5cbmRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX0JpbmFyeSwgZnVuY3Rpb24gKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgIHZhciByaWdodCA9IHRoaXMucmlnaHQuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IpO1xuICAgIGlmICghcmlnaHQpXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgaWYgKGxhenlfb3AuaGFzKHRoaXMub3BlcmF0b3IpKSB7XG4gICAgICAgIGlmIChyaWdodCA9PT0gdGhpcy5yaWdodClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgbm9kZS5yaWdodCA9IHJpZ2h0O1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGVmdCA9IHRoaXMubGVmdC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICAgICAgaWYgKCFsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIFtsZWZ0LCByaWdodF0pO1xuICAgIH1cbn0pO1xuXG5kZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9Bc3NpZ24sIGZ1bmN0aW9uIChjb21wcmVzc29yKSB7XG4gICAgaWYgKHRoaXMubG9naWNhbClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgbGVmdCA9IHRoaXMubGVmdDtcbiAgICBpZiAobGVmdC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgIHx8IGNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIilcbiAgICAgICAgJiYgbGVmdCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzXG4gICAgICAgICYmIGxlZnQuZXhwcmVzc2lvbi5pc19jb25zdGFudCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRfZmxhZyh0aGlzLCBXUklURV9PTkxZKTtcbiAgICB3aGlsZSAobGVmdCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzKSB7XG4gICAgICAgIGxlZnQgPSBsZWZ0LmV4cHJlc3Npb247XG4gICAgfVxuICAgIGlmIChsZWZ0LmlzX2NvbnN0YW50X2V4cHJlc3Npb24oY29tcHJlc3Nvci5maW5kX3BhcmVudChBU1RfU2NvcGUpKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSk7XG5cbmRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbiAoY29tcHJlc3Nvcikge1xuICAgIHZhciBjb25zZXF1ZW50ID0gdGhpcy5jb25zZXF1ZW50LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICB2YXIgYWx0ZXJuYXRpdmUgPSB0aGlzLmFsdGVybmF0aXZlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICBpZiAoY29uc2VxdWVudCA9PT0gdGhpcy5jb25zZXF1ZW50ICYmIGFsdGVybmF0aXZlID09PSB0aGlzLmFsdGVybmF0aXZlKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAoIWNvbnNlcXVlbnQpXG4gICAgICAgIHJldHVybiBhbHRlcm5hdGl2ZSA/IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCB0aGlzLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCJ8fFwiLFxuICAgICAgICAgICAgbGVmdDogdGhpcy5jb25kaXRpb24sXG4gICAgICAgICAgICByaWdodDogYWx0ZXJuYXRpdmVcbiAgICAgICAgfSkgOiB0aGlzLmNvbmRpdGlvbi5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgaWYgKCFhbHRlcm5hdGl2ZSlcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCB0aGlzLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgbGVmdDogdGhpcy5jb25kaXRpb24sXG4gICAgICAgICAgICByaWdodDogY29uc2VxdWVudFxuICAgICAgICB9KTtcbiAgICB2YXIgbm9kZSA9IHRoaXMuY2xvbmUoKTtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgIG5vZGUuYWx0ZXJuYXRpdmUgPSBhbHRlcm5hdGl2ZTtcbiAgICByZXR1cm4gbm9kZTtcbn0pO1xuXG5kZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9VbmFyeSwgZnVuY3Rpb24gKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgIGlmICh1bmFyeV9zaWRlX2VmZmVjdHMuaGFzKHRoaXMub3BlcmF0b3IpKSB7XG4gICAgICAgIGlmICghdGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHNldF9mbGFnKHRoaXMsIFdSSVRFX09OTFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJfZmxhZyh0aGlzLCBXUklURV9PTkxZKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT0gXCJ0eXBlb2ZcIiAmJiB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbi5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICBpZiAoZmlyc3RfaW5fc3RhdGVtZW50ICYmIGV4cHJlc3Npb24gJiYgaXNfaWlmZV9jYWxsKGV4cHJlc3Npb24pKSB7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB0aGlzLmV4cHJlc3Npb24gJiYgdGhpcy5vcGVyYXRvciA9PSBcIiFcIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5uZWdhdGUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG59KTtcblxuZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbiAoY29tcHJlc3Nvcikge1xuICAgIGNvbnN0IHNhZmVfYWNjZXNzID0gdGhpcy5pc19kZWNsYXJlZChjb21wcmVzc29yKVxuICAgICAgICB8fCBwdXJlX3Byb3BfYWNjZXNzX2dsb2JhbHMuaGFzKHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHNhZmVfYWNjZXNzID8gbnVsbCA6IHRoaXM7XG59KTtcblxuZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfT2JqZWN0LCBmdW5jdGlvbiAoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRyaW0odGhpcy5wcm9wZXJ0aWVzLCBjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgIHJldHVybiB2YWx1ZXMgJiYgbWFrZV9zZXF1ZW5jZSh0aGlzLCB2YWx1ZXMpO1xufSk7XG5cbmRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX09iamVjdEtleVZhbCwgZnVuY3Rpb24gKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgIGNvbnN0IGNvbXB1dGVkX2tleSA9IHRoaXMua2V5IGluc3RhbmNlb2YgQVNUX05vZGU7XG4gICAgY29uc3Qga2V5ID0gY29tcHV0ZWRfa2V5ICYmIHRoaXMua2V5LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIFtrZXksIHZhbHVlXSk7XG4gICAgfVxuICAgIHJldHVybiBrZXkgfHwgdmFsdWU7XG59KTtcblxuZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShbXG4gICAgQVNUX0NvbmNpc2VNZXRob2QsXG4gICAgQVNUX09iamVjdEdldHRlcixcbiAgICBBU1RfT2JqZWN0U2V0dGVyLFxuXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGVkX2tleSgpID8gdGhpcy5rZXkgOiBudWxsO1xufSk7XG5cbmRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoW1xuICAgIEFTVF9Qcml2YXRlTWV0aG9kLFxuICAgIEFTVF9Qcml2YXRlR2V0dGVyLFxuICAgIEFTVF9Qcml2YXRlU2V0dGVyLFxuXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xufSk7XG5cbmRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX0FycmF5LCBmdW5jdGlvbiAoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRyaW0odGhpcy5lbGVtZW50cywgY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICByZXR1cm4gdmFsdWVzICYmIG1ha2Vfc2VxdWVuY2UodGhpcywgdmFsdWVzKTtcbn0pO1xuXG5kZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9Eb3QsIGZ1bmN0aW9uIChjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICBpZiAoaXNfbnVsbGlzaF9zaG9ydGNpcmN1aXRlZCh0aGlzLCBjb21wcmVzc29yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9uYWwgJiYgdGhpcy5leHByZXNzaW9uLm1heV90aHJvd19vbl9hY2Nlc3MoY29tcHJlc3NvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbn0pO1xuXG5kZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9TdWIsIGZ1bmN0aW9uIChjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICBpZiAoaXNfbnVsbGlzaF9zaG9ydGNpcmN1aXRlZCh0aGlzLCBjb21wcmVzc29yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9uYWwgJiYgdGhpcy5leHByZXNzaW9uLm1heV90aHJvd19vbl9hY2Nlc3MoY29tcHJlc3NvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wcm9wZXJ0eS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgaWYgKHByb3BlcnR5ICYmIHRoaXMub3B0aW9uYWwpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24uZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG5cbiAgICBpZiAoZXhwcmVzc2lvbiAmJiBwcm9wZXJ0eSkgcmV0dXJuIG1ha2Vfc2VxdWVuY2UodGhpcywgW2V4cHJlc3Npb24sIHByb3BlcnR5XSk7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24gfHwgcHJvcGVydHk7XG59KTtcblxuZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfQ2hhaW4sIGZ1bmN0aW9uIChjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xufSk7XG5cbmRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX1NlcXVlbmNlLCBmdW5jdGlvbiAoY29tcHJlc3Nvcikge1xuICAgIHZhciBsYXN0ID0gdGhpcy50YWlsX25vZGUoKTtcbiAgICB2YXIgZXhwciA9IGxhc3QuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IpO1xuICAgIGlmIChleHByID09PSBsYXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aGlzLmV4cHJlc3Npb25zLnNsaWNlKDAsIC0xKTtcbiAgICBpZiAoZXhwcilcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByKTtcbiAgICBpZiAoIWV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHRoaXMsIHsgdmFsdWU6IDAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIGV4cHJlc3Npb25zKTtcbn0pO1xuXG5kZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9FeHBhbnNpb24sIGZ1bmN0aW9uIChjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xufSk7XG5cbmRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX1RlbXBsYXRlU2VnbWVudCwgcmV0dXJuX251bGwpO1xuXG5kZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9UZW1wbGF0ZVN0cmluZywgZnVuY3Rpb24gKGNvbXByZXNzb3IpIHtcbiAgICB2YXIgdmFsdWVzID0gdHJpbSh0aGlzLnNlZ21lbnRzLCBjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgIHJldHVybiB2YWx1ZXMgJiYgbWFrZV9zZXF1ZW5jZSh0aGlzLCB2YWx1ZXMpO1xufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY29uc3Qgcl9rZWVwX2Fzc2lnbiA9IC9rZWVwX2Fzc2lnbi87XG5cbi8qKiBEcm9wIHVudXNlZCB2YXJpYWJsZXMgZnJvbSB0aGlzIHNjb3BlICovXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiZHJvcF91bnVzZWRcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJ1bnVzZWRcIikpIHJldHVybjtcbiAgICBpZiAoY29tcHJlc3Nvci5oYXNfZGlyZWN0aXZlKFwidXNlIGFzbVwiKSkgcmV0dXJuO1xuICAgIGlmICghdGhpcy52YXJpYWJsZXMpIHJldHVybjsgLy8gbm90IHJlYWxseSBhIHNjb3BlIChlZzogQVNUX0NsYXNzKVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLnBpbm5lZCgpKSByZXR1cm47XG4gICAgdmFyIGRyb3BfZnVuY3MgPSAhKHNlbGYgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwpIHx8IGNvbXByZXNzb3IudG9wbGV2ZWwuZnVuY3M7XG4gICAgdmFyIGRyb3BfdmFycyA9ICEoc2VsZiBpbnN0YW5jZW9mIEFTVF9Ub3BsZXZlbCkgfHwgY29tcHJlc3Nvci50b3BsZXZlbC52YXJzO1xuICAgIGNvbnN0IGFzc2lnbl9hc191bnVzZWQgPSByX2tlZXBfYXNzaWduLnRlc3QoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnVzZWRcIikpID8gcmV0dXJuX2ZhbHNlIDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICYmICFub2RlLmxvZ2ljYWxcbiAgICAgICAgICAgICYmIChoYXNfZmxhZyhub2RlLCBXUklURV9PTkxZKSB8fCBub2RlLm9wZXJhdG9yID09IFwiPVwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVW5hcnkgJiYgaGFzX2ZsYWcobm9kZSwgV1JJVEVfT05MWSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmV4cHJlc3Npb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpbl91c2VfaWRzID0gbmV3IE1hcCgpO1xuICAgIHZhciBmaXhlZF9pZHMgPSBuZXcgTWFwKCk7XG4gICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwgJiYgY29tcHJlc3Nvci50b3BfcmV0YWluKSB7XG4gICAgICAgIHNlbGYudmFyaWFibGVzLmZvckVhY2goZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci50b3BfcmV0YWluKGRlZikpIHtcbiAgICAgICAgICAgICAgICBpbl91c2VfaWRzLnNldChkZWYuaWQsIGRlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdmFyX2RlZnNfYnlfaWQgPSBuZXcgTWFwKCk7XG4gICAgdmFyIGluaXRpYWxpemF0aW9ucyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIHBhc3MgMTogZmluZCBvdXQgd2hpY2ggc3ltYm9scyBhcmUgZGlyZWN0bHkgdXNlZCBpblxuICAgIC8vIHRoaXMgc2NvcGUgKG5vdCBpbiBuZXN0ZWQgc2NvcGVzKS5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhICYmIG5vZGUudXNlc19hcmd1bWVudHMgJiYgIXR3Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpKSB7XG4gICAgICAgICAgICBub2RlLmFyZ25hbWVzLmZvckVhY2goZnVuY3Rpb24oYXJnbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGFyZ25hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVjbGFyYXRpb24pKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IGFyZ25hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGluX3VzZV9pZHMuc2V0KGRlZi5pZCwgZGVmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSBzZWxmKSByZXR1cm47XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NsYXNzICYmIG5vZGUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNfc2VsZl9yZWZlcmVudGlhbCgpKSB7XG4gICAgICAgICAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnZpc2l0X25vbmRlZmVycmVkX2NsYXNzX3BhcnRzKHR3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1biB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0RlZkNsYXNzKSB7XG4gICAgICAgICAgICB2YXIgbm9kZV9kZWYgPSBub2RlLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgaW5fZXhwb3J0ID0gdHcucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfRXhwb3J0O1xuICAgICAgICAgICAgaWYgKGluX2V4cG9ydCB8fCAhZHJvcF9mdW5jcyAmJiBzY29wZSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlX2RlZi5nbG9iYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5fdXNlX2lkcy5zZXQobm9kZV9kZWYuaWQsIG5vZGVfZGVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcF9hZGQoaW5pdGlhbGl6YXRpb25zLCBub2RlX2RlZi5pZCwgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZG9uJ3QgZ28gaW4gbmVzdGVkIHNjb3Blc1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSByb290IHNjb3BlLCB3ZSBkcm9wIHRoaW5ncy4gSW4gaW5uZXIgc2NvcGVzLCB3ZSBqdXN0IGNoZWNrIGZvciB1c2VzLlxuICAgICAgICBjb25zdCBpbl9yb290X3Njb3BlID0gc2NvcGUgPT09IHNlbGY7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZyAmJiBpbl9yb290X3Njb3BlKSB7XG4gICAgICAgICAgICBtYXBfYWRkKHZhcl9kZWZzX2J5X2lkLCBub2RlLmRlZmluaXRpb24oKS5pZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMgJiYgaW5fcm9vdF9zY29wZSkge1xuICAgICAgICAgICAgY29uc3QgaW5fZXhwb3J0ID0gdHcucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfRXhwb3J0O1xuICAgICAgICAgICAgbm9kZS5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgICAgIGlmIChkZWYubmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xWYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwX2FkZCh2YXJfZGVmc19ieV9pZCwgZGVmLm5hbWUuZGVmaW5pdGlvbigpLmlkLCBkZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5fZXhwb3J0IHx8ICFkcm9wX3ZhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FsayhkZWYubmFtZSwgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IG5vZGUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX3VzZV9pZHMuc2V0KGRlZi5pZCwgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVmLm5hbWUgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZykge1xuICAgICAgICAgICAgICAgICAgICBkZWYud2Fsayh0dyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWYubmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbiAmJiBkZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVfZGVmID0gZGVmLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBtYXBfYWRkKGluaXRpYWxpemF0aW9ucywgbm9kZV9kZWYuaWQsIGRlZi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZV9kZWYuY2hhaW5lZCAmJiBkZWYubmFtZS5maXhlZF92YWx1ZSgpID09PSBkZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeGVkX2lkcy5zZXQobm9kZV9kZWYuaWQsIGRlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWUud2Fsayh0dyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FuX3JlZl9zY29wZWQobm9kZSwgZGVzY2VuZCk7XG4gICAgfSk7XG4gICAgc2VsZi53YWxrKHR3KTtcbiAgICAvLyBwYXNzIDI6IGZvciBldmVyeSB1c2VkIHN5bWJvbCB3ZSBuZWVkIHRvIHdhbGsgaXRzXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gY29kZSB0byBmaWd1cmUgb3V0IGlmIGl0IHVzZXMgb3RoZXJcbiAgICAvLyBzeW1ib2xzICh0aGF0IG1heSBub3QgYmUgaW5fdXNlKS5cbiAgICB0dyA9IG5ldyBUcmVlV2Fsa2VyKHNjYW5fcmVmX3Njb3BlZCk7XG4gICAgaW5fdXNlX2lkcy5mb3JFYWNoKGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgdmFyIGluaXQgPSBpbml0aWFsaXphdGlvbnMuZ2V0KGRlZi5pZCk7XG4gICAgICAgIGlmIChpbml0KSBpbml0LmZvckVhY2goZnVuY3Rpb24oaW5pdCkge1xuICAgICAgICAgICAgaW5pdC53YWxrKHR3KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gcGFzcyAzOiB3ZSBzaG91bGQgZHJvcCBkZWNsYXJhdGlvbnMgbm90IGluX3VzZVxuICAgIHZhciB0dCA9IG5ldyBUcmVlVHJhbnNmb3JtZXIoXG4gICAgICAgIGZ1bmN0aW9uIGJlZm9yZShub2RlLCBkZXNjZW5kLCBpbl9saXN0KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdHQucGFyZW50KCk7XG4gICAgICAgICAgICBpZiAoZHJvcF92YXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ltID0gYXNzaWduX2FzX3VudXNlZChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gc3ltLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluX3VzZSA9IGluX3VzZV9pZHMuaGFzKGRlZi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbl91c2UgfHwgZml4ZWRfaWRzLmhhcyhkZWYuaWQpICYmIGZpeGVkX2lkcy5nZXQoZGVmLmlkKSAhPT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzc2lnbmVlID0gbm9kZS5yaWdodC50cmFuc2Zvcm0odHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5fdXNlICYmICFhc3NpZ25lZS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpICYmICFpc191c2VkX2luX2V4cHJlc3Npb24odHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbl9saXN0ID8gTUFQLnNraXAgOiBtYWtlX25vZGUoQVNUX051bWJlciwgbm9kZSwgeyB2YWx1ZTogMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1haW50YWluX3RoaXNfYmluZGluZyhwYXJlbnQsIG5vZGUsIGFzc2lnbmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5fdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5fbGlzdCA/IE1BUC5za2lwIDogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIG5vZGUsIHsgdmFsdWU6IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NvcGUgIT09IHNlbGYpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZWY7XG4gICAgICAgICAgICBpZiAobm9kZS5uYW1lXG4gICAgICAgICAgICAgICAgJiYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3NFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICYmICFrZWVwX25hbWUoY29tcHJlc3Nvci5vcHRpb24oXCJrZWVwX2NsYXNzbmFtZXNcIiksIChkZWYgPSBub2RlLm5hbWUuZGVmaW5pdGlvbigpKS5uYW1lKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgJiYgIWtlZXBfbmFtZShjb21wcmVzc29yLm9wdGlvbihcImtlZXBfZm5hbWVzXCIpLCAoZGVmID0gbm9kZS5uYW1lLmRlZmluaXRpb24oKSkubmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gYW55IGRlY2xhcmF0aW9ucyB3aXRoIHNhbWUgbmFtZSB3aWxsIG92ZXJzaGFkb3dcbiAgICAgICAgICAgICAgICAvLyBuYW1lIG9mIHRoaXMgYW5vbnltb3VzIGZ1bmN0aW9uIGFuZCBjYW4gdGhlcmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gbmV2ZXIgYmUgdXNlZCBhbnl3aGVyZVxuICAgICAgICAgICAgICAgIGlmICghaW5fdXNlX2lkcy5oYXMoZGVmLmlkKSB8fCBkZWYub3JpZy5sZW5ndGggPiAxKSBub2RlLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhICYmICEobm9kZSBpbnN0YW5jZW9mIEFTVF9BY2Nlc3NvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJpbSA9XG4gICAgICAgICAgICAgICAgICAgICFjb21wcmVzc29yLm9wdGlvbihcImtlZXBfZmFyZ3NcIilcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBhbiBJSUZFIHRoYXQgd29uJ3QgcmVmZXIgdG8gaXRzIG5hbWU/XG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBwYXJlbnQuZXhwcmVzc2lvbiA9PT0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgIW5vZGUucGlubmVkKClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICghbm9kZS5uYW1lIHx8IG5vZGUubmFtZS51bnJlZmVyZW5jZWQoKSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IG5vZGUuYXJnbmFtZXMsIGkgPSBhLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBhW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ltIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltID0gc3ltLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5bSBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0QXNzaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW0gPSBzeW0ubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgZHJvcCBkZXN0cnVjdHVyaW5nIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBjb25zdGl0dXRlIGEgdHlwZSBhc3NlcnRpb24gb2Ygc29ydHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgIShzeW0gaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICFpbl91c2VfaWRzLmhhcyhzeW0uZGVmaW5pdGlvbigpLmlkKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldF9mbGFnKHN5bSwgVU5VU0VEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZkNsYXNzICYmIG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWYgPSBub2RlLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2VlcF9jbGFzcyA9IGRlZi5nbG9iYWwgJiYgIWRyb3BfZnVuY3MgfHwgaW5fdXNlX2lkcy5oYXMoZGVmLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBfY2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2VwdCA9IG5vZGUuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2VwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYuZWxpbWluYXRlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluX2xpc3QgPyBNQVAuc2tpcCA6IG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZnVuICYmIG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWYgPSBub2RlLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtlZXAgPSBkZWYuZ2xvYmFsICYmICFkcm9wX2Z1bmNzIHx8IGluX3VzZV9pZHMuaGFzKGRlZi5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZi5lbGltaW5hdGVkKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbl9saXN0ID8gTUFQLnNraXAgOiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyAmJiAhKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Gb3JJbiAmJiBwYXJlbnQuaW5pdCA9PT0gbm9kZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJvcF9ibG9jayA9ICEocGFyZW50IGluc3RhbmNlb2YgQVNUX1RvcGxldmVsKSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyKTtcbiAgICAgICAgICAgICAgICAvLyBwbGFjZSB1bmluaXRpYWxpemVkIG5hbWVzIGF0IHRoZSBzdGFydFxuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gW10sIGhlYWQgPSBbXSwgdGFpbCA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGZvciB1bnVzZWQgbmFtZXMgd2hvc2UgaW5pdGlhbGl6YXRpb24gaGFzXG4gICAgICAgICAgICAgICAgLy8gc2lkZSBlZmZlY3RzLCB3ZSBjYW4gY2FzY2FkZSB0aGUgaW5pdC4gY29kZVxuICAgICAgICAgICAgICAgIC8vIGludG8gdGhlIG5leHQgb25lLCBvciBuZXh0IHN0YXRlbWVudC5cbiAgICAgICAgICAgICAgICB2YXIgc2lkZV9lZmZlY3RzID0gW107XG4gICAgICAgICAgICAgICAgbm9kZS5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlKSBkZWYudmFsdWUgPSBkZWYudmFsdWUudHJhbnNmb3JtKHR0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzX2Rlc3RydWN0dXJlID0gZGVmLm5hbWUgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IGlzX2Rlc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBTeW1ib2xEZWYobnVsbCwgeyBuYW1lOiBcIjxkZXN0cnVjdHVyZT5cIiB9KSAvKiBmYWtlIFN5bWJvbERlZiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWYubmFtZS5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcm9wX2Jsb2NrICYmIHN5bS5nbG9iYWwpIHJldHVybiB0YWlsLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZHJvcF92YXJzIHx8IGRyb3BfYmxvY2spXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBpc19kZXN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChkZWYubmFtZS5uYW1lcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZGVmLm5hbWUuaXNfYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIikgIT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGluX3VzZV9pZHMuaGFzKHN5bS5pZClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlICYmIGZpeGVkX2lkcy5oYXMoc3ltLmlkKSAmJiBmaXhlZF9pZHMuZ2V0KHN5bS5pZCkgIT09IGRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZSA9IGRlZi52YWx1ZS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLm5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcl9kZWZzID0gdmFyX2RlZnNfYnlfaWQuZ2V0KHN5bS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcl9kZWZzLmxlbmd0aCA+IDEgJiYgKCFkZWYudmFsdWUgfHwgc3ltLm9yaWcuaW5kZXhPZihkZWYubmFtZSkgPiBzeW0uZWxpbWluYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sUmVmLCBkZWYubmFtZSwgZGVmLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltLnJlZmVyZW5jZXMucHVzaChyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzc2lnbiA9IG1ha2Vfbm9kZShBU1RfQXNzaWduLCBkZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naWNhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBkZWYudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpeGVkX2lkcy5nZXQoc3ltLmlkKSA9PT0gZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4ZWRfaWRzLnNldChzeW0uaWQsIGFzc2lnbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMucHVzaChhc3NpZ24udHJhbnNmb3JtKHR0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHZhcl9kZWZzLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0uZWxpbWluYXRlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWRlX2VmZmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMucHVzaChkZWYudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gbWFrZV9zZXF1ZW5jZShkZWYudmFsdWUsIHNpZGVfZWZmZWN0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBtYWtlX3NlcXVlbmNlKG5vZGUsIHNpZGVfZWZmZWN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFpbC5wdXNoKGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQucHVzaChkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN5bS5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbENhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkZWYudmFsdWUgJiYgZGVmLnZhbHVlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkgc2lkZV9lZmZlY3RzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQucHVzaChkZWYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGVmLnZhbHVlICYmIGRlZi52YWx1ZS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW0uZWxpbWluYXRlZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWQubGVuZ3RoID4gMCB8fCB0YWlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kZWZpbml0aW9ucyA9IGhlYWQuY29uY2F0KHRhaWwpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaWRlX2VmZmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG1ha2Vfc2VxdWVuY2Uobm9kZSwgc2lkZV9lZmZlY3RzKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYm9keS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluX2xpc3QgPyBNQVAuc2tpcCA6IG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9keVswXTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbl9saXN0ID8gTUFQLnNwbGljZShib2R5KSA6IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIG5vZGUsIHsgYm9keSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjZXJ0YWluIGNvbWJpbmF0aW9uIG9mIHVudXNlZCBuYW1lICsgc2lkZSBlZmZlY3QgbGVhZHMgdG86XG4gICAgICAgICAgICAvLyAgICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvNDRcbiAgICAgICAgICAgIC8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2lzc3Vlcy8xODMwXG4gICAgICAgICAgICAvLyAgICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvMTgzOFxuICAgICAgICAgICAgLy8gdGhhdCdzIGFuIGludmFsaWQgQVNULlxuICAgICAgICAgICAgLy8gV2UgZml4IGl0IGF0IHRoaXMgc3RhZ2UgYnkgbW92aW5nIHRoZSBgdmFyYCBvdXRzaWRlIHRoZSBgZm9yYC5cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Zvcikge1xuICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmluaXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBub2RlLmluaXQ7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5pdCA9IGJsb2NrLmJvZHkucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmJvZHkucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5pdCBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbml0ID0gbm9kZS5pbml0LmJvZHk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc19lbXB0eShub2RlLmluaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhYmxvY2sgPyBub2RlIDogaW5fbGlzdCA/IE1BUC5zcGxpY2UoYmxvY2suYm9keSkgOiBibG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhYmVsZWRTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAmJiBub2RlLmJvZHkgaW5zdGFuY2VvZiBBU1RfRm9yXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkZXNjZW5kKG5vZGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmJvZHkgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5ib2R5O1xuICAgICAgICAgICAgICAgICAgICBub2RlLmJvZHkgPSBibG9jay5ib2R5LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBibG9jay5ib2R5LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbl9saXN0ID8gTUFQLnNwbGljZShibG9jay5ib2R5KSA6IGJsb2NrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5fbGlzdCAmJiBub2RlLmJvZHkuZXZlcnkoY2FuX2JlX2V2aWN0ZWRfZnJvbV9ibG9jaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1BUC5zcGxpY2Uobm9kZS5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3NTdGF0aWNCbG9jaykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYXZlX3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzYXZlX3Njb3BlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiBhZnRlcihub2RlLCBpbl9saXN0KSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gaW5fbGlzdCA/IE1BUC5za2lwIDogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIG5vZGUsIHsgdmFsdWU6IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5vZGUuZXhwcmVzc2lvbnNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHNlbGYudHJhbnNmb3JtKHR0KTtcblxuICAgIGZ1bmN0aW9uIHNjYW5fcmVmX3Njb3BlZChub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgIHZhciBub2RlX2RlZjtcbiAgICAgICAgY29uc3Qgc3ltID0gYXNzaWduX2FzX3VudXNlZChub2RlKTtcbiAgICAgICAgaWYgKHN5bSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICYmICFpc19yZWZfb2Yobm9kZS5sZWZ0LCBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbilcbiAgICAgICAgICAgICYmIHNlbGYudmFyaWFibGVzLmdldChzeW0ubmFtZSkgPT09IChub2RlX2RlZiA9IHN5bS5kZWZpbml0aW9uKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yaWdodC53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVfZGVmLmNoYWluZWQgJiYgbm9kZS5sZWZ0LmZpeGVkX3ZhbHVlKCkgPT09IG5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZml4ZWRfaWRzLnNldChub2RlX2RlZi5pZCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICBub2RlX2RlZiA9IG5vZGUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFpbl91c2VfaWRzLmhhcyhub2RlX2RlZi5pZCkpIHtcbiAgICAgICAgICAgICAgICBpbl91c2VfaWRzLnNldChub2RlX2RlZi5pZCwgbm9kZV9kZWYpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlX2RlZi5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbENhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZGVmID0gbm9kZV9kZWYuc2NvcGUuaXNfYmxvY2tfc2NvcGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgbm9kZV9kZWYuc2NvcGUuZ2V0X2RlZnVuX3Njb3BlKCkudmFyaWFibGVzLmdldChub2RlX2RlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGVmKSBpbl91c2VfaWRzLnNldChyZWRlZi5pZCwgcmVkZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NsYXNzKSB7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3NTdGF0aWNCbG9jaykpIHtcbiAgICAgICAgICAgIHZhciBzYXZlX3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICBzY29wZSA9IG5vZGU7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBzY29wZSA9IHNhdmVfc2NvcGU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogRGVmaW5lIHRoZSBtZXRob2QgQVNUX05vZGUjcmVkdWNlX3ZhcnMsIHdoaWNoIGdvZXMgdGhyb3VnaCB0aGUgQVNUIGluXG4gKiBleGVjdXRpb24gb3JkZXIgdG8gcGVyZm9ybSBiYXNpYyBmbG93IGFuYWx5c2lzXG4gKi9cbmZ1bmN0aW9uIGRlZl9yZWR1Y2VfdmFycyhub2RlLCBmdW5jKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJyZWR1Y2VfdmFyc1wiLCBmdW5jKTtcbn1cblxuZGVmX3JlZHVjZV92YXJzKEFTVF9Ob2RlLCBub29wKTtcblxuLyoqIENsZWFyIGRlZmluaXRpb24gcHJvcGVydGllcyAqL1xuZnVuY3Rpb24gcmVzZXRfZGVmKGNvbXByZXNzb3IsIGRlZikge1xuICAgIGRlZi5hc3NpZ25tZW50cyA9IDA7XG4gICAgZGVmLmNoYWluZWQgPSBmYWxzZTtcbiAgICBkZWYuZGlyZWN0X2FjY2VzcyA9IGZhbHNlO1xuICAgIGRlZi5lc2NhcGVkID0gMDtcbiAgICBkZWYucmVjdXJzaXZlX3JlZnMgPSAwO1xuICAgIGRlZi5yZWZlcmVuY2VzID0gW107XG4gICAgZGVmLnNpbmdsZV91c2UgPSB1bmRlZmluZWQ7XG4gICAgaWYgKFxuICAgICAgICBkZWYuc2NvcGUucGlubmVkKClcbiAgICAgICAgfHwgKGRlZi5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZyAmJiBkZWYuc2NvcGUudXNlc19hcmd1bWVudHMpXG4gICAgKSB7XG4gICAgICAgIGRlZi5maXhlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZGVmLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ29uc3QgfHwgIWNvbXByZXNzb3IuZXhwb3NlZChkZWYpKSB7XG4gICAgICAgIGRlZi5maXhlZCA9IGRlZi5pbml0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZi5maXhlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRfdmFyaWFibGVzKHR3LCBjb21wcmVzc29yLCBub2RlKSB7XG4gICAgbm9kZS52YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgcmVzZXRfZGVmKGNvbXByZXNzb3IsIGRlZik7XG4gICAgICAgIGlmIChkZWYuZml4ZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHR3LmRlZnNfdG9fc2FmZV9pZHMuc2V0KGRlZi5pZCwgdHcuc2FmZV9pZHMpO1xuICAgICAgICAgICAgbWFyayh0dywgZGVmLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWYuZml4ZWQpIHtcbiAgICAgICAgICAgIHR3Lmxvb3BfaWRzLnNldChkZWYuaWQsIHR3LmluX2xvb3ApO1xuICAgICAgICAgICAgbWFyayh0dywgZGVmLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZXNldF9ibG9ja192YXJpYWJsZXMoY29tcHJlc3Nvciwgbm9kZSkge1xuICAgIGlmIChub2RlLmJsb2NrX3Njb3BlKSBub2RlLmJsb2NrX3Njb3BlLnZhcmlhYmxlcy5mb3JFYWNoKChkZWYpID0+IHtcbiAgICAgICAgcmVzZXRfZGVmKGNvbXByZXNzb3IsIGRlZik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHB1c2godHcpIHtcbiAgICB0dy5zYWZlX2lkcyA9IE9iamVjdC5jcmVhdGUodHcuc2FmZV9pZHMpO1xufVxuXG5mdW5jdGlvbiBwb3AodHcpIHtcbiAgICB0dy5zYWZlX2lkcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0dy5zYWZlX2lkcyk7XG59XG5cbmZ1bmN0aW9uIG1hcmsodHcsIGRlZiwgc2FmZSkge1xuICAgIHR3LnNhZmVfaWRzW2RlZi5pZF0gPSBzYWZlO1xufVxuXG5mdW5jdGlvbiBzYWZlX3RvX3JlYWQodHcsIGRlZikge1xuICAgIGlmIChkZWYuc2luZ2xlX3VzZSA9PSBcIm1cIikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0dy5zYWZlX2lkc1tkZWYuaWRdKSB7XG4gICAgICAgIGlmIChkZWYuZml4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9yaWcgPSBkZWYub3JpZ1swXTtcbiAgICAgICAgICAgIGlmIChvcmlnIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZyB8fCBvcmlnLm5hbWUgPT0gXCJhcmd1bWVudHNcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVmLmZpeGVkID0gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIG9yaWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZGVmLmZpeGVkIGluc3RhbmNlb2YgQVNUX0RlZnVuO1xufVxuXG5mdW5jdGlvbiBzYWZlX3RvX2Fzc2lnbih0dywgZGVmLCBzY29wZSwgdmFsdWUpIHtcbiAgICBpZiAoZGVmLmZpeGVkID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICAgIGxldCBkZWZfc2FmZV9pZHM7XG4gICAgaWYgKGRlZi5maXhlZCA9PT0gbnVsbFxuICAgICAgICAmJiAoZGVmX3NhZmVfaWRzID0gdHcuZGVmc190b19zYWZlX2lkcy5nZXQoZGVmLmlkKSlcbiAgICApIHtcbiAgICAgICAgZGVmX3NhZmVfaWRzW2RlZi5pZF0gPSBmYWxzZTtcbiAgICAgICAgdHcuZGVmc190b19zYWZlX2lkcy5kZWxldGUoZGVmLmlkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghSE9QKHR3LnNhZmVfaWRzLCBkZWYuaWQpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFzYWZlX3RvX3JlYWQodHcsIGRlZikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGVmLmZpeGVkID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkZWYuZml4ZWQgIT0gbnVsbCAmJiAoIXZhbHVlIHx8IGRlZi5yZWZlcmVuY2VzLmxlbmd0aCA+IGRlZi5hc3NpZ25tZW50cykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGVmLmZpeGVkIGluc3RhbmNlb2YgQVNUX0RlZnVuKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFTVF9Ob2RlICYmIGRlZi5maXhlZC5wYXJlbnRfc2NvcGUgPT09IHNjb3BlO1xuICAgIH1cbiAgICByZXR1cm4gZGVmLm9yaWcuZXZlcnkoKHN5bSkgPT4ge1xuICAgICAgICByZXR1cm4gIShzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ29uc3RcbiAgICAgICAgICAgIHx8IHN5bSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWZ1blxuICAgICAgICAgICAgfHwgc3ltIGluc3RhbmNlb2YgQVNUX1N5bWJvbExhbWJkYSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZl9vbmNlKHR3LCBjb21wcmVzc29yLCBkZWYpIHtcbiAgICByZXR1cm4gY29tcHJlc3Nvci5vcHRpb24oXCJ1bnVzZWRcIilcbiAgICAgICAgJiYgIWRlZi5zY29wZS5waW5uZWQoKVxuICAgICAgICAmJiBkZWYucmVmZXJlbmNlcy5sZW5ndGggLSBkZWYucmVjdXJzaXZlX3JlZnMgPT0gMVxuICAgICAgICAmJiB0dy5sb29wX2lkcy5nZXQoZGVmLmlkKSA9PT0gdHcuaW5fbG9vcDtcbn1cblxuZnVuY3Rpb24gaXNfaW1tdXRhYmxlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB2YWx1ZS5pc19jb25zdGFudCgpXG4gICAgICAgIHx8IHZhbHVlIGluc3RhbmNlb2YgQVNUX0xhbWJkYVxuICAgICAgICB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFTVF9UaGlzO1xufVxuXG4vLyBBIGRlZmluaXRpb24gXCJlc2NhcGVzXCIgd2hlbiBpdHMgdmFsdWUgY2FuIGxlYXZlIHRoZSBwb2ludCBvZiB1c2UuXG4vLyBFeGFtcGxlOiBgYSA9IGIgfHwgY2Bcbi8vIEluIHRoaXMgZXhhbXBsZSwgXCJiXCIgYW5kIFwiY1wiIGFyZSBlc2NhcGluZywgYmVjYXVzZSB0aGV5J3JlIGdvaW5nIGludG8gXCJhXCJcbi8vXG4vLyBkZWYuZXNjYXBlZCBpcyAhPSAwIHdoZW4gaXQgZXNjYXBlcy5cbi8vXG4vLyBXaGVuIGdyZWF0ZXIgdGhhbiAxLCBpdCBtZWFucyB0aGF0IE4gY2hhaW5lZCBwcm9wZXJ0aWVzIHdpbGwgYmUgcmVhZCBvZmZcbi8vIG9mIHRoYXQgZGVmIGJlZm9yZSBhbiBlc2NhcGUgb2NjdXJzLiBUaGlzIGlzIHVzZWZ1bCBmb3IgZXZhbHVhdGluZ1xuLy8gcHJvcGVydHkgYWNjZXNzZXMsIHdoZXJlIHlvdSBuZWVkIHRvIGtub3cgd2hlbiB0byBzdG9wLlxuZnVuY3Rpb24gbWFya19lc2NhcGVkKHR3LCBkLCBzY29wZSwgbm9kZSwgdmFsdWUsIGxldmVsID0gMCwgZGVwdGggPSAxKSB7XG4gICAgdmFyIHBhcmVudCA9IHR3LnBhcmVudChsZXZlbCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5pc19jb25zdGFudCgpKSByZXR1cm47XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9DbGFzc0V4cHJlc3Npb24pIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24gJiYgKHBhcmVudC5vcGVyYXRvciA9PT0gXCI9XCIgfHwgcGFyZW50LmxvZ2ljYWwpICYmIG5vZGUgPT09IHBhcmVudC5yaWdodFxuICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiAobm9kZSAhPT0gcGFyZW50LmV4cHJlc3Npb24gfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX05ldylcbiAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0V4aXQgJiYgbm9kZSA9PT0gcGFyZW50LnZhbHVlICYmIG5vZGUuc2NvcGUgIT09IGQuc2NvcGVcbiAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX1ZhckRlZkxpa2UgJiYgbm9kZSA9PT0gcGFyZW50LnZhbHVlXG4gICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9ZaWVsZCAmJiBub2RlID09PSBwYXJlbnQudmFsdWUgJiYgbm9kZS5zY29wZSAhPT0gZC5zY29wZVxuICAgICkge1xuICAgICAgICBpZiAoZGVwdGggPiAxICYmICEodmFsdWUgJiYgdmFsdWUuaXNfY29uc3RhbnRfZXhwcmVzc2lvbihzY29wZSkpKSBkZXB0aCA9IDE7XG4gICAgICAgIGlmICghZC5lc2NhcGVkIHx8IGQuZXNjYXBlZCA+IGRlcHRoKSBkLmVzY2FwZWQgPSBkZXB0aDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHBhcmVudCBpbnN0YW5jZW9mIEFTVF9BcnJheVxuICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQXdhaXRcbiAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiBsYXp5X29wLmhhcyhwYXJlbnQub3BlcmF0b3IpXG4gICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAmJiBub2RlICE9PSBwYXJlbnQuY29uZGl0aW9uXG4gICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb25cbiAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlICYmIG5vZGUgPT09IHBhcmVudC50YWlsX25vZGUoKVxuICAgICkge1xuICAgICAgICBtYXJrX2VzY2FwZWQodHcsIGQsIHNjb3BlLCBwYXJlbnQsIHBhcmVudCwgbGV2ZWwgKyAxLCBkZXB0aCk7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsICYmIG5vZGUgPT09IHBhcmVudC52YWx1ZSkge1xuICAgICAgICB2YXIgb2JqID0gdHcucGFyZW50KGxldmVsICsgMSk7XG5cbiAgICAgICAgbWFya19lc2NhcGVkKHR3LCBkLCBzY29wZSwgb2JqLCBvYmosIGxldmVsICsgMiwgZGVwdGgpO1xuICAgIH0gZWxzZSBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgbm9kZSA9PT0gcGFyZW50LmV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFsdWUgPSByZWFkX3Byb3BlcnR5KHZhbHVlLCBwYXJlbnQucHJvcGVydHkpO1xuXG4gICAgICAgIG1hcmtfZXNjYXBlZCh0dywgZCwgc2NvcGUsIHBhcmVudCwgdmFsdWUsIGxldmVsICsgMSwgZGVwdGggKyAxKTtcbiAgICAgICAgaWYgKHZhbHVlKSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxldmVsID4gMCkgcmV0dXJuO1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UgJiYgbm9kZSAhPT0gcGFyZW50LnRhaWxfbm9kZSgpKSByZXR1cm47XG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHJldHVybjtcblxuICAgIGQuZGlyZWN0X2FjY2VzcyA9IHRydWU7XG59XG5cbmNvbnN0IHN1cHByZXNzID0gbm9kZSA9PiB3YWxrKG5vZGUsIG5vZGUgPT4ge1xuICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSkgcmV0dXJuO1xuICAgIHZhciBkID0gbm9kZS5kZWZpbml0aW9uKCk7XG4gICAgaWYgKCFkKSByZXR1cm47XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSBkLnJlZmVyZW5jZXMucHVzaChub2RlKTtcbiAgICBkLmZpeGVkID0gZmFsc2U7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9BY2Nlc3NvciwgZnVuY3Rpb24odHcsIGRlc2NlbmQsIGNvbXByZXNzb3IpIHtcbiAgICBwdXNoKHR3KTtcbiAgICByZXNldF92YXJpYWJsZXModHcsIGNvbXByZXNzb3IsIHRoaXMpO1xuICAgIGRlc2NlbmQoKTtcbiAgICBwb3AodHcpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbmRlZl9yZWR1Y2VfdmFycyhBU1RfQXNzaWduLCBmdW5jdGlvbih0dywgZGVzY2VuZCwgY29tcHJlc3Nvcikge1xuICAgIHZhciBub2RlID0gdGhpcztcbiAgICBpZiAobm9kZS5sZWZ0IGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmcpIHtcbiAgICAgICAgc3VwcHJlc3Mobm9kZS5sZWZ0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbmlzaF93YWxrID0gKCkgPT4ge1xuICAgICAgICBpZiAobm9kZS5sb2dpY2FsKSB7XG4gICAgICAgICAgICBub2RlLmxlZnQud2Fsayh0dyk7XG5cbiAgICAgICAgICAgIHB1c2godHcpO1xuICAgICAgICAgICAgbm9kZS5yaWdodC53YWxrKHR3KTtcbiAgICAgICAgICAgIHBvcCh0dyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzeW0gPSBub2RlLmxlZnQ7XG4gICAgaWYgKCEoc3ltIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikpIHJldHVybiBmaW5pc2hfd2FsaygpO1xuXG4gICAgdmFyIGRlZiA9IHN5bS5kZWZpbml0aW9uKCk7XG4gICAgdmFyIHNhZmUgPSBzYWZlX3RvX2Fzc2lnbih0dywgZGVmLCBzeW0uc2NvcGUsIG5vZGUucmlnaHQpO1xuICAgIGRlZi5hc3NpZ25tZW50cysrO1xuICAgIGlmICghc2FmZSkgcmV0dXJuIGZpbmlzaF93YWxrKCk7XG5cbiAgICB2YXIgZml4ZWQgPSBkZWYuZml4ZWQ7XG4gICAgaWYgKCFmaXhlZCAmJiBub2RlLm9wZXJhdG9yICE9IFwiPVwiICYmICFub2RlLmxvZ2ljYWwpIHJldHVybiBmaW5pc2hfd2FsaygpO1xuXG4gICAgdmFyIGVxID0gbm9kZS5vcGVyYXRvciA9PSBcIj1cIjtcbiAgICB2YXIgdmFsdWUgPSBlcSA/IG5vZGUucmlnaHQgOiBub2RlO1xuICAgIGlmIChpc19tb2RpZmllZChjb21wcmVzc29yLCB0dywgbm9kZSwgdmFsdWUsIDApKSByZXR1cm4gZmluaXNoX3dhbGsoKTtcblxuICAgIGRlZi5yZWZlcmVuY2VzLnB1c2goc3ltKTtcblxuICAgIGlmICghbm9kZS5sb2dpY2FsKSB7XG4gICAgICAgIGlmICghZXEpIGRlZi5jaGFpbmVkID0gdHJ1ZTtcblxuICAgICAgICBkZWYuZml4ZWQgPSBlcSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUucmlnaHQ7XG4gICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgbm9kZSwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBub2RlLm9wZXJhdG9yLnNsaWNlKDAsIC0xKSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmaXhlZCBpbnN0YW5jZW9mIEFTVF9Ob2RlID8gZml4ZWQgOiBmaXhlZCgpLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBub2RlLnJpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5sb2dpY2FsKSB7XG4gICAgICAgIG1hcmsodHcsIGRlZiwgZmFsc2UpO1xuICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgbm9kZS5yaWdodC53YWxrKHR3KTtcbiAgICAgICAgcG9wKHR3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbWFyayh0dywgZGVmLCBmYWxzZSk7XG4gICAgbm9kZS5yaWdodC53YWxrKHR3KTtcbiAgICBtYXJrKHR3LCBkZWYsIHRydWUpO1xuXG4gICAgbWFya19lc2NhcGVkKHR3LCBkZWYsIHN5bS5zY29wZSwgbm9kZSwgdmFsdWUsIDAsIDEpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9CaW5hcnksIGZ1bmN0aW9uKHR3KSB7XG4gICAgaWYgKCFsYXp5X29wLmhhcyh0aGlzLm9wZXJhdG9yKSkgcmV0dXJuO1xuICAgIHRoaXMubGVmdC53YWxrKHR3KTtcbiAgICBwdXNoKHR3KTtcbiAgICB0aGlzLnJpZ2h0LndhbGsodHcpO1xuICAgIHBvcCh0dyk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9CbG9jaywgZnVuY3Rpb24odHcsIGRlc2NlbmQsIGNvbXByZXNzb3IpIHtcbiAgICByZXNldF9ibG9ja192YXJpYWJsZXMoY29tcHJlc3NvciwgdGhpcyk7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9DYXNlLCBmdW5jdGlvbih0dykge1xuICAgIHB1c2godHcpO1xuICAgIHRoaXMuZXhwcmVzc2lvbi53YWxrKHR3KTtcbiAgICBwb3AodHcpO1xuICAgIHB1c2godHcpO1xuICAgIHdhbGtfYm9keSh0aGlzLCB0dyk7XG4gICAgcG9wKHR3KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG5kZWZfcmVkdWNlX3ZhcnMoQVNUX0NsYXNzLCBmdW5jdGlvbih0dywgZGVzY2VuZCkge1xuICAgIGNsZWFyX2ZsYWcodGhpcywgSU5MSU5FRCk7XG4gICAgcHVzaCh0dyk7XG4gICAgZGVzY2VuZCgpO1xuICAgIHBvcCh0dyk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9DbGFzc1N0YXRpY0Jsb2NrLCBmdW5jdGlvbih0dywgZGVzY2VuZCwgY29tcHJlc3Nvcikge1xuICAgIHJlc2V0X2Jsb2NrX3ZhcmlhYmxlcyhjb21wcmVzc29yLCB0aGlzKTtcbn0pO1xuXG5kZWZfcmVkdWNlX3ZhcnMoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbih0dykge1xuICAgIHRoaXMuY29uZGl0aW9uLndhbGsodHcpO1xuICAgIHB1c2godHcpO1xuICAgIHRoaXMuY29uc2VxdWVudC53YWxrKHR3KTtcbiAgICBwb3AodHcpO1xuICAgIHB1c2godHcpO1xuICAgIHRoaXMuYWx0ZXJuYXRpdmUud2Fsayh0dyk7XG4gICAgcG9wKHR3KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG5kZWZfcmVkdWNlX3ZhcnMoQVNUX0NoYWluLCBmdW5jdGlvbih0dywgZGVzY2VuZCkge1xuICAgIC8vIENoYWlucycgY29uZGl0aW9ucyBhcHBseSBsZWZ0LXRvLXJpZ2h0LCBjdW11bGF0aXZlbHkuXG4gICAgLy8gSWYgd2Ugd2FsayBub3JtYWxseSB3ZSBkb24ndCBnbyBpbiB0aGF0IG9yZGVyIGJlY2F1c2Ugd2Ugd291bGQgcG9wIGJlZm9yZSBwdXNoaW5nIGFnYWluXG4gICAgLy8gU29sdXRpb246IEFTVF9Qcm9wQWNjZXNzIGFuZCBBU1RfQ2FsbCBwdXNoIHdoZW4gdGhleSBhcmUgb3B0aW9uYWwsIGFuZCBuZXZlciBwb3AuXG4gICAgLy8gVGhlbiB3ZSBwb3AgZXZlcnl0aGluZyB3aGVuIHRoZXkgYXJlIGRvbmUgYmVpbmcgd2Fsa2VkLlxuICAgIGNvbnN0IHNhZmVfaWRzID0gdHcuc2FmZV9pZHM7XG5cbiAgICBkZXNjZW5kKCk7XG5cbiAgICAvLyBVbnJvbGwgYmFjayB0byBzdGFydFxuICAgIHR3LnNhZmVfaWRzID0gc2FmZV9pZHM7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9DYWxsLCBmdW5jdGlvbiAodHcpIHtcbiAgICB0aGlzLmV4cHJlc3Npb24ud2Fsayh0dyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25hbCkge1xuICAgICAgICAvLyBOZXZlciBwb3AgLS0gaXQncyBwb3BwZWQgYXQgQVNUX0NoYWluIGFib3ZlXG4gICAgICAgIHB1c2godHcpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYXJnIG9mIHRoaXMuYXJncykgYXJnLndhbGsodHcpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9Qcm9wQWNjZXNzLCBmdW5jdGlvbiAodHcpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9uYWwpIHJldHVybjtcblxuICAgIHRoaXMuZXhwcmVzc2lvbi53YWxrKHR3KTtcblxuICAgIC8vIE5ldmVyIHBvcCAtLSBpdCdzIHBvcHBlZCBhdCBBU1RfQ2hhaW4gYWJvdmVcbiAgICBwdXNoKHR3KTtcblxuICAgIGlmICh0aGlzLnByb3BlcnR5IGluc3RhbmNlb2YgQVNUX05vZGUpIHRoaXMucHJvcGVydHkud2Fsayh0dyk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG5kZWZfcmVkdWNlX3ZhcnMoQVNUX0RlZmF1bHQsIGZ1bmN0aW9uKHR3LCBkZXNjZW5kKSB7XG4gICAgcHVzaCh0dyk7XG4gICAgZGVzY2VuZCgpO1xuICAgIHBvcCh0dyk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZnVuY3Rpb24gbWFya19sYW1iZGEodHcsIGRlc2NlbmQsIGNvbXByZXNzb3IpIHtcbiAgICBjbGVhcl9mbGFnKHRoaXMsIElOTElORUQpO1xuICAgIHB1c2godHcpO1xuICAgIHJlc2V0X3ZhcmlhYmxlcyh0dywgY29tcHJlc3NvciwgdGhpcyk7XG5cbiAgICB2YXIgaWlmZTtcbiAgICBpZiAoIXRoaXMubmFtZVxuICAgICAgICAmJiAhdGhpcy51c2VzX2FyZ3VtZW50c1xuICAgICAgICAmJiAhdGhpcy5waW5uZWQoKVxuICAgICAgICAmJiAoaWlmZSA9IHR3LnBhcmVudCgpKSBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICYmIGlpZmUuZXhwcmVzc2lvbiA9PT0gdGhpc1xuICAgICAgICAmJiAhaWlmZS5hcmdzLnNvbWUoYXJnID0+IGFyZyBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pXG4gICAgICAgICYmIHRoaXMuYXJnbmFtZXMuZXZlcnkoYXJnX25hbWUgPT4gYXJnX25hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKVxuICAgICkge1xuICAgICAgICAvLyBWaXJ0dWFsbHkgdHVybiBJSUZFIHBhcmFtZXRlcnMgaW50byB2YXJpYWJsZSBkZWZpbml0aW9uczpcbiAgICAgICAgLy8gICAoZnVuY3Rpb24oYSxiKSB7Li4ufSkoYyxkKSA9PiAoZnVuY3Rpb24oKSB7dmFyIGE9YyxiPWQ7IC4uLn0pKClcbiAgICAgICAgLy8gU28gZXhpc3RpbmcgdHJhbnNmb3JtYXRpb24gcnVsZXMgY2FuIHdvcmsgb24gdGhlbS5cbiAgICAgICAgdGhpcy5hcmduYW1lcy5mb3JFYWNoKChhcmcsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICghYXJnLmRlZmluaXRpb24pIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkID0gYXJnLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgIC8vIEF2b2lkIHNldHRpbmcgZml4ZWQgd2hlbiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUgb3JpZ2luIGZvciBhIHZhcmlhYmxlIHZhbHVlXG4gICAgICAgICAgICBpZiAoZC5vcmlnLmxlbmd0aCA+IDEpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChkLmZpeGVkID09PSB1bmRlZmluZWQgJiYgKCF0aGlzLnVzZXNfYXJndW1lbnRzIHx8IHR3Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpKSkge1xuICAgICAgICAgICAgICAgIGQuZml4ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpZmUuYXJnc1tpXSB8fCBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgaWlmZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0dy5sb29wX2lkcy5zZXQoZC5pZCwgdHcuaW5fbG9vcCk7XG4gICAgICAgICAgICAgICAgbWFyayh0dywgZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGQuZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVzY2VuZCgpO1xuICAgIHBvcCh0dyk7XG5cbiAgICBoYW5kbGVfZGVmaW5lZF9hZnRlcl9ob2lzdCh0aGlzKTtcblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEl0J3MgcG9zc2libGUgZm9yIGEgaG9pc3RlZCBmdW5jdGlvbiB0byB1c2Ugc29tZXRoaW5nIHRoYXQncyBub3QgZGVmaW5lZCB5ZXQuIEV4YW1wbGU6XG4gKlxuICogaG9pc3RlZCgpO1xuICogdmFyIGRlZmluZWRfYWZ0ZXIgPSB0cnVlO1xuICogZnVuY3Rpb24gaG9pc3RlZCgpIHtcbiAqICAgLy8gdXNlIGRlZmluZWRfYWZ0ZXJcbiAqIH1cbiAqXG4gKiBPciBldmVuIGluZGlyZWN0bHk6XG4gKlxuICogQigpO1xuICogdmFyIGRlZmluZWRfYWZ0ZXIgPSB0cnVlO1xuICogZnVuY3Rpb24gQSgpIHtcbiAqICAgLy8gdXNlIGRlZmluZWRfYWZ0ZXJcbiAqIH1cbiAqIGZ1bmN0aW9uIEIoKSB7XG4gKiAgIEEoKTtcbiAqIH1cbiAqXG4gKiBBY2Nlc3MgYSB2YXJpYWJsZSBiZWZvcmUgZGVjbGFyYXRpb24gd2lsbCBlaXRoZXIgdGhyb3cgYSBSZWZlcmVuY2VFcnJvclxuICogKGlmIHRoZSB2YXJpYWJsZSBpcyBkZWNsYXJlZCB3aXRoIGBsZXRgIG9yIGBjb25zdGApLFxuICogb3IgZ2V0IGFuIGB1bmRlZmluZWRgIChpZiB0aGUgdmFyaWFibGUgaXMgZGVjbGFyZWQgd2l0aCBgdmFyYCkuXG4gKlxuICogSWYgdGhlIHZhcmlhYmxlIGlzIGlubGluZWQgaW50byB0aGUgZnVuY3Rpb24sIHRoZSBiZWhhdmlvciB3aWxsIGNoYW5nZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiB0aGUgcGFyZW50IHRvIGRpc2FsbG93IGlubGluaW5nIG9mIHN1Y2ggdmFyaWFibGVzLFxuICovXG5mdW5jdGlvbiBoYW5kbGVfZGVmaW5lZF9hZnRlcl9ob2lzdChwYXJlbnQpIHtcbiAgICBjb25zdCBkZWZ1bnMgPSBbXTtcbiAgICB3YWxrKHBhcmVudCwgbm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlID09PSBwYXJlbnQpIHJldHVybjtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW4pIHtcbiAgICAgICAgICAgIGRlZnVucy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZVxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnRcbiAgICAgICAgKSByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIGBkZWZ1bmAgaWQgdG8gYXJyYXkgb2YgYGRlZnVuYCBpdCB1c2VzXG4gICAgY29uc3QgZGVmdW5fZGVwZW5kZW5jaWVzX21hcCA9IG5ldyBNYXAoKTtcbiAgICAvLyBgZGVmdW5gIGlkIHRvIGFycmF5IG9mIGVuY2xvc2luZyBgZGVmYCB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBmdW5jdGlvblxuICAgIGNvbnN0IGRlcGVuZGVuY2llc19tYXAgPSBuZXcgTWFwKCk7XG4gICAgLy8gYWxsIHN5bWJvbCBpZHMgdGhhdCB3aWxsIGJlIHRyYWNrZWQgZm9yIHJlYWQvd3JpdGVcbiAgICBjb25zdCBzeW1ib2xzX29mX2ludGVyZXN0ID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRlZnVuc19vZl9pbnRlcmVzdCA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3QgZGVmdW4gb2YgZGVmdW5zKSB7XG4gICAgICAgIGNvbnN0IGZuYW1lX2RlZiA9IGRlZnVuLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICBjb25zdCBlbmNsb3NpbmdfZGVmcyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZnVuLmVuY2xvc2VkKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZGVmLmZpeGVkID09PSBmYWxzZVxuICAgICAgICAgICAgICAgIHx8IGRlZiA9PT0gZm5hbWVfZGVmXG4gICAgICAgICAgICAgICAgfHwgZGVmLnNjb3BlLmdldF9kZWZ1bl9zY29wZSgpICE9PSBwYXJlbnRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzeW1ib2xzX29mX2ludGVyZXN0LmFkZChkZWYuaWQpO1xuXG4gICAgICAgICAgICAvLyBmb3VuZCBhIHJlZmVyZW5jZSB0byBhbm90aGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZGVmLmFzc2lnbm1lbnRzID09PSAwXG4gICAgICAgICAgICAgICAgJiYgZGVmLm9yaWcubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgICAgJiYgZGVmLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVmdW5cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRlZnVuc19vZl9pbnRlcmVzdC5hZGQoZGVmLmlkKTtcbiAgICAgICAgICAgICAgICBzeW1ib2xzX29mX2ludGVyZXN0LmFkZChkZWYuaWQpO1xuXG4gICAgICAgICAgICAgICAgZGVmdW5zX29mX2ludGVyZXN0LmFkZChmbmFtZV9kZWYuaWQpO1xuICAgICAgICAgICAgICAgIHN5bWJvbHNfb2ZfaW50ZXJlc3QuYWRkKGZuYW1lX2RlZi5pZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRlZnVuX2RlcGVuZGVuY2llc19tYXAuaGFzKGZuYW1lX2RlZi5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmdW5fZGVwZW5kZW5jaWVzX21hcC5zZXQoZm5hbWVfZGVmLmlkLCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZnVuX2RlcGVuZGVuY2llc19tYXAuZ2V0KGZuYW1lX2RlZi5pZCkucHVzaChkZWYuaWQpO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVuY2xvc2luZ19kZWZzLnB1c2goZGVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmNsb3NpbmdfZGVmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llc19tYXAuc2V0KGZuYW1lX2RlZi5pZCwgZW5jbG9zaW5nX2RlZnMpO1xuICAgICAgICAgICAgZGVmdW5zX29mX2ludGVyZXN0LmFkZChmbmFtZV9kZWYuaWQpO1xuICAgICAgICAgICAgc3ltYm9sc19vZl9pbnRlcmVzdC5hZGQoZm5hbWVfZGVmLmlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIGRlZnVucyB1c2Ugb3V0c2lkZSBjb25zdGFudHNcbiAgICBpZiAoIWRlcGVuZGVuY2llc19tYXAuc2l6ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW5jcmVtZW50IHRvIGNvdW50IFwic3ltYm9scyBvZiBpbnRlcmVzdFwiIChkZWZ1bnMgb3IgZGVmcykgdGhhdCB3ZSBmb3VuZC5cbiAgICAvLyBUaGVzZSBhcmUgdHJhY2tlZCBpbiBBU1Qgb3JkZXIgc28gd2UgY2FuIGNoZWNrIHdoaWNoIGlzIGFmdGVyIHdoaWNoLlxuICAgIGxldCBzeW1ib2xfaW5kZXggPSAxO1xuICAgIC8vIE1hcCBhIGRlZnVuIElEIHRvIGl0cyBmaXJzdCByZWFkIChhIGBzeW1ib2xfaW5kZXhgKVxuICAgIGNvbnN0IGRlZnVuX2ZpcnN0X3JlYWRfbWFwID0gbmV3IE1hcCgpO1xuICAgIC8vIE1hcCBhIHN5bWJvbCBJRCB0byBpdHMgbGFzdCB3cml0ZSAoYSBgc3ltYm9sX2luZGV4YClcbiAgICBjb25zdCBzeW1ib2xfbGFzdF93cml0ZV9tYXAgPSBuZXcgTWFwKCk7XG5cbiAgICB3YWxrX3BhcmVudChwYXJlbnQsIChub2RlLCB3YWxrX2luZm8pID0+IHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sICYmIG5vZGUudGhlZGVmKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IG5vZGUuZGVmaW5pdGlvbigpLmlkO1xuXG4gICAgICAgICAgICBzeW1ib2xfaW5kZXgrKztcblxuICAgICAgICAgICAgLy8gVHJhY2sgbGFzdC13cml0ZXMgdG8gc3ltYm9sc1xuICAgICAgICAgICAgaWYgKHN5bWJvbHNfb2ZfaW50ZXJlc3QuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uIHx8IGlzX2xocyhub2RlLCB3YWxrX2luZm8ucGFyZW50KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbF9sYXN0X3dyaXRlX21hcC5zZXQoaWQsIHN5bWJvbF9pbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUcmFjayBmaXJzdC1yZWFkcyBvZiBkZWZ1bnMgKHJlZmluZWQgbGF0ZXIpXG4gICAgICAgICAgICBpZiAoZGVmdW5zX29mX2ludGVyZXN0LmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZnVuX2ZpcnN0X3JlYWRfbWFwLmhhcyhpZCkgJiYgIWlzX3JlY3Vyc2l2ZV9yZWYod2Fsa19pbmZvLCBpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmdW5fZmlyc3RfcmVhZF9tYXAuc2V0KGlkLCBzeW1ib2xfaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVmaW5lIGBkZWZ1bl9maXJzdF9yZWFkX21hcGAgdG8gYmUgYXMgaGlnaCBhcyBwb3NzaWJsZVxuICAgIGZvciAoY29uc3QgW2RlZnVuLCBkZWZ1bl9maXJzdF9yZWFkXSBvZiBkZWZ1bl9maXJzdF9yZWFkX21hcCkge1xuICAgICAgICAvLyBVcGRhdGUgYWxsIGRlcGVuZGVuY2llcyBvZiBgZGVmdW5gXG4gICAgICAgIGNvbnN0IHF1ZXVlID0gbmV3IFNldChkZWZ1bl9kZXBlbmRlbmNpZXNfbWFwLmdldChkZWZ1bikpO1xuICAgICAgICBmb3IgKGNvbnN0IGVuY2xvc2VkX2RlZnVuIG9mIHF1ZXVlKSB7XG4gICAgICAgICAgICBsZXQgZW5jbG9zZWRfZGVmdW5fZmlyc3RfcmVhZCA9IGRlZnVuX2ZpcnN0X3JlYWRfbWFwLmdldChlbmNsb3NlZF9kZWZ1bik7XG4gICAgICAgICAgICBpZiAoZW5jbG9zZWRfZGVmdW5fZmlyc3RfcmVhZCAhPSBudWxsICYmIGVuY2xvc2VkX2RlZnVuX2ZpcnN0X3JlYWQgPCBkZWZ1bl9maXJzdF9yZWFkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZnVuX2ZpcnN0X3JlYWRfbWFwLnNldChlbmNsb3NlZF9kZWZ1biwgZGVmdW5fZmlyc3RfcmVhZCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jbG9zZWRfZW5jbG9zZWRfZGVmdW4gb2YgZGVmdW5fZGVwZW5kZW5jaWVzX21hcC5nZXQoZW5jbG9zZWRfZGVmdW4pIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgcXVldWUuYWRkKGVuY2xvc2VkX2VuY2xvc2VkX2RlZnVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSB3cml0ZS10aGVuLXJlYWQgb3JkZXIsIG90aGVyd2lzZSBjbGVhciBgZml4ZWRgXG4gICAgLy8gVGhpcyBpcyBzYWZlIGJlY2F1c2UgbGFzdC13cml0ZXMgKGZvdW5kX3N5bWJvbF93cml0ZXMpIGFyZSBhc3N1bWVkIHRvIGJlIGFzIGxhdGUgYXMgcG9zc2libGUsIGFuZCBmaXJzdC1yZWFkcyAoZGVmdW5fZmlyc3RfcmVhZF9tYXApIGFyZSBhc3N1bWVkIHRvIGJlIGFzIGVhcmx5IGFzIHBvc3NpYmxlLlxuICAgIGZvciAoY29uc3QgW2RlZnVuLCBkZWZzXSBvZiBkZXBlbmRlbmNpZXNfbWFwKSB7XG4gICAgICAgIGNvbnN0IGRlZnVuX2ZpcnN0X3JlYWQgPSBkZWZ1bl9maXJzdF9yZWFkX21hcC5nZXQoZGVmdW4pO1xuICAgICAgICBpZiAoZGVmdW5fZmlyc3RfcmVhZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZnMpIHtcbiAgICAgICAgICAgIGlmIChkZWYuZml4ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBkZWZfbGFzdF93cml0ZSA9IHN5bWJvbF9sYXN0X3dyaXRlX21hcC5nZXQoZGVmLmlkKSB8fCAwO1xuXG4gICAgICAgICAgICBpZiAoZGVmdW5fZmlyc3RfcmVhZCA8IGRlZl9sYXN0X3dyaXRlKSB7XG4gICAgICAgICAgICAgICAgZGVmLmZpeGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmRlZl9yZWR1Y2VfdmFycyhBU1RfTGFtYmRhLCBtYXJrX2xhbWJkYSk7XG5cbmRlZl9yZWR1Y2VfdmFycyhBU1RfRG8sIGZ1bmN0aW9uKHR3LCBkZXNjZW5kLCBjb21wcmVzc29yKSB7XG4gICAgcmVzZXRfYmxvY2tfdmFyaWFibGVzKGNvbXByZXNzb3IsIHRoaXMpO1xuICAgIGNvbnN0IHNhdmVkX2xvb3AgPSB0dy5pbl9sb29wO1xuICAgIHR3LmluX2xvb3AgPSB0aGlzO1xuICAgIHB1c2godHcpO1xuICAgIHRoaXMuYm9keS53YWxrKHR3KTtcbiAgICBpZiAoaGFzX2JyZWFrX29yX2NvbnRpbnVlKHRoaXMpKSB7XG4gICAgICAgIHBvcCh0dyk7XG4gICAgICAgIHB1c2godHcpO1xuICAgIH1cbiAgICB0aGlzLmNvbmRpdGlvbi53YWxrKHR3KTtcbiAgICBwb3AodHcpO1xuICAgIHR3LmluX2xvb3AgPSBzYXZlZF9sb29wO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbmRlZl9yZWR1Y2VfdmFycyhBU1RfRm9yLCBmdW5jdGlvbih0dywgZGVzY2VuZCwgY29tcHJlc3Nvcikge1xuICAgIHJlc2V0X2Jsb2NrX3ZhcmlhYmxlcyhjb21wcmVzc29yLCB0aGlzKTtcbiAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQud2Fsayh0dyk7XG4gICAgY29uc3Qgc2F2ZWRfbG9vcCA9IHR3LmluX2xvb3A7XG4gICAgdHcuaW5fbG9vcCA9IHRoaXM7XG4gICAgcHVzaCh0dyk7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uKSB0aGlzLmNvbmRpdGlvbi53YWxrKHR3KTtcbiAgICB0aGlzLmJvZHkud2Fsayh0dyk7XG4gICAgaWYgKHRoaXMuc3RlcCkge1xuICAgICAgICBpZiAoaGFzX2JyZWFrX29yX2NvbnRpbnVlKHRoaXMpKSB7XG4gICAgICAgICAgICBwb3AodHcpO1xuICAgICAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGVwLndhbGsodHcpO1xuICAgIH1cbiAgICBwb3AodHcpO1xuICAgIHR3LmluX2xvb3AgPSBzYXZlZF9sb29wO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbmRlZl9yZWR1Y2VfdmFycyhBU1RfRm9ySW4sIGZ1bmN0aW9uKHR3LCBkZXNjZW5kLCBjb21wcmVzc29yKSB7XG4gICAgcmVzZXRfYmxvY2tfdmFyaWFibGVzKGNvbXByZXNzb3IsIHRoaXMpO1xuICAgIHN1cHByZXNzKHRoaXMuaW5pdCk7XG4gICAgdGhpcy5vYmplY3Qud2Fsayh0dyk7XG4gICAgY29uc3Qgc2F2ZWRfbG9vcCA9IHR3LmluX2xvb3A7XG4gICAgdHcuaW5fbG9vcCA9IHRoaXM7XG4gICAgcHVzaCh0dyk7XG4gICAgdGhpcy5ib2R5LndhbGsodHcpO1xuICAgIHBvcCh0dyk7XG4gICAgdHcuaW5fbG9vcCA9IHNhdmVkX2xvb3A7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9JZiwgZnVuY3Rpb24odHcpIHtcbiAgICB0aGlzLmNvbmRpdGlvbi53YWxrKHR3KTtcbiAgICBwdXNoKHR3KTtcbiAgICB0aGlzLmJvZHkud2Fsayh0dyk7XG4gICAgcG9wKHR3KTtcbiAgICBpZiAodGhpcy5hbHRlcm5hdGl2ZSkge1xuICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZS53YWxrKHR3KTtcbiAgICAgICAgcG9wKHR3KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9MYWJlbGVkU3RhdGVtZW50LCBmdW5jdGlvbih0dykge1xuICAgIHB1c2godHcpO1xuICAgIHRoaXMuYm9keS53YWxrKHR3KTtcbiAgICBwb3AodHcpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbmRlZl9yZWR1Y2VfdmFycyhBU1RfU3ltYm9sQ2F0Y2gsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGVmaW5pdGlvbigpLmZpeGVkID0gZmFsc2U7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9TeW1ib2xSZWYsIGZ1bmN0aW9uKHR3LCBkZXNjZW5kLCBjb21wcmVzc29yKSB7XG4gICAgdmFyIGQgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICBkLnJlZmVyZW5jZXMucHVzaCh0aGlzKTtcbiAgICBpZiAoZC5yZWZlcmVuY2VzLmxlbmd0aCA9PSAxXG4gICAgICAgICYmICFkLmZpeGVkXG4gICAgICAgICYmIGQub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWZ1bikge1xuICAgICAgICB0dy5sb29wX2lkcy5zZXQoZC5pZCwgdHcuaW5fbG9vcCk7XG4gICAgfVxuICAgIHZhciBmaXhlZF92YWx1ZTtcbiAgICBpZiAoZC5maXhlZCA9PT0gdW5kZWZpbmVkIHx8ICFzYWZlX3RvX3JlYWQodHcsIGQpKSB7XG4gICAgICAgIGQuZml4ZWQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGQuZml4ZWQpIHtcbiAgICAgICAgZml4ZWRfdmFsdWUgPSB0aGlzLmZpeGVkX3ZhbHVlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZpeGVkX3ZhbHVlIGluc3RhbmNlb2YgQVNUX0xhbWJkYVxuICAgICAgICAgICAgJiYgaXNfcmVjdXJzaXZlX3JlZih0dywgZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkLnJlY3Vyc2l2ZV9yZWZzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoZml4ZWRfdmFsdWVcbiAgICAgICAgICAgICYmICFjb21wcmVzc29yLmV4cG9zZWQoZClcbiAgICAgICAgICAgICYmIHJlZl9vbmNlKHR3LCBjb21wcmVzc29yLCBkKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGQuc2luZ2xlX3VzZSA9XG4gICAgICAgICAgICAgICAgZml4ZWRfdmFsdWUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhICYmICFmaXhlZF92YWx1ZS5waW5uZWQoKVxuICAgICAgICAgICAgICAgIHx8IGZpeGVkX3ZhbHVlIGluc3RhbmNlb2YgQVNUX0NsYXNzXG4gICAgICAgICAgICAgICAgfHwgZC5zY29wZSA9PT0gdGhpcy5zY29wZSAmJiBmaXhlZF92YWx1ZS5pc19jb25zdGFudF9leHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkLnNpbmdsZV91c2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfbW9kaWZpZWQoY29tcHJlc3NvciwgdHcsIHRoaXMsIGZpeGVkX3ZhbHVlLCAwLCBpc19pbW11dGFibGUoZml4ZWRfdmFsdWUpKSkge1xuICAgICAgICAgICAgaWYgKGQuc2luZ2xlX3VzZSkge1xuICAgICAgICAgICAgICAgIGQuc2luZ2xlX3VzZSA9IFwibVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkLmZpeGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFya19lc2NhcGVkKHR3LCBkLCB0aGlzLnNjb3BlLCB0aGlzLCBmaXhlZF92YWx1ZSwgMCwgMSk7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9Ub3BsZXZlbCwgZnVuY3Rpb24odHcsIGRlc2NlbmQsIGNvbXByZXNzb3IpIHtcbiAgICB0aGlzLmdsb2JhbHMuZm9yRWFjaChmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgcmVzZXRfZGVmKGNvbXByZXNzb3IsIGRlZik7XG4gICAgfSk7XG4gICAgcmVzZXRfdmFyaWFibGVzKHR3LCBjb21wcmVzc29yLCB0aGlzKTtcbiAgICBkZXNjZW5kKCk7XG4gICAgaGFuZGxlX2RlZmluZWRfYWZ0ZXJfaG9pc3QodGhpcyk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9UcnksIGZ1bmN0aW9uKHR3LCBkZXNjZW5kLCBjb21wcmVzc29yKSB7XG4gICAgcmVzZXRfYmxvY2tfdmFyaWFibGVzKGNvbXByZXNzb3IsIHRoaXMpO1xuICAgIHB1c2godHcpO1xuICAgIHRoaXMuYm9keS53YWxrKHR3KTtcbiAgICBwb3AodHcpO1xuICAgIGlmICh0aGlzLmJjYXRjaCkge1xuICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgdGhpcy5iY2F0Y2gud2Fsayh0dyk7XG4gICAgICAgIHBvcCh0dyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmJmaW5hbGx5KSB0aGlzLmJmaW5hbGx5LndhbGsodHcpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbmRlZl9yZWR1Y2VfdmFycyhBU1RfVW5hcnksIGZ1bmN0aW9uKHR3KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzO1xuICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIisrXCIgJiYgbm9kZS5vcGVyYXRvciAhPT0gXCItLVwiKSByZXR1cm47XG4gICAgdmFyIGV4cCA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgICBpZiAoIShleHAgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSkgcmV0dXJuO1xuICAgIHZhciBkZWYgPSBleHAuZGVmaW5pdGlvbigpO1xuICAgIHZhciBzYWZlID0gc2FmZV90b19hc3NpZ24odHcsIGRlZiwgZXhwLnNjb3BlLCB0cnVlKTtcbiAgICBkZWYuYXNzaWdubWVudHMrKztcbiAgICBpZiAoIXNhZmUpIHJldHVybjtcbiAgICB2YXIgZml4ZWQgPSBkZWYuZml4ZWQ7XG4gICAgaWYgKCFmaXhlZCkgcmV0dXJuO1xuICAgIGRlZi5yZWZlcmVuY2VzLnB1c2goZXhwKTtcbiAgICBkZWYuY2hhaW5lZCA9IHRydWU7XG4gICAgZGVmLmZpeGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgbm9kZSwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IG5vZGUub3BlcmF0b3Iuc2xpY2UoMCwgLTEpLFxuICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgbm9kZSwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmaXhlZCBpbnN0YW5jZW9mIEFTVF9Ob2RlID8gZml4ZWQgOiBmaXhlZCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJpZ2h0OiBtYWtlX25vZGUoQVNUX051bWJlciwgbm9kZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIG1hcmsodHcsIGRlZiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9WYXJEZWYsIGZ1bmN0aW9uKHR3LCBkZXNjZW5kKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzO1xuICAgIGlmIChub2RlLm5hbWUgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZykge1xuICAgICAgICBzdXBwcmVzcyhub2RlLm5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkID0gbm9kZS5uYW1lLmRlZmluaXRpb24oKTtcbiAgICBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICBpZiAoc2FmZV90b19hc3NpZ24odHcsIGQsIG5vZGUubmFtZS5zY29wZSwgbm9kZS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGQuZml4ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0dy5sb29wX2lkcy5zZXQoZC5pZCwgdHcuaW5fbG9vcCk7XG4gICAgICAgICAgICBtYXJrKHR3LCBkLCBmYWxzZSk7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBtYXJrKHR3LCBkLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZC5maXhlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmRlZl9yZWR1Y2VfdmFycyhBU1RfVXNpbmdEZWYsIGZ1bmN0aW9uKCkge1xuICAgIHN1cHByZXNzKHRoaXMubmFtZSk7XG59KTtcblxuZGVmX3JlZHVjZV92YXJzKEFTVF9XaGlsZSwgZnVuY3Rpb24odHcsIGRlc2NlbmQsIGNvbXByZXNzb3IpIHtcbiAgICByZXNldF9ibG9ja192YXJpYWJsZXMoY29tcHJlc3NvciwgdGhpcyk7XG4gICAgY29uc3Qgc2F2ZWRfbG9vcCA9IHR3LmluX2xvb3A7XG4gICAgdHcuaW5fbG9vcCA9IHRoaXM7XG4gICAgcHVzaCh0dyk7XG4gICAgZGVzY2VuZCgpO1xuICAgIHBvcCh0dyk7XG4gICAgdHcuaW5fbG9vcCA9IHNhdmVkX2xvb3A7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5mdW5jdGlvbiBsb29wX2JvZHkoeCkge1xuICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4geC5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50ID8geC5ib2R5IDogeDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIGlzX2xoc19yZWFkX29ubHkobGhzKSB7XG4gICAgaWYgKGxocyBpbnN0YW5jZW9mIEFTVF9UaGlzKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobGhzIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikgcmV0dXJuIGxocy5kZWZpbml0aW9uKCkub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xMYW1iZGE7XG4gICAgaWYgKGxocyBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzKSB7XG4gICAgICAgIGxocyA9IGxocy5leHByZXNzaW9uO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikge1xuICAgICAgICAgICAgaWYgKGxocy5pc19pbW11dGFibGUoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGhzID0gbGhzLmZpeGVkX3ZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaHMpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQVNUX1JlZ0V4cCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQVNUX0NvbnN0YW50KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGlzX2xoc19yZWFkX29ubHkobGhzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiogdmFyIGEgPSAxIC0tPiB2YXIgYSovXG5mdW5jdGlvbiByZW1vdmVfaW5pdGlhbGl6ZXJzKHZhcl9zdGF0ZW1lbnQpIHtcbiAgICB2YXIgZGVjbHMgPSBbXTtcbiAgICB2YXJfc3RhdGVtZW50LmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgIGlmIChkZWYubmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgZGVmLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGRlY2xzLnB1c2goZGVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZi5kZWNsYXJhdGlvbnNfYXNfbmFtZXMoKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIGRlY2xzLnB1c2gobWFrZV9ub2RlKEFTVF9WYXJEZWYsIGRlZiwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlY2xzLmxlbmd0aCA/IG1ha2Vfbm9kZShBU1RfVmFyLCB2YXJfc3RhdGVtZW50LCB7IGRlZmluaXRpb25zOiBkZWNscyB9KSA6IG51bGw7XG59XG5cbi8qKiBDYWxsZWQgb24gY29kZSB3aGljaCB3b24ndCBiZSBleGVjdXRlZCBidXQgaGFzIGFuIGVmZmVjdCBvdXRzaWRlIG9mIGl0c2VsZjogYHZhcmAsIGBmdW5jdGlvbmAgc3RhdGVtZW50cywgYGV4cG9ydGAsIGBpbXBvcnRgLiAqL1xuZnVuY3Rpb24gZXh0cmFjdF9mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc3RhdCwgdGFyZ2V0KSB7XG4gICAgd2FsayhzdGF0LCBub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyKSB7XG4gICAgICAgICAgICBjb25zdCBub19pbml0aWFsaXplcnMgPSByZW1vdmVfaW5pdGlhbGl6ZXJzKG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vX2luaXRpYWxpemVycykgdGFyZ2V0LnB1c2gobm9faW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW5cbiAgICAgICAgICAgICYmIChub2RlID09PSBzdGF0IHx8ICFjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5vZGUgPT09IHN0YXQgPyBub2RlIDogbWFrZV9ub2RlKEFTVF9WYXIsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBtYWtlX25vZGUoQVNUX1ZhckRlZiwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbWFrZV9ub2RlKEFTVF9TeW1ib2xWYXIsIG5vZGUubmFtZSwgbm9kZS5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRXhwb3J0IHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfSW1wb3J0KSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBnbyBpbnRvIG5lc3RlZCBzY29wZXNcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKiBUaWdodGVuIGEgYnVuY2ggb2Ygc3RhdGVtZW50cyB0b2dldGhlciwgYW5kIHBlcmZvcm0gc3RhdGVtZW50LWxldmVsIG9wdGltaXphdGlvbi4gKi9cbmZ1bmN0aW9uIHRpZ2h0ZW5fYm9keShzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgY29uc3QgbmVhcmVzdF9zY29wZSA9IGNvbXByZXNzb3IuZmluZF9zY29wZSgpO1xuICAgIGNvbnN0IGRlZnVuX3Njb3BlID0gbmVhcmVzdF9zY29wZS5nZXRfZGVmdW5fc2NvcGUoKTtcbiAgICBjb25zdCB7IGluX2xvb3AsIGluX3RyeSB9ID0gZmluZF9sb29wX3Njb3BlX3RyeSgpO1xuXG4gICAgdmFyIENIQU5HRUQsIG1heF9pdGVyID0gMTA7XG4gICAgZG8ge1xuICAgICAgICBDSEFOR0VEID0gZmFsc2U7XG4gICAgICAgIGVsaW1pbmF0ZV9zcHVyaW91c19ibG9ja3Moc3RhdGVtZW50cyk7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICAgICAgZWxpbWluYXRlX2RlYWRfY29kZShzdGF0ZW1lbnRzLCBjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJpZl9yZXR1cm5cIikpIHtcbiAgICAgICAgICAgIGhhbmRsZV9pZl9yZXR1cm4oc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iuc2VxdWVuY2VzX2xpbWl0ID4gMCkge1xuICAgICAgICAgICAgc2VxdWVuY2VzaXplKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VxdWVuY2VzaXplXzIoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiam9pbl92YXJzXCIpKSB7XG4gICAgICAgICAgICBqb2luX2NvbnNlY3V0aXZlX3ZhcnMoc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiY29sbGFwc2VfdmFyc1wiKSkge1xuICAgICAgICAgICAgY29sbGFwc2Uoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChDSEFOR0VEICYmIG1heF9pdGVyLS0gPiAwKTtcblxuICAgIGZ1bmN0aW9uIGZpbmRfbG9vcF9zY29wZV90cnkoKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tcHJlc3Nvci5zZWxmKCksIGxldmVsID0gMCwgaW5fbG9vcCA9IGZhbHNlLCBpbl90cnkgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaW5fbG9vcCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9UcnlCbG9jaykge1xuICAgICAgICAgICAgICAgIGluX3RyeSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG5vZGUgPSBjb21wcmVzc29yLnBhcmVudChsZXZlbCsrKSk7XG5cbiAgICAgICAgcmV0dXJuIHsgaW5fbG9vcCwgaW5fdHJ5IH07XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoIGZyb20gcmlnaHQgdG8gbGVmdCBmb3IgYXNzaWdubWVudC1saWtlIGV4cHJlc3Npb25zOlxuICAgIC8vIC0gYHZhciBhID0geDtgXG4gICAgLy8gLSBgYSA9IHg7YFxuICAgIC8vIC0gYCsrYWBcbiAgICAvLyBGb3IgZWFjaCBjYW5kaWRhdGUsIHNjYW4gZnJvbSBsZWZ0IHRvIHJpZ2h0IGZvciBmaXJzdCB1c2FnZSwgdGhlbiB0cnlcbiAgICAvLyB0byBmb2xkIGFzc2lnbm1lbnQgaW50byB0aGUgc2l0ZSBmb3IgY29tcHJlc3Npb24uXG4gICAgLy8gV2lsbCBub3QgYXR0ZW1wdCB0byBjb2xsYXBzZSBhc3NpZ25tZW50cyBpbnRvIG9yIHBhc3QgY29kZSBibG9ja3NcbiAgICAvLyB3aGljaCBhcmUgbm90IHNlcXVlbnRpYWxseSBleGVjdXRlZCwgZS5nLiBsb29wcyBhbmQgY29uZGl0aW9uYWxzLlxuICAgIGZ1bmN0aW9uIGNvbGxhcHNlKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKG5lYXJlc3Rfc2NvcGUucGlubmVkKCkgfHwgZGVmdW5fc2NvcGUucGlubmVkKCkpXG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgICAgICAgdmFyIGFyZ3M7XG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gW107XG4gICAgICAgIHZhciBzdGF0X2luZGV4ID0gc3RhdGVtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBzY2FubmVyID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGFib3J0KVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgLy8gU2tpcCBub2RlcyBiZWZvcmUgYGNhbmRpZGF0ZWAgYXMgcXVpY2tseSBhcyBwb3NzaWJsZVxuICAgICAgICAgICAgaWYgKCFoaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gaGl0X3N0YWNrW2hpdF9pbmRleF0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIGhpdF9pbmRleCsrO1xuICAgICAgICAgICAgICAgIGlmIChoaXRfaW5kZXggPCBoaXRfc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlX2N1c3RvbV9zY2FuX29yZGVyKG5vZGUpO1xuICAgICAgICAgICAgICAgIGhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RvcF9hZnRlciA9IGZpbmRfc3RvcChub2RlLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcF9hZnRlciA9PT0gbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcCBpbW1lZGlhdGVseSBpZiB0aGVzZSBub2RlIHR5cGVzIGFyZSBlbmNvdW50ZXJlZFxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHNjYW5uZXIucGFyZW50KCk7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgJiYgKG5vZGUubG9naWNhbCB8fCBub2RlLm9wZXJhdG9yICE9IFwiPVwiICYmIGxocy5lcXVpdmFsZW50X3RvKG5vZGUubGVmdCkpXG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Bd2FpdFxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfVXNpbmdcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgbGhzIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgbGhzLmVxdWl2YWxlbnRfdG8obm9kZS5leHByZXNzaW9uKVxuICAgICAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgIChub2RlIGluc3RhbmNlb2YgQVNUX0NhbGwgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAmJiBub2RlLm9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9EZWJ1Z2dlclxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uXG4gICAgICAgICAgICAgICAgICAgICYmIG5vZGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9TeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IG5vZGUuZXhwcmVzc2lvbi5kZWZpbml0aW9uKCkucmVmZXJlbmNlcy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfRm9yKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2xcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1RyeVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfV2l0aFxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfWWllbGRcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0V4cG9ydFxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3NcbiAgICAgICAgICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfRm9yICYmIG5vZGUgIT09IHBhcmVudC5pbml0XG4gICAgICAgICAgICAgICAgfHwgIXJlcGxhY2VfYWxsXG4gICAgICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhbm9kZS5pc19kZWNsYXJlZChjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXB1cmVfcHJvcF9hY2Nlc3NfZ2xvYmFscy5oYXMobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAgICAgICAgICYmIHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAgICAgICAgICYmIGhhc19hbm5vdGF0aW9uKHBhcmVudCwgX05PSU5MSU5FKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0UHJvcGVydHkgJiYgbm9kZS5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcCBvbmx5IGlmIGNhbmRpZGF0ZSBpcyBmb3VuZCB3aXRoaW4gY29uZGl0aW9uYWwgYnJhbmNoZXNcbiAgICAgICAgICAgIGlmICghc3RvcF9pZl9oaXQgJiYgKCFsaHNfbG9jYWwgfHwgIXJlcGxhY2VfYWxsKVxuICAgICAgICAgICAgICAgICYmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIGxhenlfb3AuaGFzKHBhcmVudC5vcGVyYXRvcikgJiYgcGFyZW50LmxlZnQgIT09IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICYmIHBhcmVudC5jb25kaXRpb24gIT09IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0lmICYmIHBhcmVudC5jb25kaXRpb24gIT09IG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgc3RvcF9pZl9oaXQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHZhcmlhYmxlIHdpdGggYXNzaWdubWVudCB3aGVuIGZvdW5kXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY2FuX3JlcGxhY2VcbiAgICAgICAgICAgICAgICAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVjbGFyYXRpb24pXG4gICAgICAgICAgICAgICAgJiYgbGhzLmVxdWl2YWxlbnRfdG8obm9kZSlcbiAgICAgICAgICAgICAgICAmJiAhc2hhZG93cyhzY2FubmVyLmZpbmRfc2NvcGUoKSB8fCBuZWFyZXN0X3Njb3BlLCBsdmFsdWVzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BfaWZfaGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc19saHMobm9kZSwgcGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVfZGVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlX2RlZiAmJiBjYW5kaWRhdGUgaW5zdGFuY2VvZiBBU1RfVmFyRGVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIENIQU5HRUQgPSBhYm9ydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIEFTVF9VbmFyeVBvc3RmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIEFTVF9WYXJEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IGNhbmRpZGF0ZS5uYW1lLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2FuZGlkYXRlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnJlZmVyZW5jZXMubGVuZ3RoIC0gZGVmLnJlcGxhY2VkID09IDEgJiYgIWNvbXByZXNzb3IuZXhwb3NlZChkZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYucmVwbGFjZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdW5hcmcgJiYgaXNfaWRlbnRpZmllcl9hdG9tKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWludGFpbl90aGlzX2JpbmRpbmcocGFyZW50LCBub2RlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQXNzaWduLCBjYW5kaWRhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2ljYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9TeW1ib2xSZWYsIGNhbmRpZGF0ZS5uYW1lLCBjYW5kaWRhdGUubmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsZWFyX2ZsYWcoY2FuZGlkYXRlLCBXUklURV9PTkxZKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlc2Ugbm9kZSB0eXBlcyBoYXZlIGNoaWxkIG5vZGVzIHRoYXQgZXhlY3V0ZSBzZXF1ZW50aWFsbHksXG4gICAgICAgICAgICAvLyBidXQgYXJlIG90aGVyd2lzZSBub3Qgc2FmZSB0byBzY2FuIGludG8gb3IgYmV5b25kIHRoZW0uXG4gICAgICAgICAgICB2YXIgc3ltO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FsbFxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRXhpdFxuICAgICAgICAgICAgICAgICYmIChzaWRlX2VmZmVjdHMgfHwgbGhzIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgfHwgbWF5X21vZGlmeShsaHMpKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2Vzc1xuICAgICAgICAgICAgICAgICYmIChzaWRlX2VmZmVjdHMgfHwgbm9kZS5leHByZXNzaW9uLm1heV90aHJvd19vbl9hY2Nlc3MoY29tcHJlc3NvcikpXG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAmJiAoKGx2YWx1ZXMuaGFzKG5vZGUubmFtZSkgJiYgbHZhbHVlcy5nZXQobm9kZS5uYW1lKS5tb2RpZmllZCkgfHwgc2lkZV9lZmZlY3RzICYmIG1heV9tb2RpZnkobm9kZSkpXG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9WYXJEZWYgJiYgbm9kZS52YWx1ZVxuICAgICAgICAgICAgICAgICYmIChsdmFsdWVzLmhhcyhub2RlLm5hbWUubmFtZSkgfHwgc2lkZV9lZmZlY3RzICYmIG1heV9tb2RpZnkobm9kZS5uYW1lKSlcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1VzaW5nXG4gICAgICAgICAgICAgICAgfHwgKHN5bSA9IGlzX2xocyhub2RlLmxlZnQsIG5vZGUpKVxuICAgICAgICAgICAgICAgICYmIChzeW0gaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyB8fCBsdmFsdWVzLmhhcyhzeW0ubmFtZSkpXG4gICAgICAgICAgICAgICAgfHwgbWF5X3Rocm93XG4gICAgICAgICAgICAgICAgJiYgKGluX3RyeSA/IG5vZGUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSA6IHNpZGVfZWZmZWN0c19leHRlcm5hbChub2RlKSkpIHtcbiAgICAgICAgICAgICAgICBzdG9wX2FmdGVyID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSlcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZV9jdXN0b21fc2Nhbl9vcmRlcihub2RlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChhYm9ydClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoc3RvcF9hZnRlciA9PT0gbm9kZSlcbiAgICAgICAgICAgICAgICBhYm9ydCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoc3RvcF9pZl9oaXQgPT09IG5vZGUpXG4gICAgICAgICAgICAgICAgc3RvcF9pZl9oaXQgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbXVsdGlfcmVwbGFjZXIgPSBuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoYWJvcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAvLyBTa2lwIG5vZGVzIGJlZm9yZSBgY2FuZGlkYXRlYCBhcyBxdWlja2x5IGFzIHBvc3NpYmxlXG4gICAgICAgICAgICBpZiAoIWhpdCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSBoaXRfc3RhY2tbaGl0X2luZGV4XSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgaGl0X2luZGV4Kys7XG4gICAgICAgICAgICAgICAgaWYgKGhpdF9pbmRleCA8IGhpdF9zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBoaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVwbGFjZSB2YXJpYWJsZSB3aGVuIGZvdW5kXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAmJiBub2RlLm5hbWUgPT0gZGVmLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIS0tcmVwbGFjZWQpXG4gICAgICAgICAgICAgICAgICAgIGFib3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNfbGhzKG5vZGUsIG11bHRpX3JlcGxhY2VyLnBhcmVudCgpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgZGVmLnJlcGxhY2VkKys7XG4gICAgICAgICAgICAgICAgdmFsdWVfZGVmLnJlcGxhY2VkLS07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgKG5vbi1leGVjdXRlZCkgZnVuY3Rpb25zIGFuZCAobGVhZGluZykgZGVmYXVsdCBjYXNlIGluIHN3aXRjaCBzdGF0ZW1lbnRzXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0IHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaWxlICgtLXN0YXRfaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gVHJlYXQgcGFyYW1ldGVycyBhcyBjb2xsYXBzaWJsZSBpbiBJSUZFLCBpLmUuXG4gICAgICAgICAgICAvLyAgIGZ1bmN0aW9uKGEsIGIpeyAuLi4gfSh4KCkpO1xuICAgICAgICAgICAgLy8gd291bGQgYmUgdHJhbnNsYXRlZCBpbnRvIGVxdWl2YWxlbnQgYXNzaWdubWVudHM6XG4gICAgICAgICAgICAvLyAgIHZhciBhID0geCgpLCBiID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHN0YXRfaW5kZXggPT0gMCAmJiBjb21wcmVzc29yLm9wdGlvbihcInVudXNlZFwiKSlcbiAgICAgICAgICAgICAgICBleHRyYWN0X2FyZ3MoKTtcbiAgICAgICAgICAgIC8vIEZpbmQgY29sbGFwc2libGUgYXNzaWdubWVudHNcbiAgICAgICAgICAgIHZhciBoaXRfc3RhY2sgPSBbXTtcbiAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhzdGF0ZW1lbnRzW3N0YXRfaW5kZXhdKTtcbiAgICAgICAgICAgIHdoaWxlIChjYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBoaXRfc3RhY2sgPSBjYW5kaWRhdGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBoaXRfaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBoaXRfc3RhY2tbaGl0X3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZV9kZWYgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzdG9wX2FmdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcF9pZl9oaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBsaHMgPSBnZXRfbGhzKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaHMgfHwgaXNfbGhzX3JlYWRfb25seShsaHMpIHx8IGxocy5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAvLyBMb2NhdGUgc3ltYm9scyB3aGljaCBtYXkgZXhlY3V0ZSBjb2RlIG91dHNpZGUgb2Ygc2Nhbm5pbmcgcmFuZ2VcbiAgICAgICAgICAgICAgICB2YXIgbHZhbHVlcyA9IGdldF9sdmFsdWVzKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGxoc19sb2NhbCA9IGlzX2xoc19sb2NhbChsaHMpO1xuICAgICAgICAgICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGx2YWx1ZXMuc2V0KGxocy5uYW1lLCB7IGRlZjogbGhzLmRlZmluaXRpb24oKSwgbW9kaWZpZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2lkZV9lZmZlY3RzID0gdmFsdWVfaGFzX3NpZGVfZWZmZWN0cyhjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlX2FsbCA9IHJlcGxhY2VfYWxsX3N5bWJvbHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF5X3Rocm93ID0gY2FuZGlkYXRlLm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuYXJnID0gY2FuZGlkYXRlLm5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRnVuYXJnO1xuICAgICAgICAgICAgICAgIHZhciBoaXQgPSBmdW5hcmc7XG4gICAgICAgICAgICAgICAgdmFyIGFib3J0ID0gZmFsc2UsIHJlcGxhY2VkID0gMCwgY2FuX3JlcGxhY2UgPSAhYXJncyB8fCAhaGl0O1xuICAgICAgICAgICAgICAgIGlmICghY2FuX3JlcGxhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBqID0gY29tcHJlc3Nvci5zZWxmKCkuYXJnbmFtZXMubGFzdEluZGV4T2YoY2FuZGlkYXRlLm5hbWUpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICFhYm9ydCAmJiBqIDwgYXJncy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKytcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2pdLnRyYW5zZm9ybShzY2FubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYW5fcmVwbGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGF0X2luZGV4OyAhYWJvcnQgJiYgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1tpXS50cmFuc2Zvcm0oc2Nhbm5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZV9kZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IGNhbmRpZGF0ZS5uYW1lLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFib3J0ICYmIGRlZi5yZWZlcmVuY2VzLmxlbmd0aCAtIGRlZi5yZXBsYWNlZCA+IHJlcGxhY2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0X2luZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdCA9IGZ1bmFyZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGF0X2luZGV4OyAhYWJvcnQgJiYgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzW2ldLnRyYW5zZm9ybShtdWx0aV9yZXBsYWNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV9kZWYuc2luZ2xlX3VzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlZCAmJiAhcmVtb3ZlX2NhbmRpZGF0ZShjYW5kaWRhdGUpKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnNwbGljZShzdGF0X2luZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZV9jdXN0b21fc2Nhbl9vcmRlcihub2RlKSB7XG4gICAgICAgICAgICAvLyBTa2lwIChub24tZXhlY3V0ZWQpIGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICAgICAgICAgIC8vIFNjYW4gY2FzZSBleHByZXNzaW9ucyBmaXJzdCBpbiBhIHN3aXRjaCBzdGF0ZW1lbnRcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N3aXRjaCkge1xuICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IG5vZGUuZXhwcmVzc2lvbi50cmFuc2Zvcm0oc2Nhbm5lcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGUuYm9keS5sZW5ndGg7ICFhYm9ydCAmJiBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJyYW5jaCA9IG5vZGUuYm9keVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyYW5jaCBpbnN0YW5jZW9mIEFTVF9DYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicmFuY2ggIT09IGhpdF9zdGFja1toaXRfaW5kZXhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRfaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaC5leHByZXNzaW9uID0gYnJhbmNoLmV4cHJlc3Npb24udHJhbnNmb3JtKHNjYW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXBsYWNlX2FsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhYm9ydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWRlZmluZWRfd2l0aGluX3Njb3BlKGRlZiwgc2NvcGUpIHtcbiAgICAgICAgICAgIGlmIChkZWYuZ2xvYmFsKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjdXJfc2NvcGUgPSBkZWYuc2NvcGU7XG4gICAgICAgICAgICB3aGlsZSAoY3VyX3Njb3BlICYmIGN1cl9zY29wZSAhPT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyX3Njb3BlLnZhcmlhYmxlcy5oYXMoZGVmLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJfc2NvcGUgPSBjdXJfc2NvcGUucGFyZW50X3Njb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFzX292ZXJsYXBwaW5nX3N5bWJvbChmbiwgYXJnLCBmbl9zdHJpY3QpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlLCBzY2FuX3RoaXMgPSAhKGZuIGluc3RhbmNlb2YgQVNUX0Fycm93KTtcbiAgICAgICAgICAgIGFyZy53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uIChub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgKGZuLnZhcmlhYmxlcy5oYXMobm9kZS5uYW1lKSB8fCByZWRlZmluZWRfd2l0aGluX3Njb3BlKG5vZGUuZGVmaW5pdGlvbigpLCBmbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gbm9kZS5kZWZpbml0aW9uKCkuc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzICE9PSBkZWZ1bl9zY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzID0gcy5wYXJlbnRfc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gZGVmdW5fc2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGZuX3N0cmljdCB8fCBzY2FuX3RoaXMpICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfVGhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXJyb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gc2Nhbl90aGlzO1xuICAgICAgICAgICAgICAgICAgICBzY2FuX3RoaXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICBzY2FuX3RoaXMgPSBwcmV2O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhcmdfaXNfaW5qZWN0YWJsZShhcmcpIHtcbiAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjb250YWluc19hd2FpdCA9IHdhbGsoYXJnLCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0F3YWl0KSByZXR1cm4gd2Fsa19hYm9ydDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zX2F3YWl0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleHRyYWN0X2FyZ3MoKSB7XG4gICAgICAgICAgICB2YXIgaWlmZSwgZm4gPSBjb21wcmVzc29yLnNlbGYoKTtcbiAgICAgICAgICAgIGlmIChpc19mdW5jX2V4cHIoZm4pXG4gICAgICAgICAgICAgICAgJiYgIWZuLm5hbWVcbiAgICAgICAgICAgICAgICAmJiAhZm4udXNlc19hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAmJiAhZm4ucGlubmVkKClcbiAgICAgICAgICAgICAgICAmJiAoaWlmZSA9IGNvbXByZXNzb3IucGFyZW50KCkpIGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgICAgICAgICAmJiBpaWZlLmV4cHJlc3Npb24gPT09IGZuXG4gICAgICAgICAgICAgICAgJiYgaWlmZS5hcmdzLmV2ZXJ5KGFyZ19pc19pbmplY3RhYmxlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuX3N0cmljdCA9IGNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIik7XG4gICAgICAgICAgICAgICAgaWYgKGZuX3N0cmljdCAmJiAhbWVtYmVyKGZuX3N0cmljdCwgZm4uYm9keSkpXG4gICAgICAgICAgICAgICAgICAgIGZuX3N0cmljdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBmbi5hcmduYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYXJncyA9IGlpZmUuYXJncy5zbGljZShsZW4pO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbGVuOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IGZuLmFyZ25hbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gaWlmZS5hcmdzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHR3byBsaW5lIGZpeCBpcyBhIGR1cGxpY2F0ZSBvZiB0aGUgZml4IGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZXJzZXIvdGVyc2VyL2NvbW1pdC8wMTFkM2ViMDhjZWZlNjkyMmM3ZDFiZGZhMTEzZmM0YWVhY2ExYjc1XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWlnaHQgbWVhbiB0aGF0IHRoZXNlIHR3byBwaWVjZXMgb2YgY29kZSAob25lIGhlcmUgaW4gY29sbGFwc2VfdmFycyBhbmQgYW5vdGhlciBpbiByZWR1Y2VfdmFyc1xuICAgICAgICAgICAgICAgICAgICAvLyBNaWdodCBiZSBkb2luZyB0aGUgZXhhY3Qgc2FtZSB0aGluZy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gc3ltLmRlZmluaXRpb24gJiYgc3ltLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNfcmVhc3NpZ25lZCA9IGRlZiAmJiBkZWYub3JpZy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfcmVhc3NpZ25lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQobWFrZV9ub2RlKEFTVF9WYXJEZWYsIHN5bSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3ltLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZ1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lcy5oYXMoc3ltLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLmFkZChzeW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW0gaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBpaWZlLmFyZ3Muc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMuZXZlcnkoKGFyZykgPT4gIWhhc19vdmVybGFwcGluZ19zeW1ib2woZm4sIGFyZywgZm5fc3RyaWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMudW5zaGlmdChbbWFrZV9ub2RlKEFTVF9WYXJEZWYsIHN5bSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzeW0uZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1ha2Vfbm9kZShBU1RfQXJyYXksIGlpZmUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzeW0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgQVNUX0xhbWJkYSAmJiBhcmcucGlubmVkKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBoYXNfb3ZlcmxhcHBpbmdfc3ltYm9sKGZuLCBhcmcsIGZuX3N0cmljdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnVuc2hpZnQoW21ha2Vfbm9kZShBU1RfVmFyRGVmLCBzeW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3ltLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXJnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByKSB7XG4gICAgICAgICAgICBoaXRfc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xuICAgICAgICAgICAgICAgIGlmICghZXhwci5sZWZ0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgJiYgIShleHByLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0NoYWluKSkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goaGl0X3N0YWNrLnNsaWNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5yaWdodCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIubGVmdCk7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIucmlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgIWhhc19hbm5vdGF0aW9uKGV4cHIsIF9OT0lOTElORSkpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBleHByLmFyZ3MuZm9yRWFjaChleHRyYWN0X2NhbmRpZGF0ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0Nhc2UpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLmNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuY29uc2VxdWVudCk7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGV4cHIuZGVmaW5pdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIGxpbWl0IG51bWJlciBvZiB0cmFpbGluZyB2YXJpYWJsZSBkZWZpbml0aW9ucyBmb3IgY29uc2lkZXJhdGlvblxuICAgICAgICAgICAgICAgIHZhciBpID0gbGVuIC0gMjAwO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5kZWZpbml0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0RXTG9vcCkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLmNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCEoZXhwci5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfRXhpdCkge1xuICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfRm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIuaW5pdClcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuaW5pdCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIuY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChleHByLnN0ZXApXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLnN0ZXApO1xuICAgICAgICAgICAgICAgIGlmICghKGV4cHIuYm9keSBpbnN0YW5jZW9mIEFTVF9CbG9jaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0ZvckluKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIub2JqZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoIShleHByLmJvZHkgaW5zdGFuY2VvZiBBU1RfQmxvY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLmJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLmNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCEoZXhwci5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIuYWx0ZXJuYXRpdmUgJiYgIShleHByLmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0Jsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5hbHRlcm5hdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgZXhwci5leHByZXNzaW9ucy5mb3JFYWNoKGV4dHJhY3RfY2FuZGlkYXRlcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuYm9keSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgZXhwci5ib2R5LmZvckVhY2goZXh0cmFjdF9jYW5kaWRhdGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9VbmFyeSkge1xuICAgICAgICAgICAgICAgIGlmIChleHByLm9wZXJhdG9yID09IFwiKytcIiB8fCBleHByLm9wZXJhdG9yID09IFwiLS1cIikge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goaGl0X3N0YWNrLnNsaWNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9WYXJEZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwci52YWx1ZSAmJiAhKGV4cHIudmFsdWUgaW5zdGFuY2VvZiBBU1RfQ2hhaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChoaXRfc3RhY2suc2xpY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoaXRfc3RhY2sucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kX3N0b3Aobm9kZSwgbGV2ZWwsIHdyaXRlX29ubHkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBzY2FubmVyLnBhcmVudChsZXZlbCk7XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xuICAgICAgICAgICAgICAgIGlmICh3cml0ZV9vbmx5XG4gICAgICAgICAgICAgICAgICAgICYmICFwYXJlbnQubG9naWNhbFxuICAgICAgICAgICAgICAgICAgICAmJiAhKHBhcmVudC5sZWZ0IGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGx2YWx1ZXMuaGFzKHBhcmVudC5sZWZ0Lm5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZF9zdG9wKHBhcmVudCwgbGV2ZWwgKyAxLCB3cml0ZV9vbmx5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX0JpbmFyeSkge1xuICAgICAgICAgICAgICAgIGlmICh3cml0ZV9vbmx5ICYmICghbGF6eV9vcC5oYXMocGFyZW50Lm9wZXJhdG9yKSB8fCBwYXJlbnQubGVmdCA9PT0gbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRfc3RvcChwYXJlbnQsIGxldmVsICsgMSwgd3JpdGVfb25seSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYXNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgIGlmICh3cml0ZV9vbmx5ICYmIHBhcmVudC5jb25kaXRpb24gPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRfc3RvcChwYXJlbnQsIGxldmVsICsgMSwgd3JpdGVfb25seSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kX3N0b3AocGFyZW50LCBsZXZlbCArIDEsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9FeGl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlX29ubHkgPyBmaW5kX3N0b3AocGFyZW50LCBsZXZlbCArIDEsIHdyaXRlX29ubHkpIDogbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgICAgICBpZiAod3JpdGVfb25seSAmJiBwYXJlbnQuY29uZGl0aW9uID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5kX3N0b3AocGFyZW50LCBsZXZlbCArIDEsIHdyaXRlX29ubHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kX3N0b3AocGFyZW50LCBsZXZlbCArIDEsIHBhcmVudC50YWlsX25vZGUoKSAhPT0gbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kX3N0b3AocGFyZW50LCBsZXZlbCArIDEsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX1ZhckRlZilcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWFuZ2xlYWJsZV92YXIodmFyX2RlZikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFyX2RlZi52YWx1ZTtcbiAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHZhbHVlLm5hbWUgPT0gXCJhcmd1bWVudHNcIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGVmID0gdmFsdWUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgaWYgKGRlZi51bmRlY2xhcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZV9kZWYgPSBkZWY7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRfbGhzKGV4cHIpIHtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0Fzc2lnbiAmJiBleHByLmxvZ2ljYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfVmFyRGVmICYmIGV4cHIubmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBleHByLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICghbWVtYmVyKGV4cHIubmFtZSwgZGVmLm9yaWcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIHJlZmVyZW5jZWQgPSBkZWYucmVmZXJlbmNlcy5sZW5ndGggLSBkZWYucmVwbGFjZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZlcmVuY2VkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGRlY2xhcmVkID0gZGVmLm9yaWcubGVuZ3RoIC0gZGVmLmVsaW1pbmF0ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGRlY2xhcmVkID4gMSAmJiAhKGV4cHIubmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xGdW5hcmcpXG4gICAgICAgICAgICAgICAgICAgIHx8IChyZWZlcmVuY2VkID4gMSA/IG1hbmdsZWFibGVfdmFyKGV4cHIpIDogIWNvbXByZXNzb3IuZXhwb3NlZChkZWYpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TeW1ib2xSZWYsIGV4cHIubmFtZSwgZXhwci5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxocyA9IGV4cHIgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAgICAgICAgID8gZXhwci5sZWZ0XG4gICAgICAgICAgICAgICAgICAgIDogZXhwci5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNfcmVmX29mKGxocywgQVNUX1N5bWJvbENvbnN0KVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNfcmVmX29mKGxocywgQVNUX1N5bWJvbExldClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzX3JlZl9vZihsaHMsIEFTVF9TeW1ib2xVc2luZylcbiAgICAgICAgICAgICAgICAgICAgJiYgbGhzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0X3J2YWx1ZShleHByKSB7XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwci5yaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRfbHZhbHVlcyhleHByKSB7XG4gICAgICAgICAgICB2YXIgbHZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX1VuYXJ5KVxuICAgICAgICAgICAgICAgIHJldHVybiBsdmFsdWVzO1xuICAgICAgICAgICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltID0gbm9kZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3ltIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIHN5bSA9IHN5bS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIGlmIChzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBsdmFsdWVzLmdldChzeW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldiB8fCAhcHJldi5tb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbHZhbHVlcy5zZXQoc3ltLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWY6IHN5bS5kZWZpbml0aW9uKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQ6IGlzX21vZGlmaWVkKGNvbXByZXNzb3IsIHR3LCBub2RlLCBub2RlLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdldF9ydmFsdWUoZXhwcikud2Fsayh0dyk7XG4gICAgICAgICAgICByZXR1cm4gbHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZV9jYW5kaWRhdGUoZXhwcikge1xuICAgICAgICAgICAgaWYgKGV4cHIubmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xGdW5hcmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWlmZSA9IGNvbXByZXNzb3IucGFyZW50KCksIGFyZ25hbWVzID0gY29tcHJlc3Nvci5zZWxmKCkuYXJnbmFtZXM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYXJnbmFtZXMuaW5kZXhPZihleHByLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWlmZS5hcmdzLmxlbmd0aCA9IE1hdGgubWluKGlpZmUuYXJncy5sZW5ndGgsIGFyZ25hbWVzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gaWlmZS5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnc1tpbmRleF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2luZGV4XSA9IG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBhcmdzW2luZGV4XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzW3N0YXRfaW5kZXhdLnRyYW5zZm9ybShuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uIChub2RlLCBkZXNjZW5kLCBpbl9saXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gZXhwciB8fCBub2RlLmJvZHkgPT09IGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9WYXJEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlLm5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ29uc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBub2RlLnZhbHVlKSAvLyBgY29uc3RgIGFsd2F5cyBuZWVkcyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5fbGlzdCA/IE1BUC5za2lwIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlKVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGUuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbm9kZS5leHByZXNzaW9uc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNfbGhzX2xvY2FsKGxocykge1xuICAgICAgICAgICAgd2hpbGUgKGxocyBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzKVxuICAgICAgICAgICAgICAgIGxocyA9IGxocy5leHByZXNzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIGxocyBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAmJiBsaHMuZGVmaW5pdGlvbigpLnNjb3BlLmdldF9kZWZ1bl9zY29wZSgpID09PSBkZWZ1bl9zY29wZVxuICAgICAgICAgICAgICAgICYmICEoaW5fbG9vcFxuICAgICAgICAgICAgICAgICAgICAmJiAobHZhbHVlcy5oYXMobGhzLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBjYW5kaWRhdGUgaW5zdGFuY2VvZiBBU1RfVW5hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChjYW5kaWRhdGUgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIWNhbmRpZGF0ZS5sb2dpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2FuZGlkYXRlLm9wZXJhdG9yICE9IFwiPVwiKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdmFsdWVfaGFzX3NpZGVfZWZmZWN0cyhleHByKSB7XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9VbmFyeSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5hcnlfc2lkZV9lZmZlY3RzLmhhcyhleHByLm9wZXJhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRfcnZhbHVlKGV4cHIpLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlX2FsbF9zeW1ib2xzKCkge1xuICAgICAgICAgICAgaWYgKHNpZGVfZWZmZWN0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodmFsdWVfZGVmKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmID0gbGhzLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLnJlZmVyZW5jZXMubGVuZ3RoIC0gZGVmLnJlcGxhY2VkID09IChjYW5kaWRhdGUgaW5zdGFuY2VvZiBBU1RfVmFyRGVmID8gMSA6IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1heV9tb2RpZnkoc3ltKSB7XG4gICAgICAgICAgICBpZiAoIXN5bS5kZWZpbml0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBBU1RfRGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgdmFyIGRlZiA9IHN5bS5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBpZiAoZGVmLm9yaWcubGVuZ3RoID09IDEgJiYgZGVmLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVmdW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRlZi5zY29wZS5nZXRfZGVmdW5fc2NvcGUoKSAhPT0gZGVmdW5fc2NvcGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnJlZmVyZW5jZXMuc29tZSgocmVmKSA9PlxuICAgICAgICAgICAgICAgIHJlZi5zY29wZS5nZXRfZGVmdW5fc2NvcGUoKSAhPT0gZGVmdW5fc2NvcGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzaWRlX2VmZmVjdHNfZXh0ZXJuYWwobm9kZSwgbGhzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZGVfZWZmZWN0c19leHRlcm5hbChub2RlLmxlZnQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVW5hcnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZGVfZWZmZWN0c19leHRlcm5hbChub2RlLmV4cHJlc3Npb24sIHRydWUpO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyRGVmKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlICYmIHNpZGVfZWZmZWN0c19leHRlcm5hbChub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChsaHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Eb3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlX2VmZmVjdHNfZXh0ZXJuYWwobm9kZS5leHByZXNzaW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TdWIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlX2VmZmVjdHNfZXh0ZXJuYWwobm9kZS5leHByZXNzaW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmRlZmluaXRpb24oKS5zY29wZS5nZXRfZGVmdW5fc2NvcGUoKSAhPT0gZGVmdW5fc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBhbnkgb2YgdGhlIHB1bGxlZC1pbiBsdmFsdWVzIHNoYWRvdyBhIHZhcmlhYmxlIGluIG5ld1Njb3BlIG9yIHBhcmVudHM/XG4gICAgICAgICAqIHNpbWlsYXIgdG8gc2NvcGVfZW5jbG9zZXNfdmFyaWFibGVzX2luX3RoaXNfc2NvcGUgKi9cbiAgICAgICAgZnVuY3Rpb24gc2hhZG93cyhteV9zY29wZSwgbHZhbHVlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGRlZiB9IG9mIGx2YWx1ZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb29rZWRfdXAgPSBteV9zY29wZS5maW5kX3ZhcmlhYmxlKGRlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobG9va2VkX3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29rZWRfdXAgPT09IGRlZikgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVsaW1pbmF0ZV9zcHVyaW91c19ibG9ja3Moc3RhdGVtZW50cykge1xuICAgICAgICB2YXIgc2Vlbl9kaXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCAmJiBzdGF0LmJvZHkuZXZlcnkoY2FuX2JlX2V2aWN0ZWRfZnJvbV9ibG9jaykpIHtcbiAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbGltaW5hdGVfc3B1cmlvdXNfYmxvY2tzKHN0YXQuYm9keSk7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cy5zcGxpY2UoaSwgMSwgLi4uc3RhdC5ib2R5KTtcbiAgICAgICAgICAgICAgICBpICs9IHN0YXQuYm9keS5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbl9kaXJzLmluZGV4T2Yoc3RhdC52YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgc2Vlbl9kaXJzLnB1c2goc3RhdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9pZl9yZXR1cm4oc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICB2YXIgc2VsZiA9IGNvbXByZXNzb3Iuc2VsZigpO1xuICAgICAgICB2YXIgbXVsdGlwbGVfaWZfcmV0dXJucyA9IGhhc19tdWx0aXBsZV9pZl9yZXR1cm5zKHN0YXRlbWVudHMpO1xuICAgICAgICB2YXIgaW5fbGFtYmRhID0gc2VsZiBpbnN0YW5jZW9mIEFTVF9MYW1iZGE7XG4gICAgICAgIC8vIFByZXZlbnQgZXh0cmVtZWx5IGRlZXAgbmVzdGluZ1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGVyc2VyL3RlcnNlci9pc3N1ZXMvMTQzMlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2lzc3Vlcy8xNzU0OFxuICAgICAgICBjb25zdCBpdGVyYXRpb25fc3RhcnQgPSBNYXRoLm1pbihzdGF0ZW1lbnRzLmxlbmd0aCwgNTAwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGl0ZXJhdGlvbl9zdGFydDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgaiA9IG5leHRfaW5kZXgoaSk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHN0YXRlbWVudHNbal07XG5cbiAgICAgICAgICAgIGlmIChpbl9sYW1iZGEgJiYgIW5leHQgJiYgc3RhdCBpbnN0YW5jZW9mIEFTVF9SZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQudmFsdWUgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXggJiYgc3RhdC52YWx1ZS5vcGVyYXRvciA9PSBcInZvaWRcIikge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1tpXSA9IG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBzdGF0LnZhbHVlLmV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWIsIG5ld19lbHNlO1xuXG4gICAgICAgICAgICAgICAgYWIgPSBhYm9ydHMoc3RhdC5ib2R5KTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGNhbl9tZXJnZV9mbG93KGFiKVxuICAgICAgICAgICAgICAgICAgICAmJiAobmV3X2Vsc2UgPSBhc19zdGF0ZW1lbnRfYXJyYXlfd2l0aF9yZXR1cm4oc3RhdC5ib2R5LCBhYikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGFiLmxhYmVsLnRoZWRlZi5yZWZlcmVuY2VzLCBhYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQgPSBzdGF0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuY29uZGl0aW9uID0gc3RhdC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5hbHRlcm5hdGl2ZSkuY29uY2F0KGV4dHJhY3RfZGVmdW5zKCkpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogbmV3X2Vsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHNbaV0gPSBzdGF0LnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWIgPSBhYm9ydHMoc3RhdC5hbHRlcm5hdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBjYW5fbWVyZ2VfZmxvdyhhYilcbiAgICAgICAgICAgICAgICAgICAgJiYgKG5ld19lbHNlID0gYXNfc3RhdGVtZW50X2FycmF5X3dpdGhfcmV0dXJuKHN0YXQuYWx0ZXJuYXRpdmUsIGFiKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFiLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoYWIubGFiZWwudGhlZGVmLnJlZmVyZW5jZXMsIGFiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5ib2R5ID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdC5ib2R5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5ib2R5KS5jb25jYXQoZXh0cmFjdF9kZWZ1bnMoKSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LmFsdGVybmF0aXZlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBuZXdfZWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1tpXSA9IHN0YXQudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0lmICYmIHN0YXQuYm9keSBpbnN0YW5jZW9mIEFTVF9SZXR1cm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdGF0LmJvZHkudmFsdWU7XG4gICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAvLyBwcmV0dHkgc2lsbHkgY2FzZSwgYnV0OlxuICAgICAgICAgICAgICAgIC8vIGlmIChmb28oKSkgcmV0dXJuOyByZXR1cm47ID09PiBmb28oKTsgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgJiYgKGluX2xhbWJkYSAmJiAhbmV4dCB8fCBuZXh0IGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiAhbmV4dC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHNbaV0gPSBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc3RhdC5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHN0YXQuY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAvLyBpZiAoZm9vKCkpIHJldHVybiB4OyByZXR1cm4geTsgPT0+IHJldHVybiBmb28oKSA/IHggOiB5O1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhc3RhdC5hbHRlcm5hdGl2ZSAmJiBuZXh0IGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiBuZXh0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1tpXSA9IHN0YXQudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgICAgICAgLy8gaWYgKGZvbygpKSByZXR1cm4geDsgWyByZXR1cm4gOyBdID09PiByZXR1cm4gZm9vKCkgPyB4IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhc3RhdC5hbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgICAgICAmJiAoIW5leHQgJiYgaW5fbGFtYmRhICYmIG11bHRpcGxlX2lmX3JldHVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IG5leHQgaW5zdGFuY2VvZiBBU1RfUmV0dXJuKSkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5hbHRlcm5hdGl2ZSA9IG5leHQgfHwgbWFrZV9ub2RlKEFTVF9SZXR1cm4sIHN0YXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzW2ldID0gc3RhdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLy0tLVxuICAgICAgICAgICAgICAgIC8vIGlmIChhKSByZXR1cm4gYjsgaWYgKGMpIHJldHVybiBkOyBlOyA9PT4gcmV0dXJuIGEgPyBiIDogYyA/IGQgOiB2b2lkIGU7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBpZiBzZXF1ZW5jZXMgaXMgbm90IGVuYWJsZWQsIHRoaXMgY2FuIGxlYWQgdG8gYW4gZW5kbGVzcyBsb29wIChpc3N1ZSAjODY2KS5cbiAgICAgICAgICAgICAgICAvLyBob3dldmVyLCB3aXRoIHNlcXVlbmNlcyBvbiB0aGlzIGhlbHBzIHByb2R1Y2luZyBzbGlnaHRseSBiZXR0ZXIgb3V0cHV0IGZvclxuICAgICAgICAgICAgICAgIC8vIHRoZSBleGFtcGxlIGNvZGUuXG4gICAgICAgICAgICAgICAgdmFyIHByZXYgPSBzdGF0ZW1lbnRzW3ByZXZfaW5kZXgoaSldO1xuICAgICAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNlcXVlbmNlc1wiKSAmJiBpbl9sYW1iZGEgJiYgIXN0YXQuYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgJiYgcHJldiBpbnN0YW5jZW9mIEFTVF9JZiAmJiBwcmV2LmJvZHkgaW5zdGFuY2VvZiBBU1RfUmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICYmIG5leHRfaW5kZXgoaikgPT0gc3RhdGVtZW50cy5sZW5ndGggJiYgbmV4dCBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQgPSBzdGF0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBuZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlX25vZGUoQVNUX1JldHVybiwgbmV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzW2ldID0gc3RhdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYXNfbXVsdGlwbGVfaWZfcmV0dXJucyhzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhdGVtZW50cy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9JZiAmJiBzdGF0LmJvZHkgaW5zdGFuY2VvZiBBU1RfUmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK24gPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNfcmV0dXJuX3ZvaWQodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAhdmFsdWUgfHwgdmFsdWUgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXggJiYgdmFsdWUub3BlcmF0b3IgPT0gXCJ2b2lkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjYW5fbWVyZ2VfZmxvdyhhYikge1xuICAgICAgICAgICAgaWYgKCFhYilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDEsIGxlbiA9IHN0YXRlbWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudHNbal07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnNMaWtlICYmICEoc3RhdCBpbnN0YW5jZW9mIEFTVF9WYXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGN0ID0gYWIgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2wgPyBjb21wcmVzc29yLmxvb3Bjb250cm9sX3RhcmdldChhYikgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGFiIGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiBpbl9sYW1iZGEgJiYgaXNfcmV0dXJuX3ZvaWQoYWIudmFsdWUpXG4gICAgICAgICAgICAgICAgfHwgYWIgaW5zdGFuY2VvZiBBU1RfQ29udGludWUgJiYgc2VsZiA9PT0gbG9vcF9ib2R5KGxjdClcbiAgICAgICAgICAgICAgICB8fCBhYiBpbnN0YW5jZW9mIEFTVF9CcmVhayAmJiBsY3QgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQgJiYgc2VsZiA9PT0gbGN0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXh0cmFjdF9kZWZ1bnMoKSB7XG4gICAgICAgICAgICB2YXIgdGFpbCA9IHN0YXRlbWVudHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgc3RhdGVtZW50cy5sZW5ndGggPSBpICsgMTtcbiAgICAgICAgICAgIHJldHVybiB0YWlsLmZpbHRlcihmdW5jdGlvbiAoc3RhdCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0RlZnVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXNfc3RhdGVtZW50X2FycmF5X3dpdGhfcmV0dXJuKG5vZGUsIGFiKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGFzX3N0YXRlbWVudF9hcnJheShub2RlKTtcbiAgICAgICAgICAgIGlmIChhYiAhPT0gYm9keVtib2R5Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkgPSBib2R5LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGlmICghYm9keS5ldmVyeShzdGF0ID0+IGNhbl9iZV9ldmljdGVkX2Zyb21fYmxvY2soc3RhdCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGJvZHkucHVzaChtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgYWIudmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogYWIudmFsdWUuZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbmV4dF9pbmRleChpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDEsIGxlbiA9IHN0YXRlbWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudHNbal07XG4gICAgICAgICAgICAgICAgaWYgKCEoc3RhdCBpbnN0YW5jZW9mIEFTVF9WYXIgJiYgZGVjbGFyYXRpb25zX29ubHkoc3RhdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJldl9pbmRleChpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaTsgLS1qID49IDA7KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnRzW2pdO1xuICAgICAgICAgICAgICAgIGlmICghKHN0YXQgaW5zdGFuY2VvZiBBU1RfVmFyICYmIGRlY2xhcmF0aW9uc19vbmx5KHN0YXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gajtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVsaW1pbmF0ZV9kZWFkX2NvZGUoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICB2YXIgaGFzX3F1aXQ7XG4gICAgICAgIHZhciBzZWxmID0gY29tcHJlc3Nvci5zZWxmKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gMCwgbGVuID0gc3RhdGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGN0ID0gY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoc3RhdCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfQnJlYWtcbiAgICAgICAgICAgICAgICAgICAgJiYgIShsY3QgaW5zdGFuY2VvZiBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAmJiBsb29wX2JvZHkobGN0KSA9PT0gc2VsZlxuICAgICAgICAgICAgICAgICAgICB8fCBzdGF0IGluc3RhbmNlb2YgQVNUX0NvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICYmIGxvb3BfYm9keShsY3QpID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoc3RhdC5sYWJlbC50aGVkZWYucmVmZXJlbmNlcywgc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzW24rK10gPSBzdGF0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50c1tuKytdID0gc3RhdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydHMoc3RhdCkpIHtcbiAgICAgICAgICAgICAgICBoYXNfcXVpdCA9IHN0YXRlbWVudHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlbWVudHMubGVuZ3RoID0gbjtcbiAgICAgICAgQ0hBTkdFRCA9IG4gIT0gbGVuO1xuICAgICAgICBpZiAoaGFzX3F1aXQpXG4gICAgICAgICAgICBoYXNfcXVpdC5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc3RhdCwgc3RhdGVtZW50cyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNsYXJhdGlvbnNfb25seShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmRlZmluaXRpb25zLmV2ZXJ5KCh2YXJfZGVmKSA9PiAhdmFyX2RlZi52YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VxdWVuY2VzaXplKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHNlcSA9IFtdLCBuID0gMDtcbiAgICAgICAgZnVuY3Rpb24gcHVzaF9zZXEoKSB7XG4gICAgICAgICAgICBpZiAoIXNlcS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBtYWtlX3NlcXVlbmNlKHNlcVswXSwgc2VxKTtcbiAgICAgICAgICAgIHN0YXRlbWVudHNbbisrXSA9IG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBib2R5LCB7IGJvZHk6IGJvZHkgfSk7XG4gICAgICAgICAgICBzZXEgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RhdGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcS5sZW5ndGggPj0gY29tcHJlc3Nvci5zZXF1ZW5jZXNfbGltaXQpXG4gICAgICAgICAgICAgICAgICAgIHB1c2hfc2VxKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBzdGF0LmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gYm9keS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkpXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlX3NlcXVlbmNlKHNlcSwgYm9keSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMgJiYgZGVjbGFyYXRpb25zX29ubHkoc3RhdClcbiAgICAgICAgICAgICAgICB8fCBzdGF0IGluc3RhbmNlb2YgQVNUX0RlZnVuKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50c1tuKytdID0gc3RhdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVzaF9zZXEoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzW24rK10gPSBzdGF0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1c2hfc2VxKCk7XG4gICAgICAgIHN0YXRlbWVudHMubGVuZ3RoID0gbjtcbiAgICAgICAgaWYgKG4gIT0gbGVuKVxuICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9fc2ltcGxlX3N0YXRlbWVudChibG9jaywgZGVjbHMpIHtcbiAgICAgICAgaWYgKCEoYmxvY2sgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpKVxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICB2YXIgc3RhdCA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBibG9jay5ib2R5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGJsb2NrLmJvZHlbaV07XG4gICAgICAgICAgICBpZiAobGluZSBpbnN0YW5jZW9mIEFTVF9WYXIgJiYgZGVjbGFyYXRpb25zX29ubHkobGluZSkpIHtcbiAgICAgICAgICAgICAgICBkZWNscy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IHx8IGxpbmUgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnNMaWtlICYmICEobGluZSBpbnN0YW5jZW9mIEFTVF9WYXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ID0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXF1ZW5jZXNpemVfMihzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvbnNfc2VxKHJpZ2h0KSB7XG4gICAgICAgICAgICBuLS07XG4gICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gcHJldi5ib2R5O1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2UobGVmdCwgW2xlZnQsIHJpZ2h0XSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gMCwgcHJldjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0V4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC52YWx1ZSA9IGNvbnNfc2VxKHN0YXQudmFsdWUgfHwgbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHN0YXQpLnRyYW5zZm9ybShjb21wcmVzc29yKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0Zvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGF0LmluaXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnNMaWtlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWJvcnQgPSB3YWxrKHByZXYuYm9keSwgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBub2RlLm9wZXJhdG9yID09PSBcImluXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGtfYWJvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXQuaW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0ID0gY29uc19zZXEoc3RhdC5pbml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0ID0gcHJldi5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Gb3JJbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGF0LmluaXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnNMaWtlKSB8fCBzdGF0LmluaXQgaW5zdGFuY2VvZiBBU1RfVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0Lm9iamVjdCA9IGNvbnNfc2VxKHN0YXQub2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmNvbmRpdGlvbiA9IGNvbnNfc2VxKHN0YXQuY29uZGl0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuZXhwcmVzc2lvbiA9IGNvbnNfc2VxKHN0YXQuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1dpdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5leHByZXNzaW9uID0gY29uc19zZXEoc3RhdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJjb25kaXRpb25hbHNcIikgJiYgc3RhdCBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgICAgIHZhciBkZWNscyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gdG9fc2ltcGxlX3N0YXRlbWVudChzdGF0LmJvZHksIGRlY2xzKTtcbiAgICAgICAgICAgICAgICB2YXIgYWx0ID0gdG9fc2ltcGxlX3N0YXRlbWVudChzdGF0LmFsdGVybmF0aXZlLCBkZWNscyk7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkgIT09IGZhbHNlICYmIGFsdCAhPT0gZmFsc2UgJiYgZGVjbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gZGVjbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBkZWNscy5wdXNoKG1ha2Vfbm9kZShBU1RfSWYsIHN0YXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogc3RhdC5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5IHx8IG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHN0YXQuYm9keSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZTogYWx0XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjbHMudW5zaGlmdChuLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgW10uc3BsaWNlLmFwcGx5KHN0YXRlbWVudHMsIGRlY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSBsZW47XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gbGVuICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnRzW24rK10gPSBzdGF0O1xuICAgICAgICAgICAgcHJldiA9IHN0YXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50ID8gc3RhdCA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVtZW50cy5sZW5ndGggPSBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGpvaW5fb2JqZWN0X2Fzc2lnbm1lbnRzKGRlZm4sIGJvZHkpIHtcbiAgICAgICAgaWYgKCEoZGVmbiBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBkZWYgPSBkZWZuLmRlZmluaXRpb25zW2RlZm4uZGVmaW5pdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghKGRlZi52YWx1ZSBpbnN0YW5jZW9mIEFTVF9PYmplY3QpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZXhwcnM7XG4gICAgICAgIGlmIChib2R5IGluc3RhbmNlb2YgQVNUX0Fzc2lnbiAmJiAhYm9keS5sb2dpY2FsKSB7XG4gICAgICAgICAgICBleHBycyA9IFtib2R5XTtcbiAgICAgICAgfSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlKSB7XG4gICAgICAgICAgICBleHBycyA9IGJvZHkuZXhwcmVzc2lvbnMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4cHJzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdHJpbW1lZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGV4cHJzWzBdO1xuICAgICAgICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT0gXCI9XCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoIShub2RlLmxlZnQgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcykpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgc3ltID0gbm9kZS5sZWZ0LmV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoIShzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChkZWYubmFtZS5uYW1lICE9IHN5bS5uYW1lKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKCFub2RlLnJpZ2h0LmlzX2NvbnN0YW50X2V4cHJlc3Npb24obmVhcmVzdF9zY29wZSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IG5vZGUubGVmdC5wcm9wZXJ0eTtcbiAgICAgICAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgQVNUX05vZGUpIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gcHJvcC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgQVNUX05vZGUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwcm9wID0gXCJcIiArIHByb3A7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGNvbXByZXNzb3Iub3B0aW9uKFwiZWNtYVwiKSA8IDIwMTVcbiAgICAgICAgICAgICAgICAmJiBjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpID8gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUua2V5ICE9IHByb3AgJiYgKG5vZGUua2V5ICYmIG5vZGUua2V5Lm5hbWUgIT0gcHJvcCk7XG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmtleSAmJiBub2RlLmtleS5uYW1lICE9IHByb3A7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghZGVmLnZhbHVlLnByb3BlcnRpZXMuZXZlcnkoZGlmZikpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgcCA9IGRlZi52YWx1ZS5wcm9wZXJ0aWVzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5rZXkgPT09IHByb3A7IH0pWzBdO1xuICAgICAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICAgICAgZGVmLnZhbHVlLnByb3BlcnRpZXMucHVzaChtYWtlX25vZGUoQVNUX09iamVjdEtleVZhbCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLnJpZ2h0XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwLnZhbHVlID0gbmV3IEFTVF9TZXF1ZW5jZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczogW3AudmFsdWUuY2xvbmUoKSwgbm9kZS5yaWdodC5jbG9uZSgpXSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwLmVuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwcnMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRyaW1tZWQgPSB0cnVlO1xuICAgICAgICB9IHdoaWxlIChleHBycy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdHJpbW1lZCAmJiBleHBycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqb2luX2NvbnNlY3V0aXZlX3ZhcnMoc3RhdGVtZW50cykge1xuICAgICAgICB2YXIgZGVmcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAtMSwgbGVuID0gc3RhdGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHByZXYgPSBzdGF0ZW1lbnRzW2pdO1xuICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2LlRZUEUgPT0gc3RhdC5UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYuZGVmaW5pdGlvbnMgPSBwcmV2LmRlZmluaXRpb25zLmNvbmNhdChzdGF0LmRlZmluaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZzICYmIGRlZnMuVFlQRSA9PSBzdGF0LlRZUEUgJiYgZGVjbGFyYXRpb25zX29ubHkoc3RhdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5kZWZpbml0aW9ucyA9IGRlZnMuZGVmaW5pdGlvbnMuY29uY2F0KHN0YXQuZGVmaW5pdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzWysral0gPSBzdGF0O1xuICAgICAgICAgICAgICAgICAgICBkZWZzID0gc3RhdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0YXQgaW5zdGFuY2VvZiBBU1RfVXNpbmdcbiAgICAgICAgICAgICAgICAmJiBwcmV2IGluc3RhbmNlb2YgQVNUX1VzaW5nXG4gICAgICAgICAgICAgICAgJiYgcHJldi5hd2FpdCA9PT0gc3RhdC5hd2FpdFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJldi5kZWZpbml0aW9ucyA9IHByZXYuZGVmaW5pdGlvbnMuY29uY2F0KHN0YXQuZGVmaW5pdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0V4aXQpIHtcbiAgICAgICAgICAgICAgICBzdGF0LnZhbHVlID0gZXh0cmFjdF9vYmplY3RfYXNzaWdubWVudHMoc3RhdC52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHJzID0gam9pbl9vYmplY3RfYXNzaWdubWVudHMocHJldiwgc3RhdC5pbml0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuaW5pdCA9IGV4cHJzLmxlbmd0aCA/IG1ha2Vfc2VxdWVuY2Uoc3RhdC5pbml0LCBleHBycykgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzWysral0gPSBzdGF0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHByZXYgaW5zdGFuY2VvZiBBU1RfVmFyXG4gICAgICAgICAgICAgICAgICAgICYmICghc3RhdC5pbml0IHx8IHN0YXQuaW5pdC5UWVBFID09IHByZXYuVFlQRSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXQuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5kZWZpbml0aW9ucyA9IHByZXYuZGVmaW5pdGlvbnMuY29uY2F0KHN0YXQuaW5pdC5kZWZpbml0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0ID0gcHJldjtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1tqXSA9IHN0YXQ7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGRlZnMgaW5zdGFuY2VvZiBBU1RfVmFyXG4gICAgICAgICAgICAgICAgICAgICYmIHN0YXQuaW5pdCBpbnN0YW5jZW9mIEFTVF9WYXJcbiAgICAgICAgICAgICAgICAgICAgJiYgZGVjbGFyYXRpb25zX29ubHkoc3RhdC5pbml0KVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBkZWZzLmRlZmluaXRpb25zID0gZGVmcy5kZWZpbml0aW9ucy5jb25jYXQoc3RhdC5pbml0LmRlZmluaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1srK2pdID0gc3RhdDtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1srK2pdID0gc3RhdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRm9ySW4pIHtcbiAgICAgICAgICAgICAgICBzdGF0Lm9iamVjdCA9IGV4dHJhY3Rfb2JqZWN0X2Fzc2lnbm1lbnRzKHN0YXQub2JqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgICAgIHN0YXQuY29uZGl0aW9uID0gZXh0cmFjdF9vYmplY3RfYXNzaWdubWVudHMoc3RhdC5jb25kaXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBleHBycyA9IGpvaW5fb2JqZWN0X2Fzc2lnbm1lbnRzKHByZXYsIHN0YXQuYm9keSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cHJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX3NlcXVlbmNlKHN0YXQuYm9keSwgZXhwcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzWysral0gPSBzdGF0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1N3aXRjaCkge1xuICAgICAgICAgICAgICAgIHN0YXQuZXhwcmVzc2lvbiA9IGV4dHJhY3Rfb2JqZWN0X2Fzc2lnbm1lbnRzKHN0YXQuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfV2l0aCkge1xuICAgICAgICAgICAgICAgIHN0YXQuZXhwcmVzc2lvbiA9IGV4dHJhY3Rfb2JqZWN0X2Fzc2lnbm1lbnRzKHN0YXQuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHNbKytqXSA9IHN0YXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVtZW50cy5sZW5ndGggPSBqICsgMTtcblxuICAgICAgICBmdW5jdGlvbiBleHRyYWN0X29iamVjdF9hc3NpZ25tZW50cyh2YWx1ZSkge1xuICAgICAgICAgICAgc3RhdGVtZW50c1srK2pdID0gc3RhdDtcbiAgICAgICAgICAgIHZhciBleHBycyA9IGpvaW5fb2JqZWN0X2Fzc2lnbm1lbnRzKHByZXYsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChleHBycykge1xuICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChleHBycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2UodmFsdWUsIGV4cHJzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50YWlsX25vZGUoKS5sZWZ0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmluZyBsb2dpYy5cbiAqXG4gKiBAbW9kdWxlXG4gKlxuICogVGhlIHN0YXJzIG9mIHRoZSBzaG93IGFyZSBgaW5saW5lX2ludG9fc3ltYm9scmVmYCBhbmQgYGlubGluZV9pbnRvX2NhbGxgLlxuICovXG5cbmZ1bmN0aW9uIHdpdGhpbl9hcnJheV9vcl9vYmplY3RfbGl0ZXJhbChjb21wcmVzc29yKSB7XG4gICAgdmFyIG5vZGUsIGxldmVsID0gMDtcbiAgICB3aGlsZSAobm9kZSA9IGNvbXByZXNzb3IucGFyZW50KGxldmVsKyspKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9BcnJheVxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RLZXlWYWxcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNjb3BlX2VuY2xvc2VzX3ZhcmlhYmxlc19pbl90aGlzX3Njb3BlKHNjb3BlLCBwdWxsZWRfc2NvcGUpIHtcbiAgICBmb3IgKGNvbnN0IGVuY2xvc2VkIG9mIHB1bGxlZF9zY29wZS5lbmNsb3NlZCkge1xuICAgICAgICBpZiAocHVsbGVkX3Njb3BlLnZhcmlhYmxlcy5oYXMoZW5jbG9zZWQubmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvb2tlZF91cCA9IHNjb3BlLmZpbmRfdmFyaWFibGUoZW5jbG9zZWQubmFtZSk7XG4gICAgICAgIGlmIChsb29rZWRfdXApIHtcbiAgICAgICAgICAgIGlmIChsb29rZWRfdXAgPT09IGVuY2xvc2VkKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBbiBleHRyYSBjaGVjayBmdW5jdGlvbiBmb3IgYHRvcF9yZXRhaW5gIG9wdGlvbiwgY29tcGFyZSB0aGUgbGVuZ3RoIG9mIGNvbnN0IGlkZW50aWZpZXJcbiAqIGFuZCBpbml0IHZhbHVlIGxlbmd0aCBhbmQgcmV0dXJuIHRydWUgaWYgaW5pdCB2YWx1ZSBpcyBsb25nZXIgdGhhbiBpZGVudGlmaWVyLiBmb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogLy8gdG9wX3JldGFpbjogW1wiZXhhbXBsZVwiXVxuICogY29uc3QgZXhhbXBsZSA9IDEwMFxuICogYGBgXG4gKiBpdCB3aWxsIHJldHVybiBmYWxzZSBiZWNhdXNlIGxlbmd0aCBvZiBcIjEwMFwiIGlzIHNob3J0IHRoYW4gaWRlbnRpZmllciBcImV4YW1wbGVcIi5cbiAqL1xuZnVuY3Rpb24gaXNfY29uc3Rfc3ltYm9sX3Nob3J0X3RoYW5faW5pdF92YWx1ZShkZWYsIGZpeGVkX3ZhbHVlKSB7XG4gICAgaWYgKGRlZi5vcmlnLmxlbmd0aCA9PT0gMSAmJiBmaXhlZF92YWx1ZSkge1xuICAgICAgICBjb25zdCBpbml0X3ZhbHVlX2xlbmd0aCA9IGZpeGVkX3ZhbHVlLnNpemUoKTtcbiAgICAgICAgY29uc3QgaWRlbnRpZmVyX2xlbmd0aCA9IGRlZi5uYW1lLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGluaXRfdmFsdWVfbGVuZ3RoID4gaWRlbnRpZmVyX2xlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlubGluZV9pbnRvX3N5bWJvbHJlZihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKGNvbXByZXNzb3IuaW5fY29tcHV0ZWRfa2V5KCkpIHJldHVybiBzZWxmO1xuXG4gICAgY29uc3QgcGFyZW50ID0gY29tcHJlc3Nvci5wYXJlbnQoKTtcbiAgICBjb25zdCBkZWYgPSBzZWxmLmRlZmluaXRpb24oKTtcbiAgICBjb25zdCBuZWFyZXN0X3Njb3BlID0gY29tcHJlc3Nvci5maW5kX3Njb3BlKCk7XG4gICAgbGV0IGZpeGVkID0gc2VsZi5maXhlZF92YWx1ZSgpO1xuICAgIGlmIChcbiAgICAgICAgY29tcHJlc3Nvci50b3BfcmV0YWluICYmXG4gICAgICAgIGRlZi5nbG9iYWwgJiYgXG4gICAgICAgIGNvbXByZXNzb3IudG9wX3JldGFpbihkZWYpICYmIFxuICAgICAgICAvLyB3aGVuIGlkZW50aWZpZXIgaXMgaW4gdG9wX3JldGFpbiBvcHRpb24gZG9zZSBub3QgbWVhbiB3ZSBjYW4gYWx3YXlzIGlubGluZSBpdC5cbiAgICAgICAgLy8gaWYgaWRlbnRpZmllciBuYW1lIGlzIGxvbmdlciB0aGVuIGluaXQgdmFsdWUsIHdlIGNhbiByZXBsYWNlIGl0LlxuICAgICAgICBpc19jb25zdF9zeW1ib2xfc2hvcnRfdGhhbl9pbml0X3ZhbHVlKGRlZiwgZml4ZWQpXG4gICAgKSB7XG4gICAgICAgIC8vIGtlZXAgaXRcbiAgICAgICAgZGVmLmZpeGVkID0gZmFsc2U7XG4gICAgICAgIGRlZi5zaW5nbGVfdXNlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGlmIChkb250X2lubGluZV9sYW1iZGFfaW5fbG9vcChjb21wcmVzc29yLCBmaXhlZCkpIHJldHVybiBzZWxmO1xuXG4gICAgbGV0IHNpbmdsZV91c2UgPSBkZWYuc2luZ2xlX3VzZVxuICAgICAgICAmJiAhKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAmJiAocGFyZW50LmlzX2NhbGxlZV9wdXJlKGNvbXByZXNzb3IpKVxuICAgICAgICAgICAgICAgIHx8IGhhc19hbm5vdGF0aW9uKHBhcmVudCwgX05PSU5MSU5FKSlcbiAgICAgICAgJiYgIShwYXJlbnQgaW5zdGFuY2VvZiBBU1RfRXhwb3J0XG4gICAgICAgICAgICAmJiBmaXhlZCBpbnN0YW5jZW9mIEFTVF9MYW1iZGFcbiAgICAgICAgICAgICYmIGZpeGVkLm5hbWUpO1xuXG4gICAgaWYgKHNpbmdsZV91c2UgJiYgZml4ZWQgaW5zdGFuY2VvZiBBU1RfTm9kZSkge1xuICAgICAgICBzaW5nbGVfdXNlID1cbiAgICAgICAgICAgICFmaXhlZC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAmJiAhZml4ZWQubWF5X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH1cblxuICAgIGlmIChmaXhlZCBpbnN0YW5jZW9mIEFTVF9DbGFzcyAmJiBkZWYuc2NvcGUgIT09IHNlbGYuc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgaWYgKHNpbmdsZV91c2UgJiYgKGZpeGVkIGluc3RhbmNlb2YgQVNUX0xhbWJkYSB8fCBmaXhlZCBpbnN0YW5jZW9mIEFTVF9DbGFzcykpIHtcbiAgICAgICAgaWYgKHJldGFpbl90b3BfZnVuYyhmaXhlZCwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHNpbmdsZV91c2UgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWYuc2NvcGUgIT09IHNlbGYuc2NvcGVcbiAgICAgICAgICAgICYmIChkZWYuZXNjYXBlZCA9PSAxXG4gICAgICAgICAgICAgICAgfHwgaGFzX2ZsYWcoZml4ZWQsIElOTElORUQpXG4gICAgICAgICAgICAgICAgfHwgd2l0aGluX2FycmF5X29yX29iamVjdF9saXRlcmFsKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfHwgIWNvbXByZXNzb3Iub3B0aW9uKFwicmVkdWNlX2Z1bmNzXCIpKSkge1xuICAgICAgICAgICAgc2luZ2xlX3VzZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX3JlY3Vyc2l2ZV9yZWYoY29tcHJlc3NvciwgZGVmKSkge1xuICAgICAgICAgICAgc2luZ2xlX3VzZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRlZi5zY29wZSAhPT0gc2VsZi5zY29wZSB8fCBkZWYub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xGdW5hcmcpIHtcbiAgICAgICAgICAgIHNpbmdsZV91c2UgPSBmaXhlZC5pc19jb25zdGFudF9leHByZXNzaW9uKHNlbGYuc2NvcGUpO1xuICAgICAgICAgICAgaWYgKHNpbmdsZV91c2UgPT0gXCJmXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSBzZWxmLnNjb3BlO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlIGluc3RhbmNlb2YgQVNUX0RlZnVuIHx8IGlzX2Z1bmNfZXhwcihzY29wZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldF9mbGFnKHNjb3BlLCBJTkxJTkVEKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50X3Njb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaW5nbGVfdXNlICYmIChmaXhlZCBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgfHwgZml4ZWQgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpKSB7XG4gICAgICAgIHNpbmdsZV91c2UgPVxuICAgICAgICAgICAgZGVmLnNjb3BlID09PSBzZWxmLnNjb3BlXG4gICAgICAgICAgICAgICAgJiYgIXNjb3BlX2VuY2xvc2VzX3ZhcmlhYmxlc19pbl90aGlzX3Njb3BlKG5lYXJlc3Rfc2NvcGUsIGZpeGVkKVxuICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgICAgICAgICAmJiBwYXJlbnQuZXhwcmVzc2lvbiA9PT0gc2VsZlxuICAgICAgICAgICAgICAgICYmICFzY29wZV9lbmNsb3Nlc192YXJpYWJsZXNfaW5fdGhpc19zY29wZShuZWFyZXN0X3Njb3BlLCBmaXhlZClcbiAgICAgICAgICAgICAgICAmJiAhKGZpeGVkLm5hbWUgJiYgZml4ZWQubmFtZS5kZWZpbml0aW9uKCkucmVjdXJzaXZlX3JlZnMgPiAwKTtcbiAgICB9XG5cbiAgICBpZiAoc2luZ2xlX3VzZSAmJiBmaXhlZCkge1xuICAgICAgICBpZiAoZml4ZWQgaW5zdGFuY2VvZiBBU1RfRGVmQ2xhc3MpIHtcbiAgICAgICAgICAgIHNldF9mbGFnKGZpeGVkLCBTUVVFRVpFRCk7XG4gICAgICAgICAgICBmaXhlZCA9IG1ha2Vfbm9kZShBU1RfQ2xhc3NFeHByZXNzaW9uLCBmaXhlZCwgZml4ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXhlZCBpbnN0YW5jZW9mIEFTVF9EZWZ1bikge1xuICAgICAgICAgICAgc2V0X2ZsYWcoZml4ZWQsIFNRVUVFWkVEKTtcbiAgICAgICAgICAgIGZpeGVkID0gbWFrZV9ub2RlKEFTVF9GdW5jdGlvbiwgZml4ZWQsIGZpeGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnJlY3Vyc2l2ZV9yZWZzID4gMCAmJiBmaXhlZC5uYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlZnVuKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZ1bl9kZWYgPSBmaXhlZC5uYW1lLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGxldCBsYW1iZGFfZGVmID0gZml4ZWQudmFyaWFibGVzLmdldChmaXhlZC5uYW1lLm5hbWUpO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBsYW1iZGFfZGVmICYmIGxhbWJkYV9kZWYub3JpZ1swXTtcbiAgICAgICAgICAgIGlmICghKG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhKSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBtYWtlX25vZGUoQVNUX1N5bWJvbExhbWJkYSwgZml4ZWQubmFtZSwgZml4ZWQubmFtZSk7XG4gICAgICAgICAgICAgICAgbmFtZS5zY29wZSA9IGZpeGVkO1xuICAgICAgICAgICAgICAgIGZpeGVkLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGxhbWJkYV9kZWYgPSBmaXhlZC5kZWZfZnVuY3Rpb24obmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YWxrKGZpeGVkLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgbm9kZS5kZWZpbml0aW9uKCkgPT09IGRlZnVuX2RlZikge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnRoZWRlZiA9IGxhbWJkYV9kZWY7XG4gICAgICAgICAgICAgICAgICAgIGxhbWJkYV9kZWYucmVmZXJlbmNlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChmaXhlZCBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgfHwgZml4ZWQgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpXG4gICAgICAgICAgICAmJiBmaXhlZC5wYXJlbnRfc2NvcGUgIT09IG5lYXJlc3Rfc2NvcGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmaXhlZCA9IGZpeGVkLmNsb25lKHRydWUsIGNvbXByZXNzb3IuZ2V0X3RvcGxldmVsKCkpO1xuXG4gICAgICAgICAgICBuZWFyZXN0X3Njb3BlLmFkZF9jaGlsZF9zY29wZShmaXhlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpeGVkLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cblxuICAgIC8vIG11bHRpcGxlIHVzZXNcbiAgICBpZiAoZml4ZWQpIHtcbiAgICAgICAgbGV0IHJlcGxhY2U7XG5cbiAgICAgICAgaWYgKGZpeGVkIGluc3RhbmNlb2YgQVNUX1RoaXMpIHtcbiAgICAgICAgICAgIGlmICghKGRlZi5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZylcbiAgICAgICAgICAgICAgICAmJiBkZWYucmVmZXJlbmNlcy5ldmVyeSgocmVmKSA9PlxuICAgICAgICAgICAgICAgICAgICBkZWYuc2NvcGUgPT09IHJlZi5zY29wZVxuICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlID0gZml4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXYgPSBmaXhlZC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBldiAhPT0gZml4ZWRcbiAgICAgICAgICAgICAgICAmJiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfcmVnZXhwXCIpIHx8ICEoZXYgaW5zdGFuY2VvZiBSZWdFeHApKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZSA9IG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGV2LCBmaXhlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZV9sZW5ndGggPSBzZWxmLnNpemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBjb25zdCByZXBsYWNlX3NpemUgPSByZXBsYWNlLnNpemUoY29tcHJlc3Nvcik7XG5cbiAgICAgICAgICAgIGxldCBvdmVyaGVhZCA9IDA7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnVzZWRcIikgJiYgIWNvbXByZXNzb3IuZXhwb3NlZChkZWYpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmhlYWQgPVxuICAgICAgICAgICAgICAgICAgICAobmFtZV9sZW5ndGggKyAyICsgZml4ZWQuc2l6ZShjb21wcmVzc29yKSkgL1xuICAgICAgICAgICAgICAgICAgICAoZGVmLnJlZmVyZW5jZXMubGVuZ3RoIC0gZGVmLmFzc2lnbm1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlcGxhY2Vfc2l6ZSA8PSBuYW1lX2xlbmd0aCArIG92ZXJoZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gaW5saW5lX2ludG9fY2FsbChzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKGNvbXByZXNzb3IuaW5fY29tcHV0ZWRfa2V5KCkpIHJldHVybiBzZWxmO1xuXG4gICAgdmFyIGV4cCA9IHNlbGYuZXhwcmVzc2lvbjtcbiAgICB2YXIgZm4gPSBleHA7XG4gICAgdmFyIHNpbXBsZV9hcmdzID0gc2VsZi5hcmdzLmV2ZXJ5KChhcmcpID0+ICEoYXJnIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikpO1xuXG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwicmVkdWNlX3ZhcnNcIilcbiAgICAgICAgJiYgZm4gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICYmICFoYXNfYW5ub3RhdGlvbihzZWxmLCBfTk9JTkxJTkUpXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGZpeGVkID0gZm4uZml4ZWRfdmFsdWUoKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICByZXRhaW5fdG9wX2Z1bmMoZml4ZWQsIGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCAhY29tcHJlc3Nvci50b3BsZXZlbC5mdW5jcyAmJiBleHAuZGVmaW5pdGlvbigpLmdsb2JhbFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgZm4gPSBmaXhlZDtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIGRvbnRfaW5saW5lX2xhbWJkYV9pbl9sb29wKGNvbXByZXNzb3IsIGZuKVxuICAgICAgICAmJiAhaGFzX2Fubm90YXRpb24oc2VsZiwgX0lOTElORSlcbiAgICApIHJldHVybiBzZWxmO1xuXG4gICAgdmFyIGlzX2Z1bmMgPSBmbiBpbnN0YW5jZW9mIEFTVF9MYW1iZGE7XG5cbiAgICB2YXIgc3RhdCA9IGlzX2Z1bmMgJiYgZm4uYm9keVswXTtcbiAgICB2YXIgaXNfcmVndWxhcl9mdW5jID0gaXNfZnVuYyAmJiAhZm4uaXNfZ2VuZXJhdG9yICYmICFmbi5hc3luYztcbiAgICB2YXIgY2FuX2lubGluZSA9IGlzX3JlZ3VsYXJfZnVuYyAmJiBjb21wcmVzc29yLm9wdGlvbihcImlubGluZVwiKSAmJiAhc2VsZi5pc19jYWxsZWVfcHVyZShjb21wcmVzc29yKTtcbiAgICBpZiAoY2FuX2lubGluZSAmJiBzdGF0IGluc3RhbmNlb2YgQVNUX1JldHVybikge1xuICAgICAgICBsZXQgcmV0dXJuZWQgPSBzdGF0LnZhbHVlO1xuICAgICAgICBpZiAoIXJldHVybmVkIHx8IHJldHVybmVkLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oKSkge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuZWQgPSByZXR1cm5lZC5jbG9uZSh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuZWQgPSBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gc2VsZi5hcmdzLmNvbmNhdChyZXR1cm5lZCk7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCBhcmdzKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9wdGltaXplIGlkZW50aXR5IGZ1bmN0aW9uXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZuLmFyZ25hbWVzLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgJiYgKGZuLmFyZ25hbWVzWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZylcbiAgICAgICAgICAgICYmIHNlbGYuYXJncy5sZW5ndGggPCAyXG4gICAgICAgICAgICAmJiAhKHNlbGYuYXJnc1swXSBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pXG4gICAgICAgICAgICAmJiByZXR1cm5lZCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICYmIHJldHVybmVkLm5hbWUgPT09IGZuLmFyZ25hbWVzWzBdLm5hbWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9XG4gICAgICAgICAgICAgICAgKHNlbGYuYXJnc1swXSB8fCBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCkpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuXG4gICAgICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50IGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3NcbiAgICAgICAgICAgICAgICAmJiAocGFyZW50ID0gY29tcHJlc3Nvci5wYXJlbnQoKSkgaW5zdGFuY2VvZiBBU1RfQ2FsbFxuICAgICAgICAgICAgICAgICYmIHBhcmVudC5leHByZXNzaW9uID09PSBzZWxmXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBpZGVudGl0eSBmdW5jdGlvbiB3YXMgYmVpbmcgdXNlZCB0byByZW1vdmUgYHRoaXNgLCBsaWtlIGluXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBpZChiYWcubm9fdGhpcykoLi4uKVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB3aXRoIGEgbGFyZ2VyIGJ1dCBtb3JlIGVmZmlzaCAoMCwgYmFnLm5vX3RoaXMpIHdyYXBwZXIuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCBbXG4gICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBzZWxmLCB7IHZhbHVlOiAwIH0pLFxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVwbGFjZSBjYWxsIHdpdGggZmlyc3QgYXJndW1lbnQgb3IgdW5kZWZpbmVkIGlmIG5vbmUgcGFzc2VkXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2FuX2lubGluZSkge1xuICAgICAgICB2YXIgc2NvcGUsIGluX2xvb3AsIGxldmVsID0gLTE7XG4gICAgICAgIGxldCBkZWY7XG4gICAgICAgIGxldCByZXR1cm5lZF92YWx1ZTtcbiAgICAgICAgbGV0IG5lYXJlc3Rfc2NvcGU7XG4gICAgICAgIGlmIChzaW1wbGVfYXJnc1xuICAgICAgICAgICAgJiYgIWZuLnVzZXNfYXJndW1lbnRzXG4gICAgICAgICAgICAmJiAhKGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpXG4gICAgICAgICAgICAmJiAhKGZuLm5hbWUgJiYgZm4gaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb24pXG4gICAgICAgICAgICAmJiAocmV0dXJuZWRfdmFsdWUgPSBjYW5fZmxhdHRlbl9ib2R5KHN0YXQpKVxuICAgICAgICAgICAgJiYgKGV4cCA9PT0gZm5cbiAgICAgICAgICAgICAgICB8fCBoYXNfYW5ub3RhdGlvbihzZWxmLCBfSU5MSU5FKVxuICAgICAgICAgICAgICAgIHx8IGNvbXByZXNzb3Iub3B0aW9uKFwidW51c2VkXCIpXG4gICAgICAgICAgICAgICAgICAgICYmIChkZWYgPSBleHAuZGVmaW5pdGlvbigpKS5yZWZlcmVuY2VzLmxlbmd0aCA9PSAxXG4gICAgICAgICAgICAgICAgICAgICYmICFpc19yZWN1cnNpdmVfcmVmKGNvbXByZXNzb3IsIGRlZilcbiAgICAgICAgICAgICAgICAgICAgJiYgZm4uaXNfY29uc3RhbnRfZXhwcmVzc2lvbihleHAuc2NvcGUpKVxuICAgICAgICAgICAgJiYgIWhhc19hbm5vdGF0aW9uKHNlbGYsIF9QVVJFIHwgX05PSU5MSU5FKVxuICAgICAgICAgICAgJiYgIWZuLmNvbnRhaW5zX3RoaXMoKVxuICAgICAgICAgICAgJiYgY2FuX2luamVjdF9zeW1ib2xzKClcbiAgICAgICAgICAgICYmIChuZWFyZXN0X3Njb3BlID0gY29tcHJlc3Nvci5maW5kX3Njb3BlKCkpXG4gICAgICAgICAgICAmJiAhc2NvcGVfZW5jbG9zZXNfdmFyaWFibGVzX2luX3RoaXNfc2NvcGUobmVhcmVzdF9zY29wZSwgZm4pXG4gICAgICAgICAgICAmJiAhKGZ1bmN0aW9uIGluX2RlZmF1bHRfYXNzaWduKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEdWUgdG8gdGhlIGZhY3QgZnVuY3Rpb24gcGFyYW1ldGVycyBoYXZlIHRoZWlyIG93biBzY29wZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBjYW4ndCB1c2UgYHZhciBzb21ldGhpbmdgIGluIHRoZSBmdW5jdGlvbiBib2R5IHdpdGhpbixcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2ltcGx5IGRvbid0IGlubGluZSBpbnRvIERlZmF1bHRBc3NpZ24uXG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgocCA9IGNvbXByZXNzb3IucGFyZW50KGkrKykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0QXNzaWduKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0Jsb2NrKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICAgJiYgIShzY29wZSBpbnN0YW5jZW9mIEFTVF9DbGFzcylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBzZXRfZmxhZyhmbiwgU1FVRUVaRUQpO1xuICAgICAgICAgICAgbmVhcmVzdF9zY29wZS5hZGRfY2hpbGRfc2NvcGUoZm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgZmxhdHRlbl9mbihyZXR1cm5lZF92YWx1ZSkpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhbl9pbmxpbmUgJiYgaGFzX2Fubm90YXRpb24oc2VsZiwgX0lOTElORSkpIHtcbiAgICAgICAgc2V0X2ZsYWcoZm4sIFNRVUVFWkVEKTtcbiAgICAgICAgZm4gPSBtYWtlX25vZGUoZm4uQ1RPUiA9PT0gQVNUX0RlZnVuID8gQVNUX0Z1bmN0aW9uIDogZm4uQ1RPUiwgZm4sIGZuKTtcbiAgICAgICAgZm4gPSBmbi5jbG9uZSh0cnVlKTtcbiAgICAgICAgZm4uZmlndXJlX291dF9zY29wZSh7fSwge1xuICAgICAgICAgICAgcGFyZW50X3Njb3BlOiBjb21wcmVzc29yLmZpbmRfc2NvcGUoKSxcbiAgICAgICAgICAgIHRvcGxldmVsOiBjb21wcmVzc29yLmdldF90b3BsZXZlbCgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0NhbGwsIHNlbGYsIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGZuLFxuICAgICAgICAgICAgYXJnczogc2VsZi5hcmdzLFxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYW5fZHJvcF90aGlzX2NhbGwgPSBpc19yZWd1bGFyX2Z1bmMgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikgJiYgZm4uYm9keS5ldmVyeShpc19lbXB0eSk7XG4gICAgaWYgKGNhbl9kcm9wX3RoaXNfY2FsbCkge1xuICAgICAgICB2YXIgYXJncyA9IHNlbGYuYXJncy5jb25jYXQobWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYpKTtcbiAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgYXJncykub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgfVxuXG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwibmVnYXRlX2lpZmVcIilcbiAgICAgICAgJiYgY29tcHJlc3Nvci5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnRcbiAgICAgICAgJiYgaXNfaWlmZV9jYWxsKHNlbGYpKSB7XG4gICAgICAgIHJldHVybiBzZWxmLm5lZ2F0ZShjb21wcmVzc29yLCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgZXYgPSBzZWxmLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgIGlmIChldiAhPT0gc2VsZikge1xuICAgICAgICBldiA9IG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGV2LCBzZWxmKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgcmV0dXJuIGJlc3Rfb2YoY29tcHJlc3NvciwgZXYsIHNlbGYpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuX3ZhbHVlKHN0YXQpIHtcbiAgICAgICAgaWYgKCFzdGF0KSByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYpO1xuICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9SZXR1cm4pIHtcbiAgICAgICAgICAgIGlmICghc3RhdC52YWx1ZSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0LnZhbHVlLmNsb25lKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIHN0YXQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCJ2b2lkXCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc3RhdC5ib2R5LmNsb25lKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbl9mbGF0dGVuX2JvZHkoc3RhdCkge1xuICAgICAgICB2YXIgYm9keSA9IGZuLmJvZHk7XG4gICAgICAgIHZhciBsZW4gPSBib2R5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiaW5saW5lXCIpIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PSAxICYmIHJldHVybl92YWx1ZShzdGF0KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBib2R5W2ldO1xuICAgICAgICAgICAgaWYgKGxpbmUgaW5zdGFuY2VvZiBBU1RfVmFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQgJiYgIWxpbmUuZGVmaW5pdGlvbnMuZXZlcnkoKHZhcl9kZWYpID0+XG4gICAgICAgICAgICAgICAgICAgICF2YXJfZGVmLnZhbHVlXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKGxpbmUgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdCA9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybl92YWx1ZShzdGF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5faW5qZWN0X2FyZ3MoYmxvY2tfc2NvcGVkLCBzYWZlX3RvX2luamVjdCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4uYXJnbmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBmbi5hcmduYW1lc1tpXTtcbiAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBU1RfRGVmYXVsdEFzc2lnbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNfZmxhZyhhcmcubGVmdCwgVU5VU0VEKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNfZmxhZyhhcmcuZXhwcmVzc2lvbiwgVU5VU0VEKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc19mbGFnKGFyZywgVU5VU0VEKSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIXNhZmVfdG9faW5qZWN0XG4gICAgICAgICAgICAgICAgfHwgYmxvY2tfc2NvcGVkLmhhcyhhcmcubmFtZSlcbiAgICAgICAgICAgICAgICB8fCBpZGVudGlmaWVyX2F0b20uaGFzKGFyZy5uYW1lKVxuICAgICAgICAgICAgICAgIHx8IHNjb3BlLmNvbmZsaWN0aW5nX2RlZihhcmcubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5fbG9vcCkgaW5fbG9vcC5wdXNoKGFyZy5kZWZpbml0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbl9pbmplY3RfdmFycyhibG9ja19zY29wZWQsIHNhZmVfdG9faW5qZWN0KSB7XG4gICAgICAgIHZhciBsZW4gPSBmbi5ib2R5Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXQgPSBmbi5ib2R5W2ldO1xuICAgICAgICAgICAgaWYgKCEoc3RhdCBpbnN0YW5jZW9mIEFTVF9WYXIpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghc2FmZV90b19pbmplY3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGF0LmRlZmluaXRpb25zLmxlbmd0aDsgLS1qID49IDA7KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBzdGF0LmRlZmluaXRpb25zW2pdLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgICAgICAgICB8fCBibG9ja19zY29wZWQuaGFzKG5hbWUubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgaWRlbnRpZmllcl9hdG9tLmhhcyhuYW1lLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHx8IHNjb3BlLmNvbmZsaWN0aW5nX2RlZihuYW1lLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluX2xvb3ApIGluX2xvb3AucHVzaChuYW1lLmRlZmluaXRpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuX2luamVjdF9zeW1ib2xzKCkge1xuICAgICAgICB2YXIgYmxvY2tfc2NvcGVkID0gbmV3IFNldCgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBzY29wZSA9IGNvbXByZXNzb3IucGFyZW50KCsrbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKHNjb3BlLmlzX2Jsb2NrX3Njb3BlKCkgJiYgc2NvcGUuYmxvY2tfc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBkdXJpbmcgY29tcHJlc3Npb24uXG4gICAgICAgICAgICAgICAgLy8gQnV0IGl0IHNob3VsZCBhbHdheXMgaGF2ZSBhIHZhbHVlIVxuICAgICAgICAgICAgICAgIHNjb3BlLmJsb2NrX3Njb3BlLnZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja19zY29wZWQuYWRkKHZhcmlhYmxlLm5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjb3BlIGluc3RhbmNlb2YgQVNUX0NhdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBjYW4gd2UgZGVsZXRlPyBBU1RfQ2F0Y2ggaXMgYSBibG9jayBzY29wZS5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUuYXJnbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja19zY29wZWQuYWRkKHNjb3BlLmFyZ25hbWUubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzY29wZSBpbnN0YW5jZW9mIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpbl9sb29wID0gW107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNjb3BlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikge1xuICAgICAgICAgICAgICAgIGlmIChzY29wZS5maXhlZF92YWx1ZSgpIGluc3RhbmNlb2YgQVNUX1Njb3BlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCEoc2NvcGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpKTtcblxuICAgICAgICB2YXIgc2FmZV90b19pbmplY3QgPSAhKHNjb3BlIGluc3RhbmNlb2YgQVNUX1RvcGxldmVsKSB8fCBjb21wcmVzc29yLnRvcGxldmVsLnZhcnM7XG4gICAgICAgIHZhciBpbmxpbmUgPSBjb21wcmVzc29yLm9wdGlvbihcImlubGluZVwiKTtcbiAgICAgICAgaWYgKCFjYW5faW5qZWN0X3ZhcnMoYmxvY2tfc2NvcGVkLCBpbmxpbmUgPj0gMyAmJiBzYWZlX3RvX2luamVjdCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFjYW5faW5qZWN0X2FyZ3MoYmxvY2tfc2NvcGVkLCBpbmxpbmUgPj0gMiAmJiBzYWZlX3RvX2luamVjdCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICFpbl9sb29wIHx8IGluX2xvb3AubGVuZ3RoID09IDAgfHwgIWlzX3JlYWNoYWJsZShmbiwgaW5fbG9vcCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kX3ZhcihkZWNscywgZXhwcmVzc2lvbnMsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBkZWYgPSBuYW1lLmRlZmluaXRpb24oKTtcblxuICAgICAgICAvLyBOYW1lIGFscmVhZHkgZXhpc3RzLCBvbmx5IHdoZW4gYSBmdW5jdGlvbiBhcmd1bWVudCBoYWQgdGhlIHNhbWUgbmFtZVxuICAgICAgICBjb25zdCBhbHJlYWR5X2FwcGVuZGVkID0gc2NvcGUudmFyaWFibGVzLmhhcyhuYW1lLm5hbWUpO1xuICAgICAgICBpZiAoIWFscmVhZHlfYXBwZW5kZWQpIHtcbiAgICAgICAgICAgIHNjb3BlLnZhcmlhYmxlcy5zZXQobmFtZS5uYW1lLCBkZWYpO1xuICAgICAgICAgICAgc2NvcGUuZW5jbG9zZWQucHVzaChkZWYpO1xuICAgICAgICAgICAgZGVjbHMucHVzaChtYWtlX25vZGUoQVNUX1ZhckRlZiwgbmFtZSwge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzeW0gPSBtYWtlX25vZGUoQVNUX1N5bWJvbFJlZiwgbmFtZSwgbmFtZSk7XG4gICAgICAgIGRlZi5yZWZlcmVuY2VzLnB1c2goc3ltKTtcbiAgICAgICAgaWYgKHZhbHVlKSBleHByZXNzaW9ucy5wdXNoKG1ha2Vfbm9kZShBU1RfQXNzaWduLCBzZWxmLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCI9XCIsXG4gICAgICAgICAgICBsb2dpY2FsOiBmYWxzZSxcbiAgICAgICAgICAgIGxlZnQ6IHN5bSxcbiAgICAgICAgICAgIHJpZ2h0OiB2YWx1ZS5jbG9uZSgpXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbGF0dGVuX2FyZ3MoZGVjbHMsIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBsZW4gPSBmbi5hcmduYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmFyZ3MubGVuZ3RoOyAtLWkgPj0gbGVuOykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChzZWxmLmFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGxlbjsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGZuLmFyZ25hbWVzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5hcmdzW2ldO1xuICAgICAgICAgICAgaWYgKGhhc19mbGFnKG5hbWUsIFVOVVNFRCkgfHwgIW5hbWUubmFtZSB8fCBzY29wZS5jb25mbGljdGluZ19kZWYobmFtZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkgZXhwcmVzc2lvbnMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBtYWtlX25vZGUoQVNUX1N5bWJvbFZhciwgbmFtZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgbmFtZS5kZWZpbml0aW9uKCkub3JpZy5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiBpbl9sb29wKSB2YWx1ZSA9IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKTtcbiAgICAgICAgICAgICAgICBhcHBlbmRfdmFyKGRlY2xzLCBleHByZXNzaW9ucywgc3ltYm9sLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVjbHMucmV2ZXJzZSgpO1xuICAgICAgICBleHByZXNzaW9ucy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmxhdHRlbl92YXJzKGRlY2xzLCBleHByZXNzaW9ucykge1xuICAgICAgICB2YXIgcG9zID0gZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGluZXMgPSBmbi5ib2R5Lmxlbmd0aDsgaSA8IGxpbmVzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGF0ID0gZm4uYm9keVtpXTtcbiAgICAgICAgICAgIGlmICghKHN0YXQgaW5zdGFuY2VvZiBBU1RfVmFyKSkgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgZGVmcyA9IHN0YXQuZGVmaW5pdGlvbnMubGVuZ3RoOyBqIDwgZGVmczsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhcl9kZWYgPSBzdGF0LmRlZmluaXRpb25zW2pdO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdmFyX2RlZi5uYW1lO1xuICAgICAgICAgICAgICAgIGFwcGVuZF92YXIoZGVjbHMsIGV4cHJlc3Npb25zLCBuYW1lLCB2YXJfZGVmLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5fbG9vcCAmJiBmbi5hcmduYW1lcy5ldmVyeSgoYXJnbmFtZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgYXJnbmFtZS5uYW1lICE9IG5hbWUubmFtZVxuICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IGZuLnZhcmlhYmxlcy5nZXQobmFtZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sUmVmLCBuYW1lLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmLnJlZmVyZW5jZXMucHVzaChzeW0pO1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5zcGxpY2UocG9zKyssIDAsIG1ha2Vfbm9kZShBU1RfQXNzaWduLCB2YXJfZGVmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dpY2FsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHN5bSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5fZm4ocmV0dXJuZWRfdmFsdWUpIHtcbiAgICAgICAgdmFyIGRlY2xzID0gW107XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBmbGF0dGVuX2FyZ3MoZGVjbHMsIGV4cHJlc3Npb25zKTtcbiAgICAgICAgZmxhdHRlbl92YXJzKGRlY2xzLCBleHByZXNzaW9ucyk7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2gocmV0dXJuZWRfdmFsdWUpO1xuXG4gICAgICAgIGlmIChkZWNscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBzY29wZS5ib2R5LmluZGV4T2YoY29tcHJlc3Nvci5wYXJlbnQobGV2ZWwgLSAxKSkgKyAxO1xuICAgICAgICAgICAgc2NvcGUuYm9keS5zcGxpY2UoaSwgMCwgbWFrZV9ub2RlKEFTVF9WYXIsIGZuLCB7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbnM6IGRlY2xzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnMubWFwKGV4cCA9PiBleHAuY2xvbmUodHJ1ZSkpO1xuICAgIH1cbn1cblxuLyoqIHByZXZlbnQgaW5saW5pbmcgZnVuY3Rpb25zIGludG8gbG9vcHMsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zICovXG5mdW5jdGlvbiBkb250X2lubGluZV9sYW1iZGFfaW5fbG9vcChjb21wcmVzc29yLCBtYXliZV9sYW1iZGEpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAobWF5YmVfbGFtYmRhIGluc3RhbmNlb2YgQVNUX0xhbWJkYSB8fCBtYXliZV9sYW1iZGEgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpXG4gICAgICAgICYmICEhY29tcHJlc3Nvci5pc193aXRoaW5fbG9vcCgpXG4gICAgKTtcbn1cblxuKGZ1bmN0aW9uKGRlZl9maW5kX2RlZnMpIHtcbiAgICBmdW5jdGlvbiB0b19ub2RlKHZhbHVlLCBvcmlnKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9Ob2RlKSB7XG4gICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBWYWx1ZSBtYXkgYmUgYSBmdW5jdGlvbiwgYW4gYXJyYXkgaW5jbHVkaW5nIGZ1bmN0aW9ucyBhbmQgZXZlbiBhIGNvbXBsZXggYXNzaWduIC8gYmxvY2sgZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAvLyBzbyBpdCBzaG91bGQgbmV2ZXIgYmUgc2hhcmVkIGluIGRpZmZlcmVudCBwbGFjZXMuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdyb25nIGluZm9ybWF0aW9uIG1heSBiZSB1c2VkIGluIHRoZSBjb21wcmVzc2lvbiBwaGFzZVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2xvbmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKHZhbHVlLkNUT1IsIG9yaWcsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiBtYWtlX25vZGUoQVNUX0FycmF5LCBvcmlnLCB7XG4gICAgICAgICAgICBlbGVtZW50czogdmFsdWUubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvX25vZGUodmFsdWUsIG9yaWcpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGlmIChIT1AodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKG1ha2Vfbm9kZShBU1RfT2JqZWN0S2V5VmFsLCBvcmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9fbm9kZSh2YWx1ZVtrZXldLCBvcmlnKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX09iamVjdCwgb3JpZywge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQodmFsdWUsIG9yaWcpO1xuICAgIH1cblxuICAgIEFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJyZXNvbHZlX2RlZmluZXNcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwiZ2xvYmFsX2RlZnNcIikpIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLmZpZ3VyZV9vdXRfc2NvcGUoeyBpZTg6IGNvbXByZXNzb3Iub3B0aW9uKFwiaWU4XCIpIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gbm9kZS5fZmluZF9kZWZzKGNvbXByZXNzb3IsIFwiXCIpO1xuICAgICAgICAgICAgaWYgKCFkZWYpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IDAsIGNoaWxkID0gbm9kZSwgcGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCA9IHRoaXMucGFyZW50KGxldmVsKyspKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MpKSBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LmV4cHJlc3Npb24gIT09IGNoaWxkKSBicmVhaztcbiAgICAgICAgICAgICAgICBjaGlsZCA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc19saHMoY2hpbGQsIHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9KSk7XG4gICAgfSk7XG4gICAgZGVmX2ZpbmRfZGVmcyhBU1RfTm9kZSwgbm9vcCk7XG4gICAgZGVmX2ZpbmRfZGVmcyhBU1RfQ2hhaW4sIGZ1bmN0aW9uKGNvbXByZXNzb3IsIHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLl9maW5kX2RlZnMoY29tcHJlc3Nvciwgc3VmZml4KTtcbiAgICB9KTtcbiAgICBkZWZfZmluZF9kZWZzKEFTVF9Eb3QsIGZ1bmN0aW9uKGNvbXByZXNzb3IsIHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLl9maW5kX2RlZnMoY29tcHJlc3NvciwgXCIuXCIgKyB0aGlzLnByb3BlcnR5ICsgc3VmZml4KTtcbiAgICB9KTtcbiAgICBkZWZfZmluZF9kZWZzKEFTVF9TeW1ib2xEZWNsYXJhdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5nbG9iYWwoKSkgcmV0dXJuO1xuICAgIH0pO1xuICAgIGRlZl9maW5kX2RlZnMoQVNUX1N5bWJvbFJlZiwgZnVuY3Rpb24oY29tcHJlc3Nvciwgc3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5nbG9iYWwoKSkgcmV0dXJuO1xuICAgICAgICB2YXIgZGVmaW5lcyA9IGNvbXByZXNzb3Iub3B0aW9uKFwiZ2xvYmFsX2RlZnNcIik7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lICsgc3VmZml4O1xuICAgICAgICBpZiAoSE9QKGRlZmluZXMsIG5hbWUpKSByZXR1cm4gdG9fbm9kZShkZWZpbmVzW25hbWVdLCB0aGlzKTtcbiAgICB9KTtcbiAgICBkZWZfZmluZF9kZWZzKEFTVF9JbXBvcnRNZXRhLCBmdW5jdGlvbihjb21wcmVzc29yLCBzdWZmaXgpIHtcbiAgICAgICAgdmFyIGRlZmluZXMgPSBjb21wcmVzc29yLm9wdGlvbihcImdsb2JhbF9kZWZzXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IFwiaW1wb3J0Lm1ldGFcIiArIHN1ZmZpeDtcbiAgICAgICAgaWYgKEhPUChkZWZpbmVzLCBuYW1lKSkgcmV0dXJuIHRvX25vZGUoZGVmaW5lc1tuYW1lXSwgdGhpcyk7XG4gICAgfSk7XG59KShmdW5jdGlvbihub2RlLCBmdW5jKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJfZmluZF9kZWZzXCIsIGZ1bmMpO1xufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY2xhc3MgQ29tcHJlc3NvciBleHRlbmRzIFRyZWVXYWxrZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHsgZmFsc2VfYnlfZGVmYXVsdCA9IGZhbHNlLCBtYW5nbGVfb3B0aW9ucyA9IGZhbHNlIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMgIT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5kZWZhdWx0cykgZmFsc2VfYnlfZGVmYXVsdCA9IHRydWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGFyZ3VtZW50cyAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGFycm93cyAgICAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIGJvb2xlYW5zICAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIGJvb2xlYW5zX2FzX2ludGVnZXJzIDogZmFsc2UsXG4gICAgICAgICAgICBjb2xsYXBzZV92YXJzIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBjb21wYXJpc29ucyAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBjb21wdXRlZF9wcm9wczogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBjb25kaXRpb25hbHMgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBkZWFkX2NvZGUgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBkZWZhdWx0cyAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZXMgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIGRyb3BfY29uc29sZSAgOiBmYWxzZSxcbiAgICAgICAgICAgIGRyb3BfZGVidWdnZXIgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIGVjbWEgICAgICAgICAgOiA1LFxuICAgICAgICAgICAgZXZhbHVhdGUgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgZXhwcmVzc2lvbiAgICA6IGZhbHNlLFxuICAgICAgICAgICAgZ2xvYmFsX2RlZnMgICA6IGZhbHNlLFxuICAgICAgICAgICAgaG9pc3RfZnVucyAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaG9pc3RfcHJvcHMgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgaG9pc3RfdmFycyAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaWU4ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaWZfcmV0dXJuICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgaW5saW5lICAgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgam9pbl92YXJzICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAga2VlcF9jbGFzc25hbWVzOiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBfZmFyZ3MgICAgOiB0cnVlLFxuICAgICAgICAgICAga2VlcF9mbmFtZXMgICA6IGZhbHNlLFxuICAgICAgICAgICAga2VlcF9pbmZpbml0eSA6IGZhbHNlLFxuICAgICAgICAgICAgbGhzX2NvbnN0YW50cyA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgbG9vcHMgICAgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgbmVnYXRlX2lpZmUgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgcGFzc2VzICAgICAgICA6IDEsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBwdXJlX2dldHRlcnMgIDogIWZhbHNlX2J5X2RlZmF1bHQgJiYgXCJzdHJpY3RcIixcbiAgICAgICAgICAgIHB1cmVfZnVuY3MgICAgOiBudWxsLFxuICAgICAgICAgICAgcHVyZV9uZXcgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgcmVkdWNlX2Z1bmNzICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgcmVkdWNlX3ZhcnMgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgc2VxdWVuY2VzICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgc2lkZV9lZmZlY3RzICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgc3dpdGNoZXMgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgdG9wX3JldGFpbiAgICA6IG51bGwsXG4gICAgICAgICAgICB0b3BsZXZlbCAgICAgIDogISEob3B0aW9ucyAmJiBvcHRpb25zW1widG9wX3JldGFpblwiXSksXG4gICAgICAgICAgICB0eXBlb2ZzICAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICB1bnNhZmUgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnNhZmVfYXJyb3dzIDogZmFsc2UsXG4gICAgICAgICAgICB1bnNhZmVfY29tcHMgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnNhZmVfRnVuY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgdW5zYWZlX21hdGggICA6IGZhbHNlLFxuICAgICAgICAgICAgdW5zYWZlX3N5bWJvbHM6IGZhbHNlLFxuICAgICAgICAgICAgdW5zYWZlX21ldGhvZHM6IGZhbHNlLFxuICAgICAgICAgICAgdW5zYWZlX3Byb3RvICA6IGZhbHNlLFxuICAgICAgICAgICAgdW5zYWZlX3JlZ2V4cCA6IGZhbHNlLFxuICAgICAgICAgICAgdW5zYWZlX3VuZGVmaW5lZDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWQgICAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICB3YXJuaW5ncyAgICAgIDogZmFsc2UgIC8vIGxlZ2FjeVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgdmFyIGdsb2JhbF9kZWZzID0gdGhpcy5vcHRpb25zW1wiZ2xvYmFsX2RlZnNcIl07XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsX2RlZnMgPT0gXCJvYmplY3RcIikgZm9yICh2YXIga2V5IGluIGdsb2JhbF9kZWZzKSB7XG4gICAgICAgICAgICBpZiAoa2V5WzBdID09PSBcIkBcIiAmJiBIT1AoZ2xvYmFsX2RlZnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxfZGVmc1trZXkuc2xpY2UoMSldID0gcGFyc2UoZ2xvYmFsX2RlZnNba2V5XSwge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcImlubGluZVwiXSA9PT0gdHJ1ZSkgdGhpcy5vcHRpb25zW1wiaW5saW5lXCJdID0gMztcbiAgICAgICAgdmFyIHB1cmVfZnVuY3MgPSB0aGlzLm9wdGlvbnNbXCJwdXJlX2Z1bmNzXCJdO1xuICAgICAgICBpZiAodHlwZW9mIHB1cmVfZnVuY3MgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnB1cmVfZnVuY3MgPSBwdXJlX2Z1bmNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdXJlX2Z1bmNzID0gcHVyZV9mdW5jcyA/IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXB1cmVfZnVuY3MuaW5jbHVkZXMobm9kZS5leHByZXNzaW9uLnByaW50X3RvX3N0cmluZygpKTtcbiAgICAgICAgICAgIH0gOiByZXR1cm5fdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9wX3JldGFpbiA9IHRoaXMub3B0aW9uc1tcInRvcF9yZXRhaW5cIl07XG4gICAgICAgIGlmICh0b3BfcmV0YWluIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICB0aGlzLnRvcF9yZXRhaW4gPSBmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9wX3JldGFpbi50ZXN0KGRlZi5uYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRvcF9yZXRhaW4gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnRvcF9yZXRhaW4gPSB0b3BfcmV0YWluO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcF9yZXRhaW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9wX3JldGFpbiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdG9wX3JldGFpbiA9IHRvcF9yZXRhaW4uc3BsaXQoLywvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudG9wX3JldGFpbiA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3BfcmV0YWluLmluY2x1ZGVzKGRlZi5uYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcIm1vZHVsZVwiXSkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzW1widXNlIHN0cmljdFwiXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbXCJ0b3BsZXZlbFwiXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcGxldmVsID0gdGhpcy5vcHRpb25zW1widG9wbGV2ZWxcIl07XG4gICAgICAgIHRoaXMudG9wbGV2ZWwgPSB0eXBlb2YgdG9wbGV2ZWwgPT0gXCJzdHJpbmdcIiA/IHtcbiAgICAgICAgICAgIGZ1bmNzOiAvZnVuY3MvLnRlc3QodG9wbGV2ZWwpLFxuICAgICAgICAgICAgdmFyczogL3ZhcnMvLnRlc3QodG9wbGV2ZWwpXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBmdW5jczogdG9wbGV2ZWwsXG4gICAgICAgICAgICB2YXJzOiB0b3BsZXZlbFxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VxdWVuY2VzID0gdGhpcy5vcHRpb25zW1wic2VxdWVuY2VzXCJdO1xuICAgICAgICB0aGlzLnNlcXVlbmNlc19saW1pdCA9IHNlcXVlbmNlcyA9PSAxID8gODAwIDogc2VxdWVuY2VzIHwgMDtcbiAgICAgICAgdGhpcy5ldmFsdWF0ZWRfcmVnZXhwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdG9wbGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX21hbmdsZV9vcHRpb25zID0gbWFuZ2xlX29wdGlvbnNcbiAgICAgICAgICAgID8gZm9ybWF0X21hbmdsZXJfb3B0aW9ucyhtYW5nbGVfb3B0aW9ucylcbiAgICAgICAgICAgIDogbWFuZ2xlX29wdGlvbnM7XG4gICAgfVxuXG4gICAgbWFuZ2xlX29wdGlvbnMoKSB7XG4gICAgICAgIHZhciBudGhfaWRlbnRpZmllciA9IHRoaXMuX21hbmdsZV9vcHRpb25zICYmIHRoaXMuX21hbmdsZV9vcHRpb25zLm50aF9pZGVudGlmaWVyIHx8IGJhc2U1NDtcbiAgICAgICAgdmFyIG1vZHVsZSA9IHRoaXMuX21hbmdsZV9vcHRpb25zICYmIHRoaXMuX21hbmdsZV9vcHRpb25zLm1vZHVsZSB8fCB0aGlzLm9wdGlvbihcIm1vZHVsZVwiKTtcbiAgICAgICAgcmV0dXJuIHsgaWU4OiB0aGlzLm9wdGlvbihcImllOFwiKSwgbnRoX2lkZW50aWZpZXIsIG1vZHVsZSB9O1xuICAgIH1cblxuICAgIG9wdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGV4cG9zZWQoZGVmKSB7XG4gICAgICAgIGlmIChkZWYuZXhwb3J0KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGRlZi5nbG9iYWwpIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZWYub3JpZy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy50b3BsZXZlbFtkZWYub3JpZ1tpXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWZ1biA/IFwiZnVuY3NcIiA6IFwidmFyc1wiXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGluX2Jvb2xlYW5fY29udGV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbihcImJvb2xlYW5zXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcy5zZWxmKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwOyBwID0gdGhpcy5wYXJlbnQoaSk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50XG4gICAgICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAmJiBwLmNvbmRpdGlvbiA9PT0gc2VsZlxuICAgICAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfRFdMb29wICYmIHAuY29uZGl0aW9uID09PSBzZWxmXG4gICAgICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9Gb3IgJiYgcC5jb25kaXRpb24gPT09IHNlbGZcbiAgICAgICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0lmICYmIHAuY29uZGl0aW9uID09PSBzZWxmXG4gICAgICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeCAmJiBwLm9wZXJhdG9yID09IFwiIVwiICYmIHAuZXhwcmVzc2lvbiA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHAub3BlcmF0b3IgPT0gXCImJlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBwLm9wZXJhdG9yID09IFwifHxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgcC5vcGVyYXRvciA9PSBcIj8/XCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWxcbiAgICAgICAgICAgICAgICB8fCBwLnRhaWxfbm9kZSgpID09PSBzZWxmXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFRydWUgaWYgY29tcHJlc3Nvci5zZWxmKCkncyByZXN1bHQgd2lsbCBiZSB0dXJuZWQgaW50byBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqIGV4OlxuICAgICAqIH57ZXhwcn1cbiAgICAgKiAoMSwgMiwge2V4cHJ9KSB8IDBcbiAgICAgKiovXG4gICAgaW5fMzJfYml0X2NvbnRleHQob3RoZXJfb3BlcmFuZF9tdXN0X2JlX251bWJlcikge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uKFwiZXZhbHVhdGVcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLnNlbGYoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHA7IHAgPSB0aGlzLnBhcmVudChpKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgYml0d2lzZV9iaW5vcC5oYXMocC5vcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJfb3BlcmFuZF9tdXN0X2JlX251bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNlbGYgPT09IHAubGVmdCA/IHAucmlnaHQgOiBwLmxlZnQpLmlzX251bWJlcih0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwLm9wZXJhdG9yID09PSBcIn5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwIGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB0YWxrIGFib3V0IHAubGVmdC4gQ2FuIGNoYW5nZSBicmFuY2ggdGFrZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHAub3BlcmF0b3IgPT0gXCImJlwiICYmIHAucmlnaHQgPT09IHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHAub3BlcmF0b3IgPT0gXCJ8fFwiICYmIHAucmlnaHQgPT09IHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHAub3BlcmF0b3IgPT0gXCI/P1wiICYmIHAucmlnaHQgPT09IHNlbGZcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwgJiYgcC5jb25kaXRpb24gIT09IHNlbGZcbiAgICAgICAgICAgICAgICB8fCBwLnRhaWxfbm9kZSgpID09PSBzZWxmXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5fY29tcHV0ZWRfa2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uKFwiZXZhbHVhdGVcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLnNlbGYoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHA7IHAgPSB0aGlzLnBhcmVudChpKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9PYmplY3RQcm9wZXJ0eSAmJiBwLmtleSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXRfdG9wbGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3BsZXZlbDtcbiAgICB9XG5cbiAgICBjb21wcmVzcyh0b3BsZXZlbCkge1xuICAgICAgICB0b3BsZXZlbCA9IHRvcGxldmVsLnJlc29sdmVfZGVmaW5lcyh0aGlzKTtcbiAgICAgICAgdGhpcy5fdG9wbGV2ZWwgPSB0b3BsZXZlbDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uKFwiZXhwcmVzc2lvblwiKSkge1xuICAgICAgICAgICAgdGhpcy5fdG9wbGV2ZWwucHJvY2Vzc19leHByZXNzaW9uKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXNzZXMgPSArdGhpcy5vcHRpb25zLnBhc3NlcyB8fCAxO1xuICAgICAgICB2YXIgbWluX2NvdW50ID0gMSAvIDA7XG4gICAgICAgIHZhciBzdG9wcGluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgbWFuZ2xlID0gdGhpcy5tYW5nbGVfb3B0aW9ucygpO1xuICAgICAgICBmb3IgKHZhciBwYXNzID0gMDsgcGFzcyA8IHBhc3NlczsgcGFzcysrKSB7XG4gICAgICAgICAgICB0aGlzLl90b3BsZXZlbC5maWd1cmVfb3V0X3Njb3BlKG1hbmdsZSk7XG4gICAgICAgICAgICBpZiAocGFzcyA9PT0gMCAmJiB0aGlzLm9wdGlvbihcImRyb3BfY29uc29sZVwiKSkge1xuICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgcnVuIGJlZm9yZSByZWR1Y2VfdmFycyBhbmQgY29tcHJlc3MgcGFzc1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvcGxldmVsID0gdGhpcy5fdG9wbGV2ZWwuZHJvcF9jb25zb2xlKHRoaXMub3B0aW9uKFwiZHJvcF9jb25zb2xlXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXNzID4gMCB8fCB0aGlzLm9wdGlvbihcInJlZHVjZV92YXJzXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9wbGV2ZWwucmVzZXRfb3B0X2ZsYWdzKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdG9wbGV2ZWwgPSB0aGlzLl90b3BsZXZlbC50cmFuc2Zvcm0odGhpcyk7XG4gICAgICAgICAgICBpZiAocGFzc2VzID4gMSkge1xuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgd2Fsayh0aGlzLl90b3BsZXZlbCwgKCkgPT4geyBjb3VudCsrOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluX2NvdW50ID0gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdG9wcGluZykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbihcImV4cHJlc3Npb25cIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvcGxldmVsLnByb2Nlc3NfZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9wbGV2ZWwgPSB0aGlzLl90b3BsZXZlbDtcbiAgICAgICAgdGhpcy5fdG9wbGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0b3BsZXZlbDtcbiAgICB9XG5cbiAgICBiZWZvcmUobm9kZSwgZGVzY2VuZCkge1xuICAgICAgICBpZiAoaGFzX2ZsYWcobm9kZSwgU1FVRUVaRUQpKSByZXR1cm4gbm9kZTtcbiAgICAgICAgdmFyIHdhc19zY29wZSA9IGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuaG9pc3RfcHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmhvaXN0X2RlY2xhcmF0aW9ucyh0aGlzKTtcbiAgICAgICAgICAgIHdhc19zY29wZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVmb3JlIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL3B1bGwvMTYwMiBBU1RfTm9kZS5vcHRpbWl6ZSgpXG4gICAgICAgIC8vIHdvdWxkIGNhbGwgQVNUX05vZGUudHJhbnNmb3JtKCkgaWYgYSBkaWZmZXJlbnQgaW5zdGFuY2Ugb2YgQVNUX05vZGUgaXNcbiAgICAgICAgLy8gcHJvZHVjZWQgYWZ0ZXIgZGVmX29wdGltaXplKCkuXG4gICAgICAgIC8vIFRoaXMgY29ycnVwdHMgVHJlZVdhbGtlci5zdGFjaywgd2hpY2ggY2F1c2UgQVNUIGxvb2stdXBzIHRvIG1hbGZ1bmN0aW9uLlxuICAgICAgICAvLyBNaWdyYXRlIGFuZCBkZWZlciBhbGwgY2hpbGRyZW4ncyBBU1RfTm9kZS50cmFuc2Zvcm0oKSB0byBiZWxvdywgd2hpY2hcbiAgICAgICAgLy8gd2lsbCBub3cgaGFwcGVuIGFmdGVyIHRoaXMgcGFyZW50IEFTVF9Ob2RlIGhhcyBiZWVuIHByb3Blcmx5IHN1YnN0aXR1dGVkXG4gICAgICAgIC8vIHRodXMgZ2l2ZXMgYSBjb25zaXN0ZW50IEFTVCBzbmFwc2hvdC5cbiAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgLy8gRXhpc3RpbmcgY29kZSByZWxpZXMgb24gaG93IEFTVF9Ob2RlLm9wdGltaXplKCkgd29ya2VkLCBhbmQgb21pdHRpbmcgdGhlXG4gICAgICAgIC8vIGZvbGxvd2luZyByZXBsYWNlbWVudCBjYWxsIHdvdWxkIHJlc3VsdCBpbiBkZWdyYWRlZCBlZmZpY2llbmN5IG9mIGJvdGhcbiAgICAgICAgLy8gb3V0cHV0IGFuZCBwZXJmb3JtYW5jZS5cbiAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgdmFyIG9wdCA9IG5vZGUub3B0aW1pemUodGhpcyk7XG4gICAgICAgIGlmICh3YXNfc2NvcGUgJiYgb3B0IGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICBvcHQuZHJvcF91bnVzZWQodGhpcyk7XG4gICAgICAgICAgICBkZXNjZW5kKG9wdCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdCA9PT0gbm9kZSkgc2V0X2ZsYWcob3B0LCBTUVVFRVpFRCk7XG4gICAgICAgIHJldHVybiBvcHQ7XG4gICAgfVxuXG4gICAgLyoqIEFsdGVybmF0aXZlIHRvIHBsYWluIGlzX2xocygpIHdoaWNoIGRvZXNuJ3Qgd29yayB3aXRoaW4gLm9wdGltaXplKCkgKi9cbiAgICBpc19saHMoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgcmV0dXJuIGlzX2xocyhzZWxmLCBwYXJlbnQpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBkZWZfb3B0aW1pemUobm9kZSwgb3B0aW1pemVyKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJvcHRpbWl6ZVwiLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGhhc19mbGFnKHNlbGYsIE9QVElNSVpFRCkpIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5oYXNfZGlyZWN0aXZlKFwidXNlIGFzbVwiKSkgcmV0dXJuIHNlbGY7XG4gICAgICAgIHZhciBvcHQgPSBvcHRpbWl6ZXIoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgIHNldF9mbGFnKG9wdCwgT1BUSU1JWkVEKTtcbiAgICAgICAgcmV0dXJuIG9wdDtcbiAgICB9KTtcbn1cblxuZGVmX29wdGltaXplKEFTVF9Ob2RlLCBmdW5jdGlvbihzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcImRyb3BfY29uc29sZVwiLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkob3B0aW9ucyk7XG4gICAgY29uc3QgdHQgPSBuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYuVFlQRSAhPT0gXCJDYWxsXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHAgPSBzZWxmLmV4cHJlc3Npb247XG5cbiAgICAgICAgaWYgKCEoZXhwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSA9IGV4cC5leHByZXNzaW9uO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBleHAucHJvcGVydHk7XG4gICAgICAgIHZhciBkZXB0aCA9IDI7XG4gICAgICAgIHdoaWxlIChuYW1lLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gbmFtZS5wcm9wZXJ0eTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLmV4cHJlc3Npb247XG4gICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXkgJiYgIW9wdGlvbnMuaW5jbHVkZXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfdW5kZWNsYXJlZF9yZWYobmFtZSkgJiYgbmFtZS5uYW1lID09IFwiY29uc29sZVwiKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZGVwdGggPT09IDNcbiAgICAgICAgICAgICAgICAmJiAhW1wiY2FsbFwiLCBcImFwcGx5XCJdLmluY2x1ZGVzKGV4cC5wcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAmJiBpc191c2VkX2luX2V4cHJlc3Npb24odHQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBhICh1c2VkKSBjYWxsIHRvIEZ1bmN0aW9uLnByb3RvdHlwZSBtZXRob2RzIChlZzogY29uc29sZS5sb2cuYmluZChjb25zb2xlKSlcbiAgICAgICAgICAgICAgICAvLyBidXQgbm90IC5jYWxsIGFuZCAuYXBwbHkgd2hpY2ggd291bGQgYWxzbyByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgIGV4cC5leHByZXNzaW9uID0gbWFrZV9lbXB0eV9mdW5jdGlvbihzZWxmKTtcbiAgICAgICAgICAgICAgICBzZXRfZmxhZyhleHAuZXhwcmVzc2lvbiwgU1FVRUVaRUQpO1xuICAgICAgICAgICAgICAgIHNlbGYuYXJncyA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odHQpO1xufSk7XG5cbkFTVF9Ob2RlLkRFRk1FVEhPRChcImVxdWl2YWxlbnRfdG9cIiwgZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBlcXVpdmFsZW50X3RvKHRoaXMsIG5vZGUpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJwcm9jZXNzX2V4cHJlc3Npb25cIiwgZnVuY3Rpb24oaW5zZXJ0LCBjb21wcmVzc29yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0dCA9IG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoaW5zZXJ0ICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9SZXR1cm4sIG5vZGUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbm9kZS5ib2R5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluc2VydCAmJiBub2RlIGluc3RhbmNlb2YgQVNUX1JldHVybikge1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlICYmIG5vZGUudmFsdWUuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICA/IG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBub2RlLCB7IGJvZHk6IHZhbHVlIH0pXG4gICAgICAgICAgICAgICAgICAgIDogbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBub2RlLnZhbHVlIHx8IG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwidm9pZFwiLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX051bWJlciwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3MgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgJiYgbm9kZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQmxvY2spIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGUuYm9keS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBub2RlLmJvZHlbaW5kZXhdID0gbm9kZS5ib2R5W2luZGV4XS50cmFuc2Zvcm0odHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgIG5vZGUuYm9keSA9IG5vZGUuYm9keS50cmFuc2Zvcm0odHQpO1xuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFsdGVybmF0aXZlID0gbm9kZS5hbHRlcm5hdGl2ZS50cmFuc2Zvcm0odHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfV2l0aCkge1xuICAgICAgICAgICAgbm9kZS5ib2R5ID0gbm9kZS5ib2R5LnRyYW5zZm9ybSh0dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgc2VsZi50cmFuc2Zvcm0odHQpO1xufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJyZXNldF9vcHRfZmxhZ3NcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHJlZHVjZV92YXJzID0gY29tcHJlc3Nvci5vcHRpb24oXCJyZWR1Y2VfdmFyc1wiKTtcblxuICAgIGNvbnN0IHByZXBhcmF0aW9uID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSwgZGVzY2VuZCkge1xuICAgICAgICBjbGVhcl9mbGFnKG5vZGUsIENMRUFSX0JFVFdFRU5fUEFTU0VTKTtcbiAgICAgICAgaWYgKHJlZHVjZV92YXJzKSB7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci50b3BfcmV0YWluXG4gICAgICAgICAgICAgICAgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1biAgLy8gT25seSBmdW5jdGlvbnMgYXJlIHJldGFpbmVkXG4gICAgICAgICAgICAgICAgJiYgcHJlcGFyYXRpb24ucGFyZW50KCkgPT09IHNlbGZcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNldF9mbGFnKG5vZGUsIFRPUCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5yZWR1Y2VfdmFycyhwcmVwYXJhdGlvbiwgZGVzY2VuZCwgY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBTdGFjayBvZiBsb29rLXVwIHRhYmxlcyB0byBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgYSBgU3ltYm9sRGVmYCBoYXMgYmVlblxuICAgIC8vIHByb3Blcmx5IGFzc2lnbmVkIGJlZm9yZSB1c2U6XG4gICAgLy8gLSBgcHVzaCgpYCAmIGBwb3AoKWAgd2hlbiB2aXNpdGluZyBjb25kaXRpb25hbCBicmFuY2hlc1xuICAgIHByZXBhcmF0aW9uLnNhZmVfaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBwcmVwYXJhdGlvbi5pbl9sb29wID0gbnVsbDtcbiAgICBwcmVwYXJhdGlvbi5sb29wX2lkcyA9IG5ldyBNYXAoKTtcbiAgICBwcmVwYXJhdGlvbi5kZWZzX3RvX3NhZmVfaWRzID0gbmV3IE1hcCgpO1xuICAgIHNlbGYud2FsayhwcmVwYXJhdGlvbik7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJmaXhlZF92YWx1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgZml4ZWQgPSB0aGlzLnRoZWRlZi5maXhlZDtcbiAgICBpZiAoIWZpeGVkIHx8IGZpeGVkIGluc3RhbmNlb2YgQVNUX05vZGUpIHJldHVybiBmaXhlZDtcbiAgICByZXR1cm4gZml4ZWQoKTtcbn0pO1xuXG5BU1RfU3ltYm9sUmVmLkRFRk1FVEhPRChcImlzX2ltbXV0YWJsZVwiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZyA9IHRoaXMuZGVmaW5pdGlvbigpLm9yaWc7XG4gICAgcmV0dXJuIG9yaWcubGVuZ3RoID09IDEgJiYgb3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xMYW1iZGE7XG59KTtcblxuZnVuY3Rpb24gZmluZF92YXJpYWJsZShjb21wcmVzc29yLCBuYW1lKSB7XG4gICAgdmFyIHNjb3BlLCBpID0gMDtcbiAgICB3aGlsZSAoc2NvcGUgPSBjb21wcmVzc29yLnBhcmVudChpKyspKSB7XG4gICAgICAgIGlmIChzY29wZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkgYnJlYWs7XG4gICAgICAgIGlmIChzY29wZSBpbnN0YW5jZW9mIEFTVF9DYXRjaCAmJiBzY29wZS5hcmduYW1lKSB7XG4gICAgICAgICAgICBzY29wZSA9IHNjb3BlLmFyZ25hbWUuZGVmaW5pdGlvbigpLnNjb3BlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlLmZpbmRfdmFyaWFibGUobmFtZSk7XG59XG5cbnZhciBnbG9iYWxfbmFtZXMgPSBtYWtlUHJlZGljYXRlKFwiQXJyYXkgQm9vbGVhbiBjbGVhckludGVydmFsIGNsZWFyVGltZW91dCBjb25zb2xlIERhdGUgZGVjb2RlVVJJIGRlY29kZVVSSUNvbXBvbmVudCBlbmNvZGVVUkkgZW5jb2RlVVJJQ29tcG9uZW50IEVycm9yIGVzY2FwZSBldmFsIEV2YWxFcnJvciBGdW5jdGlvbiBpc0Zpbml0ZSBpc05hTiBKU09OIE1hdGggTnVtYmVyIHBhcnNlRmxvYXQgcGFyc2VJbnQgUmFuZ2VFcnJvciBSZWZlcmVuY2VFcnJvciBSZWdFeHAgT2JqZWN0IHNldEludGVydmFsIHNldFRpbWVvdXQgU3RyaW5nIFN5bnRheEVycm9yIFR5cGVFcnJvciB1bmVzY2FwZSBVUklFcnJvclwiKTtcbkFTVF9TeW1ib2xSZWYuREVGTUVUSE9EKFwiaXNfZGVjbGFyZWRcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgIHJldHVybiAhdGhpcy5kZWZpbml0aW9uKCkudW5kZWNsYXJlZFxuICAgICAgICB8fCBjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZVwiKSAmJiBnbG9iYWxfbmFtZXMuaGFzKHRoaXMubmFtZSk7XG59KTtcblxuLyogLS0tLS1bIG9wdGltaXplcnMgXS0tLS0tICovXG5cbnZhciBkaXJlY3RpdmVzID0gbmV3IFNldChbXCJ1c2UgYXNtXCIsIFwidXNlIHN0cmljdFwiXSk7XG5kZWZfb3B0aW1pemUoQVNUX0RpcmVjdGl2ZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRpcmVjdGl2ZXNcIilcbiAgICAgICAgJiYgKCFkaXJlY3RpdmVzLmhhcyhzZWxmLnZhbHVlKSB8fCBjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoc2VsZi52YWx1ZSkgIT09IHNlbGYpKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9EZWJ1Z2dlciwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRyb3BfZGVidWdnZXJcIikpXG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0JyZWFrXG4gICAgICAgICYmIGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KHNlbGYuYm9keSkgPT09IHNlbGYuYm9keSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmLmxhYmVsLnJlZmVyZW5jZXMubGVuZ3RoID09IDAgPyBzZWxmLmJvZHkgOiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfQmxvY2ssIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB0aWdodGVuX2JvZHkoc2VsZi5ib2R5LCBjb21wcmVzc29yKTtcbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5mdW5jdGlvbiBjYW5fYmVfZXh0cmFjdGVkX2Zyb21faWZfYmxvY2sobm9kZSkge1xuICAgIHJldHVybiAhKFxuICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX0NvbnN0XG4gICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfTGV0XG4gICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfVXNpbmdcbiAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9DbGFzc1xuICAgICk7XG59XG5cbmRlZl9vcHRpbWl6ZShBU1RfQmxvY2tTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB0aWdodGVuX2JvZHkoc2VsZi5ib2R5LCBjb21wcmVzc29yKTtcbiAgICBzd2l0Y2ggKHNlbGYuYm9keS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKCFjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpXG4gICAgICAgICAgICAmJiBjb21wcmVzc29yLnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0lmXG4gICAgICAgICAgICAmJiBjYW5fYmVfZXh0cmFjdGVkX2Zyb21faWZfYmxvY2soc2VsZi5ib2R5WzBdKVxuICAgICAgICAgICAgfHwgY2FuX2JlX2V2aWN0ZWRfZnJvbV9ibG9jayhzZWxmLmJvZHlbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5ib2R5WzBdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOiByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmZ1bmN0aW9uIG9wdF9BU1RfTGFtYmRhKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB0aWdodGVuX2JvZHkoc2VsZi5ib2R5LCBjb21wcmVzc29yKTtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIilcbiAgICAgICAgJiYgc2VsZi5ib2R5Lmxlbmd0aCA9PSAxXG4gICAgICAgICYmIHNlbGYuYm9keVswXSA9PT0gY29tcHJlc3Nvci5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSkge1xuICAgICAgICBzZWxmLmJvZHkubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5kZWZfb3B0aW1pemUoQVNUX0xhbWJkYSwgb3B0X0FTVF9MYW1iZGEpO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiaG9pc3RfZGVjbGFyYXRpb25zXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBhc21cIikpIHJldHVybiBzZWxmO1xuXG4gICAgdmFyIGhvaXN0X2Z1bnMgPSBjb21wcmVzc29yLm9wdGlvbihcImhvaXN0X2Z1bnNcIik7XG4gICAgdmFyIGhvaXN0X3ZhcnMgPSBjb21wcmVzc29yLm9wdGlvbihcImhvaXN0X3ZhcnNcIik7XG5cbiAgICBpZiAoaG9pc3RfZnVucyB8fCBob2lzdF92YXJzKSB7XG4gICAgICAgIHZhciBkaXJzID0gW107XG4gICAgICAgIHZhciBob2lzdGVkID0gW107XG4gICAgICAgIHZhciB2YXJzID0gbmV3IE1hcCgpLCB2YXJzX2ZvdW5kID0gMCwgdmFyX2RlY2wgPSAwO1xuICAgICAgICAvLyBsZXQncyBjb3VudCB2YXJfZGVjbCBmaXJzdCwgd2Ugc2VlbSB0byB3YXN0ZSBhIGxvdCBvZlxuICAgICAgICAvLyBzcGFjZSBpZiB3ZSBob2lzdCBgdmFyYCB3aGVuIHRoZXJlJ3Mgb25seSBvbmUuXG4gICAgICAgIHdhbGsoc2VsZiwgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSAmJiBub2RlICE9PSBzZWxmKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyKSB7XG4gICAgICAgICAgICAgICAgKyt2YXJfZGVjbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGhvaXN0X3ZhcnMgPSBob2lzdF92YXJzICYmIHZhcl9kZWNsID4gMTtcbiAgICAgICAgdmFyIHR0ID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJlZm9yZShub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvaXN0X2Z1bnMgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1blxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgISh0dC5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9FeHBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB0dC5wYXJlbnQoKSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RlZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0X3ZhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhbm9kZS5kZWZpbml0aW9ucy5zb21lKGRlZiA9PiBkZWYubmFtZSBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnNldChkZWYubmFtZS5uYW1lLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdmFyc19mb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcSA9IG5vZGUudG9fYXNzaWdubWVudHMoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHR0LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfRm9ySW4gJiYgcC5pbml0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBub2RlLmRlZmluaXRpb25zWzBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1N5bWJvbFJlZiwgZGVmLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfRm9yICYmIHAuaW5pdCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlcSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2VxXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlOyAvLyB0byBhdm9pZCBkZXNjZW5kaW5nIGluIG5lc3RlZCBzY29wZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHNlbGYgPSBzZWxmLnRyYW5zZm9ybSh0dCk7XG4gICAgICAgIGlmICh2YXJzX2ZvdW5kID4gMCkge1xuICAgICAgICAgICAgLy8gY29sbGVjdCBvbmx5IHZhcnMgd2hpY2ggZG9uJ3Qgc2hvdyB1cCBpbiBzZWxmJ3MgYXJndW1lbnRzIGxpc3RcbiAgICAgICAgICAgIHZhciBkZWZzID0gW107XG4gICAgICAgICAgICBjb25zdCBpc19sYW1iZGEgPSBzZWxmIGluc3RhbmNlb2YgQVNUX0xhbWJkYTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3NfYXNfbmFtZXMgPSBpc19sYW1iZGEgPyBzZWxmLmFyZ3NfYXNfbmFtZXMoKSA6IG51bGw7XG4gICAgICAgICAgICB2YXJzLmZvckVhY2goKGRlZiwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc19sYW1iZGEgJiYgYXJnc19hc19uYW1lcy5zb21lKCh4KSA9PiB4Lm5hbWUgPT09IGRlZi5uYW1lLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZiA9IGRlZi5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgdmFycy5zZXQobmFtZSwgZGVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gbWVyZ2UgaW4gYXNzaWdubWVudHNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuYm9keS5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJvZHlbaV0gaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHNlbGYuYm9keVtpXS5ib2R5LCBzeW0sIGFzc2lnbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGV4cHIub3BlcmF0b3IgPT0gXCI9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoc3ltID0gZXhwci5sZWZ0KSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB2YXJzLmhhcyhzeW0ubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSB2YXJzLmdldChzeW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gZXhwci5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoZGVmcywgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoYXNzaWduID0gZXhwci5leHByZXNzaW9uc1swXSkgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYXNzaWduLm9wZXJhdG9yID09IFwiPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHN5bSA9IGFzc2lnbi5sZWZ0KSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB2YXJzLmhhcyhzeW0ubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSB2YXJzLmdldChzeW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gYXNzaWduLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShkZWZzLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMucHVzaChkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keVtpXS5ib2R5ID0gbWFrZV9zZXF1ZW5jZShleHByLCBleHByLmV4cHJlc3Npb25zLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5ib2R5W2ldIGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYm9keVtpXSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5LnNwbGljZShpLCAxLCAuLi5zZWxmLmJvZHlbaV0uYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmcyA9IG1ha2Vfbm9kZShBU1RfVmFyLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiBkZWZzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaG9pc3RlZC5wdXNoKGRlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuYm9keSA9IGRpcnMuY29uY2F0KGhvaXN0ZWQsIHNlbGYuYm9keSk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJob2lzdF9wcm9wZXJ0aWVzXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImhvaXN0X3Byb3BzXCIpIHx8IGNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBhc21cIikpIHJldHVybiBzZWxmO1xuICAgIHZhciB0b3BfcmV0YWluID0gc2VsZiBpbnN0YW5jZW9mIEFTVF9Ub3BsZXZlbCAmJiBjb21wcmVzc29yLnRvcF9yZXRhaW4gfHwgcmV0dXJuX2ZhbHNlO1xuICAgIHZhciBkZWZzX2J5X2lkID0gbmV3IE1hcCgpO1xuICAgIHZhciBob2lzdGVyID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1ZhckRlZikge1xuICAgICAgICAgICAgY29uc3Qgc3ltID0gbm9kZS5uYW1lO1xuICAgICAgICAgICAgbGV0IGRlZjtcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChzeW0uc2NvcGUgPT09IHNlbGZcbiAgICAgICAgICAgICAgICAmJiAhKHN5bSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xVc2luZylcbiAgICAgICAgICAgICAgICAmJiAoZGVmID0gc3ltLmRlZmluaXRpb24oKSkuZXNjYXBlZCAhPSAxXG4gICAgICAgICAgICAgICAgJiYgIWRlZi5hc3NpZ25tZW50c1xuICAgICAgICAgICAgICAgICYmICFkZWYuZGlyZWN0X2FjY2Vzc1xuICAgICAgICAgICAgICAgICYmICFkZWYuc2luZ2xlX3VzZVxuICAgICAgICAgICAgICAgICYmICFjb21wcmVzc29yLmV4cG9zZWQoZGVmKVxuICAgICAgICAgICAgICAgICYmICF0b3BfcmV0YWluKGRlZilcbiAgICAgICAgICAgICAgICAmJiAodmFsdWUgPSBzeW0uZml4ZWRfdmFsdWUoKSkgPT09IG5vZGUudmFsdWVcbiAgICAgICAgICAgICAgICAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RcbiAgICAgICAgICAgICAgICAmJiAhdmFsdWUucHJvcGVydGllcy5zb21lKHByb3AgPT5cbiAgICAgICAgICAgICAgICAgICAgcHJvcCBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24gfHwgcHJvcC5jb21wdXRlZF9rZXkoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc3NpZ25tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhbHVlLnByb3BlcnRpZXMuZm9yRWFjaCgoeyBrZXksIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGUgPSBob2lzdGVyLmZpbmRfc2NvcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0gc2VsZi5jcmVhdGVfc3ltYm9sKHN5bS5DVE9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHN5bSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3Rfc2NvcGVzOiBuZXcgU2V0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zeW0uZGVmaW5pdGlvbigpLnJlZmVyZW5jZXMubWFwKHJlZiA9PiByZWYuc2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnRhdGl2ZV9uYW1lOiBzeW0ubmFtZSArIFwiX1wiICsga2V5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuc2V0KFN0cmluZyhrZXkpLCBzeW1ib2wuZGVmaW5pdGlvbigpKTtcblxuICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50cy5wdXNoKG1ha2Vfbm9kZShBU1RfVmFyRGVmLCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVmc19ieV9pZC5zZXQoZGVmLmlkLCBkZWZzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTUFQLnNwbGljZShhc3NpZ25tZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzXG4gICAgICAgICAgICAmJiBub2RlLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgZGVmcyA9IGRlZnNfYnlfaWQuZ2V0KG5vZGUuZXhwcmVzc2lvbi5kZWZpbml0aW9uKCkuaWQpO1xuICAgICAgICAgICAgaWYgKGRlZnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWYgPSBkZWZzLmdldChTdHJpbmcoZ2V0X3NpbXBsZV9rZXkobm9kZS5wcm9wZXJ0eSkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW0gPSBtYWtlX25vZGUoQVNUX1N5bWJvbFJlZiwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkZWYubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU6IG5vZGUuZXhwcmVzc2lvbi5zY29wZSxcbiAgICAgICAgICAgICAgICAgICAgdGhlZGVmOiBkZWZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzeW0ucmVmZXJlbmNlKHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGYudHJhbnNmb3JtKGhvaXN0ZXIpO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2lkZV9lZmZlY3RzXCIpKSB7XG4gICAgICAgIHZhciBib2R5ID0gc2VsZi5ib2R5O1xuICAgICAgICB2YXIgbm9kZSA9IGJvZHkuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIHRydWUpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAhPT0gYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7IGJvZHk6IG5vZGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9XaGlsZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHJldHVybiBjb21wcmVzc29yLm9wdGlvbihcImxvb3BzXCIpID8gbWFrZV9ub2RlKEFTVF9Gb3IsIHNlbGYsIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpIDogc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0RvLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImxvb3BzXCIpKSByZXR1cm4gc2VsZjtcbiAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uLnRhaWxfbm9kZSgpLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgIGlmICghKGNvbmQgaW5zdGFuY2VvZiBBU1RfTm9kZSkpIHtcbiAgICAgICAgaWYgKGNvbmQpIHJldHVybiBtYWtlX25vZGUoQVNUX0Zvciwgc2VsZiwge1xuICAgICAgICAgICAgYm9keTogbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZi5ib2R5LCB7XG4gICAgICAgICAgICAgICAgYm9keTogW1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHksXG4gICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2VsZi5jb25kaXRpb25cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKCFoYXNfYnJlYWtfb3JfY29udGludWUoc2VsZiwgY29tcHJlc3Nvci5wYXJlbnQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLmJvZHksIHtcbiAgICAgICAgICAgICAgICBib2R5OiBbXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmZ1bmN0aW9uIGlmX2JyZWFrX2luX2xvb3Aoc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHZhciBmaXJzdCA9IHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCA/IHNlbGYuYm9keS5ib2R5WzBdIDogc2VsZi5ib2R5O1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSAmJiBpc19icmVhayhmaXJzdCkpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgaWYgKHNlbGYuaW5pdCBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIGJvZHkucHVzaChzZWxmLmluaXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaW5pdCkge1xuICAgICAgICAgICAgYm9keS5wdXNoKG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLmluaXQsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmluaXRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24pIHtcbiAgICAgICAgICAgIGJvZHkucHVzaChtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmNvbmRpdGlvblxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhY3RfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHNlbGYuYm9keSwgYm9keSk7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgaWYgKGlzX2JyZWFrKGZpcnN0LmJvZHkpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiJiZcIixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZpcnN0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3NvciksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gZmlyc3QuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyb3BfaXQoZmlyc3QuYWx0ZXJuYXRpdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX2JyZWFrKGZpcnN0LmFsdGVybmF0aXZlKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiYmXCIsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmaXJzdC5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gZmlyc3QuY29uZGl0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJvcF9pdChmaXJzdC5ib2R5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcblxuICAgIGZ1bmN0aW9uIGlzX2JyZWFrKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBBU1RfQnJlYWtcbiAgICAgICAgICAgICYmIGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KG5vZGUpID09PSBjb21wcmVzc29yLnNlbGYoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcm9wX2l0KHJlc3QpIHtcbiAgICAgICAgcmVzdCA9IGFzX3N0YXRlbWVudF9hcnJheShyZXN0KTtcbiAgICAgICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LmNsb25lKCk7XG4gICAgICAgICAgICBzZWxmLmJvZHkuYm9keSA9IHJlc3QuY29uY2F0KHNlbGYuYm9keS5ib2R5LnNsaWNlKDEpKTtcbiAgICAgICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLmJvZHksIHtcbiAgICAgICAgICAgICAgICBib2R5OiByZXN0XG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZiA9IGlmX2JyZWFrX2luX2xvb3Aoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgfVxufVxuXG5kZWZfb3B0aW1pemUoQVNUX0ZvciwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJsb29wc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2lkZV9lZmZlY3RzXCIpICYmIHNlbGYuaW5pdCkge1xuICAgICAgICBzZWxmLmluaXQgPSBzZWxmLmluaXQuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5jb25kaXRpb24pIHtcbiAgICAgICAgdmFyIGNvbmQgPSBzZWxmLmNvbmRpdGlvbi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKCEoY29uZCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSkge1xuICAgICAgICAgICAgaWYgKGNvbmQpIHNlbGYuY29uZGl0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnID0gc2VsZi5jb25kaXRpb247XG4gICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBtYWtlX25vZGVfZnJvbV9jb25zdGFudChjb25kLCBzZWxmLmNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBiZXN0X29mX2V4cHJlc3Npb24oc2VsZi5jb25kaXRpb24udHJhbnNmb3JtKGNvbXByZXNzb3IpLCBvcmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikpIHtcbiAgICAgICAgICAgIGlmIChjb25kIGluc3RhbmNlb2YgQVNUX05vZGUpIGNvbmQgPSBzZWxmLmNvbmRpdGlvbi50YWlsX25vZGUoKS5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGlmICghY29uZCkge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc2VsZi5ib2R5LCBib2R5KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5pbml0IGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2goc2VsZi5pbml0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYuaW5pdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2VsZi5pbml0XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmNvbmRpdGlvblxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwgeyBib2R5OiBib2R5IH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZl9icmVha19pbl9sb29wKHNlbGYsIGNvbXByZXNzb3IpO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfSWYsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoaXNfZW1wdHkoc2VsZi5hbHRlcm5hdGl2ZSkpIHNlbGYuYWx0ZXJuYXRpdmUgPSBudWxsO1xuXG4gICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImNvbmRpdGlvbmFsc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgLy8gaWYgY29uZGl0aW9uIGNhbiBiZSBzdGF0aWNhbGx5IGRldGVybWluZWQsIGRyb3BcbiAgICAvLyBvbmUgb2YgdGhlIGJsb2Nrcy4gIG5vdGUsIHN0YXRpY2FsbHkgZGV0ZXJtaW5lZCBpbXBsaWVzXG4gICAgLy8g4oCcaGFzIG5vIHNpZGUgZWZmZWN0c+KAnTsgYWxzbyBpdCBkb2Vzbid0IHdvcmsgZm9yIGNhc2VzIGxpa2VcbiAgICAvLyBgeCAmJiB0cnVlYCwgdGhvdWdoIGl0IHByb2JhYmx5IHNob3VsZC5cbiAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikgJiYgIShjb25kIGluc3RhbmNlb2YgQVNUX05vZGUpKSB7XG4gICAgICAgIHZhciBvcmlnID0gc2VsZi5jb25kaXRpb247XG4gICAgICAgIHNlbGYuY29uZGl0aW9uID0gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoY29uZCwgb3JpZyk7XG4gICAgICAgIHNlbGYuY29uZGl0aW9uID0gYmVzdF9vZl9leHByZXNzaW9uKHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybShjb21wcmVzc29yKSwgb3JpZyk7XG4gICAgfVxuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICBpZiAoY29uZCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSBjb25kID0gc2VsZi5jb25kaXRpb24udGFpbF9ub2RlKCkuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmICghY29uZCkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgICAgIGV4dHJhY3RfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHNlbGYuYm9keSwgYm9keSk7XG4gICAgICAgICAgICBib2R5LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgYm9keTogc2VsZi5jb25kaXRpb25cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlKSBib2R5LnB1c2goc2VsZi5hbHRlcm5hdGl2ZSk7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwgeyBib2R5OiBib2R5IH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCEoY29uZCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgICAgIGJvZHkucHVzaChtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmNvbmRpdGlvblxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgYm9keS5wdXNoKHNlbGYuYm9keSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHNlbGYuYWx0ZXJuYXRpdmUsIGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHsgYm9keTogYm9keSB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmVnYXRlZCA9IHNlbGYuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICB2YXIgc2VsZl9jb25kaXRpb25fbGVuZ3RoID0gc2VsZi5jb25kaXRpb24uc2l6ZSgpO1xuICAgIHZhciBuZWdhdGVkX2xlbmd0aCA9IG5lZ2F0ZWQuc2l6ZSgpO1xuICAgIHZhciBuZWdhdGVkX2lzX2Jlc3QgPSBuZWdhdGVkX2xlbmd0aCA8IHNlbGZfY29uZGl0aW9uX2xlbmd0aDtcbiAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSAmJiBuZWdhdGVkX2lzX2Jlc3QpIHtcbiAgICAgICAgbmVnYXRlZF9pc19iZXN0ID0gZmFsc2U7IC8vIGJlY2F1c2Ugd2UgYWxyZWFkeSBkbyB0aGUgc3dpdGNoIGhlcmUuXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gc3dhcCB2YWx1ZXMgb2Ygc2VsZl9jb25kaXRpb25fbGVuZ3RoIGFuZCBuZWdhdGVkX2xlbmd0aFxuICAgICAgICAvLyBoZXJlIGJlY2F1c2UgdGhleSBhcmUgb25seSB1c2VkIGluIGFuIGVxdWFsaXR5IGNvbXBhcmlzb24gbGF0ZXIgb24uXG4gICAgICAgIHNlbGYuY29uZGl0aW9uID0gbmVnYXRlZDtcbiAgICAgICAgdmFyIHRtcCA9IHNlbGYuYm9keTtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5hbHRlcm5hdGl2ZSB8fCBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IHRtcDtcbiAgICB9XG4gICAgaWYgKGlzX2VtcHR5KHNlbGYuYm9keSkgJiYgaXNfZW1wdHkoc2VsZi5hbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgYm9keTogc2VsZi5jb25kaXRpb24uY2xvbmUoKVxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnRcbiAgICAgICAgJiYgc2VsZi5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICBib2R5OiBtYWtlX25vZGUoQVNUX0NvbmRpdGlvbmFsLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uICAgOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW50ICA6IHNlbGYuYm9keS5ib2R5LFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlIDogc2VsZi5hbHRlcm5hdGl2ZS5ib2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgaWYgKGlzX2VtcHR5KHNlbGYuYWx0ZXJuYXRpdmUpICYmIHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgaWYgKHNlbGZfY29uZGl0aW9uX2xlbmd0aCA9PT0gbmVnYXRlZF9sZW5ndGggJiYgIW5lZ2F0ZWRfaXNfYmVzdFxuICAgICAgICAgICAgJiYgc2VsZi5jb25kaXRpb24gaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIHNlbGYuY29uZGl0aW9uLm9wZXJhdG9yID09IFwifHxcIikge1xuICAgICAgICAgICAgLy8gYWx0aG91Z2ggdGhlIGNvZGUgbGVuZ3RoIG9mIHNlbGYuY29uZGl0aW9uIGFuZCBuZWdhdGVkIGFyZSB0aGUgc2FtZSxcbiAgICAgICAgICAgIC8vIG5lZ2F0ZWQgZG9lcyBub3QgcmVxdWlyZSBhZGRpdGlvbmFsIHN1cnJvdW5kaW5nIHBhcmVudGhlc2VzLlxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2lzc3Vlcy85NzlcbiAgICAgICAgICAgIG5lZ2F0ZWRfaXNfYmVzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZ2F0ZWRfaXNfYmVzdCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICBib2R5OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogXCJ8fFwiLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbmVnYXRlZCxcbiAgICAgICAgICAgICAgICByaWdodCAgICA6IHNlbGYuYm9keS5ib2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICBib2R5OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogXCImJlwiLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgIDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgcmlnaHQgICAgOiBzZWxmLmJvZHkuYm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnRcbiAgICAgICAgJiYgc2VsZi5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICBib2R5OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogXCJ8fFwiLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgIDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgcmlnaHQgICAgOiBzZWxmLmFsdGVybmF0aXZlLmJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0V4aXRcbiAgICAgICAgJiYgc2VsZi5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9FeGl0XG4gICAgICAgICYmIHNlbGYuYm9keS5UWVBFID09IHNlbGYuYWx0ZXJuYXRpdmUuVFlQRSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKHNlbGYuYm9keS5DVE9SLCBzZWxmLCB7XG4gICAgICAgICAgICB2YWx1ZTogbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbiAgIDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgY29uc2VxdWVudCAgOiBzZWxmLmJvZHkudmFsdWUgfHwgbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYuYm9keSksXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmUgOiBzZWxmLmFsdGVybmF0aXZlLnZhbHVlIHx8IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmLmFsdGVybmF0aXZlKVxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpXG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0lmXG4gICAgICAgICYmICFzZWxmLmJvZHkuYWx0ZXJuYXRpdmVcbiAgICAgICAgJiYgIXNlbGYuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfSWYsIHNlbGYsIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbjogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiJiZcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICByaWdodDogc2VsZi5ib2R5LmNvbmRpdGlvblxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBib2R5OiBzZWxmLmJvZHkuYm9keSxcbiAgICAgICAgICAgIGFsdGVybmF0aXZlOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYWJvcnRzKHNlbGYuYm9keSkpIHtcbiAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHZhciBhbHQgPSBzZWxmLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IFsgc2VsZiwgYWx0IF1cbiAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhYm9ydHMoc2VsZi5hbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBzZWxmLmJvZHk7XG4gICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYWx0ZXJuYXRpdmU7XG4gICAgICAgIHNlbGYuY29uZGl0aW9uID0gbmVnYXRlZF9pc19iZXN0ID8gbmVnYXRlZCA6IHNlbGYuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICBib2R5OiBbIHNlbGYsIGJvZHkgXVxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9Td2l0Y2gsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwic3dpdGNoZXNcIikpIHJldHVybiBzZWxmO1xuICAgIHZhciBicmFuY2g7XG4gICAgdmFyIHZhbHVlID0gc2VsZi5leHByZXNzaW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQVNUX05vZGUpKSB7XG4gICAgICAgIHZhciBvcmlnID0gc2VsZi5leHByZXNzaW9uO1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBtYWtlX25vZGVfZnJvbV9jb25zdGFudCh2YWx1ZSwgb3JpZyk7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IGJlc3Rfb2ZfZXhwcmVzc2lvbihzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKGNvbXByZXNzb3IpLCBvcmlnKTtcbiAgICB9XG4gICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQVNUX05vZGUpIHtcbiAgICAgICAgdmFsdWUgPSBzZWxmLmV4cHJlc3Npb24udGFpbF9ub2RlKCkuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIHZhciBkZWNsID0gW107XG4gICAgdmFyIGJvZHkgPSBbXTtcbiAgICB2YXIgZGVmYXVsdF9icmFuY2g7XG4gICAgdmFyIGV4YWN0X21hdGNoO1xuICAgIC8vIC0gY29tcHJlc3Mgc2VsZi5ib2R5IGludG8gYGJvZHlgXG4gICAgLy8gLSBmaW5kIGFuZCBkZWR1cGxpY2F0ZSBkZWZhdWx0IGJyYW5jaFxuICAgIC8vIC0gZmluZCB0aGUgZXhhY3QgbWF0Y2ggKGBjYXNlIDEyMzRgIGluc2lkZSBgc3dpdGNoKDEyMzQpYClcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5ib2R5Lmxlbmd0aDsgaSA8IGxlbiAmJiAhZXhhY3RfbWF0Y2g7IGkrKykge1xuICAgICAgICBicmFuY2ggPSBzZWxmLmJvZHlbaV07XG4gICAgICAgIGlmIChicmFuY2ggaW5zdGFuY2VvZiBBU1RfRGVmYXVsdCkge1xuICAgICAgICAgICAgaWYgKCFkZWZhdWx0X2JyYW5jaCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRfYnJhbmNoID0gYnJhbmNoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGltaW5hdGVfYnJhbmNoKGJyYW5jaCwgYm9keVtib2R5Lmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQVNUX05vZGUpKSB7XG4gICAgICAgICAgICB2YXIgZXhwID0gYnJhbmNoLmV4cHJlc3Npb24uZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBpZiAoIShleHAgaW5zdGFuY2VvZiBBU1RfTm9kZSkgJiYgZXhwICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGVsaW1pbmF0ZV9icmFuY2goYnJhbmNoLCBib2R5W2JvZHkubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cCBpbnN0YW5jZW9mIEFTVF9Ob2RlICYmICFleHAuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgIGV4cCA9IGJyYW5jaC5leHByZXNzaW9uLnRhaWxfbm9kZSgpLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBleGFjdF9tYXRjaCA9IGJyYW5jaDtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdF9icmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRfaW5kZXggPSBib2R5LmluZGV4T2YoZGVmYXVsdF9icmFuY2gpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LnNwbGljZShkZWZhdWx0X2luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZWxpbWluYXRlX2JyYW5jaChkZWZhdWx0X2JyYW5jaCwgYm9keVtkZWZhdWx0X2luZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0X2JyYW5jaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJvZHkucHVzaChicmFuY2gpO1xuICAgIH1cbiAgICAvLyBpIDwgbGVuIGlmIHdlIGZvdW5kIGFuIGV4YWN0X21hdGNoLiBlbGltaW5hdGUgdGhlIHJlc3RcbiAgICB3aGlsZSAoaSA8IGxlbikgZWxpbWluYXRlX2JyYW5jaChzZWxmLmJvZHlbaSsrXSwgYm9keVtib2R5Lmxlbmd0aCAtIDFdKTtcbiAgICBzZWxmLmJvZHkgPSBib2R5O1xuXG4gICAgbGV0IGRlZmF1bHRfb3JfZXhhY3QgPSBkZWZhdWx0X2JyYW5jaCB8fCBleGFjdF9tYXRjaDtcbiAgICBkZWZhdWx0X2JyYW5jaCA9IG51bGw7XG4gICAgZXhhY3RfbWF0Y2ggPSBudWxsO1xuXG4gICAgLy8gZ3JvdXAgZXF1aXZhbGVudCBicmFuY2hlcyBzbyB0aGV5IHdpbGwgYmUgbG9jYXRlZCBuZXh0IHRvIGVhY2ggb3RoZXIsXG4gICAgLy8gdGhhdCB3YXkgdGhlIG5leHQgbWljcm8tb3B0aW1pemF0aW9uIHdpbGwgbWVyZ2UgdGhlbS5cbiAgICAvLyAqKiBiYWlsIG1pY3JvLW9wdGltaXphdGlvbiBpZiBub3QgYSBzaW1wbGUgc3dpdGNoIGNhc2Ugd2l0aCBicmVha3NcbiAgICBpZiAoYm9keS5ldmVyeSgoYnJhbmNoLCBpKSA9PlxuICAgICAgICAoYnJhbmNoID09PSBkZWZhdWx0X29yX2V4YWN0IHx8IGJyYW5jaC5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX0NvbnN0YW50KVxuICAgICAgICAmJiAoYnJhbmNoLmJvZHkubGVuZ3RoID09PSAwIHx8IGFib3J0cyhicmFuY2gpIHx8IGJvZHkubGVuZ3RoIC0gMSA9PT0gaSkpXG4gICAgKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYnJhbmNoID0gYm9keVtpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGJvZHkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gYm9keVtqXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5ib2R5Lmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdF9icmFuY2ggPSBqID09PSAoYm9keS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcXVpdmFsZW50QnJhbmNoID0gYnJhbmNoZXNfZXF1aXZhbGVudChuZXh0LCBicmFuY2gsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXF1aXZhbGVudEJyYW5jaCB8fCAobGFzdF9icmFuY2ggJiYgYnJhbmNoZXNfZXF1aXZhbGVudChuZXh0LCBicmFuY2gsIHRydWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWl2YWxlbnRCcmFuY2ggJiYgbGFzdF9icmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuYm9keS5wdXNoKG1ha2Vfbm9kZShBU1RfQnJlYWspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGZpbmQgcHJldmlvdXMgc2libGluZ3Mgd2l0aCBpbmVydCBmYWxsdGhyb3VnaC4uLlxuICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IGogLSAxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmFsbHRocm91Z2hEZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh4ID4gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2luZXJ0X2JvZHkoYm9keVt4LS1dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGx0aHJvdWdoRGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbHVja2VkID0gYm9keS5zcGxpY2UoaiAtIGZhbGx0aHJvdWdoRGVwdGgsIDEgKyBmYWxsdGhyb3VnaERlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5zcGxpY2UoaSArIDEsIDAsIC4uLnBsdWNrZWQpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IHBsdWNrZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1lcmdlIGVxdWl2YWxlbnQgYnJhbmNoZXMgaW4gYSByb3dcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGJyYW5jaCA9IGJvZHlbaV07XG4gICAgICAgIGlmIChicmFuY2guYm9keS5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWFib3J0cyhicmFuY2gpKSBjb250aW51ZTtcblxuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBib2R5Lmxlbmd0aDsgaSsrLCBqKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gYm9keVtqXTtcbiAgICAgICAgICAgIGlmIChuZXh0LmJvZHkubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBicmFuY2hlc19lcXVpdmFsZW50KG5leHQsIGJyYW5jaCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgfHwgKGogPT09IGJvZHkubGVuZ3RoIC0gMSAmJiBicmFuY2hlc19lcXVpdmFsZW50KG5leHQsIGJyYW5jaCwgdHJ1ZSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBicmFuY2guYm9keSA9IFtdO1xuICAgICAgICAgICAgICAgIGJyYW5jaCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBydW5lIGFueSBlbXB0eSBicmFuY2hlcyBhdCB0aGUgZW5kIG9mIHRoZSBzd2l0Y2ggc3RhdGVtZW50LlxuICAgIHtcbiAgICAgICAgbGV0IGkgPSBib2R5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGJib2R5ID0gYm9keVtpXS5ib2R5O1xuICAgICAgICAgICAgd2hpbGUgKGlzX2JyZWFrKGJib2R5W2Jib2R5Lmxlbmd0aCAtIDFdLCBjb21wcmVzc29yKSkgYmJvZHkucG9wKCk7XG4gICAgICAgICAgICBpZiAoIWlzX2luZXJ0X2JvZHkoYm9keVtpXSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGkgbm93IHBvaW50cyB0byB0aGUgaW5kZXggb2YgYSBicmFuY2ggdGhhdCBjb250YWlucyBhIGJvZHkuIEJ5IGluY3JlbWVudGluZywgaXQnc1xuICAgICAgICAvLyBwb2ludGluZyB0byB0aGUgZmlyc3QgYnJhbmNoIHRoYXQncyBlbXB0eS5cbiAgICAgICAgaSsrO1xuICAgICAgICBpZiAoIWRlZmF1bHRfb3JfZXhhY3QgfHwgYm9keS5pbmRleE9mKGRlZmF1bHRfb3JfZXhhY3QpID49IGkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGRvIG5vdGhpbmcuIFdlIGNhbiB0YWtlIGFkdmFudGFnZSBvZiB0aGF0IHRvXG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIGNhc2UgZXhwcmVzc2lvbnMgdGhhdCBhcmUgc2lkZS1lZmZlY3QgZnJlZSB0aGF0IGFsc28gZG9cbiAgICAgICAgICAgIC8vIG5vdGhpbmcsIHNpbmNlIHRoZXknbGwgZGVmYXVsdCB0byBkb2luZyBub3RoaW5nLiBCdXQgd2UgY2FuJ3QgcmVtb3ZlIGFueVxuICAgICAgICAgICAgLy8gY2FzZSBleHByZXNzaW9ucyBiZWZvcmUgb25lIHRoYXQgd291bGQgc2lkZS1lZmZlY3QsIHNpbmNlIHRoZXkgbWF5IGNhdXNlXG4gICAgICAgICAgICAvLyB0aGUgc2lkZS1lZmZlY3QgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSBib2R5Lmxlbmd0aCAtIDE7IGogPj0gaTsgai0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJyYW5jaCA9IGJvZHlbal07XG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaCA9PT0gZGVmYXVsdF9vcl9leGFjdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0X29yX2V4YWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZWxpbWluYXRlX2JyYW5jaChib2R5LnBvcCgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFicmFuY2guZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsaW1pbmF0ZV9icmFuY2goYm9keS5wb3AoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBQcnVuZSBzaWRlLWVmZmVjdCBmcmVlIGJyYW5jaGVzIHRoYXQgZmFsbCBpbnRvIGRlZmF1bHQuXG4gICAgREVGQVVMVDogaWYgKGRlZmF1bHRfb3JfZXhhY3QpIHtcbiAgICAgICAgbGV0IGRlZmF1bHRfaW5kZXggPSBib2R5LmluZGV4T2YoZGVmYXVsdF9vcl9leGFjdCk7XG4gICAgICAgIGxldCBkZWZhdWx0X2JvZHlfaW5kZXggPSBkZWZhdWx0X2luZGV4O1xuICAgICAgICBmb3IgKDsgZGVmYXVsdF9ib2R5X2luZGV4IDwgYm9keS5sZW5ndGggLSAxOyBkZWZhdWx0X2JvZHlfaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKCFpc19pbmVydF9ib2R5KGJvZHlbZGVmYXVsdF9ib2R5X2luZGV4XSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0X2JvZHlfaW5kZXggPCBib2R5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGJyZWFrIERFRkFVTFQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2lkZV9lZmZlY3RfaW5kZXggPSBib2R5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAoOyBzaWRlX2VmZmVjdF9pbmRleCA+PSAwOyBzaWRlX2VmZmVjdF9pbmRleC0tKSB7XG4gICAgICAgICAgICBsZXQgYnJhbmNoID0gYm9keVtzaWRlX2VmZmVjdF9pbmRleF07XG4gICAgICAgICAgICBpZiAoYnJhbmNoID09PSBkZWZhdWx0X29yX2V4YWN0KSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChicmFuY2guZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZGVmYXVsdCBiZWhhdmlvciBjb21lcyBhZnRlciBhbnkgc2lkZS1lZmZlY3QgY2FzZSBleHByZXNzaW9ucyxcbiAgICAgICAgLy8gdGhlbiB3ZSBjYW4gZm9sZCBhbGwgc2lkZS1lZmZlY3QgZnJlZSBjYXNlcyBpbnRvIHRoZSBkZWZhdWx0IGJyYW5jaC5cbiAgICAgICAgLy8gSWYgdGhlIHNpZGUtZWZmZWN0IGNhc2UgaXMgYWZ0ZXIgdGhlIGRlZmF1bHQsIHRoZW4gYW55IHNpZGUtZWZmZWN0XG4gICAgICAgIC8vIGZyZWUgY2FzZXMgY291bGQgcHJldmVudCB0aGUgc2lkZS1lZmZlY3QgZnJvbSBvY2N1cnJpbmcuXG4gICAgICAgIGlmIChkZWZhdWx0X2JvZHlfaW5kZXggPiBzaWRlX2VmZmVjdF9pbmRleCkge1xuICAgICAgICAgICAgbGV0IHByZXZfYm9keV9pbmRleCA9IGRlZmF1bHRfaW5kZXggLSAxO1xuICAgICAgICAgICAgZm9yICg7IHByZXZfYm9keV9pbmRleCA+PSAwOyBwcmV2X2JvZHlfaW5kZXgtLSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNfaW5lcnRfYm9keShib2R5W3ByZXZfYm9keV9pbmRleF0pKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBNYXRoLm1heChzaWRlX2VmZmVjdF9pbmRleCwgcHJldl9ib2R5X2luZGV4KSArIDE7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkZWZhdWx0X2luZGV4O1xuICAgICAgICAgICAgaWYgKHNpZGVfZWZmZWN0X2luZGV4ID4gZGVmYXVsdF9pbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkZWZhdWx0IGZhbGxzIGludG8gdGhlIHNhbWUgYm9keSBhcyBhIHNpZGUtZWZmZWN0XG4gICAgICAgICAgICAgICAgLy8gY2FzZSwgdGhlbiB3ZSBuZWVkIHByZXNlcnZlIHRoYXQgY2FzZSBhbmQgb25seSBwcnVuZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBjYXNlcyBhZnRlciBpdC5cbiAgICAgICAgICAgICAgICBhZnRlciA9IHNpZGVfZWZmZWN0X2luZGV4O1xuICAgICAgICAgICAgICAgIGJvZHlbc2lkZV9lZmZlY3RfaW5kZXhdLmJvZHkgPSBib2R5W2RlZmF1bHRfYm9keV9pbmRleF0uYm9keTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgd2lsbCBiZSB0aGUgbGFzdCBicmFuY2guXG4gICAgICAgICAgICAgICAgZGVmYXVsdF9vcl9leGFjdC5ib2R5ID0gYm9keVtkZWZhdWx0X2JvZHlfaW5kZXhdLmJvZHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBydW5lIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGRlZmF1bHQgKG9yIGxhc3Qgc2lkZS1lZmZlY3QgY2FzZSlcbiAgICAgICAgICAgIC8vIHVudGlsIHRoZSBuZXh0IGNhc2Ugd2l0aCBhIGJvZHkuXG4gICAgICAgICAgICBib2R5LnNwbGljZShhZnRlciArIDEsIGRlZmF1bHRfYm9keV9pbmRleCAtIGFmdGVyKTtcbiAgICAgICAgICAgIC8vIFBydW5lIGV2ZXJ5dGhpbmcgYmVmb3JlIHRoZSBkZWZhdWx0IHRoYXQgZmFsbHMgaW50byBpdC5cbiAgICAgICAgICAgIGJvZHkuc3BsaWNlKGJlZm9yZSwgZGVmYXVsdF9pbmRleCAtIGJlZm9yZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZWUgaWYgd2UgY2FuIHJlbW92ZSB0aGUgc3dpdGNoIGVudGlyZWx5IGlmIGFsbCBjYXNlcyAodGhlIGRlZmF1bHQpIGZhbGwgaW50byB0aGUgc2FtZSBjYXNlIGJvZHkuXG4gICAgREVGQVVMVDogaWYgKGRlZmF1bHRfb3JfZXhhY3QpIHtcbiAgICAgICAgbGV0IGkgPSBib2R5LmZpbmRJbmRleChicmFuY2ggPT4gIWlzX2luZXJ0X2JvZHkoYnJhbmNoKSk7XG4gICAgICAgIGxldCBjYXNlQm9keTtcbiAgICAgICAgLy8gYGlgIGlzIGVxdWFsIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgICAgICAvLyAtIGAtMWAsIHRoZXJlIGlzIG5vIGJvZHkgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQuXG4gICAgICAgIC8vIC0gYGJvZHkubGVuZ3RoIC0gMWAsIGFsbCBjYXNlcyBmYWxsIGludG8gdGhlIHNhbWUgYm9keS5cbiAgICAgICAgLy8gLSBhbnl0aGluZyBlbHNlLCB0aGVyZSBhcmUgbXVsdGlwbGUgYm9kaWVzIGluIHRoZSBzd2l0Y2guXG4gICAgICAgIGlmIChpID09PSBib2R5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIEFsbCBjYXNlcyBmYWxsIGludG8gdGhlIGNhc2UgYm9keS5cbiAgICAgICAgICAgIGxldCBicmFuY2ggPSBib2R5W2ldO1xuICAgICAgICAgICAgaWYgKGhhc19uZXN0ZWRfYnJlYWsoc2VsZikpIGJyZWFrIERFRkFVTFQ7XG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3QgY2FzZSBib2R5LCBhbmQgd2UndmUgYWxyZWFkeSBwcnVuZWQgYW55IGJyZWFrcywgc28gaXQnc1xuICAgICAgICAgICAgLy8gc2FmZSB0byBob2lzdC5cbiAgICAgICAgICAgIGNhc2VCb2R5ID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgYnJhbmNoLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYnJhbmNoLmJvZHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJhbmNoLmJvZHkgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGJvZGllcywgdGhlbiB3ZSBjYW5ub3Qgb3B0aW1pemUgYW55dGhpbmcuXG4gICAgICAgICAgICBicmVhayBERUZBVUxUO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNpZGVFZmZlY3QgPSBib2R5LmZpbmQoXG4gICAgICAgICAgICBicmFuY2ggPT4gYnJhbmNoICE9PSBkZWZhdWx0X29yX2V4YWN0ICYmIGJyYW5jaC5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgKTtcbiAgICAgICAgLy8gSWYgbm8gY2FzZXMgY2F1c2UgYSBzaWRlLWVmZmVjdCwgd2UgY2FuIGVsaW1pbmF0ZSB0aGUgc3dpdGNoIGVudGlyZWx5LlxuICAgICAgICBpZiAoIXNpZGVFZmZlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYm9keTogZGVjbC5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudChzZWxmLmV4cHJlc3Npb24pLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0X29yX2V4YWN0LmV4cHJlc3Npb24gPyBzdGF0ZW1lbnQoZGVmYXVsdF9vcl9leGFjdC5leHByZXNzaW9uKSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICBjYXNlQm9keSB8fCBbXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UncmUgdGhpcyBmYXIsIGVpdGhlciB0aGVyZSB3YXMgbm8gYm9keSBvciBhbGwgY2FzZXMgZmVsbCBpbnRvIHRoZSBzYW1lIGJvZHkuXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBib2R5LCB0aGVuIHdlIGRvbid0IG5lZWQgYSBkZWZhdWx0IGJyYW5jaCAoYmVjYXVzZSB0aGUgZGVmYXVsdCBpc1xuICAgICAgICAvLyBkbyBub3RoaW5nKS4gSWYgdGhlcmUgd2FzIGEgYm9keSwgd2UnbGwgZXh0cmFjdCBpdCB0byBhZnRlciB0aGUgc3dpdGNoLCBzbyB0aGVcbiAgICAgICAgLy8gc3dpdGNoJ3MgbmV3IGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyBhbmQgd2UgY2FuIHN0aWxsIHBydW5lIGl0LlxuICAgICAgICBjb25zdCBkZWZhdWx0X2luZGV4ID0gYm9keS5pbmRleE9mKGRlZmF1bHRfb3JfZXhhY3QpO1xuICAgICAgICBib2R5LnNwbGljZShkZWZhdWx0X2luZGV4LCAxKTtcbiAgICAgICAgZGVmYXVsdF9vcl9leGFjdCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGNhc2VCb2R5KSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNlIGludG8gc3dpdGNoIHN0YXRlbWVudCBvbmUgbW9yZSB0aW1lIHNvIHRoYXQgd2UgY2FuIGFwcGVuZCB0aGUgY2FzZSBib2R5XG4gICAgICAgICAgICAvLyBvdXRzaWRlIG9mIHRoZSBzd2l0Y2guIFRoaXMgcmVjdXJzaW9uIHdpbGwgb25seSBoYXBwZW4gb25jZSBzaW5jZSB3ZSd2ZSBwcnVuZWRcbiAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IGNhc2UuXG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGRlY2wuY29uY2F0KHNlbGYsIGNhc2VCb2R5KVxuICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZmFsbCBoZXJlLCB0aGVyZSBpcyBhIGRlZmF1bHQgYnJhbmNoIHNvbWV3aGVyZSwgdGhlcmUgYXJlIG5vIGNhc2UgYm9kaWVzLFxuICAgICAgICAvLyBhbmQgdGhlcmUncyBhIHNpZGUtZWZmZWN0IHNvbWV3aGVyZS4gSnVzdCBsZXQgdGhlIGJlbG93IHBhdGhzIHRha2UgY2FyZSBvZiBpdC5cbiAgICB9XG5cbiAgICAvLyBSZWludGVncmF0ZSBgZGVjbGAgKHZhciBzdGF0ZW1lbnRzKVxuICAgIGlmIChib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgYm9keVswXS5ib2R5ID0gZGVjbC5jb25jYXQoYm9keVswXS5ib2R5KTtcbiAgICB9XG4gICAgaWYgKGJvZHkubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgIGJvZHk6IGRlY2wuY29uY2F0KHN0YXRlbWVudChzZWxmLmV4cHJlc3Npb24pKVxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG5cbiAgICBpZiAoYm9keS5sZW5ndGggPT0gMSAmJiAhaGFzX25lc3RlZF9icmVhayhzZWxmKSkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IGNhc2UgYm9keSwgYW5kIHdlJ3ZlIGFscmVhZHkgcHJ1bmVkIGFueSBicmVha3MsIHNvIGl0J3NcbiAgICAgICAgLy8gc2FmZSB0byBob2lzdC5cbiAgICAgICAgbGV0IGJyYW5jaCA9IGJvZHlbMF07XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0lmLCBzZWxmLCB7XG4gICAgICAgICAgICBjb25kaXRpb246IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPT09XCIsXG4gICAgICAgICAgICAgICAgbGVmdDogc2VsZi5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBicmFuY2guZXhwcmVzc2lvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYm9keTogbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgYnJhbmNoLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYnJhbmNoLmJvZHlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IG51bGxcbiAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIGlmIChib2R5Lmxlbmd0aCA9PT0gMiAmJiBkZWZhdWx0X29yX2V4YWN0ICYmICFoYXNfbmVzdGVkX2JyZWFrKHNlbGYpKSB7XG4gICAgICAgIGxldCBicmFuY2ggPSBib2R5WzBdID09PSBkZWZhdWx0X29yX2V4YWN0ID8gYm9keVsxXSA6IGJvZHlbMF07XG4gICAgICAgIGxldCBleGFjdF9leHAgPSBkZWZhdWx0X29yX2V4YWN0LmV4cHJlc3Npb24gJiYgc3RhdGVtZW50KGRlZmF1bHRfb3JfZXhhY3QuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChhYm9ydHMoYm9keVswXSkpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdGhlIGZpcnN0IGJyYW5jaCBib2R5IGNvdWxkIGhhdmUgYSBicmVhayAoYXQgdGhlIGxhc3Qgc3RhdGVtZW50KVxuICAgICAgICAgICAgbGV0IGZpcnN0ID0gYm9keVswXTtcbiAgICAgICAgICAgIGlmIChpc19icmVhayhmaXJzdC5ib2R5W2ZpcnN0LmJvZHkubGVuZ3RoIC0gMV0sIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3QuYm9keS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0lmLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9PT1cIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogYnJhbmNoLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgYm9keTogbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgYnJhbmNoLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJyYW5jaC5ib2R5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIGRlZmF1bHRfb3JfZXhhY3QsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogW10uY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3RfZXhwIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdF9vcl9leGFjdC5ib2R5XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZXJhdG9yID0gXCI9PT1cIjtcbiAgICAgICAgbGV0IGNvbnNlcXVlbnQgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBicmFuY2gsIHtcbiAgICAgICAgICAgIGJvZHk6IGJyYW5jaC5ib2R5LFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGFsd2F5cyA9IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIGRlZmF1bHRfb3JfZXhhY3QsIHtcbiAgICAgICAgICAgIGJvZHk6IFtdLmNvbmNhdChcbiAgICAgICAgICAgICAgICBleGFjdF9leHAgfHwgW10sXG4gICAgICAgICAgICAgICAgZGVmYXVsdF9vcl9leGFjdC5ib2R5XG4gICAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYm9keVswXSA9PT0gZGVmYXVsdF9vcl9leGFjdCkge1xuICAgICAgICAgICAgb3BlcmF0b3IgPSBcIiE9PVwiO1xuICAgICAgICAgICAgbGV0IHRtcCA9IGFsd2F5cztcbiAgICAgICAgICAgIGFsd2F5cyA9IGNvbnNlcXVlbnQ7XG4gICAgICAgICAgICBjb25zZXF1ZW50ID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICBib2R5OiBbXG4gICAgICAgICAgICAgICAgbWFrZV9ub2RlKEFTVF9JZiwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb246IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogYnJhbmNoLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBjb25zZXF1ZW50LFxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBhbHdheXMsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG5cbiAgICBmdW5jdGlvbiBlbGltaW5hdGVfYnJhbmNoKGJyYW5jaCwgcHJldikge1xuICAgICAgICBpZiAocHJldiAmJiAhYWJvcnRzKHByZXYpKSB7XG4gICAgICAgICAgICBwcmV2LmJvZHkgPSBwcmV2LmJvZHkuY29uY2F0KGJyYW5jaC5ib2R5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhY3RfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIGJyYW5jaCwgZGVjbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYnJhbmNoZXNfZXF1aXZhbGVudChicmFuY2gsIHByZXYsIGluc2VydEJyZWFrKSB7XG4gICAgICAgIGxldCBiYm9keSA9IGJyYW5jaC5ib2R5O1xuICAgICAgICBsZXQgcGJvZHkgPSBwcmV2LmJvZHk7XG4gICAgICAgIGlmIChpbnNlcnRCcmVhaykge1xuICAgICAgICAgICAgYmJvZHkgPSBiYm9keS5jb25jYXQobWFrZV9ub2RlKEFTVF9CcmVhaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYm9keS5sZW5ndGggIT09IHBib2R5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgYmJsb2NrID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgYnJhbmNoLCB7IGJvZHk6IGJib2R5IH0pO1xuICAgICAgICBsZXQgcGJsb2NrID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgcHJldiwgeyBib2R5OiBwYm9keSB9KTtcbiAgICAgICAgcmV0dXJuIGJibG9jay5lcXVpdmFsZW50X3RvKHBibG9jayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXRlbWVudChib2R5KSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgYm9keSwgeyBib2R5IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNfbmVzdGVkX2JyZWFrKHJvb3QpIHtcbiAgICAgICAgbGV0IGhhc19icmVhayA9IGZhbHNlO1xuXG4gICAgICAgIGxldCB0dyA9IG5ldyBUcmVlV2Fsa2VyKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGhhc19icmVhaykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghaXNfYnJlYWsobm9kZSwgdHcpKSByZXR1cm47XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdHcucGFyZW50KCk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGFyZW50IGluc3RhbmNlb2YgQVNUX1N3aXRjaEJyYW5jaFxuICAgICAgICAgICAgICAgICYmIHBhcmVudC5ib2R5W3BhcmVudC5ib2R5Lmxlbmd0aCAtIDFdID09PSBub2RlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNfYnJlYWsgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcm9vdC53YWxrKHR3KTtcbiAgICAgICAgcmV0dXJuIGhhc19icmVhaztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNfYnJlYWsobm9kZSwgc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBBU1RfQnJlYWtcbiAgICAgICAgICAgICYmIHN0YWNrLmxvb3Bjb250cm9sX3RhcmdldChub2RlKSA9PT0gc2VsZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNfaW5lcnRfYm9keShicmFuY2gpIHtcbiAgICAgICAgcmV0dXJuICFhYm9ydHMoYnJhbmNoKSAmJiAhbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgYnJhbmNoLCB7XG4gICAgICAgICAgICBib2R5OiBicmFuY2guYm9keVxuICAgICAgICB9KS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgIH1cbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX1RyeSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmIChzZWxmLmJjYXRjaCAmJiBzZWxmLmJmaW5hbGx5ICYmIHNlbGYuYmZpbmFsbHkuYm9keS5ldmVyeShpc19lbXB0eSkpIHNlbGYuYmZpbmFsbHkgPSBudWxsO1xuXG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpICYmIHNlbGYuYm9keS5ib2R5LmV2ZXJ5KGlzX2VtcHR5KSkge1xuICAgICAgICB2YXIgYm9keSA9IFtdO1xuICAgICAgICBpZiAoc2VsZi5iY2F0Y2gpIHtcbiAgICAgICAgICAgIGV4dHJhY3RfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHNlbGYuYmNhdGNoLCBib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5iZmluYWxseSkgYm9keS5wdXNoKC4uLnNlbGYuYmZpbmFsbHkuYm9keSk7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5BU1RfRGVmaW5pdGlvbnMuREVGTUVUSE9EKFwidG9fYXNzaWdubWVudHNcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgIHZhciByZWR1Y2VfdmFycyA9IGNvbXByZXNzb3Iub3B0aW9uKFwicmVkdWNlX3ZhcnNcIik7XG4gICAgdmFyIGFzc2lnbm1lbnRzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGRlZiBvZiB0aGlzLmRlZmluaXRpb25zKSB7XG4gICAgICAgIGlmIChkZWYudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbWFrZV9ub2RlKEFTVF9TeW1ib2xSZWYsIGRlZi5uYW1lLCBkZWYubmFtZSk7XG4gICAgICAgICAgICBhc3NpZ25tZW50cy5wdXNoKG1ha2Vfbm9kZShBU1RfQXNzaWduLCBkZWYsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwiPVwiLFxuICAgICAgICAgICAgICAgIGxvZ2ljYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbmFtZSxcbiAgICAgICAgICAgICAgICByaWdodCAgICA6IGRlZi52YWx1ZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHJlZHVjZV92YXJzKSBuYW1lLmRlZmluaXRpb24oKS5maXhlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoZWRlZiA9IGRlZi5uYW1lLmRlZmluaXRpb24oKTtcbiAgICAgICAgdGhlZGVmLmVsaW1pbmF0ZWQrKztcbiAgICAgICAgdGhlZGVmLnJlcGxhY2VkLS07XG4gICAgfVxuXG4gICAgaWYgKGFzc2lnbm1lbnRzLmxlbmd0aCA9PSAwKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZSh0aGlzLCBhc3NpZ25tZW50cyk7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9EZWZpbml0aW9ucywgZnVuY3Rpb24oc2VsZikge1xuICAgIGlmIChzZWxmLmRlZmluaXRpb25zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9WYXJEZWYsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoXG4gICAgICAgIHNlbGYubmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xMZXRcbiAgICAgICAgJiYgc2VsZi52YWx1ZSAhPSBudWxsXG4gICAgICAgICYmIGlzX3VuZGVmaW5lZChzZWxmLnZhbHVlLCBjb21wcmVzc29yKVxuICAgICkge1xuICAgICAgICBzZWxmLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9JbXBvcnQsIGZ1bmN0aW9uKHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0NhbGwsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB2YXIgZXhwID0gc2VsZi5leHByZXNzaW9uO1xuICAgIHZhciBmbiA9IGV4cDtcbiAgICBpbmxpbmVfYXJyYXlfbGlrZV9zcHJlYWQoc2VsZi5hcmdzKTtcbiAgICB2YXIgc2ltcGxlX2FyZ3MgPSBzZWxmLmFyZ3MuZXZlcnkoKGFyZykgPT4gIShhcmcgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSk7XG5cbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJyZWR1Y2VfdmFyc1wiKSAmJiBmbiBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgZm4gPSBmbi5maXhlZF92YWx1ZSgpO1xuICAgIH1cblxuICAgIHZhciBpc19mdW5jID0gZm4gaW5zdGFuY2VvZiBBU1RfTGFtYmRhO1xuXG4gICAgaWYgKGlzX2Z1bmMgJiYgZm4ucGlubmVkKCkpIHJldHVybiBzZWxmO1xuXG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW51c2VkXCIpXG4gICAgICAgICYmIHNpbXBsZV9hcmdzXG4gICAgICAgICYmIGlzX2Z1bmNcbiAgICAgICAgJiYgIWZuLnVzZXNfYXJndW1lbnRzKSB7XG4gICAgICAgIHZhciBwb3MgPSAwLCBsYXN0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGZuLmFyZ25hbWVzW2ldIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNfZmxhZyhmbi5hcmduYW1lc1tpXS5leHByZXNzaW9uLCBVTlVTRUQpKSB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHNlbGYuYXJnc1tpKytdLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXJnc1twb3MrK10gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXJnc1twb3MrK10gPSBzZWxmLmFyZ3NbaSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdCA9IHBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmltID0gaSA+PSBmbi5hcmduYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodHJpbSB8fCBoYXNfZmxhZyhmbi5hcmduYW1lc1tpXSwgVU5VU0VEKSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gc2VsZi5hcmdzW2ldLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFyZ3NbcG9zKytdID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0cmltKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXJnc1twb3MrK10gPSBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZi5hcmdzW2ldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFyZ3NbcG9zKytdID0gc2VsZi5hcmdzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdCA9IHBvcztcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmFyZ3MubGVuZ3RoID0gbGFzdDtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIGV4cCBpbnN0YW5jZW9mIEFTVF9Eb3RcbiAgICAgICAgJiYgZXhwLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICYmIGV4cC5leHByZXNzaW9uLm5hbWUgPT09IFwiY29uc29sZVwiXG4gICAgICAgICYmIGV4cC5leHByZXNzaW9uLmRlZmluaXRpb24oKS51bmRlY2xhcmVkXG4gICAgICAgICYmIGV4cC5wcm9wZXJ0eSA9PT0gXCJhc3NlcnRcIlxuICAgICkge1xuICAgICAgICBjb25zdCBjb25kaXRpb24gPSBzZWxmLmFyZ3NbMF07XG4gICAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29uZGl0aW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgIFxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAxIHx8IHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gICAgXG5cbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikgJiYgIWV4cC5jb250YWluc19vcHRpb25hbCgpKSB7XG4gICAgICAgIGlmIChleHAgaW5zdGFuY2VvZiBBU1RfRG90ICYmIGV4cC5zdGFydC52YWx1ZSA9PT0gXCJBcnJheVwiICYmIGV4cC5wcm9wZXJ0eSA9PT0gXCJmcm9tXCIgJiYgc2VsZi5hcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgW2FyZ3VtZW50XSA9IHNlbGYuYXJncztcbiAgICAgICAgICAgIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIEFTVF9BcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0FycmF5LCBhcmd1bWVudCwge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogYXJndW1lbnQuZWxlbWVudHNcbiAgICAgICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfdW5kZWNsYXJlZF9yZWYoZXhwKSkgc3dpdGNoIChleHAubmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0FycmF5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBzZWxmLmFyZ3NcbiAgICAgICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5hcmdzWzBdIGluc3RhbmNlb2YgQVNUX051bWJlciAmJiBzZWxmLmFyZ3NbMF0udmFsdWUgPD0gMTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5hcmdzWzBdLnZhbHVlOyBpKyspIGVsZW1lbnRzLnB1c2gobmV3IEFTVF9Ib2xlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9BcnJheSh7IGVsZW1lbnRzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX09iamVjdCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlN0cmluZ1wiOlxuICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPD0gMSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogc2VsZi5hcmdzWzBdLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHsgdmFsdWU6IFwiXCIgfSlcbiAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIk51bWJlclwiOlxuICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMSAmJiBjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9tYXRoXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc2VsZi5hcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCJcbiAgICAgICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJTeW1ib2xcIjpcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDEgJiYgc2VsZi5hcmdzWzBdIGluc3RhbmNlb2YgQVNUX1N0cmluZyAmJiBjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9zeW1ib2xzXCIpKVxuICAgICAgICAgICAgICAgIHNlbGYuYXJncy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJCb29sZWFuXCI6XG4gICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAwKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9GYWxzZSwgc2VsZik7XG4gICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAxKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc2VsZi5hcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIhXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIhXCJcbiAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlJlZ0V4cFwiOlxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPj0gMVxuICAgICAgICAgICAgICAgICYmIHNlbGYuYXJncy5sZW5ndGggPD0gMlxuICAgICAgICAgICAgICAgICYmIHNlbGYuYXJncy5ldmVyeSgoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFyZy5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnICE9PSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICYmIHJlZ2V4cF9pc19zYWZlKHBhcmFtc1swXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxldCBbIHNvdXJjZSwgZmxhZ3MgXSA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSByZWdleHBfc291cmNlX2ZpeChuZXcgUmVnRXhwKHNvdXJjZSkuc291cmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByeCA9IG1ha2Vfbm9kZShBU1RfUmVnRXhwLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHNvdXJjZSwgZmxhZ3MgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyeC5fZXZhbChjb21wcmVzc29yKSAhPT0gcngpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cCBpbnN0YW5jZW9mIEFTVF9Eb3QpIHN3aXRjaChleHAucHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlIFwidG9TdHJpbmdcIjpcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDAgJiYgIWV4cC5leHByZXNzaW9uLm1heV90aHJvd19vbl9hY2Nlc3MoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHsgdmFsdWU6IFwiXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGV4cC5leHByZXNzaW9uXG4gICAgICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiam9pblwiOlxuICAgICAgICAgICAgaWYgKGV4cC5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX0FycmF5KSBFWElUOiB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gc2VsZi5hcmdzWzBdLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSBzZWxmLmFyZ3NbMF0pIGJyZWFrIEVYSVQ7IC8vIG5vdCBhIGNvbnN0YW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBjb25zdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwLmV4cHJlc3Npb24uZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gZXhwLmV4cHJlc3Npb24uZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIGJyZWFrIEVYSVQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVsLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb25zdHMuam9pbihzZXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb25zdHMuam9pbihzZXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PSAwKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHsgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1swXS5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIGVsZW1lbnRzWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCAgICAgOiBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwgeyB2YWx1ZTogXCJcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogZWxlbWVudHNbMF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1swXS5pc19zdHJpbmcoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGVsZW1lbnRzWzFdLmlzX3N0cmluZyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBlbGVtZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwgeyB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IHByZXYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgICAgOiBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZpcnN0KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGF3a3dhcmQgY2xvbmluZyB0byBub3QgYWZmZWN0IG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBiZXN0X29mIHdpbGwgZGVjaWRlIHdoaWNoIG9uZSB0byBnZXQgdGhyb3VnaC5cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHNlbGYuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBub2RlLmV4cHJlc3Npb24uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IG5vZGUuZXhwcmVzc2lvbi5leHByZXNzaW9uLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uLmV4cHJlc3Npb24uZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZihjb21wcmVzc29yLCBzZWxmLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjaGFyQXRcIjpcbiAgICAgICAgICAgIGlmIChleHAuZXhwcmVzc2lvbi5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gc2VsZi5hcmdzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFyZyA/IGFyZy5ldmFsdWF0ZShjb21wcmVzc29yKSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3ViLCBleHAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cC5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGluZGV4IHwgMCwgYXJnIHx8IGV4cClcbiAgICAgICAgICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImFwcGx5XCI6XG4gICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAyICYmIHNlbGYuYXJnc1sxXSBpbnN0YW5jZW9mIEFTVF9BcnJheSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2VsZi5hcmdzWzFdLmVsZW1lbnRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KHNlbGYuYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQ2FsbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX0RvdCwgZXhwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHAuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcImNhbGxcIlxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgIHZhciBmdW5jID0gZXhwLmV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoZnVuYyBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICBmdW5jID0gZnVuYy5maXhlZF92YWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmMgaW5zdGFuY2VvZiBBU1RfTGFtYmRhICYmICFmdW5jLmNvbnRhaW5zX3RoaXMoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc2VsZi5hcmdzLmxlbmd0aCA/IG1ha2Vfc2VxdWVuY2UodGhpcywgW1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfQ2FsbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBzZWxmLmFyZ3Muc2xpY2UoMSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdKSA6IG1ha2Vfbm9kZShBU1RfQ2FsbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHAuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgICAgICAgICB9KSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9GdW5jdGlvblwiKVxuICAgICAgICAmJiBpc191bmRlY2xhcmVkX3JlZihleHApXG4gICAgICAgICYmIGV4cC5uYW1lID09IFwiRnVuY3Rpb25cIikge1xuICAgICAgICAvLyBuZXcgRnVuY3Rpb24oKSA9PiBmdW5jdGlvbigpe31cbiAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMCkgcmV0dXJuIG1ha2VfZW1wdHlfZnVuY3Rpb24oc2VsZikub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChzZWxmLmFyZ3MuZXZlcnkoKHgpID0+IHggaW5zdGFuY2VvZiBBU1RfU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gcXVpdGUgYSBjb3JuZXItY2FzZSwgYnV0IHdlIGNhbiBoYW5kbGUgaXQ6XG4gICAgICAgICAgICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2lzc3Vlcy8yMDNcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb2RlIGFyZ3VtZW50IGlzIGEgY29uc3RhbnQsIHRoZW4gd2UgY2FuIG1pbmlmeSBpdC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBcIm4oZnVuY3Rpb24oXCIgKyBzZWxmLmFyZ3Muc2xpY2UoMCwgLTEpLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwiKXtcIiArIHNlbGYuYXJnc1tzZWxmLmFyZ3MubGVuZ3RoIC0gMV0udmFsdWUgKyBcIn0pXCI7XG4gICAgICAgICAgICAgICAgdmFyIGFzdCA9IHBhcnNlKGNvZGUpO1xuICAgICAgICAgICAgICAgIHZhciBtYW5nbGUgPSBjb21wcmVzc29yLm1hbmdsZV9vcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgYXN0LmZpZ3VyZV9vdXRfc2NvcGUobWFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgY29tcCA9IG5ldyBDb21wcmVzc29yKGNvbXByZXNzb3Iub3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBtYW5nbGVfb3B0aW9uczogY29tcHJlc3Nvci5fbWFuZ2xlX29wdGlvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3QgPSBhc3QudHJhbnNmb3JtKGNvbXApO1xuICAgICAgICAgICAgICAgIGFzdC5maWd1cmVfb3V0X3Njb3BlKG1hbmdsZSk7XG4gICAgICAgICAgICAgICAgYXN0LmNvbXB1dGVfY2hhcl9mcmVxdWVuY3kobWFuZ2xlKTtcbiAgICAgICAgICAgICAgICBhc3QubWFuZ2xlX25hbWVzKG1hbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bjtcbiAgICAgICAgICAgICAgICB3YWxrKGFzdCwgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19mdW5jX2V4cHIobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1biA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2Fsa19hYm9ydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gT3V0cHV0U3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgQVNUX0Jsb2NrU3RhdGVtZW50LnByb3RvdHlwZS5fY29kZWdlbi5jYWxsKGZ1biwgZnVuLCBjb2RlKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuLmFyZ25hbWVzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLnByaW50X3RvX3N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIixcIilcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLmFyZ3Nbc2VsZi5hcmdzLmxlbmd0aCAtIDFdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29kZS5nZXQoKS5yZXBsYWNlKC9ee3x9JC9nLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGlmICghKGV4IGluc3RhbmNlb2YgSlNfUGFyc2VfRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaXQgY3Jhc2hlcyBhdCBydW50aW1lLiBPciBtYXliZSBpdCdzIG5vbnN0YW5kYXJkIHN5bnRheC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmxpbmVfaW50b19jYWxsKHNlbGYsIGNvbXByZXNzb3IpO1xufSk7XG5cbi8qKiBEb2VzIHRoaXMgbm9kZSBjb250YWluIG9wdGlvbmFsIHByb3BlcnR5IGFjY2VzcyBvciBvcHRpb25hbCBjYWxsPyAqL1xuQVNUX05vZGUuREVGTUVUSE9EKFwiY29udGFpbnNfb3B0aW9uYWxcIiwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKFxuICAgICAgICB0aGlzIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3NcbiAgICAgICAgfHwgdGhpcyBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgIHx8IHRoaXMgaW5zdGFuY2VvZiBBU1RfQ2hhaW5cbiAgICApIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5jb250YWluc19vcHRpb25hbCgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX05ldywgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmIChcbiAgICAgICAgY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikgJiZcbiAgICAgICAgaXNfdW5kZWNsYXJlZF9yZWYoc2VsZi5leHByZXNzaW9uKSAmJlxuICAgICAgICBbXCJPYmplY3RcIiwgXCJSZWdFeHBcIiwgXCJGdW5jdGlvblwiLCBcIkVycm9yXCIsIFwiQXJyYXlcIl0uaW5jbHVkZXMoc2VsZi5leHByZXNzaW9uLm5hbWUpXG4gICAgKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9DYWxsLCBzZWxmLCBzZWxmKS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9TZXF1ZW5jZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikpIHJldHVybiBzZWxmO1xuICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgIGZpbHRlcl9mb3Jfc2lkZV9lZmZlY3RzKCk7XG4gICAgdmFyIGVuZCA9IGV4cHJlc3Npb25zLmxlbmd0aCAtIDE7XG4gICAgdHJpbV9yaWdodF9mb3JfdW5kZWZpbmVkKCk7XG4gICAgaWYgKGVuZCA9PSAwKSB7XG4gICAgICAgIHNlbGYgPSBtYWludGFpbl90aGlzX2JpbmRpbmcoY29tcHJlc3Nvci5wYXJlbnQoKSwgY29tcHJlc3Nvci5zZWxmKCksIGV4cHJlc3Npb25zWzBdKTtcbiAgICAgICAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkpIHNlbGYgPSBzZWxmLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgc2VsZi5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gZmlsdGVyX2Zvcl9zaWRlX2VmZmVjdHMoKSB7XG4gICAgICAgIHZhciBmaXJzdCA9IGZpcnN0X2luX3N0YXRlbWVudChjb21wcmVzc29yKTtcbiAgICAgICAgdmFyIGxhc3QgPSBzZWxmLmV4cHJlc3Npb25zLmxlbmd0aCAtIDE7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbihleHByLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGFzdCkgZXhwciA9IGV4cHIuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIGZpcnN0KTtcbiAgICAgICAgICAgIGlmIChleHByKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2Vfc2VxdWVuY2UoZXhwcmVzc2lvbnMsIGV4cHIpO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaW1fcmlnaHRfZm9yX3VuZGVmaW5lZCgpIHtcbiAgICAgICAgd2hpbGUgKGVuZCA+IDAgJiYgaXNfdW5kZWZpbmVkKGV4cHJlc3Npb25zW2VuZF0sIGNvbXByZXNzb3IpKSBlbmQtLTtcbiAgICAgICAgaWYgKGVuZCA8IGV4cHJlc3Npb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zW2VuZF0gPSBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgICA6IFwidm9pZFwiLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBleHByZXNzaW9uc1tlbmRdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLmxlbmd0aCA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuQVNUX1VuYXJ5LkRFRk1FVEhPRChcImxpZnRfc2VxdWVuY2VzXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzZXF1ZW5jZXNcIikpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmV4cHJlc3Npb24uZXhwcmVzc2lvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgZS5leHByZXNzaW9uID0geC5wb3AoKTtcbiAgICAgICAgICAgIHgucHVzaChlKTtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIHgpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfVW5hcnlQb3N0Zml4LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgcmV0dXJuIHNlbGYubGlmdF9zZXF1ZW5jZXMoY29tcHJlc3Nvcik7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9VbmFyeVByZWZpeCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHZhciBlID0gc2VsZi5leHByZXNzaW9uO1xuICAgIGlmIChcbiAgICAgICAgc2VsZi5vcGVyYXRvciA9PSBcImRlbGV0ZVwiICYmXG4gICAgICAgICEoXG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiB8fFxuICAgICAgICAgICAgZSBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIHx8XG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgQVNUX0NoYWluIHx8XG4gICAgICAgICAgICBpc19pZGVudGlmaWVyX2F0b20oZSlcbiAgICAgICAgKVxuICAgICkge1xuICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCBbZSwgbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKV0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICB2YXIgc2VxID0gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICBpZiAoc2VxICE9PSBzZWxmKSB7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNpZGVfZWZmZWN0c1wiKSAmJiBzZWxmLm9wZXJhdG9yID09IFwidm9pZFwiKSB7XG4gICAgICAgIGUgPSBlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IGU7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZikub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgc3dpdGNoIChzZWxmLm9wZXJhdG9yKSB7XG4gICAgICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4ICYmIGUub3BlcmF0b3IgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAvLyAhIWZvbyA9PT4gZm9vLCBpZiB3ZSdyZSBpbiBib29sZWFuIGNvbnRleHRcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5leHByZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgc2VsZiA9IGJlc3Rfb2YoY29tcHJlc3Nvciwgc2VsZiwgZS5uZWdhdGUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KGNvbXByZXNzb3IpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidHlwZW9mXCI6XG4gICAgICAgICAgICAvLyB0eXBlb2YgYWx3YXlzIHJldHVybnMgYSBub24tZW1wdHkgc3RyaW5nLCB0aHVzIGl0J3NcbiAgICAgICAgICAgIC8vIGFsd2F5cyB0cnVlIGluIGJvb2xlYW5zXG4gICAgICAgICAgICAvLyBBbmQgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBpZiBpdCdzIHVuZGVjbGFyZWQsIGJlY2F1c2UgaW4gdHlwZW9mLCB0aGF0J3MgT0tcbiAgICAgICAgICAgIHJldHVybiAoZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgPyBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpIDogbWFrZV9zZXF1ZW5jZShzZWxmLCBbXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpXG4gICAgICAgICAgICBdKSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGYub3BlcmF0b3IgPT0gXCItXCIgJiYgZSBpbnN0YW5jZW9mIEFTVF9JbmZpbml0eSkge1xuICAgICAgICBlID0gZS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAmJiAoc2VsZi5vcGVyYXRvciA9PSBcIitcIiB8fCBzZWxmLm9wZXJhdG9yID09IFwiLVwiKVxuICAgICAgICAmJiAoZS5vcGVyYXRvciA9PSBcIipcIiB8fCBlLm9wZXJhdG9yID09IFwiL1wiIHx8IGUub3BlcmF0b3IgPT0gXCIlXCIpKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IGUub3BlcmF0b3IsXG4gICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBlLmxlZnQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBlLmxlZnRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmlnaHQ6IGUucmlnaHRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZXZhbHVhdGVcIikpIHtcbiAgICAgICAgLy8gfn54ID0+IHggKGluIDMyLWJpdCBjb250ZXh0KVxuICAgICAgICAvLyB+fnszMiBiaXQgaW50ZWdlcn0gPT4gezMyIGJpdCBpbnRlZ2VyfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBzZWxmLm9wZXJhdG9yID09PSBcIn5cIlxuICAgICAgICAgICAgJiYgc2VsZi5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAmJiBzZWxmLmV4cHJlc3Npb24ub3BlcmF0b3IgPT09IFwiflwiXG4gICAgICAgICAgICAmJiAoY29tcHJlc3Nvci5pbl8zMl9iaXRfY29udGV4dChmYWxzZSkgfHwgc2VsZi5leHByZXNzaW9uLmV4cHJlc3Npb24uaXNfMzJfYml0X2ludGVnZXIoY29tcHJlc3NvcikpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZXhwcmVzc2lvbi5leHByZXNzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gfih4IF4geSkgPT4geCBeIH55XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPT09IFwiflwiXG4gICAgICAgICAgICAmJiBlIGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgZS5vcGVyYXRvciA9PT0gXCJeXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZS5sZWZ0IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4ICYmIGUubGVmdC5vcGVyYXRvciA9PT0gXCJ+XCIpIHtcbiAgICAgICAgICAgICAgICAvLyB+KH54IF4geSkgPT4geCBeIHlcbiAgICAgICAgICAgICAgICBlLmxlZnQgPSBlLmxlZnQuYml0d2lzZV9uZWdhdGUoY29tcHJlc3NvciwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucmlnaHQgPSBlLnJpZ2h0LmJpdHdpc2VfbmVnYXRlKGNvbXByZXNzb3IsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIHNlbGYub3BlcmF0b3IgIT0gXCItXCJcbiAgICAgICAgLy8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uIG9mIG51bWVyYWxzXG4gICAgICAgIHx8ICEoZSBpbnN0YW5jZW9mIEFTVF9OdW1iZXIgfHwgZSBpbnN0YW5jZW9mIEFTVF9JbmZpbml0eSB8fCBlIGluc3RhbmNlb2YgQVNUX0JpZ0ludClcbiAgICApIHtcbiAgICAgICAgdmFyIGV2ID0gc2VsZi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKGV2ICE9PSBzZWxmKSB7XG4gICAgICAgICAgICBldiA9IG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGV2LCBzZWxmKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHJldHVybiBiZXN0X29mKGNvbXByZXNzb3IsIGV2LCBzZWxmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5BU1RfQmluYXJ5LkRFRk1FVEhPRChcImxpZnRfc2VxdWVuY2VzXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzZXF1ZW5jZXNcIikpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdCBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmxlZnQuZXhwcmVzc2lvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgZS5sZWZ0ID0geC5wb3AoKTtcbiAgICAgICAgICAgIHgucHVzaChlKTtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIHgpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlICYmICF0aGlzLmxlZnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgdmFyIGFzc2lnbiA9IHRoaXMub3BlcmF0b3IgPT0gXCI9XCIgJiYgdGhpcy5sZWZ0IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZjtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5yaWdodC5leHByZXNzaW9ucztcbiAgICAgICAgICAgIHZhciBsYXN0ID0geC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFzc2lnbiAmJiB4W2ldLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgIHggPSB4LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgZS5yaWdodCA9IHgucG9wKCk7XG4gICAgICAgICAgICAgICAgeC5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIHgpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGUucmlnaHQgPSBtYWtlX3NlcXVlbmNlKHRoaXMucmlnaHQsIHguc2xpY2UoaSkpO1xuICAgICAgICAgICAgICAgIHggPSB4LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIHgucHVzaChlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZSh0aGlzLCB4KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn0pO1xuXG52YXIgY29tbXV0YXRpdmVPcGVyYXRvcnMgPSBtYWtlUHJlZGljYXRlKFwiPT0gPT09ICE9ICE9PSAqICYgfCBeXCIpO1xuZnVuY3Rpb24gaXNfb2JqZWN0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEFTVF9BcnJheVxuICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYVxuICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdFxuICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0NsYXNzO1xufVxuXG5kZWZfb3B0aW1pemUoQVNUX0JpbmFyeSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGZ1bmN0aW9uIHJldmVyc2libGUoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxlZnQuaXNfY29uc3RhbnQoKVxuICAgICAgICAgICAgfHwgc2VsZi5yaWdodC5pc19jb25zdGFudCgpXG4gICAgICAgICAgICB8fCAhc2VsZi5sZWZ0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAmJiAhc2VsZi5yaWdodC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXZlcnNlKG9wKSB7XG4gICAgICAgIGlmIChyZXZlcnNpYmxlKCkpIHtcbiAgICAgICAgICAgIGlmIChvcCkgc2VsZi5vcGVyYXRvciA9IG9wO1xuICAgICAgICAgICAgdmFyIHRtcCA9IHNlbGYubGVmdDtcbiAgICAgICAgICAgIHNlbGYubGVmdCA9IHNlbGYucmlnaHQ7XG4gICAgICAgICAgICBzZWxmLnJpZ2h0ID0gdG1wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImxoc19jb25zdGFudHNcIikgJiYgY29tbXV0YXRpdmVPcGVyYXRvcnMuaGFzKHNlbGYub3BlcmF0b3IpKSB7XG4gICAgICAgIGlmIChzZWxmLnJpZ2h0LmlzX2NvbnN0YW50KClcbiAgICAgICAgICAgICYmICFzZWxmLmxlZnQuaXNfY29uc3RhbnQoKSkge1xuICAgICAgICAgICAgLy8gaWYgcmlnaHQgaXMgYSBjb25zdGFudCwgd2hhdGV2ZXIgc2lkZSBlZmZlY3RzIHRoZVxuICAgICAgICAgICAgLy8gbGVmdCBzaWRlIG1pZ2h0IGhhdmUgY291bGQgbm90IGluZmx1ZW5jZSB0aGVcbiAgICAgICAgICAgIC8vIHJlc3VsdC4gIGhlbmNlLCBmb3JjZSBzd2l0Y2guXG5cbiAgICAgICAgICAgIGlmICghKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICYmIFBSRUNFREVOQ0Vbc2VsZi5sZWZ0Lm9wZXJhdG9yXSA+PSBQUkVDRURFTkNFW3NlbGYub3BlcmF0b3JdKSkge1xuICAgICAgICAgICAgICAgIHJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxmID0gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJjb21wYXJpc29uc1wiKSkgc3dpdGNoIChzZWxmLm9wZXJhdG9yKSB7XG4gICAgICBjYXNlIFwiPT09XCI6XG4gICAgICBjYXNlIFwiIT09XCI6XG4gICAgICAgIHZhciBpc19zdHJpY3RfY29tcGFyaXNvbiA9IHRydWU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChzZWxmLmxlZnQuaXNfc3RyaW5nKGNvbXByZXNzb3IpICYmIHNlbGYucmlnaHQuaXNfc3RyaW5nKGNvbXByZXNzb3IpKSB8fFxuICAgICAgICAgICAgKHNlbGYubGVmdC5pc19udW1iZXIoY29tcHJlc3NvcikgJiYgc2VsZi5yaWdodC5pc19udW1iZXIoY29tcHJlc3NvcikpIHx8XG4gICAgICAgICAgICAoc2VsZi5sZWZ0LmlzX2JpZ2ludChjb21wcmVzc29yKSAmJiBzZWxmLnJpZ2h0LmlzX2JpZ2ludChjb21wcmVzc29yKSkgfHxcbiAgICAgICAgICAgIChzZWxmLmxlZnQuaXNfYm9vbGVhbigpICYmIHNlbGYucmlnaHQuaXNfYm9vbGVhbigpKSB8fFxuICAgICAgICAgICAgc2VsZi5sZWZ0LmVxdWl2YWxlbnRfdG8oc2VsZi5yaWdodClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBzZWxmLm9wZXJhdG9yID0gc2VsZi5vcGVyYXRvci5zdWJzdHIoMCwgMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBYWFg6IGludGVudGlvbmFsbHkgZmFsbGluZyBkb3duIHRvIHRoZSBuZXh0IGNhc2VcbiAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgIC8vIHZvaWQgMCA9PSB4ID0+IG51bGwgPT0geFxuICAgICAgICBpZiAoIWlzX3N0cmljdF9jb21wYXJpc29uICYmIGlzX3VuZGVmaW5lZChzZWxmLmxlZnQsIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICBzZWxmLmxlZnQgPSBtYWtlX25vZGUoQVNUX051bGwsIHNlbGYubGVmdCk7XG4gICAgICAgIC8vIHggPT0gdm9pZCAwID0+IHggPT0gbnVsbFxuICAgICAgICB9IGVsc2UgaWYgKCFpc19zdHJpY3RfY29tcGFyaXNvbiAmJiBpc191bmRlZmluZWQoc2VsZi5yaWdodCwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHNlbGYucmlnaHQgPSBtYWtlX25vZGUoQVNUX051bGwsIHNlbGYucmlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidHlwZW9mc1wiKVxuICAgICAgICAgICAgLy8gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgeCA9PiB1bmRlZmluZWQgPT09IHhcbiAgICAgICAgICAgICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9TdHJpbmdcbiAgICAgICAgICAgICYmIHNlbGYubGVmdC52YWx1ZSA9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09IFwidHlwZW9mXCIpIHtcbiAgICAgICAgICAgIHZhciBleHByID0gc2VsZi5yaWdodC5leHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmID8gZXhwci5pc19kZWNsYXJlZChjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgIDogIShleHByIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJpZThcIikpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yaWdodCA9IGV4cHI7XG4gICAgICAgICAgICAgICAgc2VsZi5sZWZ0ID0gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYubGVmdCkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub3BlcmF0b3IubGVuZ3RoID09IDIpIHNlbGYub3BlcmF0b3IgKz0gXCI9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ0eXBlb2ZzXCIpXG4gICAgICAgICAgICAvLyB0eXBlb2YgeCA9PT0gXCJ1bmRlZmluZWRcIiA9PiB4ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeFxuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09IFwidHlwZW9mXCJcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfU3RyaW5nXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LnZhbHVlID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhciBleHByID0gc2VsZi5sZWZ0LmV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgPyBleHByLmlzX2RlY2xhcmVkKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgOiAhKGV4cHIgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBjb21wcmVzc29yLm9wdGlvbihcImllOFwiKSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBleHByO1xuICAgICAgICAgICAgICAgIHNlbGYucmlnaHQgPSBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZi5yaWdodCkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub3BlcmF0b3IubGVuZ3RoID09IDIpIHNlbGYub3BlcmF0b3IgKz0gXCI9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgLy8gb2JqICE9PSBvYmogPT4gZmFsc2VcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiBzZWxmLmxlZnQuZGVmaW5pdGlvbigpID09PSBzZWxmLnJpZ2h0LmRlZmluaXRpb24oKVxuICAgICAgICAgICAgJiYgaXNfb2JqZWN0KHNlbGYubGVmdC5maXhlZF92YWx1ZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShzZWxmLm9wZXJhdG9yWzBdID09IFwiPVwiID8gQVNUX1RydWUgOiBBU1RfRmFsc2UsIHNlbGYpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYubGVmdC5pc18zMl9iaXRfaW50ZWdlcihjb21wcmVzc29yKSAmJiBzZWxmLnJpZ2h0LmlzXzMyX2JpdF9pbnRlZ2VyKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICBjb25zdCBub3QgPSBub2RlID0+IG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIhXCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbm9kZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBib29sZWFuaWZ5ID0gKG5vZGUsIHRydXRoeSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0cnV0aHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBub3Qobm90KG5vZGUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm90KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRoZSBvbmx5IGZhbHN5IDMyLWJpdCBpbnRlZ2VyIGlzIDBcbiAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfTnVtYmVyICYmIHNlbGYubGVmdC52YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBib29sZWFuaWZ5KHNlbGYucmlnaHQsIHNlbGYub3BlcmF0b3JbMF0gPT09IFwiIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX051bWJlciAmJiBzZWxmLnJpZ2h0LnZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW5pZnkoc2VsZi5sZWZ0LCBzZWxmLm9wZXJhdG9yWzBdID09PSBcIiFcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hc2sgYWxsLWJpdHMgY2hlY2tcbiAgICAgICAgICAgIC8vICh4ICYgMHhGRikgIT0gMHhGRiA9PiAhKH54ICYgMHhGRilcbiAgICAgICAgICAgIGxldCBhbmRfb3AsIHgsIG1hc2s7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGFuZF9vcCA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgPyBzZWxmLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeSA/IHNlbGYucmlnaHQgOiBudWxsKVxuICAgICAgICAgICAgICAgICYmIChtYXNrID0gYW5kX29wID09PSBzZWxmLmxlZnQgPyBzZWxmLnJpZ2h0IDogc2VsZi5sZWZ0KVxuICAgICAgICAgICAgICAgICYmIGFuZF9vcC5vcGVyYXRvciA9PT0gXCImXCJcbiAgICAgICAgICAgICAgICAmJiBtYXNrIGluc3RhbmNlb2YgQVNUX051bWJlclxuICAgICAgICAgICAgICAgICYmIG1hc2suaXNfMzJfYml0X2ludGVnZXIoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAmJiAoeCA9XG4gICAgICAgICAgICAgICAgICAgIGFuZF9vcC5sZWZ0LmVxdWl2YWxlbnRfdG8obWFzaykgPyBhbmRfb3AucmlnaHRcbiAgICAgICAgICAgICAgICAgICAgOiBhbmRfb3AucmlnaHQuZXF1aXZhbGVudF90byhtYXNrKSA/IGFuZF9vcC5sZWZ0IDogbnVsbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxldCBvcHRpbWl6ZWQgPSBib29sZWFuaWZ5KG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiZcIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFzayxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIn5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHhcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KSwgc2VsZi5vcGVyYXRvclswXSA9PT0gXCIhXCIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2YoY29tcHJlc3Nvciwgb3B0aW1pemVkLCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCImJlwiOlxuICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgIHZhciBsaHMgPSBzZWxmLmxlZnQ7XG4gICAgICAgIGlmIChsaHMub3BlcmF0b3IgPT0gc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgICAgbGhzID0gbGhzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAmJiBsaHMub3BlcmF0b3IgPT0gKHNlbGYub3BlcmF0b3IgPT0gXCImJlwiID8gXCIhPT1cIiA6IFwiPT09XCIpXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgbGhzLm9wZXJhdG9yID09IHNlbGYucmlnaHQub3BlcmF0b3JcbiAgICAgICAgICAgICYmIChpc191bmRlZmluZWQobGhzLmxlZnQsIGNvbXByZXNzb3IpICYmIHNlbGYucmlnaHQubGVmdCBpbnN0YW5jZW9mIEFTVF9OdWxsXG4gICAgICAgICAgICAgICAgfHwgbGhzLmxlZnQgaW5zdGFuY2VvZiBBU1RfTnVsbCAmJiBpc191bmRlZmluZWQoc2VsZi5yaWdodC5sZWZ0LCBjb21wcmVzc29yKSlcbiAgICAgICAgICAgICYmICFsaHMucmlnaHQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgJiYgbGhzLnJpZ2h0LmVxdWl2YWxlbnRfdG8oc2VsZi5yaWdodC5yaWdodCkpIHtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZCA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGxocy5vcGVyYXRvci5zbGljZSgwLCAtMSksXG4gICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9OdWxsLCBzZWxmKSxcbiAgICAgICAgICAgICAgICByaWdodDogbGhzLnJpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChsaHMgIT09IHNlbGYubGVmdCkge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVkID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYubGVmdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29tYmluZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHNlbGYub3BlcmF0b3IgPT0gXCIrXCIgJiYgY29tcHJlc3Nvci5pbl9ib29sZWFuX2NvbnRleHQoKSkge1xuICAgICAgICB2YXIgbGwgPSBzZWxmLmxlZnQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIHZhciByciA9IHNlbGYucmlnaHQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChsbCAmJiB0eXBlb2YgbGwgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgW1xuICAgICAgICAgICAgICAgIHNlbGYucmlnaHQsXG4gICAgICAgICAgICAgICAgbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKVxuICAgICAgICAgICAgXSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJyICYmIHR5cGVvZiByciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCBbXG4gICAgICAgICAgICAgICAgc2VsZi5sZWZ0LFxuICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfVHJ1ZSwgc2VsZilcbiAgICAgICAgICAgIF0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImNvbXBhcmlzb25zXCIpICYmIHNlbGYuaXNfYm9vbGVhbigpKSB7XG4gICAgICAgIGlmICghKGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KVxuICAgICAgICAgICAgfHwgY29tcHJlc3Nvci5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pIHtcbiAgICAgICAgICAgIHZhciBuZWdhdGVkID0gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBzZWxmLm5lZ2F0ZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQoY29tcHJlc3NvcikpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYgPSBiZXN0X29mKGNvbXByZXNzb3IsIHNlbGYsIG5lZ2F0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9jb21wc1wiKSkge1xuICAgICAgICAgICAgc3dpdGNoIChzZWxmLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCI8XCI6IHJldmVyc2UoXCI+XCIpOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIjw9XCI6IHJldmVyc2UoXCI+PVwiKTsgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGYub3BlcmF0b3IgPT0gXCIrXCIpIHtcbiAgICAgICAgaWYgKHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfU3RyaW5nXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmdldFZhbHVlKCkgPT0gXCJcIlxuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LmlzX3N0cmluZyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX1N0cmluZ1xuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LmdldFZhbHVlKCkgPT0gXCJcIlxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAmJiBzZWxmLmxlZnQub3BlcmF0b3IgPT0gXCIrXCJcbiAgICAgICAgICAgICYmIHNlbGYubGVmdC5sZWZ0IGluc3RhbmNlb2YgQVNUX1N0cmluZ1xuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LmxlZnQuZ2V0VmFsdWUoKSA9PSBcIlwiXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgc2VsZi5sZWZ0ID0gc2VsZi5sZWZ0LnJpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZXZhbHVhdGVcIikpIHtcbiAgICAgICAgc3dpdGNoIChzZWxmLm9wZXJhdG9yKSB7XG4gICAgICAgICAgY2FzZSBcIiYmXCI6XG4gICAgICAgICAgICB2YXIgbGwgPSBoYXNfZmxhZyhzZWxmLmxlZnQsIFRSVVRIWSlcbiAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICA6IGhhc19mbGFnKHNlbGYubGVmdCwgRkFMU1kpXG4gICAgICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmxlZnQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBpZiAoIWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW50YWluX3RoaXNfYmluZGluZyhjb21wcmVzc29yLnBhcmVudCgpLCBjb21wcmVzc29yLnNlbGYoKSwgc2VsZi5sZWZ0KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShsbCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHNlbGYsIFsgc2VsZi5sZWZ0LCBzZWxmLnJpZ2h0IF0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJyID0gc2VsZi5yaWdodC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGlmICghcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5pbl9ib29sZWFuX2NvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlX25vZGUoQVNUX0ZhbHNlLCBzZWxmKVxuICAgICAgICAgICAgICAgICAgICBdKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRfZmxhZyhzZWxmLCBGQUxTWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJyIGluc3RhbmNlb2YgQVNUX05vZGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGNvbXByZXNzb3IucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5vcGVyYXRvciA9PSBcIiYmXCIgJiYgcGFyZW50LmxlZnQgPT09IGNvbXByZXNzb3Iuc2VsZigpIHx8IGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubGVmdC5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB4IHx8IGZhbHNlICYmIHkgLS0tPiB4ID8geSA6IGZhbHNlXG4gICAgICAgICAgICBpZiAoc2VsZi5sZWZ0Lm9wZXJhdG9yID09IFwifHxcIikge1xuICAgICAgICAgICAgICAgIHZhciBsciA9IHNlbGYubGVmdC5yaWdodC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxyKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb246IHNlbGYubGVmdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiBzZWxmLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZTogc2VsZi5sZWZ0LnJpZ2h0XG4gICAgICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwifHxcIjpcbiAgICAgICAgICAgIHZhciBsbCA9IGhhc19mbGFnKHNlbGYubGVmdCwgVFJVVEhZKVxuICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgOiBoYXNfZmxhZyhzZWxmLmxlZnQsIEZBTFNZKVxuICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHNlbGYubGVmdC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGlmICghbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCBbIHNlbGYubGVmdCwgc2VsZi5yaWdodCBdKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShsbCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWludGFpbl90aGlzX2JpbmRpbmcoY29tcHJlc3Nvci5wYXJlbnQoKSwgY29tcHJlc3Nvci5zZWxmKCksIHNlbGYubGVmdCkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcnIgPSBzZWxmLnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKCFycikge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjb21wcmVzc29yLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQub3BlcmF0b3IgPT0gXCJ8fFwiICYmIHBhcmVudC5sZWZ0ID09PSBjb21wcmVzc29yLnNlbGYoKSB8fCBjb21wcmVzc29yLmluX2Jvb2xlYW5fY29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmxlZnQub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJyIGluc3RhbmNlb2YgQVNUX05vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKVxuICAgICAgICAgICAgICAgICAgICBdKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRfZmxhZyhzZWxmLCBUUlVUSFkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmxlZnQub3BlcmF0b3IgPT0gXCImJlwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxyID0gc2VsZi5sZWZ0LnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIGlmIChsciAmJiAhKGxyIGluc3RhbmNlb2YgQVNUX05vZGUpKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb246IHNlbGYubGVmdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiBzZWxmLmxlZnQucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBzZWxmLnJpZ2h0XG4gICAgICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiPz9cIjpcbiAgICAgICAgICAgIGlmIChpc19udWxsaXNoKHNlbGYubGVmdCwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxsID0gc2VsZi5sZWZ0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKCEobGwgaW5zdGFuY2VvZiBBU1RfTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBrbm93IHRoZSB2YWx1ZSBmb3Igc3VyZSB3ZSBjYW4gc2ltcGx5IGNvbXB1dGUgcmlnaHQgYXdheS5cbiAgICAgICAgICAgICAgICByZXR1cm4gbGwgPT0gbnVsbCA/IHNlbGYucmlnaHQgOiBzZWxmLmxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLmluX2Jvb2xlYW5fY29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnIgPSBzZWxmLnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIGlmICghKHJyIGluc3RhbmNlb2YgQVNUX05vZGUpICYmICFycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXNzb2NpYXRpdmUgPSB0cnVlO1xuICAgICAgICBzd2l0Y2ggKHNlbGYub3BlcmF0b3IpIHtcbiAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgLy8gKHggKyBcImZvb1wiKSArIFwiYmFyXCIgPT4geCArIFwiZm9vYmFyXCJcbiAgICAgICAgICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5vcGVyYXRvciA9PSBcIitcIlxuICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluYXJ5ID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmxlZnQucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLnJpZ2h0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciByID0gYmluYXJ5Lm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIGlmIChiaW5hcnkgIT09IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmxlZnQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICh4ICsgXCJmb29cIikgKyAoXCJiYXJcIiArIHkpID0+ICh4ICsgXCJmb29iYXJcIikgKyB5XG4gICAgICAgICAgICBpZiAoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5vcGVyYXRvciA9PSBcIitcIlxuICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQub3BlcmF0b3IgPT0gXCIrXCJcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBiaW5hcnkgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYubGVmdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHQubGVmdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGJpbmFyeS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAoYmluYXJ5ICE9PSBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYubGVmdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmxlZnQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5yaWdodC5yaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhICsgLWIgPT4gYSAtIGJcbiAgICAgICAgICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5vcGVyYXRvciA9PSBcIi1cIlxuICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5pc19udW1iZXJfb3JfYmlnaW50KGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIi1cIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5yaWdodC5leHByZXNzaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtYSArIGIgPT4gYiAtIGFcbiAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQub3BlcmF0b3IgPT0gXCItXCJcbiAgICAgICAgICAgICAgICAmJiByZXZlcnNpYmxlKClcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmlzX251bWJlcl9vcl9iaWdpbnQoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiLVwiLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5sZWZ0LmV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGBmb28ke2Jhcn1iYXpgICsgMSA9PiBgZm9vJHtiYXJ9YmF6MWBcbiAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHNlbGYubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHNlbGYucmlnaHQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgaWYgKHIgIT0gc2VsZi5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBsLnNlZ21lbnRzW2wuc2VnbWVudHMubGVuZ3RoIC0gMV0udmFsdWUgKz0gU3RyaW5nKHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAxICsgYGZvbyR7YmFyfWJhemAgPT4gYDFmb28ke2Jhcn1iYXpgXG4gICAgICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9UZW1wbGF0ZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciByID0gc2VsZi5yaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHNlbGYubGVmdC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAobCAhPSBzZWxmLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgci5zZWdtZW50c1swXS52YWx1ZSA9IFN0cmluZyhsKSArIHIuc2VnbWVudHNbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGAxJHtiYXJ9MmAgKyBgZm9vJHtiYXJ9YmF6YCA9PiBgMSR7YmFyfTJmb28ke2Jhcn1iYXpgXG4gICAgICAgICAgICBpZiAoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX1RlbXBsYXRlU3RyaW5nXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9UZW1wbGF0ZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBsID0gc2VsZi5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IGwuc2VnbWVudHM7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBzZWxmLnJpZ2h0O1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLnZhbHVlICs9IHIuc2VnbWVudHNbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCByLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goci5zZWdtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICBhc3NvY2lhdGl2ZSA9IGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlX21hdGhcIik7XG4gICAgICAgICAgY2FzZSBcIiZcIjpcbiAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgIGNhc2UgXCJeXCI6XG4gICAgICAgICAgICAvLyBhICsgK2IgPT4gK2IgKyBhXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc2VsZi5sZWZ0LmlzX251bWJlcl9vcl9iaWdpbnQoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmlzX251bWJlcl9vcl9iaWdpbnQoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAmJiByZXZlcnNpYmxlKClcbiAgICAgICAgICAgICAgICAmJiAhKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yICE9IHNlbGYub3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgJiYgUFJFQ0VERU5DRVtzZWxmLmxlZnQub3BlcmF0b3JdID49IFBSRUNFREVOQ0Vbc2VsZi5vcGVyYXRvcl0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVyc2VkID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmxlZnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICAgICAmJiAhKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IGJlc3Rfb2YoY29tcHJlc3NvciwgcmV2ZXJzZWQsIHNlbGYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBiZXN0X29mKGNvbXByZXNzb3IsIHNlbGYsIHJldmVyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXNzb2NpYXRpdmUgJiYgc2VsZi5pc19udW1iZXJfb3JfYmlnaW50KGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgLy8gYSArIChiICsgYykgPT4gKGEgKyBiKSArIGNcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5vcGVyYXRvciA9PSBzZWxmLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5sZWZ0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLnJpZ2h0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlbGYubGVmdC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlbGYucmlnaHQubGVmdC5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHQucmlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIChuICsgMikgKyAzID0+IDUgKyBuXG4gICAgICAgICAgICAgICAgLy8gKDIgKiBuKSAqIDMgPT4gNiArIG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5vcGVyYXRvciA9PSBzZWxmLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxlZnQubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYubGVmdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VsZi5sZWZ0LmxlZnQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogc2VsZi5yaWdodC5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5sZWZ0LnJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmxlZnQucmlnaHQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBzZWxmLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmxlZnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYubGVmdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWxmLmxlZnQucmlnaHQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogc2VsZi5yaWdodC5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5sZWZ0LmxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIChhIHwgMSkgfCAoMiB8IGQpID0+ICgzIHwgYSkgfCBiXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09IHNlbGYub3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LnJpZ2h0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQub3BlcmF0b3IgPT0gc2VsZi5vcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmxlZnQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmxlZnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5sZWZ0LmxlZnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYubGVmdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlbGYubGVmdC5yaWdodC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWxmLnJpZ2h0LmxlZnQuZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYubGVmdC5sZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLnJpZ2h0LnJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJpdHdpc2Ugb3BzXG4gICAgICAgIGlmIChiaXR3aXNlX2Jpbm9wLmhhcyhzZWxmLm9wZXJhdG9yKSkge1xuICAgICAgICAgICAgLy8gVXNlIERlIE1vcmdhbidzIGxhd3NcbiAgICAgICAgICAgIC8vIHogJiAoWCB8IHkpXG4gICAgICAgICAgICAvLyA9PiB6ICYgWCAoZ2l2ZW4geSAmIHogPT09IDApXG4gICAgICAgICAgICAvLyA9PiB6ICYgWCB8IHt5ICYgen0gKGdpdmVuIHkgJiB6ICE9PSAwKVxuICAgICAgICAgICAgbGV0IHksIHosIHhfbm9kZSwgeV9ub2RlLCB6X25vZGUgPSBzZWxmLmxlZnQ7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9PT0gXCImXCJcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQub3BlcmF0b3IgPT09IFwifFwiXG4gICAgICAgICAgICAgICAgJiYgdHlwZW9mICh6ID0gc2VsZi5sZWZ0LmV2YWx1YXRlKGNvbXByZXNzb3IpKSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoeSA9IHNlbGYucmlnaHQucmlnaHQuZXZhbHVhdGUoY29tcHJlc3NvcikpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHogJiAoWCB8IHkpXG4gICAgICAgICAgICAgICAgICAgIHhfbm9kZSA9IHNlbGYucmlnaHQubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgeV9ub2RlID0gc2VsZi5yaWdodC5yaWdodDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAoeSA9IHNlbGYucmlnaHQubGVmdC5ldmFsdWF0ZShjb21wcmVzc29yKSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8geiAmICh5IHwgWClcbiAgICAgICAgICAgICAgICAgICAgeF9ub2RlID0gc2VsZi5yaWdodC5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgeV9ub2RlID0gc2VsZi5yaWdodC5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4X25vZGUgJiYgeV9ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoeSAmIHopID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB6X25vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHhfbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZW9yZGVyZWRfb3BzID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCJ8XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiJlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB4X25vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB6X25vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoeSAmIHosIHlfbm9kZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZiA9IGJlc3Rfb2YoY29tcHJlc3Nvciwgc2VsZiwgcmVvcmRlcmVkX29wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHggfCB4ID0+IDAgfCB4XG4gICAgICAgICAgICAvLyB4ICYgeCA9PiAwIHwgeFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChzZWxmLm9wZXJhdG9yID09PSBcInxcIiB8fCBzZWxmLm9wZXJhdG9yID09PSBcIiZcIilcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQuZXF1aXZhbGVudF90byhzZWxmLnJpZ2h0KVxuICAgICAgICAgICAgICAgICYmICFzZWxmLmxlZnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICYmIGNvbXByZXNzb3IuaW5fMzJfYml0X2NvbnRleHQodHJ1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNlbGYubGVmdCA9IG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBzZWxmLCB7IHZhbHVlOiAwIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPSBcInxcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gfnggXiB+eSA9PiB4IF4geVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPT09IFwiXlwiXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09PSBcIn5cIlxuICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09PSBcIn5cIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIl5cIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLnJpZ2h0LmV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBTaGlmdHMgdGhhdCBkbyBub3RoaW5nXG4gICAgICAgICAgICAvLyB7YW55dGhpbmd9ID4+IDAgPT4ge2FueXRoaW5nfSB8IDBcbiAgICAgICAgICAgIC8vIHthbnl0aGluZ30gPDwgMCA9PiB7YW55dGhpbmd9IHwgMFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChzZWxmLm9wZXJhdG9yID09PSBcIjw8XCIgfHwgc2VsZi5vcGVyYXRvciA9PT0gXCI+PlwiKVxuICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfTnVtYmVyICYmIHNlbGYucmlnaHQudmFsdWUgPT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPSBcInxcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluZCB1c2VsZXNzIHRvLWJpdHdpc2UgY29udmVyc2lvbnNcbiAgICAgICAgICAgIC8vIHszMiBiaXQgaW50ZWdlcn0gfCAwID0+IHszMiBiaXQgaW50ZWdlcn1cbiAgICAgICAgICAgIC8vIHszMiBiaXQgaW50ZWdlcn0gXiAwID0+IHszMiBiaXQgaW50ZWdlcn1cbiAgICAgICAgICAgIGNvbnN0IHplcm9fc2lkZSA9IHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfTnVtYmVyICYmIHNlbGYucmlnaHQudmFsdWUgPT09IDAgPyBzZWxmLnJpZ2h0XG4gICAgICAgICAgICAgICAgOiBzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfTnVtYmVyICYmIHNlbGYubGVmdC52YWx1ZSA9PT0gMCA/IHNlbGYubGVmdFxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG5vbl96ZXJvX3NpZGUgPSB6ZXJvX3NpZGUgJiYgKHplcm9fc2lkZSA9PT0gc2VsZi5yaWdodCA/IHNlbGYubGVmdCA6IHNlbGYucmlnaHQpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHplcm9fc2lkZVxuICAgICAgICAgICAgICAgICYmIChzZWxmLm9wZXJhdG9yID09PSBcInxcIiB8fCBzZWxmLm9wZXJhdG9yID09PSBcIl5cIilcbiAgICAgICAgICAgICAgICAmJiAobm9uX3plcm9fc2lkZS5pc18zMl9iaXRfaW50ZWdlcihjb21wcmVzc29yKSB8fCBjb21wcmVzc29yLmluXzMyX2JpdF9jb250ZXh0KHRydWUpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vbl96ZXJvX3NpZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHthbnl0aGluZ30gJiAwID0+IDBcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB6ZXJvX3NpZGVcbiAgICAgICAgICAgICAgICAmJiBzZWxmLm9wZXJhdG9yID09PSBcIiZcIlxuICAgICAgICAgICAgICAgICYmICFub25femVyb19zaWRlLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAmJiBub25femVyb19zaWRlLmlzXzMyX2JpdF9pbnRlZ2VyKGNvbXByZXNzb3IpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb19zaWRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB+MCBpcyBhbGwgb25lcywgYXMgd2VsbCBhcyAtMS5cbiAgICAgICAgICAgIC8vIFdlIGNhbiBlbGxpZGUgc29tZSBvcGVyYXRpb25zIHdpdGggaXQuXG4gICAgICAgICAgICBjb25zdCBpc19mdWxsX21hc2sgPSAobm9kZSkgPT5cbiAgICAgICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX051bWJlciAmJiBub2RlLnZhbHVlID09PSAtMVxuICAgICAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCItXCJcbiAgICAgICAgICAgICAgICAgICAgJiYgbm9kZS5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX051bWJlclxuICAgICAgICAgICAgICAgICAgICAmJiBub2RlLmV4cHJlc3Npb24udmFsdWUgPT09IDE7XG5cbiAgICAgICAgICAgIGNvbnN0IGZ1bGxfbWFzayA9IGlzX2Z1bGxfbWFzayhzZWxmLnJpZ2h0KSA/IHNlbGYucmlnaHRcbiAgICAgICAgICAgICAgICA6IGlzX2Z1bGxfbWFzayhzZWxmLmxlZnQpID8gc2VsZi5sZWZ0XG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJfc2lkZSA9IChmdWxsX21hc2sgPT09IHNlbGYucmlnaHQgPyBzZWxmLmxlZnQgOiBzZWxmLnJpZ2h0KTtcblxuICAgICAgICAgICAgLy8gezMyIGJpdCBpbnRlZ2VyfSAmIC0xID0+IHszMiBiaXQgaW50ZWdlcn1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBmdWxsX21hc2tcbiAgICAgICAgICAgICAgICAmJiBzZWxmLm9wZXJhdG9yID09PSBcIiZcIlxuICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJfc2lkZS5pc18zMl9iaXRfaW50ZWdlcihjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICAgICB8fCBjb21wcmVzc29yLmluXzMyX2JpdF9jb250ZXh0KHRydWUpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyX3NpZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHthbnl0aGluZ30gXiAtMSA9PiB+e2FueXRoaW5nfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGZ1bGxfbWFza1xuICAgICAgICAgICAgICAgICYmIHNlbGYub3BlcmF0b3IgPT09IFwiXlwiXG4gICAgICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICAgICAgICBvdGhlcl9zaWRlLmlzXzMyX2JpdF9pbnRlZ2VyKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgICAgIHx8IGNvbXByZXNzb3IuaW5fMzJfYml0X2NvbnRleHQodHJ1ZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXJfc2lkZS5iaXR3aXNlX25lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB4ICYmICh5ICYmIHopICA9PT4gIHggJiYgeSAmJiB6XG4gICAgLy8geCB8fCAoeSB8fCB6KSAgPT0+ICB4IHx8IHkgfHwgelxuICAgIC8vIHggKyAoXCJ5XCIgKyB6KSAgPT0+ICB4ICsgXCJ5XCIgKyB6XG4gICAgLy8gXCJ4XCIgKyAoeSArIFwielwiKT09PiAgXCJ4XCIgKyB5ICsgXCJ6XCJcbiAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgJiYgc2VsZi5yaWdodC5vcGVyYXRvciA9PSBzZWxmLm9wZXJhdG9yXG4gICAgICAgICYmIChsYXp5X29wLmhhcyhzZWxmLm9wZXJhdG9yKVxuICAgICAgICAgICAgfHwgKHNlbGYub3BlcmF0b3IgPT0gXCIrXCJcbiAgICAgICAgICAgICAgICAmJiAoc2VsZi5yaWdodC5sZWZ0LmlzX3N0cmluZyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICAgICB8fCAoc2VsZi5sZWZ0LmlzX3N0cmluZyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpKSkpXG4gICAgKSB7XG4gICAgICAgIHNlbGYubGVmdCA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmxlZnQsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yIDogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgIGxlZnQgICAgIDogc2VsZi5sZWZ0LnRyYW5zZm9ybShjb21wcmVzc29yKSxcbiAgICAgICAgICAgIHJpZ2h0ICAgIDogc2VsZi5yaWdodC5sZWZ0LnRyYW5zZm9ybShjb21wcmVzc29yKVxuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi5yaWdodCA9IHNlbGYucmlnaHQucmlnaHQudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gc2VsZi50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIHZhciBldiA9IHNlbGYuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgaWYgKGV2ICE9PSBzZWxmKSB7XG4gICAgICAgIGV2ID0gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoZXYsIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gYmVzdF9vZihjb21wcmVzc29yLCBldiwgc2VsZik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfU3ltYm9sRXhwb3J0LCBmdW5jdGlvbihzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9TeW1ib2xSZWYsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoXG4gICAgICAgICFjb21wcmVzc29yLm9wdGlvbihcImllOFwiKVxuICAgICAgICAmJiBpc191bmRlY2xhcmVkX3JlZihzZWxmKVxuICAgICAgICAmJiAhY29tcHJlc3Nvci5maW5kX3BhcmVudChBU1RfV2l0aClcbiAgICApIHtcbiAgICAgICAgc3dpdGNoIChzZWxmLm5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgIGNhc2UgXCJOYU5cIjpcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX05hTiwgc2VsZikub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgY2FzZSBcIkluZmluaXR5XCI6XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9JbmZpbml0eSwgc2VsZikub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJyZWR1Y2VfdmFyc1wiKSAmJiAhY29tcHJlc3Nvci5pc19saHMoKSkge1xuICAgICAgICByZXR1cm4gaW5saW5lX2ludG9fc3ltYm9scmVmKHNlbGYsIGNvbXByZXNzb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBpc19hdG9taWMobGhzLCBzZWxmKSB7XG4gICAgcmV0dXJuIGxocyBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgfHwgbGhzLlRZUEUgPT09IHNlbGYuVFlQRTtcbn1cblxuZGVmX29wdGltaXplKEFTVF9VbmRlZmluZWQsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfdW5kZWZpbmVkXCIpKSB7XG4gICAgICAgIHZhciB1bmRlZiA9IGZpbmRfdmFyaWFibGUoY29tcHJlc3NvciwgXCJ1bmRlZmluZWRcIik7XG4gICAgICAgIGlmICh1bmRlZikge1xuICAgICAgICAgICAgdmFyIHJlZiA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sUmVmLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgbmFtZSAgIDogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICAgICAgICBzY29wZSAgOiB1bmRlZi5zY29wZSxcbiAgICAgICAgICAgICAgICB0aGVkZWYgOiB1bmRlZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRfZmxhZyhyZWYsIFVOREVGSU5FRCk7XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBsaHMgPSBjb21wcmVzc29yLmlzX2xocygpO1xuICAgIGlmIChsaHMgJiYgaXNfYXRvbWljKGxocywgc2VsZikpIHJldHVybiBzZWxmO1xuICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBzZWxmLCB7XG4gICAgICAgIG9wZXJhdG9yOiBcInZvaWRcIixcbiAgICAgICAgZXhwcmVzc2lvbjogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pXG4gICAgfSk7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9JbmZpbml0eSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHZhciBsaHMgPSBjb21wcmVzc29yLmlzX2xocygpO1xuICAgIGlmIChsaHMgJiYgaXNfYXRvbWljKGxocywgc2VsZikpIHJldHVybiBzZWxmO1xuICAgIGlmIChcbiAgICAgICAgY29tcHJlc3Nvci5vcHRpb24oXCJrZWVwX2luZmluaXR5XCIpXG4gICAgICAgICYmICEobGhzICYmICFpc19hdG9taWMobGhzLCBzZWxmKSlcbiAgICAgICAgJiYgIWZpbmRfdmFyaWFibGUoY29tcHJlc3NvciwgXCJJbmZpbml0eVwiKVxuICAgICkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgIG9wZXJhdG9yOiBcIi9cIixcbiAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH0pLFxuICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pXG4gICAgfSk7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9OYU4sIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB2YXIgbGhzID0gY29tcHJlc3Nvci5pc19saHMoKTtcbiAgICBpZiAobGhzICYmICFpc19hdG9taWMobGhzLCBzZWxmKVxuICAgICAgICB8fCBmaW5kX3ZhcmlhYmxlKGNvbXByZXNzb3IsIFwiTmFOXCIpKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IFwiL1wiLFxuICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmNvbnN0IEFTU0lHTl9PUFMgPSBtYWtlUHJlZGljYXRlKFwiKyAtIC8gKiAlID4+IDw8ID4+PiB8IF4gJlwiKTtcbmNvbnN0IEFTU0lHTl9PUFNfQ09NTVVUQVRJVkUgPSBtYWtlUHJlZGljYXRlKFwiKiB8IF4gJlwiKTtcbmRlZl9vcHRpbWl6ZShBU1RfQXNzaWduLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKHNlbGYubG9naWNhbCkge1xuICAgICAgICByZXR1cm4gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmO1xuICAgIC8vIHggPSB4IC0tLT4geFxuICAgIGlmIChcbiAgICAgICAgc2VsZi5vcGVyYXRvciA9PT0gXCI9XCJcbiAgICAgICAgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAmJiBzZWxmLmxlZnQubmFtZSAhPT0gXCJhcmd1bWVudHNcIlxuICAgICAgICAmJiAhKGRlZiA9IHNlbGYubGVmdC5kZWZpbml0aW9uKCkpLnVuZGVjbGFyZWRcbiAgICAgICAgJiYgc2VsZi5yaWdodC5lcXVpdmFsZW50X3RvKHNlbGYubGVmdClcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpXG4gICAgICAgICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgJiYgKGRlZiA9IHNlbGYubGVmdC5kZWZpbml0aW9uKCkpLnNjb3BlID09PSBjb21wcmVzc29yLmZpbmRfcGFyZW50KEFTVF9MYW1iZGEpKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IDAsIG5vZGUsIHBhcmVudCA9IHNlbGY7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICBwYXJlbnQgPSBjb21wcmVzc29yLnBhcmVudChsZXZlbCsrKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfRXhpdCkge1xuICAgICAgICAgICAgICAgIGlmIChpbl90cnkobGV2ZWwsIHBhcmVudCkpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpc19yZWFjaGFibGUoZGVmLnNjb3BlLCBbIGRlZiBdKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub3BlcmF0b3IgPT0gXCI9XCIpIHJldHVybiBzZWxmLnJpZ2h0O1xuICAgICAgICAgICAgICAgIGRlZi5maXhlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvci5zbGljZSgwLCAtMSksXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHRcbiAgICAgICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiBwYXJlbnQucmlnaHQgPT09IG5vZGVcbiAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSAmJiBwYXJlbnQudGFpbF9ub2RlKCkgPT09IG5vZGUpO1xuICAgIH1cbiAgICBzZWxmID0gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcblxuICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiPVwiICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkpIHtcbiAgICAgICAgLy8geCA9IGV4cHIxIE9QIGV4cHIyXG4gICAgICAgIGlmIChzZWxmLnJpZ2h0LmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmxlZnQubmFtZSA9PSBzZWxmLmxlZnQubmFtZVxuICAgICAgICAgICAgJiYgQVNTSUdOX09QUy5oYXMoc2VsZi5yaWdodC5vcGVyYXRvcikpIHtcbiAgICAgICAgICAgIC8vIHggPSB4IC0gMiAgLS0tPiAgeCAtPSAyXG4gICAgICAgICAgICBzZWxmLm9wZXJhdG9yID0gc2VsZi5yaWdodC5vcGVyYXRvciArIFwiPVwiO1xuICAgICAgICAgICAgc2VsZi5yaWdodCA9IHNlbGYucmlnaHQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5yaWdodC5yaWdodCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQucmlnaHQubmFtZSA9PSBzZWxmLmxlZnQubmFtZVxuICAgICAgICAgICAgJiYgQVNTSUdOX09QU19DT01NVVRBVElWRS5oYXMoc2VsZi5yaWdodC5vcGVyYXRvcilcbiAgICAgICAgICAgICYmICFzZWxmLnJpZ2h0LmxlZnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgLy8geCA9IDIgJiB4ICAtLS0+ICB4ICY9IDJcbiAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPSBzZWxmLnJpZ2h0Lm9wZXJhdG9yICsgXCI9XCI7XG4gICAgICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC5sZWZ0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gaW5fdHJ5KGxldmVsLCBub2RlKSB7XG4gICAgICAgIGZ1bmN0aW9uIG1heV9hc3NpZ25tZW50X3Rocm93KCkge1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBzZWxmLnJpZ2h0O1xuICAgICAgICAgICAgc2VsZi5yaWdodCA9IG1ha2Vfbm9kZShBU1RfTnVsbCwgcmlnaHQpO1xuICAgICAgICAgICAgY29uc3QgbWF5X3Rocm93ID0gbm9kZS5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBzZWxmLnJpZ2h0ID0gcmlnaHQ7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXlfdGhyb3c7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RvcF9hdCA9IHNlbGYubGVmdC5kZWZpbml0aW9uKCkuc2NvcGUuZ2V0X2RlZnVuX3Njb3BlKCk7XG4gICAgICAgIHZhciBwYXJlbnQ7XG4gICAgICAgIHdoaWxlICgocGFyZW50ID0gY29tcHJlc3Nvci5wYXJlbnQobGV2ZWwrKykpICE9PSBzdG9wX2F0KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX1RyeSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuYmZpbmFsbHkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuYmNhdGNoICYmIG1heV9hc3NpZ25tZW50X3Rocm93KCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfRGVmYXVsdEFzc2lnbiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJldmFsdWF0ZVwiKSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgdmFyIGV2YWx1YXRlUmlnaHQgPSBzZWxmLnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuXG4gICAgLy8gYFt4ID0gdW5kZWZpbmVkXSA9IGZvb2AgLS0tPiBgW3hdID0gZm9vYFxuICAgIC8vIGAoYXJnID0gdW5kZWZpbmVkKSA9PiAuLi5gIC0tLT4gYChhcmcpID0+IC4uLmAgKHVubGVzcyBga2VlcF9mYXJnc2ApXG4gICAgLy8gYCgoYXJnID0gdW5kZWZpbmVkKSA9PiAuLi4pKClgIC0tLT4gYCgoYXJnKSA9PiAuLi4pKClgXG4gICAgbGV0IGxhbWJkYSwgaWlmZTtcbiAgICBpZiAoZXZhbHVhdGVSaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChsYW1iZGEgPSBjb21wcmVzc29yLnBhcmVudCgpKSBpbnN0YW5jZW9mIEFTVF9MYW1iZGFcbiAgICAgICAgICAgICAgICA/IChcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Nvci5vcHRpb24oXCJrZWVwX2ZhcmdzXCIpID09PSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB8fCAoaWlmZSA9IGNvbXByZXNzb3IucGFyZW50KDEpKS5UWVBFID09PSBcIkNhbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgaWlmZS5leHByZXNzaW9uID09PSBsYW1iZGFcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiB0cnVlXG4gICAgICAgICkge1xuICAgICAgICAgICAgc2VsZiA9IHNlbGYubGVmdDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZhbHVhdGVSaWdodCAhPT0gc2VsZi5yaWdodCkge1xuICAgICAgICBldmFsdWF0ZVJpZ2h0ID0gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoZXZhbHVhdGVSaWdodCwgc2VsZi5yaWdodCk7XG4gICAgICAgIHNlbGYucmlnaHQgPSBiZXN0X29mX2V4cHJlc3Npb24oZXZhbHVhdGVSaWdodCwgc2VsZi5yaWdodCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZnVuY3Rpb24gaXNfbnVsbGlzaF9jaGVjayhjaGVjaywgY2hlY2tfc3ViamVjdCwgY29tcHJlc3Nvcikge1xuICAgIGlmIChjaGVja19zdWJqZWN0Lm1heV90aHJvdyhjb21wcmVzc29yKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgbGV0IG51bGxpc2hfc2lkZTtcblxuICAgIC8vIGZvbyA9PSBudWxsXG4gICAgaWYgKFxuICAgICAgICBjaGVjayBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgJiYgY2hlY2sub3BlcmF0b3IgPT09IFwiPT1cIlxuICAgICAgICAvLyB3aGljaCBzaWRlIGlzIG51bGxpc2g/XG4gICAgICAgICYmIChcbiAgICAgICAgICAgIChudWxsaXNoX3NpZGUgPSBpc19udWxsaXNoKGNoZWNrLmxlZnQsIGNvbXByZXNzb3IpICYmIGNoZWNrLmxlZnQpXG4gICAgICAgICAgICB8fCAobnVsbGlzaF9zaWRlID0gaXNfbnVsbGlzaChjaGVjay5yaWdodCwgY29tcHJlc3NvcikgJiYgY2hlY2sucmlnaHQpXG4gICAgICAgIClcbiAgICAgICAgLy8gaXMgdGhlIG90aGVyIHNpZGUgdGhlIHNhbWUgYXMgdGhlIGNoZWNrX3N1YmplY3RcbiAgICAgICAgJiYgKFxuICAgICAgICAgICAgbnVsbGlzaF9zaWRlID09PSBjaGVjay5sZWZ0XG4gICAgICAgICAgICAgICAgPyBjaGVjay5yaWdodFxuICAgICAgICAgICAgICAgIDogY2hlY2subGVmdFxuICAgICAgICApLmVxdWl2YWxlbnRfdG8oY2hlY2tfc3ViamVjdClcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZm9vID09PSBudWxsIHx8IGZvbyA9PT0gdW5kZWZpbmVkXG4gICAgaWYgKGNoZWNrIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiBjaGVjay5vcGVyYXRvciA9PT0gXCJ8fFwiKSB7XG4gICAgICAgIGxldCBudWxsX2NtcDtcbiAgICAgICAgbGV0IHVuZGVmaW5lZF9jbXA7XG5cbiAgICAgICAgY29uc3QgZmluZF9jb21wYXJpc29uID0gY21wID0+IHtcbiAgICAgICAgICAgIGlmICghKFxuICAgICAgICAgICAgICAgIGNtcCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAmJiAoY21wLm9wZXJhdG9yID09PSBcIj09PVwiIHx8IGNtcC5vcGVyYXRvciA9PT0gXCI9PVwiKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGZvdW5kID0gMDtcbiAgICAgICAgICAgIGxldCBkZWZpbmVkX3NpZGU7XG5cbiAgICAgICAgICAgIGlmIChjbXAubGVmdCBpbnN0YW5jZW9mIEFTVF9OdWxsKSB7XG4gICAgICAgICAgICAgICAgZm91bmQrKztcbiAgICAgICAgICAgICAgICBudWxsX2NtcCA9IGNtcDtcbiAgICAgICAgICAgICAgICBkZWZpbmVkX3NpZGUgPSBjbXAucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY21wLnJpZ2h0IGluc3RhbmNlb2YgQVNUX051bGwpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICAgICAgICAgIG51bGxfY21wID0gY21wO1xuICAgICAgICAgICAgICAgIGRlZmluZWRfc2lkZSA9IGNtcC5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzX3VuZGVmaW5lZChjbXAubGVmdCwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZF9jbXAgPSBjbXA7XG4gICAgICAgICAgICAgICAgZGVmaW5lZF9zaWRlID0gY21wLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzX3VuZGVmaW5lZChjbXAucmlnaHQsIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQrKztcbiAgICAgICAgICAgICAgICB1bmRlZmluZWRfY21wID0gY21wO1xuICAgICAgICAgICAgICAgIGRlZmluZWRfc2lkZSA9IGNtcC5sZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm91bmQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZGVmaW5lZF9zaWRlLmVxdWl2YWxlbnRfdG8oY2hlY2tfc3ViamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZmluZF9jb21wYXJpc29uKGNoZWNrLmxlZnQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZmluZF9jb21wYXJpc29uKGNoZWNrLnJpZ2h0KSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGlmIChudWxsX2NtcCAmJiB1bmRlZmluZWRfY21wICYmIG51bGxfY21wICE9PSB1bmRlZmluZWRfY21wKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZGVmX29wdGltaXplKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJjb25kaXRpb25hbHNcIikpIHJldHVybiBzZWxmO1xuICAgIC8vIFRoaXMgbG9va3MgbGlrZSBsaWZ0X3NlcXVlbmNlcygpLCBzaG91bGQgcHJvYmFibHkgYmUgdW5kZXIgXCJzZXF1ZW5jZXNcIlxuICAgIGlmIChzZWxmLmNvbmRpdGlvbiBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBzZWxmLmNvbmRpdGlvbi5leHByZXNzaW9ucy5zbGljZSgpO1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IGV4cHJlc3Npb25zLnBvcCgpO1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKHNlbGYpO1xuICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCBleHByZXNzaW9ucyk7XG4gICAgfVxuICAgIHZhciBjb25kID0gc2VsZi5jb25kaXRpb24uZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgaWYgKGNvbmQgIT09IHNlbGYuY29uZGl0aW9uKSB7XG4gICAgICAgIGlmIChjb25kKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFpbnRhaW5fdGhpc19iaW5kaW5nKGNvbXByZXNzb3IucGFyZW50KCksIGNvbXByZXNzb3Iuc2VsZigpLCBzZWxmLmNvbnNlcXVlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1haW50YWluX3RoaXNfYmluZGluZyhjb21wcmVzc29yLnBhcmVudCgpLCBjb21wcmVzc29yLnNlbGYoKSwgc2VsZi5hbHRlcm5hdGl2ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5lZ2F0ZWQgPSBjb25kLm5lZ2F0ZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQoY29tcHJlc3NvcikpO1xuICAgIGlmIChiZXN0X29mKGNvbXByZXNzb3IsIGNvbmQsIG5lZ2F0ZWQpID09PSBuZWdhdGVkKSB7XG4gICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0NvbmRpdGlvbmFsLCBzZWxmLCB7XG4gICAgICAgICAgICBjb25kaXRpb246IG5lZ2F0ZWQsXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBzZWxmLmFsdGVybmF0aXZlLFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IHNlbGYuY29uc2VxdWVudFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uO1xuICAgIHZhciBjb25zZXF1ZW50ID0gc2VsZi5jb25zZXF1ZW50O1xuICAgIHZhciBhbHRlcm5hdGl2ZSA9IHNlbGYuYWx0ZXJuYXRpdmU7XG4gICAgLy8geD94OnkgLS0+IHh8fHlcbiAgICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAmJiBjb25zZXF1ZW50IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAmJiBjb25kaXRpb24uZGVmaW5pdGlvbigpID09PSBjb25zZXF1ZW50LmRlZmluaXRpb24oKSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcInx8XCIsXG4gICAgICAgICAgICBsZWZ0OiBjb25kaXRpb24sXG4gICAgICAgICAgICByaWdodDogYWx0ZXJuYXRpdmVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGlmIChmb28pIGV4cCA9IHNvbWV0aGluZzsgZWxzZSBleHAgPSBzb21ldGhpbmdfZWxzZTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgICAgICAgICAgICAgICAgdlxuICAgIC8vIGV4cCA9IGZvbyA/IHNvbWV0aGluZyA6IHNvbWV0aGluZ19lbHNlO1xuICAgIGlmIChcbiAgICAgICAgY29uc2VxdWVudCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgJiYgYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICYmIGNvbnNlcXVlbnQub3BlcmF0b3IgPT09IGFsdGVybmF0aXZlLm9wZXJhdG9yXG4gICAgICAgICYmIGNvbnNlcXVlbnQubG9naWNhbCA9PT0gYWx0ZXJuYXRpdmUubG9naWNhbFxuICAgICAgICAmJiBjb25zZXF1ZW50LmxlZnQuZXF1aXZhbGVudF90byhhbHRlcm5hdGl2ZS5sZWZ0KVxuICAgICAgICAmJiAoIXNlbGYuY29uZGl0aW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IGNvbnNlcXVlbnQub3BlcmF0b3IgPT0gXCI9XCJcbiAgICAgICAgICAgICAgICAmJiAhY29uc2VxdWVudC5sZWZ0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Fzc2lnbiwgc2VsZiwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IGNvbnNlcXVlbnQub3BlcmF0b3IsXG4gICAgICAgICAgICBsZWZ0OiBjb25zZXF1ZW50LmxlZnQsXG4gICAgICAgICAgICBsb2dpY2FsOiBjb25zZXF1ZW50LmxvZ2ljYWwsXG4gICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgY29uc2VxdWVudDogY29uc2VxdWVudC5yaWdodCxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZTogYWx0ZXJuYXRpdmUucmlnaHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB4ID8geShhKSA6IHkoYikgLS0+IHkoeCA/IGEgOiBiKVxuICAgIHZhciBhcmdfaW5kZXg7XG4gICAgaWYgKGNvbnNlcXVlbnQgaW5zdGFuY2VvZiBBU1RfQ2FsbFxuICAgICAgICAmJiBhbHRlcm5hdGl2ZS5UWVBFID09PSBjb25zZXF1ZW50LlRZUEVcbiAgICAgICAgJiYgY29uc2VxdWVudC5hcmdzLmxlbmd0aCA+IDBcbiAgICAgICAgJiYgY29uc2VxdWVudC5hcmdzLmxlbmd0aCA9PSBhbHRlcm5hdGl2ZS5hcmdzLmxlbmd0aFxuICAgICAgICAmJiBjb25zZXF1ZW50LmV4cHJlc3Npb24uZXF1aXZhbGVudF90byhhbHRlcm5hdGl2ZS5leHByZXNzaW9uKVxuICAgICAgICAmJiAhc2VsZi5jb25kaXRpb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAmJiAhY29uc2VxdWVudC5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgJiYgdHlwZW9mIChhcmdfaW5kZXggPSBzaW5nbGVfYXJnX2RpZmYoKSkgPT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YXIgbm9kZSA9IGNvbnNlcXVlbnQuY2xvbmUoKTtcbiAgICAgICAgbm9kZS5hcmdzW2FyZ19pbmRleF0gPSBtYWtlX25vZGUoQVNUX0NvbmRpdGlvbmFsLCBzZWxmLCB7XG4gICAgICAgICAgICBjb25kaXRpb246IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgY29uc2VxdWVudDogY29uc2VxdWVudC5hcmdzW2FyZ19pbmRleF0sXG4gICAgICAgICAgICBhbHRlcm5hdGl2ZTogYWx0ZXJuYXRpdmUuYXJnc1thcmdfaW5kZXhdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8gYSA/IGIgOiBjID8gYiA6IGQgLS0+IChhIHx8IGMpID8gYiA6IGRcbiAgICBpZiAoYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWxcbiAgICAgICAgJiYgY29uc2VxdWVudC5lcXVpdmFsZW50X3RvKGFsdGVybmF0aXZlLmNvbnNlcXVlbnQpKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0NvbmRpdGlvbmFsLCBzZWxmLCB7XG4gICAgICAgICAgICBjb25kaXRpb246IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwifHxcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBjb25kaXRpb24sXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGFsdGVybmF0aXZlLmNvbmRpdGlvblxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50LFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IGFsdGVybmF0aXZlLmFsdGVybmF0aXZlXG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cblxuICAgIC8vIGEgPT0gbnVsbCA/IGIgOiBhIC0+IGEgPz8gYlxuICAgIGlmIChcbiAgICAgICAgY29tcHJlc3Nvci5vcHRpb24oXCJlY21hXCIpID49IDIwMjAgJiZcbiAgICAgICAgaXNfbnVsbGlzaF9jaGVjayhjb25kaXRpb24sIGFsdGVybmF0aXZlLCBjb21wcmVzc29yKVxuICAgICkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcIj8/XCIsXG4gICAgICAgICAgICBsZWZ0OiBhbHRlcm5hdGl2ZSxcbiAgICAgICAgICAgIHJpZ2h0OiBjb25zZXF1ZW50XG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cblxuICAgIC8vIGEgPyBiIDogKGMsIGIpIC0tPiAoYSB8fCBjKSwgYlxuICAgIGlmIChhbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZVxuICAgICAgICAmJiBjb25zZXF1ZW50LmVxdWl2YWxlbnRfdG8oYWx0ZXJuYXRpdmUuZXhwcmVzc2lvbnNbYWx0ZXJuYXRpdmUuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHNlbGYsIFtcbiAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwifHxcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBjb25kaXRpb24sXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfc2VxdWVuY2Uoc2VsZiwgYWx0ZXJuYXRpdmUuZXhwcmVzc2lvbnMuc2xpY2UoMCwgLTEpKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjb25zZXF1ZW50XG4gICAgICAgIF0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICAvLyBhID8gYiA6IChjICYmIGIpIC0tPiAoYSB8fCBjKSAmJiBiXG4gICAgaWYgKGFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAmJiBhbHRlcm5hdGl2ZS5vcGVyYXRvciA9PSBcIiYmXCJcbiAgICAgICAgJiYgY29uc2VxdWVudC5lcXVpdmFsZW50X3RvKGFsdGVybmF0aXZlLnJpZ2h0KSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcIiYmXCIsXG4gICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcInx8XCIsXG4gICAgICAgICAgICAgICAgbGVmdDogY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBhbHRlcm5hdGl2ZS5sZWZ0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJpZ2h0OiBjb25zZXF1ZW50XG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICAvLyB4P3k/ejphOmEgLS0+IHgmJnk/ejphXG4gICAgaWYgKGNvbnNlcXVlbnQgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWxcbiAgICAgICAgJiYgY29uc2VxdWVudC5hbHRlcm5hdGl2ZS5lcXVpdmFsZW50X3RvKGFsdGVybmF0aXZlKSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgY29uZGl0aW9uOiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiYmXCIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGNvbnNlcXVlbnQuY29uZGl0aW9uXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQuY29uc2VxdWVudCxcbiAgICAgICAgICAgIGFsdGVybmF0aXZlOiBhbHRlcm5hdGl2ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8geCA/IHkgOiB5IC0tPiB4LCB5XG4gICAgaWYgKGNvbnNlcXVlbnQuZXF1aXZhbGVudF90byhhbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgW1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICBjb25zZXF1ZW50XG4gICAgICAgIF0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICAvLyB4ID8geSB8fCB6IDogeiAtLT4geCAmJiB5IHx8IHpcbiAgICBpZiAoY29uc2VxdWVudCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgJiYgY29uc2VxdWVudC5vcGVyYXRvciA9PSBcInx8XCJcbiAgICAgICAgJiYgY29uc2VxdWVudC5yaWdodC5lcXVpdmFsZW50X3RvKGFsdGVybmF0aXZlKSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcInx8XCIsXG4gICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiYmXCIsXG4gICAgICAgICAgICAgICAgbGVmdDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGNvbnNlcXVlbnQubGVmdFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByaWdodDogYWx0ZXJuYXRpdmVcbiAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgfVxuXG4gICAgY29uc3QgaW5fYm9vbCA9IGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCk7XG4gICAgaWYgKGlzX3RydWUoc2VsZi5jb25zZXF1ZW50KSkge1xuICAgICAgICBpZiAoaXNfZmFsc2Uoc2VsZi5hbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgICAgIC8vIGMgPyB0cnVlIDogZmFsc2UgLS0tPiAhIWNcbiAgICAgICAgICAgIHJldHVybiBib29sZWFuaXplKHNlbGYuY29uZGl0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjID8gdHJ1ZSA6IHggLS0tPiAhIWMgfHwgeFxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcInx8XCIsXG4gICAgICAgICAgICBsZWZ0OiBib29sZWFuaXplKHNlbGYuY29uZGl0aW9uKSxcbiAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmFsdGVybmF0aXZlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfZmFsc2Uoc2VsZi5jb25zZXF1ZW50KSkge1xuICAgICAgICBpZiAoaXNfdHJ1ZShzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICAgICAgLy8gYyA/IGZhbHNlIDogdHJ1ZSAtLS0+ICFjXG4gICAgICAgICAgICByZXR1cm4gYm9vbGVhbml6ZShzZWxmLmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3NvcikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGMgPyBmYWxzZSA6IHggLS0tPiAhYyAmJiB4XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IFwiJiZcIixcbiAgICAgICAgICAgIGxlZnQ6IGJvb2xlYW5pemUoc2VsZi5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpKSxcbiAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmFsdGVybmF0aXZlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfdHJ1ZShzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICAvLyBjID8geCA6IHRydWUgLS0tPiAhYyB8fCB4XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IFwifHxcIixcbiAgICAgICAgICAgIGxlZnQ6IGJvb2xlYW5pemUoc2VsZi5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpKSxcbiAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmNvbnNlcXVlbnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc19mYWxzZShzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICAvLyBjID8geCA6IGZhbHNlIC0tLT4gISFjICYmIHhcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgbGVmdDogYm9vbGVhbml6ZShzZWxmLmNvbmRpdGlvbiksXG4gICAgICAgICAgICByaWdodDogc2VsZi5jb25zZXF1ZW50XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gYm9vbGVhbml6ZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlzX2Jvb2xlYW4oKSkgcmV0dXJuIG5vZGU7XG4gICAgICAgIC8vICEhZXhwcmVzc2lvblxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgbm9kZSwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogbm9kZS5uZWdhdGUoY29tcHJlc3NvcilcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQVNUX1RydWUgb3IgITBcbiAgICBmdW5jdGlvbiBpc190cnVlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBBU1RfVHJ1ZVxuICAgICAgICAgICAgfHwgaW5fYm9vbFxuICAgICAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAmJiBub2RlLmdldFZhbHVlKClcbiAgICAgICAgICAgIHx8IChub2RlIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAgICAgJiYgbm9kZS5vcGVyYXRvciA9PSBcIiFcIlxuICAgICAgICAgICAgICAgICYmIG5vZGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICYmICFub2RlLmV4cHJlc3Npb24uZ2V0VmFsdWUoKSk7XG4gICAgfVxuICAgIC8vIEFTVF9GYWxzZSBvciAhMVxuICAgIGZ1bmN0aW9uIGlzX2ZhbHNlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBBU1RfRmFsc2VcbiAgICAgICAgICAgIHx8IGluX2Jvb2xcbiAgICAgICAgICAgICAgICAmJiBub2RlIGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgJiYgIW5vZGUuZ2V0VmFsdWUoKVxuICAgICAgICAgICAgfHwgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICAgICAmJiBub2RlLm9wZXJhdG9yID09IFwiIVwiXG4gICAgICAgICAgICAgICAgJiYgbm9kZS5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgJiYgbm9kZS5leHByZXNzaW9uLmdldFZhbHVlKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpbmdsZV9hcmdfZGlmZigpIHtcbiAgICAgICAgdmFyIGEgPSBjb25zZXF1ZW50LmFyZ3M7XG4gICAgICAgIHZhciBiID0gYWx0ZXJuYXRpdmUuYXJncztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhW2ldIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFhW2ldLmVxdWl2YWxlbnRfdG8oYltpXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYltpXSBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIHJldHVybjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVtqXSBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhW2pdLmVxdWl2YWxlbnRfdG8oYltqXSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9Cb29sZWFuLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHJldHVybiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICB2YWx1ZTogK3NlbGYudmFsdWVcbiAgICB9KTtcbiAgICB2YXIgcCA9IGNvbXByZXNzb3IucGFyZW50KCk7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiYm9vbGVhbnNfYXNfaW50ZWdlcnNcIikpIHtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIChwLm9wZXJhdG9yID09IFwiPT09XCIgfHwgcC5vcGVyYXRvciA9PSBcIiE9PVwiKSkge1xuICAgICAgICAgICAgcC5vcGVyYXRvciA9IHAub3BlcmF0b3IucmVwbGFjZSgvPSQvLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgIHZhbHVlOiArc2VsZi52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiYm9vbGVhbnNcIikpIHtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIChwLm9wZXJhdG9yID09IFwiPT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHAub3BlcmF0b3IgPT0gXCIhPVwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICtzZWxmLnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMSAtIHNlbGYudmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5mdW5jdGlvbiBzYWZlX3RvX2ZsYXR0ZW4odmFsdWUsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuZml4ZWRfdmFsdWUoKTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFTVF9DbGFzcykpIHJldHVybiB0cnVlO1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSAmJiB2YWx1ZS5jb250YWluc190aGlzKCkpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gY29tcHJlc3Nvci5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9OZXc7XG59XG5cbkFTVF9Qcm9wQWNjZXNzLkRFRk1FVEhPRChcImZsYXR0ZW5fb2JqZWN0XCIsIGZ1bmN0aW9uKGtleSwgY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJwcm9wZXJ0aWVzXCIpKSByZXR1cm47XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikgcmV0dXJuO1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQVNUX0RvdEhhc2gpIHJldHVybjtcblxuICAgIHZhciBhcnJvd3MgPSBjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9hcnJvd3NcIikgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJlY21hXCIpID49IDIwMTU7XG4gICAgdmFyIGV4cHIgPSB0aGlzLmV4cHJlc3Npb247XG4gICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfT2JqZWN0KSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGV4cHIucHJvcGVydGllcztcblxuICAgICAgICBmb3IgKHZhciBpID0gcHJvcHMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG5cbiAgICAgICAgICAgIGlmIChcIlwiICsgKHByb3AgaW5zdGFuY2VvZiBBU1RfQ29uY2lzZU1ldGhvZCA/IHByb3Aua2V5Lm5hbWUgOiBwcm9wLmtleSkgPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsX3Byb3BzX2ZsYXR0ZW5hYmxlID0gcHJvcHMuZXZlcnkoKHApID0+XG4gICAgICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgYXJyb3dzICYmIHAgaW5zdGFuY2VvZiBBU1RfQ29uY2lzZU1ldGhvZCAmJiAhcC52YWx1ZS5pc19nZW5lcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAmJiAhcC5jb21wdXRlZF9rZXkoKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFsbF9wcm9wc19mbGF0dGVuYWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghc2FmZV90b19mbGF0dGVuKHByb3AudmFsdWUsIGNvbXByZXNzb3IpKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TdWIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbWFrZV9ub2RlKEFTVF9BcnJheSwgZXhwciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IHByb3BzLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgQVNUX0FjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBtYWtlX25vZGUoQVNUX0Z1bmN0aW9uLCB2LCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IHByb3Aua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrIGluc3RhbmNlb2YgQVNUX05vZGUgJiYgIShrIGluc3RhbmNlb2YgQVNUX1N5bWJvbE1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2UocHJvcCwgWyBrLCB2IF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtYWtlX25vZGUoQVNUX051bWJlciwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX1N1YiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHZhciBleHByID0gc2VsZi5leHByZXNzaW9uO1xuICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0eTtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJwcm9wZXJ0aWVzXCIpKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoa2V5ICE9PSBwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50b1N0cmluZygpID09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wID0gc2VsZi5wcm9wZXJ0eSA9IGJlc3Rfb2ZfZXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICAgIG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGtleSwgcHJvcCkudHJhbnNmb3JtKGNvbXByZXNzb3IpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gXCJcIiArIGtleTtcbiAgICAgICAgICAgIGlmIChpc19iYXNpY19pZGVudGlmaWVyX3N0cmluZyhwcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAmJiBwcm9wZXJ0eS5sZW5ndGggPD0gcHJvcC5zaXplKCkgKyAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRG90LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHIsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBzZWxmLm9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlOiBwcm9wLnF1b3RlLFxuICAgICAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBmbjtcbiAgICBPUFRfQVJHVU1FTlRTOiBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJhcmd1bWVudHNcIilcbiAgICAgICAgJiYgZXhwciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgJiYgZXhwci5uYW1lID09IFwiYXJndW1lbnRzXCJcbiAgICAgICAgJiYgZXhwci5kZWZpbml0aW9uKCkub3JpZy5sZW5ndGggPT0gMVxuICAgICAgICAmJiAoZm4gPSBleHByLnNjb3BlKSBpbnN0YW5jZW9mIEFTVF9MYW1iZGFcbiAgICAgICAgJiYgZm4udXNlc19hcmd1bWVudHNcbiAgICAgICAgJiYgIShmbiBpbnN0YW5jZW9mIEFTVF9BcnJvdylcbiAgICAgICAgJiYgcHJvcCBpbnN0YW5jZW9mIEFTVF9OdW1iZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcHJvcC5nZXRWYWx1ZSgpO1xuICAgICAgICB2YXIgcGFyYW1zID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgYXJnbmFtZXMgPSBmbi5hcmduYW1lcztcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhcmduYW1lcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgaWYgKCEoYXJnbmFtZXNbbl0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRnVuYXJnKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrIE9QVF9BUkdVTUVOVFM7IC8vIGRlc3RydWN0dXJpbmcgcGFyYW1ldGVyIC0gYmFpbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmFtID0gYXJnbmFtZXNbbl0ubmFtZTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrIE9QVF9BUkdVTUVOVFM7IC8vIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgLSBiYWlsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMuYWRkKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJnbmFtZSA9IGZuLmFyZ25hbWVzW2luZGV4XTtcbiAgICAgICAgaWYgKGFyZ25hbWUgJiYgY29tcHJlc3Nvci5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGFyZ25hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcInJlZHVjZV92YXJzXCIpIHx8IGRlZi5hc3NpZ25tZW50cyB8fCBkZWYub3JpZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgYXJnbmFtZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWFyZ25hbWUgJiYgIWNvbXByZXNzb3Iub3B0aW9uKFwia2VlcF9mYXJnc1wiKSAmJiBpbmRleCA8IGZuLmFyZ25hbWVzLmxlbmd0aCArIDUpIHtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA+PSBmbi5hcmduYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhcmduYW1lID0gZm4uY3JlYXRlX3N5bWJvbChBU1RfU3ltYm9sRnVuYXJnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZm4sXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlOiBmbixcbiAgICAgICAgICAgICAgICAgICAgdGVudGF0aXZlX25hbWU6IFwiYXJndW1lbnRfXCIgKyBmbi5hcmduYW1lcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm4uYXJnbmFtZXMucHVzaChhcmduYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnbmFtZSkge1xuICAgICAgICAgICAgdmFyIHN5bSA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sUmVmLCBzZWxmLCBhcmduYW1lKTtcbiAgICAgICAgICAgIHN5bS5yZWZlcmVuY2Uoe30pO1xuICAgICAgICAgICAgY2xlYXJfZmxhZyhhcmduYW1lLCBVTlVTRUQpO1xuICAgICAgICAgICAgcmV0dXJuIHN5bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcHJlc3Nvci5pc19saHMoKSkgcmV0dXJuIHNlbGY7XG4gICAgaWYgKGtleSAhPT0gcHJvcCkge1xuICAgICAgICB2YXIgc3ViID0gc2VsZi5mbGF0dGVuX29iamVjdChwcm9wZXJ0eSwgY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgIGV4cHIgPSBzZWxmLmV4cHJlc3Npb24gPSBzdWIuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHByb3AgPSBzZWxmLnByb3BlcnR5ID0gc3ViLnByb3BlcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInByb3BlcnRpZXNcIikgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIilcbiAgICAgICAgJiYgcHJvcCBpbnN0YW5jZW9mIEFTVF9OdW1iZXIgJiYgZXhwciBpbnN0YW5jZW9mIEFTVF9BcnJheSkge1xuICAgICAgICB2YXIgaW5kZXggPSBwcm9wLmdldFZhbHVlKCk7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGV4cHIuZWxlbWVudHM7XG4gICAgICAgIHZhciByZXRWYWx1ZSA9IGVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgRkxBVFRFTjogaWYgKHNhZmVfdG9fZmxhdHRlbihyZXRWYWx1ZSwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHZhciBmbGF0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBlbGVtZW50cy5sZW5ndGg7IC0taSA+IGluZGV4Oykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnRzW2ldLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnVuc2hpZnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhdHRlbiAmJiB2YWx1ZS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSBmbGF0dGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldFZhbHVlIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikgYnJlYWsgRkxBVFRFTjtcbiAgICAgICAgICAgIHJldFZhbHVlID0gcmV0VmFsdWUgaW5zdGFuY2VvZiBBU1RfSG9sZSA/IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCByZXRWYWx1ZSkgOiByZXRWYWx1ZTtcbiAgICAgICAgICAgIGlmICghZmxhdHRlbikgdmFsdWVzLnVuc2hpZnQocmV0VmFsdWUpO1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikgYnJlYWsgRkxBVFRFTjtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHZhbHVlcy51bnNoaWZ0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhdHRlbikge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJldFZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCB2YWx1ZXMpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHJldHVybiBtYWtlX25vZGUoQVNUX1N1Yiwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IG1ha2Vfbm9kZShBU1RfQXJyYXksIGV4cHIsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IHZhbHVlc1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtYWtlX25vZGUoQVNUX051bWJlciwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXhcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGV2ID0gc2VsZi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICBpZiAoZXYgIT09IHNlbGYpIHtcbiAgICAgICAgZXYgPSBtYWtlX25vZGVfZnJvbV9jb25zdGFudChldiwgc2VsZikub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBiZXN0X29mKGNvbXByZXNzb3IsIGV2LCBzZWxmKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9DaGFpbiwgZnVuY3Rpb24gKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoaXNfbnVsbGlzaChzZWxmLmV4cHJlc3Npb24sIGNvbXByZXNzb3IpKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBjb21wcmVzc29yLnBhcmVudCgpO1xuICAgICAgICAvLyBJdCdzIHZhbGlkIHRvIGRlbGV0ZSBhIG51bGxpc2ggb3B0aW9uYWwgY2hhaW4sIGJ1dCBpZiB3ZSBvcHRpbWl6ZWRcbiAgICAgICAgLy8gdGhpcyB0byBgZGVsZXRlIHVuZGVmaW5lZGAgdGhlbiBpdCB3b3VsZCBhcHBlYXIgdG8gYmUgYSBzeW50YXggZXJyb3JcbiAgICAgICAgLy8gd2hlbiB3ZSB0cnkgdG8gb3B0aW1pemUgdGhlIGRlbGV0ZS4gVGhhbmtmdWxseSwgYGRlbGV0ZSAwYCBpcyBmaW5lLlxuICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4ICYmIHBhcmVudC5vcGVyYXRvciA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KDAsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICAgc2VsZi5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3NcbiAgICAgICAgfHwgc2VsZi5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gS2VlcCB0aGUgQVNUIHZhbGlkLCBpbiBjYXNlIHRoZSBjaGlsZCBzd2FwcGVkIGl0c2VsZlxuICAgICAgICByZXR1cm4gc2VsZi5leHByZXNzaW9uO1xuICAgIH1cbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0RvdCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGNvbnN0IHBhcmVudCA9IGNvbXByZXNzb3IucGFyZW50KCk7XG4gICAgaWYgKGNvbXByZXNzb3IuaXNfbGhzKCkpIHJldHVybiBzZWxmO1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9wcm90b1wiKVxuICAgICAgICAmJiBzZWxmLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRG90XG4gICAgICAgICYmIHNlbGYuZXhwcmVzc2lvbi5wcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgIHZhciBleHAgPSBzZWxmLmV4cHJlc3Npb24uZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKGlzX3VuZGVjbGFyZWRfcmVmKGV4cCkpIHN3aXRjaCAoZXhwLm5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IG1ha2Vfbm9kZShBU1RfQXJyYXksIHNlbGYuZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IG1ha2VfZW1wdHlfZnVuY3Rpb24oc2VsZi5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJOdW1iZXJcIjpcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBzZWxmLmV4cHJlc3Npb24sIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBtYWtlX25vZGUoQVNUX09iamVjdCwgc2VsZi5leHByZXNzaW9uLCB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlJlZ0V4cFwiOlxuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uID0gbWFrZV9ub2RlKEFTVF9SZWdFeHAsIHNlbGYuZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7IHNvdXJjZTogXCJ0XCIsIGZsYWdzOiBcIlwiIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlN0cmluZ1wiOlxuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uID0gbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYuZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYWxsKSB8fCAhaGFzX2Fubm90YXRpb24ocGFyZW50LCBfTk9JTkxJTkUpKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IHNlbGYuZmxhdHRlbl9vYmplY3Qoc2VsZi5wcm9wZXJ0eSwgY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChzdWIpIHJldHVybiBzdWIub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzXG4gICAgICAgICYmIHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGxldCBldiA9IHNlbGYuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgaWYgKGV2ICE9PSBzZWxmKSB7XG4gICAgICAgIGV2ID0gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoZXYsIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gYmVzdF9vZihjb21wcmVzc29yLCBldiwgc2VsZik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmZ1bmN0aW9uIGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dChzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgcmV0dXJuIGJlc3Rfb2YoY29tcHJlc3Nvciwgc2VsZiwgbWFrZV9zZXF1ZW5jZShzZWxmLCBbXG4gICAgICAgICAgICBzZWxmLFxuICAgICAgICAgICAgbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKVxuICAgICAgICBdKS5vcHRpbWl6ZShjb21wcmVzc29yKSk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBpbmxpbmVfYXJyYXlfbGlrZV9zcHJlYWQoZWxlbWVudHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSB7XG4gICAgICAgICAgICB2YXIgZXhwciA9IGVsLmV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZXhwciBpbnN0YW5jZW9mIEFTVF9BcnJheVxuICAgICAgICAgICAgICAgICYmICFleHByLmVsZW1lbnRzLnNvbWUoZWxtID0+IGVsbSBpbnN0YW5jZW9mIEFTVF9Ib2xlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuc3BsaWNlKGksIDEsIC4uLmV4cHIuZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIC8vIFN0ZXAgYmFjayBvbmUsIGFzIHRoZSBlbGVtZW50IGF0IGkgaXMgbm93IG5ldy5cbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbiBhcnJheS1saWtlIHNwcmVhZCwgc3ByZWFkaW5nIGEgbm9uLWl0ZXJhYmxlIHZhbHVlIGlzIFR5cGVFcnJvci5cbiAgICAgICAgICAgIC8vIFdlIHRoZXJlZm9yZSBjYW7igJl0IG9wdGltaXplIGFueXRoaW5nIGVsc2UsIHVubGlrZSB3aXRoIG9iamVjdCBzcHJlYWQuXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmRlZl9vcHRpbWl6ZShBU1RfQXJyYXksIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB2YXIgb3B0aW1pemVkID0gbGl0ZXJhbHNfaW5fYm9vbGVhbl9jb250ZXh0KHNlbGYsIGNvbXByZXNzb3IpO1xuICAgIGlmIChvcHRpbWl6ZWQgIT09IHNlbGYpIHtcbiAgICAgICAgcmV0dXJuIG9wdGltaXplZDtcbiAgICB9XG4gICAgaW5saW5lX2FycmF5X2xpa2Vfc3ByZWFkKHNlbGYuZWxlbWVudHMpO1xuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmZ1bmN0aW9uIGlubGluZV9vYmplY3RfcHJvcF9zcHJlYWQocHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikge1xuICAgICAgICAgICAgY29uc3QgZXhwciA9IHByb3AuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBleHByIGluc3RhbmNlb2YgQVNUX09iamVjdFxuICAgICAgICAgICAgICAgICYmIGV4cHIucHJvcGVydGllcy5ldmVyeShwcm9wID0+IHByb3AgaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuc3BsaWNlKGksIDEsIC4uLmV4cHIucHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgLy8gU3RlcCBiYWNrIG9uZSwgYXMgdGhlIHByb3BlcnR5IGF0IGkgaXMgbm93IG5ldy5cbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChcbiAgICAgICAgICAgICAgICAgICAgLy8gYGV4cHIuaXNfY29uc3RhbnQoKWAgcmV0dXJucyBgZmFsc2VgIGZvciBgQVNUX1JlZ0V4cGAsIHNvIG5lZWQgYm90aC5cbiAgICAgICAgICAgICAgICAgICAgZXhwciBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICAgICB8fCBleHByLmlzX2NvbnN0YW50KClcbiAgICAgICAgICAgICAgICApICYmICEoZXhwciBpbnN0YW5jZW9mIEFTVF9TdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5saWtlIGFycmF5LWxpa2Ugc3ByZWFkLCBpbiBvYmplY3Qgc3ByZWFkLCBzcHJlYWRpbmcgYVxuICAgICAgICAgICAgICAgIC8vIG5vbi1pdGVyYWJsZSB2YWx1ZSBzaWxlbnRseSBkb2VzIG5vdGhpbmc7IGl0IGlzIHRodXMgc2FmZVxuICAgICAgICAgICAgICAgIC8vIHRvIHJlbW92ZS4gQVNUX1N0cmluZyBpcyB0aGUgb25seSBpdGVyYWJsZSBjb25zdGFudC5cbiAgICAgICAgICAgICAgICBwcm9wcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5kZWZfb3B0aW1pemUoQVNUX09iamVjdCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHZhciBvcHRpbWl6ZWQgPSBsaXRlcmFsc19pbl9ib29sZWFuX2NvbnRleHQoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgaWYgKG9wdGltaXplZCAhPT0gc2VsZikge1xuICAgICAgICByZXR1cm4gb3B0aW1pemVkO1xuICAgIH1cbiAgICBpbmxpbmVfb2JqZWN0X3Byb3Bfc3ByZWFkKHNlbGYucHJvcGVydGllcyk7XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9SZWdFeHAsIGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dCk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfUmV0dXJuLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKHNlbGYudmFsdWUgJiYgaXNfdW5kZWZpbmVkKHNlbGYudmFsdWUsIGNvbXByZXNzb3IpKSB7XG4gICAgICAgIHNlbGYudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0Fycm93LCBvcHRfQVNUX0xhbWJkYSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBzZWxmID0gb3B0X0FTVF9MYW1iZGEoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlX2Fycm93c1wiKVxuICAgICAgICAmJiBjb21wcmVzc29yLm9wdGlvbihcImVjbWFcIikgPj0gMjAxNVxuICAgICAgICAmJiAhc2VsZi5uYW1lXG4gICAgICAgICYmICFzZWxmLmlzX2dlbmVyYXRvclxuICAgICAgICAmJiAhc2VsZi51c2VzX2FyZ3VtZW50c1xuICAgICAgICAmJiAhc2VsZi5waW5uZWQoKSkge1xuICAgICAgICBjb25zdCB1c2VzX3RoaXMgPSB3YWxrKHNlbGYsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVGhpcykgcmV0dXJuIHdhbGtfYWJvcnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXVzZXNfdGhpcykgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQXJyb3csIHNlbGYsIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0NsYXNzLCBmdW5jdGlvbihzZWxmKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfQ2xhc3NTdGF0aWNCbG9jayAmJiBwcm9wLmJvZHkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHNlbGYucHJvcGVydGllcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0NsYXNzU3RhdGljQmxvY2ssIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB0aWdodGVuX2JvZHkoc2VsZi5ib2R5LCBjb21wcmVzc29yKTtcbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX1lpZWxkLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKHNlbGYuZXhwcmVzc2lvbiAmJiAhc2VsZi5pc19zdGFyICYmIGlzX3VuZGVmaW5lZChzZWxmLmV4cHJlc3Npb24sIGNvbXByZXNzb3IpKSB7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfVGVtcGxhdGVTdHJpbmcsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoXG4gICAgICAgICFjb21wcmVzc29yLm9wdGlvbihcImV2YWx1YXRlXCIpXG4gICAgICAgIHx8IGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZ1xuICAgICkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWxmLnNlZ21lbnRzW2ldO1xuICAgICAgICBpZiAoc2VnbWVudCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VnbWVudC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRvIGNvbnN0YW50IHZhbHVlXG4gICAgICAgICAgICAvLyBDb25zdGFudCB2YWx1ZSBzaG9ydGVyIHRoYW4gJHtzZWdtZW50fVxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gc2VnbWVudCAmJiAocmVzdWx0ICsgXCJcIikubGVuZ3RoIDw9IHNlZ21lbnQuc2l6ZSgpICsgXCIke31cIi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBzaG91bGQgYWx3YXlzIGJlIGEgcHJldmlvdXMgYW5kIG5leHQgc2VnbWVudCBpZiBzZWdtZW50IGlzIGEgbm9kZVxuICAgICAgICAgICAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLnZhbHVlID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0udmFsdWUgKyByZXN1bHQgKyBzZWxmLnNlZ21lbnRzWysraV0udmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBgYmVmb3JlICR7YGlubmVyQmVmb3JlICR7YW55fSBpbm5lckFmdGVyYH0gYWZ0ZXJgID0+IGBiZWZvcmUgaW5uZXJCZWZvcmUgJHthbnl9IGlubmVyQWZ0ZXIgYWZ0ZXJgXG4gICAgICAgICAgICAvLyBUT0RPOlxuICAgICAgICAgICAgLy8gYGJlZm9yZSAkeyd0ZXN0JyArIGZvb30gYWZ0ZXJgID0+IGBiZWZvcmUgaW5uZXJCZWZvcmUgJHthbnl9IGlubmVyQWZ0ZXIgYWZ0ZXJgXG4gICAgICAgICAgICAvLyBgYmVmb3JlICR7Zm9vICsgJ3Rlc3R9IGFmdGVyYCA9PiBgYmVmb3JlIGlubmVyQmVmb3JlICR7YW55fSBpbm5lckFmdGVyIGFmdGVyYFxuICAgICAgICAgICAgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBBU1RfVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJzID0gc2VnbWVudC5zZWdtZW50cztcbiAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS52YWx1ZSArPSBpbm5lcnNbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBpbm5lcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IGlubmVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9XG4gICAgc2VsZi5zZWdtZW50cyA9IHNlZ21lbnRzO1xuXG4gICAgLy8gYGZvb2AgPT4gXCJmb29cIlxuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHNlZ21lbnRzWzBdKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIHNlZ21lbnRzLmxlbmd0aCA9PT0gM1xuICAgICAgICAmJiBzZWdtZW50c1sxXSBpbnN0YW5jZW9mIEFTVF9Ob2RlXG4gICAgICAgICYmIChcbiAgICAgICAgICAgIHNlZ21lbnRzWzFdLmlzX3N0cmluZyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgc2VnbWVudHNbMV0uaXNfbnVtYmVyX29yX2JpZ2ludChjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgaXNfbnVsbGlzaChzZWdtZW50c1sxXSwgY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgLy8gYGZvbyR7YmFyfWAgPT4gXCJmb29cIiArIGJhclxuICAgICAgICBpZiAoc2VnbWVudHNbMl0udmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2VnbWVudHNbMF0udmFsdWUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHNlZ21lbnRzWzFdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYCR7YmFyfWJhemAgPT4gYmFyICsgXCJiYXpcIlxuICAgICAgICBpZiAoc2VnbWVudHNbMF0udmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBzZWdtZW50c1sxXSxcbiAgICAgICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNlZ21lbnRzWzJdLnZhbHVlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9QcmVmaXhlZFRlbXBsYXRlU3RyaW5nLCBmdW5jdGlvbihzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuLy8gW1wicFwiXToxIC0tLT4gcDoxXG4vLyBbNDJdOjEgLS0tPiA0MjoxXG5mdW5jdGlvbiBsaWZ0X2tleShzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImNvbXB1dGVkX3Byb3BzXCIpKSByZXR1cm4gc2VsZjtcbiAgICAvLyBzYXZlIGEgY29tcGFyaXNvbiBpbiB0aGUgdHlwaWNhbCBjYXNlXG4gICAgaWYgKCEoc2VsZi5rZXkgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQpKSByZXR1cm4gc2VsZjtcbiAgICAvLyBhbGxvdyBjZXJ0YWluIGFjY2VwdGFibGUgcHJvcHMgYXMgbm90IGFsbCBBU1RfQ29uc3RhbnRzIGFyZSB0cnVlIGNvbnN0YW50c1xuICAgIGlmIChzZWxmLmtleSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcgfHwgc2VsZi5rZXkgaW5zdGFuY2VvZiBBU1RfTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNlbGYua2V5LnZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChrZXkgPT0gXCJjb25zdHJ1Y3RvclwiXG4gICAgICAgICAgICAmJiBjb21wcmVzc29yLnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0NsYXNzKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsKSB7XG4gICAgICAgICAgICBzZWxmLnF1b3RlID0gc2VsZi5rZXkucXVvdGU7XG4gICAgICAgICAgICBzZWxmLmtleSA9IGtleTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmIGluc3RhbmNlb2YgQVNUX0NsYXNzUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHNlbGYucXVvdGUgPSBzZWxmLmtleS5xdW90ZTtcbiAgICAgICAgICAgIHNlbGYua2V5ID0gbWFrZV9ub2RlKEFTVF9TeW1ib2xDbGFzc1Byb3BlcnR5LCBzZWxmLmtleSwge1xuICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5xdW90ZSA9IHNlbGYua2V5LnF1b3RlO1xuICAgICAgICAgICAgc2VsZi5rZXkgPSBtYWtlX25vZGUoQVNUX1N5bWJvbE1ldGhvZCwgc2VsZi5rZXksIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cblxuZGVmX29wdGltaXplKEFTVF9PYmplY3RQcm9wZXJ0eSwgbGlmdF9rZXkpO1xuXG5kZWZfb3B0aW1pemUoQVNUX0NvbmNpc2VNZXRob2QsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBsaWZ0X2tleShzZWxmLCBjb21wcmVzc29yKTtcbiAgICAvLyBwKCl7cmV0dXJuIHg7fSAtLS0+IHA6KCk9PnhcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJhcnJvd3NcIilcbiAgICAgICAgJiYgY29tcHJlc3Nvci5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9PYmplY3RcbiAgICAgICAgJiYgIXNlbGYudmFsdWUuaXNfZ2VuZXJhdG9yXG4gICAgICAgICYmICFzZWxmLnZhbHVlLnVzZXNfYXJndW1lbnRzXG4gICAgICAgICYmICFzZWxmLnZhbHVlLnBpbm5lZCgpXG4gICAgICAgICYmIHNlbGYudmFsdWUuYm9keS5sZW5ndGggPT0gMVxuICAgICAgICAmJiBzZWxmLnZhbHVlLmJvZHlbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuXG4gICAgICAgICYmIHNlbGYudmFsdWUuYm9keVswXS52YWx1ZVxuICAgICAgICAmJiAhc2VsZi52YWx1ZS5jb250YWluc190aGlzKCkpIHtcbiAgICAgICAgdmFyIGFycm93ID0gbWFrZV9ub2RlKEFTVF9BcnJvdywgc2VsZi52YWx1ZSwgc2VsZi52YWx1ZSk7XG4gICAgICAgIGFycm93LmFzeW5jID0gc2VsZi52YWx1ZS5hc3luYztcbiAgICAgICAgYXJyb3cuaXNfZ2VuZXJhdG9yID0gc2VsZi52YWx1ZS5pc19nZW5lcmF0b3I7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX09iamVjdEtleVZhbCwgc2VsZiwge1xuICAgICAgICAgICAga2V5OiBzZWxmLmtleSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xNZXRob2QgPyBzZWxmLmtleS5uYW1lIDogc2VsZi5rZXksXG4gICAgICAgICAgICB2YWx1ZTogYXJyb3csXG4gICAgICAgICAgICBxdW90ZTogc2VsZi5xdW90ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfT2JqZWN0S2V5VmFsLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgbGlmdF9rZXkoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgLy8gcDpmdW5jdGlvbigpe30gLS0tPiBwKCl7fVxuICAgIC8vIHA6ZnVuY3Rpb24qKCl7fSAtLS0+ICpwKCl7fVxuICAgIC8vIHA6YXN5bmMgZnVuY3Rpb24oKXt9IC0tLT4gYXN5bmMgcCgpe31cbiAgICAvLyBwOigpPT57fSAtLS0+IHAoKXt9XG4gICAgLy8gcDphc3luYygpPT57fSAtLS0+IGFzeW5jIHAoKXt9XG4gICAgdmFyIHVuc2FmZV9tZXRob2RzID0gY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfbWV0aG9kc1wiKTtcbiAgICBpZiAodW5zYWZlX21ldGhvZHNcbiAgICAgICAgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJlY21hXCIpID49IDIwMTVcbiAgICAgICAgJiYgKCEodW5zYWZlX21ldGhvZHMgaW5zdGFuY2VvZiBSZWdFeHApIHx8IHVuc2FmZV9tZXRob2RzLnRlc3Qoc2VsZi5rZXkgKyBcIlwiKSkpIHtcbiAgICAgICAgdmFyIGtleSA9IHNlbGYua2V5O1xuICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLnZhbHVlO1xuICAgICAgICB2YXIgaXNfYXJyb3dfd2l0aF9ibG9jayA9IHZhbHVlIGluc3RhbmNlb2YgQVNUX0Fycm93XG4gICAgICAgICAgICAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmJvZHkpXG4gICAgICAgICAgICAmJiAhdmFsdWUuY29udGFpbnNfdGhpcygpO1xuICAgICAgICBpZiAoKGlzX2Fycm93X3dpdGhfYmxvY2sgfHwgdmFsdWUgaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb24pICYmICF2YWx1ZS5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Db25jaXNlTWV0aG9kLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSA/IGtleSA6IG1ha2Vfbm9kZShBU1RfU3ltYm9sTWV0aG9kLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFrZV9ub2RlKEFTVF9BY2Nlc3NvciwgdmFsdWUsIHZhbHVlKSxcbiAgICAgICAgICAgICAgICBxdW90ZTogc2VsZi5xdW90ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfRGVzdHJ1Y3R1cmluZywgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInB1cmVfZ2V0dGVyc1wiKSA9PSB0cnVlXG4gICAgICAgICYmIGNvbXByZXNzb3Iub3B0aW9uKFwidW51c2VkXCIpXG4gICAgICAgICYmICFzZWxmLmlzX2FycmF5XG4gICAgICAgICYmIEFycmF5LmlzQXJyYXkoc2VsZi5uYW1lcylcbiAgICAgICAgJiYgIWlzX2Rlc3RydWN0dXJpbmdfZXhwb3J0X2RlY2woY29tcHJlc3NvcilcbiAgICAgICAgJiYgIShzZWxmLm5hbWVzW3NlbGYubmFtZXMubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSkge1xuICAgICAgICB2YXIga2VlcCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gc2VsZi5uYW1lc1tpXTtcbiAgICAgICAgICAgIGlmICghKGVsZW0gaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsXG4gICAgICAgICAgICAgICAgJiYgdHlwZW9mIGVsZW0ua2V5ID09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAmJiBlbGVtLnZhbHVlIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uXG4gICAgICAgICAgICAgICAgJiYgIXNob3VsZF9yZXRhaW4oY29tcHJlc3NvciwgZWxlbS52YWx1ZS5kZWZpbml0aW9uKCkpKSkge1xuICAgICAgICAgICAgICAgIGtlZXAucHVzaChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2VlcC5sZW5ndGggIT0gc2VsZi5uYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGYubmFtZXMgPSBrZWVwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gaXNfZGVzdHJ1Y3R1cmluZ19leHBvcnRfZGVjbChjb21wcmVzc29yKSB7XG4gICAgICAgIHZhciBhbmNlc3RvcnMgPSBbL15WYXJEZWYkLywgL14oQ29uc3R8TGV0fFZhcikkLywgL15FeHBvcnQkL107XG4gICAgICAgIGZvciAodmFyIGEgPSAwLCBwID0gMCwgbGVuID0gYW5jZXN0b3JzLmxlbmd0aDsgYSA8IGxlbjsgcCsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gY29tcHJlc3Nvci5wYXJlbnQocCk7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGEgPT09IDAgJiYgcGFyZW50LlRZUEUgPT0gXCJEZXN0cnVjdHVyaW5nXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFhbmNlc3RvcnNbYV0udGVzdChwYXJlbnQuVFlQRSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkX3JldGFpbihjb21wcmVzc29yLCBkZWYpIHtcbiAgICAgICAgaWYgKGRlZi5yZWZlcmVuY2VzLmxlbmd0aCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghZGVmLmdsb2JhbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY29tcHJlc3Nvci50b3BsZXZlbC52YXJzKSB7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci50b3BfcmV0YWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzb3IudG9wX3JldGFpbihkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIGEgc21hbGwgd3JhcHBlciBhcm91bmQgc291cmNlLW1hcCBhbmQgQGpyaWRnZXdlbGwvc291cmNlLW1hcFxuZnVuY3Rpb24qIFNvdXJjZU1hcChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgZmlsZSA6IG51bGwsXG4gICAgICAgIHJvb3QgOiBudWxsLFxuICAgICAgICBvcmlnIDogbnVsbCxcbiAgICAgICAgZmlsZXM6IHt9LFxuICAgIH0pO1xuXG4gICAgdmFyIG9yaWdfbWFwO1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgc291cmNlTWFwLlNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGUgICAgICAgOiBvcHRpb25zLmZpbGUsXG4gICAgICAgIHNvdXJjZVJvb3QgOiBvcHRpb25zLnJvb3RcbiAgICB9KTtcblxuICAgIGxldCBzb3VyY2VzQ29udGVudCA9IHtfX3Byb3RvX186IG51bGx9O1xuICAgIGxldCBmaWxlcyA9IG9wdGlvbnMuZmlsZXM7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBmaWxlcykgaWYgKEhPUChmaWxlcywgbmFtZSkpIHtcbiAgICAgICAgc291cmNlc0NvbnRlbnRbbmFtZV0gPSBmaWxlc1tuYW1lXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub3JpZykge1xuICAgICAgICAvLyBXZSBzdXBwb3J0IGJvdGggQGpyaWRnZXdlbGwvc291cmNlLW1hcCAod2hpY2ggaGFzIGEgc3luY1xuICAgICAgICAvLyBTb3VyY2VNYXBDb25zdW1lcikgYW5kIHNvdXJjZS1tYXAgKHdoaWNoIGhhcyBhbiBhc3luY1xuICAgICAgICAvLyBTb3VyY2VNYXBDb25zdW1lcikuXG4gICAgICAgIG9yaWdfbWFwID0geWllbGQgbmV3IHNvdXJjZU1hcC5Tb3VyY2VNYXBDb25zdW1lcihvcHRpb25zLm9yaWcpO1xuICAgICAgICBpZiAob3JpZ19tYXAuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgICAgIG9yaWdfbWFwLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IG9yaWdfbWFwLnNvdXJjZXNDb250ZW50W2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXNDb250ZW50W3NvdXJjZV0gPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKHNvdXJjZSwgZ2VuX2xpbmUsIGdlbl9jb2wsIG9yaWdfbGluZSwgb3JpZ19jb2wsIG5hbWUpIHtcbiAgICAgICAgbGV0IGdlbmVyYXRlZFBvcyA9IHsgbGluZTogZ2VuX2xpbmUsIGNvbHVtbjogZ2VuX2NvbCB9O1xuXG4gICAgICAgIGlmIChvcmlnX21hcCkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBvcmlnX21hcC5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnX2xpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnX2NvbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5mby5zb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZDogZ2VuZXJhdGVkUG9zLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlID0gaW5mby5zb3VyY2U7XG4gICAgICAgICAgICBvcmlnX2xpbmUgPSBpbmZvLmxpbmU7XG4gICAgICAgICAgICBvcmlnX2NvbCA9IGluZm8uY29sdW1uO1xuICAgICAgICAgICAgbmFtZSA9IGluZm8ubmFtZSB8fCBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIGdlbmVyYXRlZCA6IGdlbmVyYXRlZFBvcyxcbiAgICAgICAgICAgIG9yaWdpbmFsICA6IHsgbGluZTogb3JpZ19saW5lLCBjb2x1bW46IG9yaWdfY29sIH0sXG4gICAgICAgICAgICBzb3VyY2UgICAgOiBzb3VyY2UsXG4gICAgICAgICAgICBuYW1lICAgICAgOiBuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2UsIHNvdXJjZXNDb250ZW50W3NvdXJjZV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFuKG1hcCkge1xuICAgICAgICBjb25zdCBhbGxOdWxsID0gbWFwLnNvdXJjZXNDb250ZW50ICYmIG1hcC5zb3VyY2VzQ29udGVudC5ldmVyeShjID0+IGMgPT0gbnVsbCk7XG4gICAgICAgIGlmIChhbGxOdWxsKSBkZWxldGUgbWFwLnNvdXJjZXNDb250ZW50O1xuICAgICAgICBpZiAobWFwLmZpbGUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIG1hcC5maWxlO1xuICAgICAgICBpZiAobWFwLnNvdXJjZVJvb3QgPT09IHVuZGVmaW5lZCkgZGVsZXRlIG1hcC5zb3VyY2VSb290O1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERlY29kZWQoKSB7XG4gICAgICAgIGlmICghZ2VuZXJhdG9yLnRvRGVjb2RlZE1hcCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBjbGVhbihnZW5lcmF0b3IudG9EZWNvZGVkTWFwKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVuY29kZWQoKSB7XG4gICAgICAgIHJldHVybiBjbGVhbihnZW5lcmF0b3IudG9KU09OKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIEBqcmlkZ2V3ZWxsL3NvdXJjZS1tYXAncyBTb3VyY2VNYXBDb25zdW1lciBkb2VzIG5vdCBuZWVkIHRvIGJlXG4gICAgICAgIC8vIG1hbnVhbGx5IGZyZWVkLlxuICAgICAgICBpZiAob3JpZ19tYXAgJiYgb3JpZ19tYXAuZGVzdHJveSkgb3JpZ19tYXAuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZCxcbiAgICAgICAgZ2V0RGVjb2RlZCxcbiAgICAgICAgZ2V0RW5jb2RlZCxcbiAgICAgICAgZGVzdHJveSxcbiAgICB9O1xufVxuXG52YXIgZG9tcHJvcHMgPSBbXG4gICAgXCIkJlwiLFxuICAgIFwiJCdcIixcbiAgICBcIiQqXCIsXG4gICAgXCIkK1wiLFxuICAgIFwiJDFcIixcbiAgICBcIiQyXCIsXG4gICAgXCIkM1wiLFxuICAgIFwiJDRcIixcbiAgICBcIiQ1XCIsXG4gICAgXCIkNlwiLFxuICAgIFwiJDdcIixcbiAgICBcIiQ4XCIsXG4gICAgXCIkOVwiLFxuICAgIFwiJF9cIixcbiAgICBcIiRgXCIsXG4gICAgXCIkaW5wdXRcIixcbiAgICBcIi1tb3otYW5pbWF0aW9uXCIsXG4gICAgXCItbW96LWFuaW1hdGlvbi1kZWxheVwiLFxuICAgIFwiLW1vei1hbmltYXRpb24tZGlyZWN0aW9uXCIsXG4gICAgXCItbW96LWFuaW1hdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLW1vei1hbmltYXRpb24tZmlsbC1tb2RlXCIsXG4gICAgXCItbW96LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIixcbiAgICBcIi1tb3otYW5pbWF0aW9uLW5hbWVcIixcbiAgICBcIi1tb3otYW5pbWF0aW9uLXBsYXktc3RhdGVcIixcbiAgICBcIi1tb3otYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiLFxuICAgIFwiLW1vei1hcHBlYXJhbmNlXCIsXG4gICAgXCItbW96LWJhY2tmYWNlLXZpc2liaWxpdHlcIixcbiAgICBcIi1tb3otYm9yZGVyLWVuZFwiLFxuICAgIFwiLW1vei1ib3JkZXItZW5kLWNvbG9yXCIsXG4gICAgXCItbW96LWJvcmRlci1lbmQtc3R5bGVcIixcbiAgICBcIi1tb3otYm9yZGVyLWVuZC13aWR0aFwiLFxuICAgIFwiLW1vei1ib3JkZXItaW1hZ2VcIixcbiAgICBcIi1tb3otYm9yZGVyLXN0YXJ0XCIsXG4gICAgXCItbW96LWJvcmRlci1zdGFydC1jb2xvclwiLFxuICAgIFwiLW1vei1ib3JkZXItc3RhcnQtc3R5bGVcIixcbiAgICBcIi1tb3otYm9yZGVyLXN0YXJ0LXdpZHRoXCIsXG4gICAgXCItbW96LWJveC1hbGlnblwiLFxuICAgIFwiLW1vei1ib3gtZGlyZWN0aW9uXCIsXG4gICAgXCItbW96LWJveC1mbGV4XCIsXG4gICAgXCItbW96LWJveC1vcmRpbmFsLWdyb3VwXCIsXG4gICAgXCItbW96LWJveC1vcmllbnRcIixcbiAgICBcIi1tb3otYm94LXBhY2tcIixcbiAgICBcIi1tb3otYm94LXNpemluZ1wiLFxuICAgIFwiLW1vei1mbG9hdC1lZGdlXCIsXG4gICAgXCItbW96LWZvbnQtZmVhdHVyZS1zZXR0aW5nc1wiLFxuICAgIFwiLW1vei1mb250LWxhbmd1YWdlLW92ZXJyaWRlXCIsXG4gICAgXCItbW96LWZvcmNlLWJyb2tlbi1pbWFnZS1pY29uXCIsXG4gICAgXCItbW96LWh5cGhlbnNcIixcbiAgICBcIi1tb3otaW1hZ2UtcmVnaW9uXCIsXG4gICAgXCItbW96LW1hcmdpbi1lbmRcIixcbiAgICBcIi1tb3otbWFyZ2luLXN0YXJ0XCIsXG4gICAgXCItbW96LW9yaWVudFwiLFxuICAgIFwiLW1vei1vc3gtZm9udC1zbW9vdGhpbmdcIixcbiAgICBcIi1tb3otb3V0bGluZS1yYWRpdXNcIixcbiAgICBcIi1tb3otb3V0bGluZS1yYWRpdXMtYm90dG9tbGVmdFwiLFxuICAgIFwiLW1vei1vdXRsaW5lLXJhZGl1cy1ib3R0b21yaWdodFwiLFxuICAgIFwiLW1vei1vdXRsaW5lLXJhZGl1cy10b3BsZWZ0XCIsXG4gICAgXCItbW96LW91dGxpbmUtcmFkaXVzLXRvcHJpZ2h0XCIsXG4gICAgXCItbW96LXBhZGRpbmctZW5kXCIsXG4gICAgXCItbW96LXBhZGRpbmctc3RhcnRcIixcbiAgICBcIi1tb3otcGVyc3BlY3RpdmVcIixcbiAgICBcIi1tb3otcGVyc3BlY3RpdmUtb3JpZ2luXCIsXG4gICAgXCItbW96LXRhYi1zaXplXCIsXG4gICAgXCItbW96LXRleHQtc2l6ZS1hZGp1c3RcIixcbiAgICBcIi1tb3otdHJhbnNmb3JtXCIsXG4gICAgXCItbW96LXRyYW5zZm9ybS1vcmlnaW5cIixcbiAgICBcIi1tb3otdHJhbnNmb3JtLXN0eWxlXCIsXG4gICAgXCItbW96LXRyYW5zaXRpb25cIixcbiAgICBcIi1tb3otdHJhbnNpdGlvbi1kZWxheVwiLFxuICAgIFwiLW1vei10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItbW96LXRyYW5zaXRpb24tcHJvcGVydHlcIixcbiAgICBcIi1tb3otdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cIixcbiAgICBcIi1tb3otdXNlci1mb2N1c1wiLFxuICAgIFwiLW1vei11c2VyLWlucHV0XCIsXG4gICAgXCItbW96LXVzZXItbW9kaWZ5XCIsXG4gICAgXCItbW96LXVzZXItc2VsZWN0XCIsXG4gICAgXCItbW96LXdpbmRvdy1kcmFnZ2luZ1wiLFxuICAgIFwiLXdlYmtpdC1hbGlnbi1jb250ZW50XCIsXG4gICAgXCItd2Via2l0LWFsaWduLWl0ZW1zXCIsXG4gICAgXCItd2Via2l0LWFsaWduLXNlbGZcIixcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uXCIsXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1kZWxheVwiLFxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24tZGlyZWN0aW9uXCIsXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlXCIsXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIixcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLW5hbWVcIixcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLXBsYXktc3RhdGVcIixcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiLFxuICAgIFwiLXdlYmtpdC1hcHBlYXJhbmNlXCIsXG4gICAgXCItd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHlcIixcbiAgICBcIi13ZWJraXQtYmFja2dyb3VuZC1jbGlwXCIsXG4gICAgXCItd2Via2l0LWJhY2tncm91bmQtb3JpZ2luXCIsXG4gICAgXCItd2Via2l0LWJhY2tncm91bmQtc2l6ZVwiLFxuICAgIFwiLXdlYmtpdC1ib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXG4gICAgXCItd2Via2l0LWJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIsXG4gICAgXCItd2Via2l0LWJvcmRlci1pbWFnZVwiLFxuICAgIFwiLXdlYmtpdC1ib3JkZXItcmFkaXVzXCIsXG4gICAgXCItd2Via2l0LWJvcmRlci10b3AtbGVmdC1yYWRpdXNcIixcbiAgICBcIi13ZWJraXQtYm9yZGVyLXRvcC1yaWdodC1yYWRpdXNcIixcbiAgICBcIi13ZWJraXQtYm94LWFsaWduXCIsXG4gICAgXCItd2Via2l0LWJveC1kaXJlY3Rpb25cIixcbiAgICBcIi13ZWJraXQtYm94LWZsZXhcIixcbiAgICBcIi13ZWJraXQtYm94LW9yZGluYWwtZ3JvdXBcIixcbiAgICBcIi13ZWJraXQtYm94LW9yaWVudFwiLFxuICAgIFwiLXdlYmtpdC1ib3gtcGFja1wiLFxuICAgIFwiLXdlYmtpdC1ib3gtc2hhZG93XCIsXG4gICAgXCItd2Via2l0LWJveC1zaXppbmdcIixcbiAgICBcIi13ZWJraXQtY2xpcC1wYXRoXCIsXG4gICAgXCItd2Via2l0LWZpbHRlclwiLFxuICAgIFwiLXdlYmtpdC1mbGV4XCIsXG4gICAgXCItd2Via2l0LWZsZXgtYmFzaXNcIixcbiAgICBcIi13ZWJraXQtZmxleC1kaXJlY3Rpb25cIixcbiAgICBcIi13ZWJraXQtZmxleC1mbG93XCIsXG4gICAgXCItd2Via2l0LWZsZXgtZ3Jvd1wiLFxuICAgIFwiLXdlYmtpdC1mbGV4LXNocmlua1wiLFxuICAgIFwiLXdlYmtpdC1mbGV4LXdyYXBcIixcbiAgICBcIi13ZWJraXQtZm9udC1mZWF0dXJlLXNldHRpbmdzXCIsXG4gICAgXCItd2Via2l0LWp1c3RpZnktY29udGVudFwiLFxuICAgIFwiLXdlYmtpdC1saW5lLWNsYW1wXCIsXG4gICAgXCItd2Via2l0LW1hc2tcIixcbiAgICBcIi13ZWJraXQtbWFzay1jbGlwXCIsXG4gICAgXCItd2Via2l0LW1hc2stY29tcG9zaXRlXCIsXG4gICAgXCItd2Via2l0LW1hc2staW1hZ2VcIixcbiAgICBcIi13ZWJraXQtbWFzay1vcmlnaW5cIixcbiAgICBcIi13ZWJraXQtbWFzay1wb3NpdGlvblwiLFxuICAgIFwiLXdlYmtpdC1tYXNrLXBvc2l0aW9uLXhcIixcbiAgICBcIi13ZWJraXQtbWFzay1wb3NpdGlvbi15XCIsXG4gICAgXCItd2Via2l0LW1hc2stcmVwZWF0XCIsXG4gICAgXCItd2Via2l0LW1hc2stc2l6ZVwiLFxuICAgIFwiLXdlYmtpdC1vcmRlclwiLFxuICAgIFwiLXdlYmtpdC1wZXJzcGVjdGl2ZVwiLFxuICAgIFwiLXdlYmtpdC1wZXJzcGVjdGl2ZS1vcmlnaW5cIixcbiAgICBcIi13ZWJraXQtdGV4dC1maWxsLWNvbG9yXCIsXG4gICAgXCItd2Via2l0LXRleHQtc2VjdXJpdHlcIixcbiAgICBcIi13ZWJraXQtdGV4dC1zaXplLWFkanVzdFwiLFxuICAgIFwiLXdlYmtpdC10ZXh0LXN0cm9rZVwiLFxuICAgIFwiLXdlYmtpdC10ZXh0LXN0cm9rZS1jb2xvclwiLFxuICAgIFwiLXdlYmtpdC10ZXh0LXN0cm9rZS13aWR0aFwiLFxuICAgIFwiLXdlYmtpdC10cmFuc2Zvcm1cIixcbiAgICBcIi13ZWJraXQtdHJhbnNmb3JtLW9yaWdpblwiLFxuICAgIFwiLXdlYmtpdC10cmFuc2Zvcm0tc3R5bGVcIixcbiAgICBcIi13ZWJraXQtdHJhbnNpdGlvblwiLFxuICAgIFwiLXdlYmtpdC10cmFuc2l0aW9uLWRlbGF5XCIsXG4gICAgXCItd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi13ZWJraXQtdHJhbnNpdGlvbi1wcm9wZXJ0eVwiLFxuICAgIFwiLXdlYmtpdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblwiLFxuICAgIFwiLXdlYmtpdC11c2VyLXNlbGVjdFwiLFxuICAgIFwiQEBpdGVyYXRvclwiLFxuICAgIFwiQUJPUlRfRVJSXCIsXG4gICAgXCJBQ1RJVkVcIixcbiAgICBcIkFDVElWRV9BVFRSSUJVVEVTXCIsXG4gICAgXCJBQ1RJVkVfVEVYVFVSRVwiLFxuICAgIFwiQUNUSVZFX1VOSUZPUk1TXCIsXG4gICAgXCJBQ1RJVkVfVU5JRk9STV9CTE9DS1NcIixcbiAgICBcIkFERElUSU9OXCIsXG4gICAgXCJBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0VcIixcbiAgICBcIkFMSUFTRURfUE9JTlRfU0laRV9SQU5HRVwiLFxuICAgIFwiQUxMXCIsXG4gICAgXCJBTExPV19LRVlCT0FSRF9JTlBVVFwiLFxuICAgIFwiQUxMUEFTU1wiLFxuICAgIFwiQUxQSEFcIixcbiAgICBcIkFMUEhBX0JJVFNcIixcbiAgICBcIkFMUkVBRFlfU0lHTkFMRURcIixcbiAgICBcIkFMVF9NQVNLXCIsXG4gICAgXCJBTFdBWVNcIixcbiAgICBcIkFOWV9TQU1QTEVTX1BBU1NFRFwiLFxuICAgIFwiQU5ZX1NBTVBMRVNfUEFTU0VEX0NPTlNFUlZBVElWRVwiLFxuICAgIFwiQU5ZX1RZUEVcIixcbiAgICBcIkFOWV9VTk9SREVSRURfTk9ERV9UWVBFXCIsXG4gICAgXCJBUlJBWV9CVUZGRVJcIixcbiAgICBcIkFSUkFZX0JVRkZFUl9CSU5ESU5HXCIsXG4gICAgXCJBVFRBQ0hFRF9TSEFERVJTXCIsXG4gICAgXCJBVFRSSUJVVEVfTk9ERVwiLFxuICAgIFwiQVRfVEFSR0VUXCIsXG4gICAgXCJBYm9ydENvbnRyb2xsZXJcIixcbiAgICBcIkFib3J0U2lnbmFsXCIsXG4gICAgXCJBYnNvbHV0ZU9yaWVudGF0aW9uU2Vuc29yXCIsXG4gICAgXCJBYnN0cmFjdFJhbmdlXCIsXG4gICAgXCJBY2NlbGVyb21ldGVyXCIsXG4gICAgXCJBZGRTZWFyY2hQcm92aWRlclwiLFxuICAgIFwiQWdncmVnYXRlRXJyb3JcIixcbiAgICBcIkFuYWx5c2VyTm9kZVwiLFxuICAgIFwiQW5pbWF0aW9uXCIsXG4gICAgXCJBbmltYXRpb25FZmZlY3RcIixcbiAgICBcIkFuaW1hdGlvbkV2ZW50XCIsXG4gICAgXCJBbmltYXRpb25QbGF5YmFja0V2ZW50XCIsXG4gICAgXCJBbmltYXRpb25UaW1lbGluZVwiLFxuICAgIFwiQW5vblhNTEh0dHBSZXF1ZXN0XCIsXG4gICAgXCJBbnlcIixcbiAgICBcIkFueVBlcm1pc3Npb25zXCIsXG4gICAgXCJBcHBsaWNhdGlvbkNhY2hlXCIsXG4gICAgXCJBcHBsaWNhdGlvbkNhY2hlRXJyb3JFdmVudFwiLFxuICAgIFwiQXJyYXlcIixcbiAgICBcIkFycmF5QnVmZmVyXCIsXG4gICAgXCJBcnJheVR5cGVcIixcbiAgICBcIkF0b21pY3NcIixcbiAgICBcIkF0dHJcIixcbiAgICBcIkF1ZGlvXCIsXG4gICAgXCJBdWRpb0J1ZmZlclwiLFxuICAgIFwiQXVkaW9CdWZmZXJTb3VyY2VOb2RlXCIsXG4gICAgXCJBdWRpb0NvbnRleHRcIixcbiAgICBcIkF1ZGlvRGF0YVwiLFxuICAgIFwiQXVkaW9EZWNvZGVyXCIsXG4gICAgXCJBdWRpb0Rlc3RpbmF0aW9uTm9kZVwiLFxuICAgIFwiQXVkaW9FbmNvZGVyXCIsXG4gICAgXCJBdWRpb0xpc3RlbmVyXCIsXG4gICAgXCJBdWRpb05vZGVcIixcbiAgICBcIkF1ZGlvUGFyYW1cIixcbiAgICBcIkF1ZGlvUGFyYW1NYXBcIixcbiAgICBcIkF1ZGlvUHJvY2Vzc2luZ0V2ZW50XCIsXG4gICAgXCJBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVcIixcbiAgICBcIkF1ZGlvU2lua0luZm9cIixcbiAgICBcIkF1ZGlvU3RyZWFtVHJhY2tcIixcbiAgICBcIkF1ZGlvV29ya2xldFwiLFxuICAgIFwiQXVkaW9Xb3JrbGV0Tm9kZVwiLFxuICAgIFwiQXV0aGVudGljYXRvckFzc2VydGlvblJlc3BvbnNlXCIsXG4gICAgXCJBdXRoZW50aWNhdG9yQXR0ZXN0YXRpb25SZXNwb25zZVwiLFxuICAgIFwiQXV0aGVudGljYXRvclJlc3BvbnNlXCIsXG4gICAgXCJBdXRvY29tcGxldGVFcnJvckV2ZW50XCIsXG4gICAgXCJCQUNLXCIsXG4gICAgXCJCQURfQk9VTkRBUllQT0lOVFNfRVJSXCIsXG4gICAgXCJCQURfUkVRVUVTVFwiLFxuICAgIFwiQkFORFBBU1NcIixcbiAgICBcIkJMRU5EXCIsXG4gICAgXCJCTEVORF9DT0xPUlwiLFxuICAgIFwiQkxFTkRfRFNUX0FMUEhBXCIsXG4gICAgXCJCTEVORF9EU1RfUkdCXCIsXG4gICAgXCJCTEVORF9FUVVBVElPTlwiLFxuICAgIFwiQkxFTkRfRVFVQVRJT05fQUxQSEFcIixcbiAgICBcIkJMRU5EX0VRVUFUSU9OX1JHQlwiLFxuICAgIFwiQkxFTkRfU1JDX0FMUEhBXCIsXG4gICAgXCJCTEVORF9TUkNfUkdCXCIsXG4gICAgXCJCTFVFXCIsXG4gICAgXCJCTFVFX0JJVFNcIixcbiAgICBcIkJMVVJcIixcbiAgICBcIkJPT0xcIixcbiAgICBcIkJPT0xFQU5fVFlQRVwiLFxuICAgIFwiQk9PTF9WRUMyXCIsXG4gICAgXCJCT09MX1ZFQzNcIixcbiAgICBcIkJPT0xfVkVDNFwiLFxuICAgIFwiQk9USFwiLFxuICAgIFwiQlJPV1NFUl9ERUZBVUxUX1dFQkdMXCIsXG4gICAgXCJCVUJCTElOR19QSEFTRVwiLFxuICAgIFwiQlVGRkVSX1NJWkVcIixcbiAgICBcIkJVRkZFUl9VU0FHRVwiLFxuICAgIFwiQllURVwiLFxuICAgIFwiQllURVNfUEVSX0VMRU1FTlRcIixcbiAgICBcIkJhY2tncm91bmRGZXRjaE1hbmFnZXJcIixcbiAgICBcIkJhY2tncm91bmRGZXRjaFJlY29yZFwiLFxuICAgIFwiQmFja2dyb3VuZEZldGNoUmVnaXN0cmF0aW9uXCIsXG4gICAgXCJCYXJQcm9wXCIsXG4gICAgXCJCYXJjb2RlRGV0ZWN0b3JcIixcbiAgICBcIkJhc2VBdWRpb0NvbnRleHRcIixcbiAgICBcIkJhc2VIcmVmXCIsXG4gICAgXCJCYXR0ZXJ5TWFuYWdlclwiLFxuICAgIFwiQmVmb3JlSW5zdGFsbFByb21wdEV2ZW50XCIsXG4gICAgXCJCZWZvcmVMb2FkRXZlbnRcIixcbiAgICBcIkJlZm9yZVVubG9hZEV2ZW50XCIsXG4gICAgXCJCaWdJbnRcIixcbiAgICBcIkJpZ0ludDY0QXJyYXlcIixcbiAgICBcIkJpZ1VpbnQ2NEFycmF5XCIsXG4gICAgXCJCaXF1YWRGaWx0ZXJOb2RlXCIsXG4gICAgXCJCbG9iXCIsXG4gICAgXCJCbG9iRXZlbnRcIixcbiAgICBcIkJsdWV0b290aFwiLFxuICAgIFwiQmx1ZXRvb3RoQ2hhcmFjdGVyaXN0aWNQcm9wZXJ0aWVzXCIsXG4gICAgXCJCbHVldG9vdGhEZXZpY2VcIixcbiAgICBcIkJsdWV0b290aFJlbW90ZUdBVFRDaGFyYWN0ZXJpc3RpY1wiLFxuICAgIFwiQmx1ZXRvb3RoUmVtb3RlR0FUVERlc2NyaXB0b3JcIixcbiAgICBcIkJsdWV0b290aFJlbW90ZUdBVFRTZXJ2ZXJcIixcbiAgICBcIkJsdWV0b290aFJlbW90ZUdBVFRTZXJ2aWNlXCIsXG4gICAgXCJCbHVldG9vdGhVVUlEXCIsXG4gICAgXCJCb29sZWFuXCIsXG4gICAgXCJCcm9hZGNhc3RDaGFubmVsXCIsXG4gICAgXCJCcm93c2VyQ2FwdHVyZU1lZGlhU3RyZWFtVHJhY2tcIixcbiAgICBcIkJyb3dzZXJJbmZvXCIsXG4gICAgXCJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5XCIsXG4gICAgXCJDQVBUVVJJTkdfUEhBU0VcIixcbiAgICBcIkNDV1wiLFxuICAgIFwiQ0RBVEFTZWN0aW9uXCIsXG4gICAgXCJDREFUQV9TRUNUSU9OX05PREVcIixcbiAgICBcIkNIQU5HRVwiLFxuICAgIFwiQ0hBUlNFVF9SVUxFXCIsXG4gICAgXCJDSEVDS0lOR1wiLFxuICAgIFwiQ0xBTVBfVE9fRURHRVwiLFxuICAgIFwiQ0xJQ0tcIixcbiAgICBcIkNMT1NFRFwiLFxuICAgIFwiQ0xPU0lOR1wiLFxuICAgIFwiQ09MT1JcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQwXCIsXG4gICAgXCJDT0xPUl9BVFRBQ0hNRU5UMVwiLFxuICAgIFwiQ09MT1JfQVRUQUNITUVOVDEwXCIsXG4gICAgXCJDT0xPUl9BVFRBQ0hNRU5UMTFcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQxMlwiLFxuICAgIFwiQ09MT1JfQVRUQUNITUVOVDEzXCIsXG4gICAgXCJDT0xPUl9BVFRBQ0hNRU5UMTRcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQxNVwiLFxuICAgIFwiQ09MT1JfQVRUQUNITUVOVDJcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQzXCIsXG4gICAgXCJDT0xPUl9BVFRBQ0hNRU5UNFwiLFxuICAgIFwiQ09MT1JfQVRUQUNITUVOVDVcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQ2XCIsXG4gICAgXCJDT0xPUl9BVFRBQ0hNRU5UN1wiLFxuICAgIFwiQ09MT1JfQVRUQUNITUVOVDhcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQ5XCIsXG4gICAgXCJDT0xPUl9CVUZGRVJfQklUXCIsXG4gICAgXCJDT0xPUl9DTEVBUl9WQUxVRVwiLFxuICAgIFwiQ09MT1JfV1JJVEVNQVNLXCIsXG4gICAgXCJDT01NRU5UX05PREVcIixcbiAgICBcIkNPTVBBUkVfUkVGX1RPX1RFWFRVUkVcIixcbiAgICBcIkNPTVBJTEVfU1RBVFVTXCIsXG4gICAgXCJDT01QTEVUSU9OX1NUQVRVU19LSFJcIixcbiAgICBcIkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUXCIsXG4gICAgXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVFwiLFxuICAgIFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcIixcbiAgICBcIkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcIixcbiAgICBcIkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTXCIsXG4gICAgXCJDT01QVVRFXCIsXG4gICAgXCJDT05ESVRJT05fU0FUSVNGSUVEXCIsXG4gICAgXCJDT05GSUdVUkFUSU9OX1VOU1VQUE9SVEVEXCIsXG4gICAgXCJDT05ORUNUSU5HXCIsXG4gICAgXCJDT05TVEFOVF9BTFBIQVwiLFxuICAgIFwiQ09OU1RBTlRfQ09MT1JcIixcbiAgICBcIkNPTlNUUkFJTlRfRVJSXCIsXG4gICAgXCJDT05URVhUX0xPU1RfV0VCR0xcIixcbiAgICBcIkNPTlRST0xfTUFTS1wiLFxuICAgIFwiQ09QWV9EU1RcIixcbiAgICBcIkNPUFlfUkVBRF9CVUZGRVJcIixcbiAgICBcIkNPUFlfUkVBRF9CVUZGRVJfQklORElOR1wiLFxuICAgIFwiQ09QWV9TUkNcIixcbiAgICBcIkNPUFlfV1JJVEVfQlVGRkVSXCIsXG4gICAgXCJDT1BZX1dSSVRFX0JVRkZFUl9CSU5ESU5HXCIsXG4gICAgXCJDT1VOVEVSX1NUWUxFX1JVTEVcIixcbiAgICBcIkNTU1wiLFxuICAgIFwiQ1NTMlByb3BlcnRpZXNcIixcbiAgICBcIkNTU0FuaW1hdGlvblwiLFxuICAgIFwiQ1NTQ2hhcnNldFJ1bGVcIixcbiAgICBcIkNTU0NvbmRpdGlvblJ1bGVcIixcbiAgICBcIkNTU0NvbnRhaW5lclJ1bGVcIixcbiAgICBcIkNTU0NvdW50ZXJTdHlsZVJ1bGVcIixcbiAgICBcIkNTU0ZvbnRGYWNlUnVsZVwiLFxuICAgIFwiQ1NTRm9udEZlYXR1cmVWYWx1ZXNSdWxlXCIsXG4gICAgXCJDU1NGb250UGFsZXR0ZVZhbHVlc1J1bGVcIixcbiAgICBcIkNTU0dyb3VwaW5nUnVsZVwiLFxuICAgIFwiQ1NTSW1hZ2VWYWx1ZVwiLFxuICAgIFwiQ1NTSW1wb3J0UnVsZVwiLFxuICAgIFwiQ1NTS2V5ZnJhbWVSdWxlXCIsXG4gICAgXCJDU1NLZXlmcmFtZXNSdWxlXCIsXG4gICAgXCJDU1NLZXl3b3JkVmFsdWVcIixcbiAgICBcIkNTU0xheWVyQmxvY2tSdWxlXCIsXG4gICAgXCJDU1NMYXllclN0YXRlbWVudFJ1bGVcIixcbiAgICBcIkNTU01hcmdpblJ1bGVcIixcbiAgICBcIkNTU01hdGhDbGFtcFwiLFxuICAgIFwiQ1NTTWF0aEludmVydFwiLFxuICAgIFwiQ1NTTWF0aE1heFwiLFxuICAgIFwiQ1NTTWF0aE1pblwiLFxuICAgIFwiQ1NTTWF0aE5lZ2F0ZVwiLFxuICAgIFwiQ1NTTWF0aFByb2R1Y3RcIixcbiAgICBcIkNTU01hdGhTdW1cIixcbiAgICBcIkNTU01hdGhWYWx1ZVwiLFxuICAgIFwiQ1NTTWF0cml4Q29tcG9uZW50XCIsXG4gICAgXCJDU1NNZWRpYVJ1bGVcIixcbiAgICBcIkNTU01vekRvY3VtZW50UnVsZVwiLFxuICAgIFwiQ1NTTmFtZVNwYWNlUnVsZVwiLFxuICAgIFwiQ1NTTmFtZXNwYWNlUnVsZVwiLFxuICAgIFwiQ1NTTmVzdGVkRGVjbGFyYXRpb25zXCIsXG4gICAgXCJDU1NOdW1lcmljQXJyYXlcIixcbiAgICBcIkNTU051bWVyaWNWYWx1ZVwiLFxuICAgIFwiQ1NTUGFnZURlc2NyaXB0b3JzXCIsXG4gICAgXCJDU1NQYWdlUnVsZVwiLFxuICAgIFwiQ1NTUGVyc3BlY3RpdmVcIixcbiAgICBcIkNTU1Bvc2l0aW9uVHJ5RGVzY3JpcHRvcnNcIixcbiAgICBcIkNTU1Bvc2l0aW9uVHJ5UnVsZVwiLFxuICAgIFwiQ1NTUG9zaXRpb25WYWx1ZVwiLFxuICAgIFwiQ1NTUHJpbWl0aXZlVmFsdWVcIixcbiAgICBcIkNTU1Byb3BlcnR5UnVsZVwiLFxuICAgIFwiQ1NTUm90YXRlXCIsXG4gICAgXCJDU1NSdWxlXCIsXG4gICAgXCJDU1NSdWxlTGlzdFwiLFxuICAgIFwiQ1NTU2NhbGVcIixcbiAgICBcIkNTU1Njb3BlUnVsZVwiLFxuICAgIFwiQ1NTU2tld1wiLFxuICAgIFwiQ1NTU2tld1hcIixcbiAgICBcIkNTU1NrZXdZXCIsXG4gICAgXCJDU1NTdGFydGluZ1N0eWxlUnVsZVwiLFxuICAgIFwiQ1NTU3R5bGVEZWNsYXJhdGlvblwiLFxuICAgIFwiQ1NTU3R5bGVSdWxlXCIsXG4gICAgXCJDU1NTdHlsZVNoZWV0XCIsXG4gICAgXCJDU1NTdHlsZVZhbHVlXCIsXG4gICAgXCJDU1NTdXBwb3J0c1J1bGVcIixcbiAgICBcIkNTU1RyYW5zZm9ybUNvbXBvbmVudFwiLFxuICAgIFwiQ1NTVHJhbnNmb3JtVmFsdWVcIixcbiAgICBcIkNTU1RyYW5zaXRpb25cIixcbiAgICBcIkNTU1RyYW5zbGF0ZVwiLFxuICAgIFwiQ1NTVW5pdFZhbHVlXCIsXG4gICAgXCJDU1NVbmtub3duUnVsZVwiLFxuICAgIFwiQ1NTVW5wYXJzZWRWYWx1ZVwiLFxuICAgIFwiQ1NTVmFsdWVcIixcbiAgICBcIkNTU1ZhbHVlTGlzdFwiLFxuICAgIFwiQ1NTVmFyaWFibGVSZWZlcmVuY2VWYWx1ZVwiLFxuICAgIFwiQ1NTVmFyaWFibGVzRGVjbGFyYXRpb25cIixcbiAgICBcIkNTU1ZhcmlhYmxlc1J1bGVcIixcbiAgICBcIkNTU1ZpZXdUcmFuc2l0aW9uUnVsZVwiLFxuICAgIFwiQ1NTVmlld3BvcnRSdWxlXCIsXG4gICAgXCJDU1NfQVRUUlwiLFxuICAgIFwiQ1NTX0NNXCIsXG4gICAgXCJDU1NfQ09VTlRFUlwiLFxuICAgIFwiQ1NTX0NVU1RPTVwiLFxuICAgIFwiQ1NTX0RFR1wiLFxuICAgIFwiQ1NTX0RJTUVOU0lPTlwiLFxuICAgIFwiQ1NTX0VNU1wiLFxuICAgIFwiQ1NTX0VYU1wiLFxuICAgIFwiQ1NTX0ZJTFRFUl9CTFVSXCIsXG4gICAgXCJDU1NfRklMVEVSX0JSSUdIVE5FU1NcIixcbiAgICBcIkNTU19GSUxURVJfQ09OVFJBU1RcIixcbiAgICBcIkNTU19GSUxURVJfQ1VTVE9NXCIsXG4gICAgXCJDU1NfRklMVEVSX0RST1BfU0hBRE9XXCIsXG4gICAgXCJDU1NfRklMVEVSX0dSQVlTQ0FMRVwiLFxuICAgIFwiQ1NTX0ZJTFRFUl9IVUVfUk9UQVRFXCIsXG4gICAgXCJDU1NfRklMVEVSX0lOVkVSVFwiLFxuICAgIFwiQ1NTX0ZJTFRFUl9PUEFDSVRZXCIsXG4gICAgXCJDU1NfRklMVEVSX1JFRkVSRU5DRVwiLFxuICAgIFwiQ1NTX0ZJTFRFUl9TQVRVUkFURVwiLFxuICAgIFwiQ1NTX0ZJTFRFUl9TRVBJQVwiLFxuICAgIFwiQ1NTX0dSQURcIixcbiAgICBcIkNTU19IWlwiLFxuICAgIFwiQ1NTX0lERU5UXCIsXG4gICAgXCJDU1NfSU5cIixcbiAgICBcIkNTU19JTkhFUklUXCIsXG4gICAgXCJDU1NfS0haXCIsXG4gICAgXCJDU1NfTUFUUklYXCIsXG4gICAgXCJDU1NfTUFUUklYM0RcIixcbiAgICBcIkNTU19NTVwiLFxuICAgIFwiQ1NTX01TXCIsXG4gICAgXCJDU1NfTlVNQkVSXCIsXG4gICAgXCJDU1NfUENcIixcbiAgICBcIkNTU19QRVJDRU5UQUdFXCIsXG4gICAgXCJDU1NfUEVSU1BFQ1RJVkVcIixcbiAgICBcIkNTU19QUklNSVRJVkVfVkFMVUVcIixcbiAgICBcIkNTU19QVFwiLFxuICAgIFwiQ1NTX1BYXCIsXG4gICAgXCJDU1NfUkFEXCIsXG4gICAgXCJDU1NfUkVDVFwiLFxuICAgIFwiQ1NTX1JHQkNPTE9SXCIsXG4gICAgXCJDU1NfUk9UQVRFXCIsXG4gICAgXCJDU1NfUk9UQVRFM0RcIixcbiAgICBcIkNTU19ST1RBVEVYXCIsXG4gICAgXCJDU1NfUk9UQVRFWVwiLFxuICAgIFwiQ1NTX1JPVEFURVpcIixcbiAgICBcIkNTU19TXCIsXG4gICAgXCJDU1NfU0NBTEVcIixcbiAgICBcIkNTU19TQ0FMRTNEXCIsXG4gICAgXCJDU1NfU0NBTEVYXCIsXG4gICAgXCJDU1NfU0NBTEVZXCIsXG4gICAgXCJDU1NfU0NBTEVaXCIsXG4gICAgXCJDU1NfU0tFV1wiLFxuICAgIFwiQ1NTX1NLRVdYXCIsXG4gICAgXCJDU1NfU0tFV1lcIixcbiAgICBcIkNTU19TVFJJTkdcIixcbiAgICBcIkNTU19UUkFOU0xBVEVcIixcbiAgICBcIkNTU19UUkFOU0xBVEUzRFwiLFxuICAgIFwiQ1NTX1RSQU5TTEFURVhcIixcbiAgICBcIkNTU19UUkFOU0xBVEVZXCIsXG4gICAgXCJDU1NfVFJBTlNMQVRFWlwiLFxuICAgIFwiQ1NTX1VOS05PV05cIixcbiAgICBcIkNTU19VUklcIixcbiAgICBcIkNTU19WQUxVRV9MSVNUXCIsXG4gICAgXCJDU1NfVkhcIixcbiAgICBcIkNTU19WTUFYXCIsXG4gICAgXCJDU1NfVk1JTlwiLFxuICAgIFwiQ1NTX1ZXXCIsXG4gICAgXCJDVUxMX0ZBQ0VcIixcbiAgICBcIkNVTExfRkFDRV9NT0RFXCIsXG4gICAgXCJDVVJSRU5UX1BST0dSQU1cIixcbiAgICBcIkNVUlJFTlRfUVVFUllcIixcbiAgICBcIkNVUlJFTlRfVkVSVEVYX0FUVFJJQlwiLFxuICAgIFwiQ1VTVE9NXCIsXG4gICAgXCJDV1wiLFxuICAgIFwiQ2FjaGVcIixcbiAgICBcIkNhY2hlU3RvcmFnZVwiLFxuICAgIFwiQ2FudmFzQ2FwdHVyZU1lZGlhU3RyZWFtXCIsXG4gICAgXCJDYW52YXNDYXB0dXJlTWVkaWFTdHJlYW1UcmFja1wiLFxuICAgIFwiQ2FudmFzR3JhZGllbnRcIixcbiAgICBcIkNhbnZhc1BhdHRlcm5cIixcbiAgICBcIkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFwiLFxuICAgIFwiQ2FwdHVyZUNvbnRyb2xsZXJcIixcbiAgICBcIkNhcmV0UG9zaXRpb25cIixcbiAgICBcIkNoYW5uZWxNZXJnZXJOb2RlXCIsXG4gICAgXCJDaGFubmVsU3BsaXR0ZXJOb2RlXCIsXG4gICAgXCJDaGFwdGVySW5mb3JtYXRpb25cIixcbiAgICBcIkNoYXJhY3RlckJvdW5kc1VwZGF0ZUV2ZW50XCIsXG4gICAgXCJDaGFyYWN0ZXJEYXRhXCIsXG4gICAgXCJDbGllbnRSZWN0XCIsXG4gICAgXCJDbGllbnRSZWN0TGlzdFwiLFxuICAgIFwiQ2xpcGJvYXJkXCIsXG4gICAgXCJDbGlwYm9hcmRFdmVudFwiLFxuICAgIFwiQ2xpcGJvYXJkSXRlbVwiLFxuICAgIFwiQ2xvc2VFdmVudFwiLFxuICAgIFwiQ2xvc2VXYXRjaGVyXCIsXG4gICAgXCJDb2xsYXRvclwiLFxuICAgIFwiQ29sb3JBcnJheVwiLFxuICAgIFwiQ29sb3JWYWx1ZVwiLFxuICAgIFwiQ29tbWFuZEV2ZW50XCIsXG4gICAgXCJDb21tZW50XCIsXG4gICAgXCJDb21waWxlRXJyb3JcIixcbiAgICBcIkNvbXBvc2l0aW9uRXZlbnRcIixcbiAgICBcIkNvbXByZXNzaW9uU3RyZWFtXCIsXG4gICAgXCJDb25zb2xlXCIsXG4gICAgXCJDb25zdGFudFNvdXJjZU5vZGVcIixcbiAgICBcIkNvbnRlbnRWaXNpYmlsaXR5QXV0b1N0YXRlQ2hhbmdlRXZlbnRcIixcbiAgICBcIkNvbnRleHRGaWx0ZXJcIixcbiAgICBcIkNvbnRleHRUeXBlXCIsXG4gICAgXCJDb250cm9sbGVyc1wiLFxuICAgIFwiQ29udm9sdmVyTm9kZVwiLFxuICAgIFwiQ29va2llQ2hhbmdlRXZlbnRcIixcbiAgICBcIkNvb2tpZVN0b3JlXCIsXG4gICAgXCJDb29raWVTdG9yZU1hbmFnZXJcIixcbiAgICBcIkNvdW50UXVldWluZ1N0cmF0ZWd5XCIsXG4gICAgXCJDb3VudGVyXCIsXG4gICAgXCJDcmVhdGVUeXBlXCIsXG4gICAgXCJDcmVkZW50aWFsXCIsXG4gICAgXCJDcmVkZW50aWFsc0NvbnRhaW5lclwiLFxuICAgIFwiQ3JvcFRhcmdldFwiLFxuICAgIFwiQ3J5cHRvXCIsXG4gICAgXCJDcnlwdG9LZXlcIixcbiAgICBcIkN1c3RvbUVsZW1lbnRSZWdpc3RyeVwiLFxuICAgIFwiQ3VzdG9tRXZlbnRcIixcbiAgICBcIkN1c3RvbVN0YXRlU2V0XCIsXG4gICAgXCJEQVRBQkFTRV9FUlJcIixcbiAgICBcIkRBVEFfQ0xPTkVfRVJSXCIsXG4gICAgXCJEQVRBX0VSUlwiLFxuICAgIFwiREJMQ0xJQ0tcIixcbiAgICBcIkRFQ1JcIixcbiAgICBcIkRFQ1JfV1JBUFwiLFxuICAgIFwiREVMRVRFX1NUQVRVU1wiLFxuICAgIFwiREVQVEhcIixcbiAgICBcIkRFUFRIMjRfU1RFTkNJTDhcIixcbiAgICBcIkRFUFRIMzJGX1NURU5DSUw4XCIsXG4gICAgXCJERVBUSF9BVFRBQ0hNRU5UXCIsXG4gICAgXCJERVBUSF9CSVRTXCIsXG4gICAgXCJERVBUSF9CVUZGRVJfQklUXCIsXG4gICAgXCJERVBUSF9DTEVBUl9WQUxVRVwiLFxuICAgIFwiREVQVEhfQ09NUE9ORU5UXCIsXG4gICAgXCJERVBUSF9DT01QT05FTlQxNlwiLFxuICAgIFwiREVQVEhfQ09NUE9ORU5UMjRcIixcbiAgICBcIkRFUFRIX0NPTVBPTkVOVDMyRlwiLFxuICAgIFwiREVQVEhfRlVOQ1wiLFxuICAgIFwiREVQVEhfUkFOR0VcIixcbiAgICBcIkRFUFRIX1NURU5DSUxcIixcbiAgICBcIkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVFwiLFxuICAgIFwiREVQVEhfVEVTVFwiLFxuICAgIFwiREVQVEhfV1JJVEVNQVNLXCIsXG4gICAgXCJERVZJQ0VfSU5FTElHSUJMRVwiLFxuICAgIFwiRElSRUNUSU9OX0RPV05cIixcbiAgICBcIkRJUkVDVElPTl9MRUZUXCIsXG4gICAgXCJESVJFQ1RJT05fUklHSFRcIixcbiAgICBcIkRJUkVDVElPTl9VUFwiLFxuICAgIFwiRElTQUJMRURcIixcbiAgICBcIkRJU1BBVENIX1JFUVVFU1RfRVJSXCIsXG4gICAgXCJESVRIRVJcIixcbiAgICBcIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVcIixcbiAgICBcIkRPQ1VNRU5UX05PREVcIixcbiAgICBcIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWVwiLFxuICAgIFwiRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlNcIixcbiAgICBcIkRPQ1VNRU5UX1BPU0lUSU9OX0RJU0NPTk5FQ1RFRFwiLFxuICAgIFwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HXCIsXG4gICAgXCJET0NVTUVOVF9QT1NJVElPTl9JTVBMRU1FTlRBVElPTl9TUEVDSUZJQ1wiLFxuICAgIFwiRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HXCIsXG4gICAgXCJET0NVTUVOVF9UWVBFX05PREVcIixcbiAgICBcIkRPTUN1cnNvclwiLFxuICAgIFwiRE9NRXJyb3JcIixcbiAgICBcIkRPTUV4Y2VwdGlvblwiLFxuICAgIFwiRE9NSW1wbGVtZW50YXRpb25cIixcbiAgICBcIkRPTUltcGxlbWVudGF0aW9uTFNcIixcbiAgICBcIkRPTU1hdHJpeFwiLFxuICAgIFwiRE9NTWF0cml4UmVhZE9ubHlcIixcbiAgICBcIkRPTVBhcnNlclwiLFxuICAgIFwiRE9NUG9pbnRcIixcbiAgICBcIkRPTVBvaW50UmVhZE9ubHlcIixcbiAgICBcIkRPTVF1YWRcIixcbiAgICBcIkRPTVJlY3RcIixcbiAgICBcIkRPTVJlY3RMaXN0XCIsXG4gICAgXCJET01SZWN0UmVhZE9ubHlcIixcbiAgICBcIkRPTVJlcXVlc3RcIixcbiAgICBcIkRPTVNUUklOR19TSVpFX0VSUlwiLFxuICAgIFwiRE9NU2V0dGFibGVUb2tlbkxpc3RcIixcbiAgICBcIkRPTVN0cmluZ0xpc3RcIixcbiAgICBcIkRPTVN0cmluZ01hcFwiLFxuICAgIFwiRE9NVG9rZW5MaXN0XCIsXG4gICAgXCJET01UcmFuc2FjdGlvbkV2ZW50XCIsXG4gICAgXCJET01fREVMVEFfTElORVwiLFxuICAgIFwiRE9NX0RFTFRBX1BBR0VcIixcbiAgICBcIkRPTV9ERUxUQV9QSVhFTFwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9EUk9QXCIsXG4gICAgXCJET01fSU5QVVRfTUVUSE9EX0hBTkRXUklUSU5HXCIsXG4gICAgXCJET01fSU5QVVRfTUVUSE9EX0lNRVwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9LRVlCT0FSRFwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9NVUxUSU1PREFMXCIsXG4gICAgXCJET01fSU5QVVRfTUVUSE9EX09QVElPTlwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9QQVNURVwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9TQ1JJUFRcIixcbiAgICBcIkRPTV9JTlBVVF9NRVRIT0RfVU5LTk9XTlwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9WT0lDRVwiLFxuICAgIFwiRE9NX0tFWV9MT0NBVElPTl9KT1lTVElDS1wiLFxuICAgIFwiRE9NX0tFWV9MT0NBVElPTl9MRUZUXCIsXG4gICAgXCJET01fS0VZX0xPQ0FUSU9OX01PQklMRVwiLFxuICAgIFwiRE9NX0tFWV9MT0NBVElPTl9OVU1QQURcIixcbiAgICBcIkRPTV9LRVlfTE9DQVRJT05fUklHSFRcIixcbiAgICBcIkRPTV9LRVlfTE9DQVRJT05fU1RBTkRBUkRcIixcbiAgICBcIkRPTV9WS18wXCIsXG4gICAgXCJET01fVktfMVwiLFxuICAgIFwiRE9NX1ZLXzJcIixcbiAgICBcIkRPTV9WS18zXCIsXG4gICAgXCJET01fVktfNFwiLFxuICAgIFwiRE9NX1ZLXzVcIixcbiAgICBcIkRPTV9WS182XCIsXG4gICAgXCJET01fVktfN1wiLFxuICAgIFwiRE9NX1ZLXzhcIixcbiAgICBcIkRPTV9WS185XCIsXG4gICAgXCJET01fVktfQVwiLFxuICAgIFwiRE9NX1ZLX0FDQ0VQVFwiLFxuICAgIFwiRE9NX1ZLX0FERFwiLFxuICAgIFwiRE9NX1ZLX0FMVFwiLFxuICAgIFwiRE9NX1ZLX0FMVEdSXCIsXG4gICAgXCJET01fVktfQU1QRVJTQU5EXCIsXG4gICAgXCJET01fVktfQVNURVJJU0tcIixcbiAgICBcIkRPTV9WS19BVFwiLFxuICAgIFwiRE9NX1ZLX0FUVE5cIixcbiAgICBcIkRPTV9WS19CXCIsXG4gICAgXCJET01fVktfQkFDS1NQQUNFXCIsXG4gICAgXCJET01fVktfQkFDS19RVU9URVwiLFxuICAgIFwiRE9NX1ZLX0JBQ0tfU0xBU0hcIixcbiAgICBcIkRPTV9WS19CQUNLX1NQQUNFXCIsXG4gICAgXCJET01fVktfQ1wiLFxuICAgIFwiRE9NX1ZLX0NBTkNFTFwiLFxuICAgIFwiRE9NX1ZLX0NBUFNfTE9DS1wiLFxuICAgIFwiRE9NX1ZLX0NJUkNVTUZMRVhcIixcbiAgICBcIkRPTV9WS19DTEVBUlwiLFxuICAgIFwiRE9NX1ZLX0NMT1NFX0JSQUNLRVRcIixcbiAgICBcIkRPTV9WS19DTE9TRV9DVVJMWV9CUkFDS0VUXCIsXG4gICAgXCJET01fVktfQ0xPU0VfUEFSRU5cIixcbiAgICBcIkRPTV9WS19DT0xPTlwiLFxuICAgIFwiRE9NX1ZLX0NPTU1BXCIsXG4gICAgXCJET01fVktfQ09OVEVYVF9NRU5VXCIsXG4gICAgXCJET01fVktfQ09OVFJPTFwiLFxuICAgIFwiRE9NX1ZLX0NPTlZFUlRcIixcbiAgICBcIkRPTV9WS19DUlNFTFwiLFxuICAgIFwiRE9NX1ZLX0NUUkxcIixcbiAgICBcIkRPTV9WS19EXCIsXG4gICAgXCJET01fVktfREVDSU1BTFwiLFxuICAgIFwiRE9NX1ZLX0RFTEVURVwiLFxuICAgIFwiRE9NX1ZLX0RJVklERVwiLFxuICAgIFwiRE9NX1ZLX0RPTExBUlwiLFxuICAgIFwiRE9NX1ZLX0RPVUJMRV9RVU9URVwiLFxuICAgIFwiRE9NX1ZLX0RPV05cIixcbiAgICBcIkRPTV9WS19FXCIsXG4gICAgXCJET01fVktfRUlTVVwiLFxuICAgIFwiRE9NX1ZLX0VORFwiLFxuICAgIFwiRE9NX1ZLX0VOVEVSXCIsXG4gICAgXCJET01fVktfRVFVQUxTXCIsXG4gICAgXCJET01fVktfRVJFT0ZcIixcbiAgICBcIkRPTV9WS19FU0NBUEVcIixcbiAgICBcIkRPTV9WS19FWENMQU1BVElPTlwiLFxuICAgIFwiRE9NX1ZLX0VYRUNVVEVcIixcbiAgICBcIkRPTV9WS19FWFNFTFwiLFxuICAgIFwiRE9NX1ZLX0ZcIixcbiAgICBcIkRPTV9WS19GMVwiLFxuICAgIFwiRE9NX1ZLX0YxMFwiLFxuICAgIFwiRE9NX1ZLX0YxMVwiLFxuICAgIFwiRE9NX1ZLX0YxMlwiLFxuICAgIFwiRE9NX1ZLX0YxM1wiLFxuICAgIFwiRE9NX1ZLX0YxNFwiLFxuICAgIFwiRE9NX1ZLX0YxNVwiLFxuICAgIFwiRE9NX1ZLX0YxNlwiLFxuICAgIFwiRE9NX1ZLX0YxN1wiLFxuICAgIFwiRE9NX1ZLX0YxOFwiLFxuICAgIFwiRE9NX1ZLX0YxOVwiLFxuICAgIFwiRE9NX1ZLX0YyXCIsXG4gICAgXCJET01fVktfRjIwXCIsXG4gICAgXCJET01fVktfRjIxXCIsXG4gICAgXCJET01fVktfRjIyXCIsXG4gICAgXCJET01fVktfRjIzXCIsXG4gICAgXCJET01fVktfRjI0XCIsXG4gICAgXCJET01fVktfRjI1XCIsXG4gICAgXCJET01fVktfRjI2XCIsXG4gICAgXCJET01fVktfRjI3XCIsXG4gICAgXCJET01fVktfRjI4XCIsXG4gICAgXCJET01fVktfRjI5XCIsXG4gICAgXCJET01fVktfRjNcIixcbiAgICBcIkRPTV9WS19GMzBcIixcbiAgICBcIkRPTV9WS19GMzFcIixcbiAgICBcIkRPTV9WS19GMzJcIixcbiAgICBcIkRPTV9WS19GMzNcIixcbiAgICBcIkRPTV9WS19GMzRcIixcbiAgICBcIkRPTV9WS19GMzVcIixcbiAgICBcIkRPTV9WS19GMzZcIixcbiAgICBcIkRPTV9WS19GNFwiLFxuICAgIFwiRE9NX1ZLX0Y1XCIsXG4gICAgXCJET01fVktfRjZcIixcbiAgICBcIkRPTV9WS19GN1wiLFxuICAgIFwiRE9NX1ZLX0Y4XCIsXG4gICAgXCJET01fVktfRjlcIixcbiAgICBcIkRPTV9WS19GSU5BTFwiLFxuICAgIFwiRE9NX1ZLX0ZST05UXCIsXG4gICAgXCJET01fVktfR1wiLFxuICAgIFwiRE9NX1ZLX0dSRUFURVJfVEhBTlwiLFxuICAgIFwiRE9NX1ZLX0hcIixcbiAgICBcIkRPTV9WS19IQU5HVUxcIixcbiAgICBcIkRPTV9WS19IQU5KQVwiLFxuICAgIFwiRE9NX1ZLX0hBU0hcIixcbiAgICBcIkRPTV9WS19IRUxQXCIsXG4gICAgXCJET01fVktfSEtfVE9HR0xFXCIsXG4gICAgXCJET01fVktfSE9NRVwiLFxuICAgIFwiRE9NX1ZLX0hZUEhFTl9NSU5VU1wiLFxuICAgIFwiRE9NX1ZLX0lcIixcbiAgICBcIkRPTV9WS19JTlNFUlRcIixcbiAgICBcIkRPTV9WS19KXCIsXG4gICAgXCJET01fVktfSlVOSkFcIixcbiAgICBcIkRPTV9WS19LXCIsXG4gICAgXCJET01fVktfS0FOQVwiLFxuICAgIFwiRE9NX1ZLX0tBTkpJXCIsXG4gICAgXCJET01fVktfTFwiLFxuICAgIFwiRE9NX1ZLX0xFRlRcIixcbiAgICBcIkRPTV9WS19MRUZUX1RBQlwiLFxuICAgIFwiRE9NX1ZLX0xFU1NfVEhBTlwiLFxuICAgIFwiRE9NX1ZLX01cIixcbiAgICBcIkRPTV9WS19NRVRBXCIsXG4gICAgXCJET01fVktfTU9ERUNIQU5HRVwiLFxuICAgIFwiRE9NX1ZLX01VTFRJUExZXCIsXG4gICAgXCJET01fVktfTlwiLFxuICAgIFwiRE9NX1ZLX05PTkNPTlZFUlRcIixcbiAgICBcIkRPTV9WS19OVU1QQUQwXCIsXG4gICAgXCJET01fVktfTlVNUEFEMVwiLFxuICAgIFwiRE9NX1ZLX05VTVBBRDJcIixcbiAgICBcIkRPTV9WS19OVU1QQUQzXCIsXG4gICAgXCJET01fVktfTlVNUEFENFwiLFxuICAgIFwiRE9NX1ZLX05VTVBBRDVcIixcbiAgICBcIkRPTV9WS19OVU1QQUQ2XCIsXG4gICAgXCJET01fVktfTlVNUEFEN1wiLFxuICAgIFwiRE9NX1ZLX05VTVBBRDhcIixcbiAgICBcIkRPTV9WS19OVU1QQUQ5XCIsXG4gICAgXCJET01fVktfTlVNX0xPQ0tcIixcbiAgICBcIkRPTV9WS19PXCIsXG4gICAgXCJET01fVktfT0VNXzFcIixcbiAgICBcIkRPTV9WS19PRU1fMTAyXCIsXG4gICAgXCJET01fVktfT0VNXzJcIixcbiAgICBcIkRPTV9WS19PRU1fM1wiLFxuICAgIFwiRE9NX1ZLX09FTV80XCIsXG4gICAgXCJET01fVktfT0VNXzVcIixcbiAgICBcIkRPTV9WS19PRU1fNlwiLFxuICAgIFwiRE9NX1ZLX09FTV83XCIsXG4gICAgXCJET01fVktfT0VNXzhcIixcbiAgICBcIkRPTV9WS19PRU1fQ09NTUFcIixcbiAgICBcIkRPTV9WS19PRU1fTUlOVVNcIixcbiAgICBcIkRPTV9WS19PRU1fUEVSSU9EXCIsXG4gICAgXCJET01fVktfT0VNX1BMVVNcIixcbiAgICBcIkRPTV9WS19PUEVOX0JSQUNLRVRcIixcbiAgICBcIkRPTV9WS19PUEVOX0NVUkxZX0JSQUNLRVRcIixcbiAgICBcIkRPTV9WS19PUEVOX1BBUkVOXCIsXG4gICAgXCJET01fVktfUFwiLFxuICAgIFwiRE9NX1ZLX1BBMVwiLFxuICAgIFwiRE9NX1ZLX1BBR0VET1dOXCIsXG4gICAgXCJET01fVktfUEFHRVVQXCIsXG4gICAgXCJET01fVktfUEFHRV9ET1dOXCIsXG4gICAgXCJET01fVktfUEFHRV9VUFwiLFxuICAgIFwiRE9NX1ZLX1BBVVNFXCIsXG4gICAgXCJET01fVktfUEVSQ0VOVFwiLFxuICAgIFwiRE9NX1ZLX1BFUklPRFwiLFxuICAgIFwiRE9NX1ZLX1BJUEVcIixcbiAgICBcIkRPTV9WS19QTEFZXCIsXG4gICAgXCJET01fVktfUExVU1wiLFxuICAgIFwiRE9NX1ZLX1BSSU5UXCIsXG4gICAgXCJET01fVktfUFJJTlRTQ1JFRU5cIixcbiAgICBcIkRPTV9WS19QUk9DRVNTS0VZXCIsXG4gICAgXCJET01fVktfUFJPUEVSSVRFU1wiLFxuICAgIFwiRE9NX1ZLX1FcIixcbiAgICBcIkRPTV9WS19RVUVTVElPTl9NQVJLXCIsXG4gICAgXCJET01fVktfUVVPVEVcIixcbiAgICBcIkRPTV9WS19SXCIsXG4gICAgXCJET01fVktfUkVET1wiLFxuICAgIFwiRE9NX1ZLX1JFVFVSTlwiLFxuICAgIFwiRE9NX1ZLX1JJR0hUXCIsXG4gICAgXCJET01fVktfU1wiLFxuICAgIFwiRE9NX1ZLX1NDUk9MTF9MT0NLXCIsXG4gICAgXCJET01fVktfU0VMRUNUXCIsXG4gICAgXCJET01fVktfU0VNSUNPTE9OXCIsXG4gICAgXCJET01fVktfU0VQQVJBVE9SXCIsXG4gICAgXCJET01fVktfU0hJRlRcIixcbiAgICBcIkRPTV9WS19TTEFTSFwiLFxuICAgIFwiRE9NX1ZLX1NMRUVQXCIsXG4gICAgXCJET01fVktfU1BBQ0VcIixcbiAgICBcIkRPTV9WS19TVUJUUkFDVFwiLFxuICAgIFwiRE9NX1ZLX1RcIixcbiAgICBcIkRPTV9WS19UQUJcIixcbiAgICBcIkRPTV9WS19USUxERVwiLFxuICAgIFwiRE9NX1ZLX1VcIixcbiAgICBcIkRPTV9WS19VTkRFUlNDT1JFXCIsXG4gICAgXCJET01fVktfVU5ET1wiLFxuICAgIFwiRE9NX1ZLX1VOSUNPREVcIixcbiAgICBcIkRPTV9WS19VUFwiLFxuICAgIFwiRE9NX1ZLX1ZcIixcbiAgICBcIkRPTV9WS19WT0xVTUVfRE9XTlwiLFxuICAgIFwiRE9NX1ZLX1ZPTFVNRV9NVVRFXCIsXG4gICAgXCJET01fVktfVk9MVU1FX1VQXCIsXG4gICAgXCJET01fVktfV1wiLFxuICAgIFwiRE9NX1ZLX1dJTlwiLFxuICAgIFwiRE9NX1ZLX1dJTkRPV1wiLFxuICAgIFwiRE9NX1ZLX1dJTl9JQ09fMDBcIixcbiAgICBcIkRPTV9WS19XSU5fSUNPX0NMRUFSXCIsXG4gICAgXCJET01fVktfV0lOX0lDT19IRUxQXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9BVFROXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9BVVRPXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9CQUNLVEFCXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9DTEVBUlwiLFxuICAgIFwiRE9NX1ZLX1dJTl9PRU1fQ09QWVwiLFxuICAgIFwiRE9NX1ZLX1dJTl9PRU1fQ1VTRUxcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0VOTFdcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0ZJTklTSFwiLFxuICAgIFwiRE9NX1ZLX1dJTl9PRU1fRkpfSklTSE9cIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0ZKX0xPWUFcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0ZKX01BU1NIT1VcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0ZKX1JPWUFcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0ZKX1RPVVJPS1VcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0pVTVBcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX1BBMVwiLFxuICAgIFwiRE9NX1ZLX1dJTl9PRU1fUEEyXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9QQTNcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX1JFU0VUXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9XU0NUUkxcIixcbiAgICBcIkRPTV9WS19YXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FERF9GQVZPUklURVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19BUFBMSUNBVElPTl9MRUZUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FQUExJQ0FUSU9OX1JJR0hUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX0NZQ0xFX1RSQUNLXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX0ZPUldBUkRcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQVVESU9fTE9XRVJfVk9MVU1FXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX01FRElBXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX01VVEVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQVVESU9fTkVYVFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19BVURJT19QQVVTRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19BVURJT19QTEFZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX1BSRVZcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQVVESU9fUkFJU0VfVk9MVU1FXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX1JBTkRPTV9QTEFZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX1JFQ09SRFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19BVURJT19SRVBFQVRcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQVVESU9fUkVXSU5EXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX1NUT1BcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQVdBWVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19CQUNLXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0JBQ0tfRk9SV0FSRFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19CQVRURVJZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0JMVUVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQkxVRVRPT1RIXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0JPT0tcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQlJJR0hUTkVTU19BREpVU1RcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQ0FMQ1VMQVRPUlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19DQUxFTkRBUlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19DRFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19DTE9TRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19DT01NVU5JVFlcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQ09OVFJBU1RfQURKVVNUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0NPUFlcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQ1VUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0NZQ0xFX0FOR0xFXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0RJU1BMQVlcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfRE9DVU1FTlRTXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0RPU1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19FSkVDVFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19FWENFTFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19FWFBMT1JFUlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19GQVZPUklURVNcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfRklOQU5DRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19GT1JXQVJEXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0ZSQU1FX0JBQ0tcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfRlJBTUVfRk9SV0FSRFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19HQU1FXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0dPXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0dSRUVOXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0hJQkVSTkFURVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19ISVNUT1JZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0hPTUVfUEFHRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19IT1RfTElOS1NcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfSV9UT1VDSFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19LQkRfQlJJR0hUTkVTU19ET1dOXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0tCRF9CUklHSFRORVNTX1VQXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0tCRF9MSUdIVF9PTl9PRkZcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTEFVTkNIMFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0gxXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0xBVU5DSDJcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTEFVTkNIM1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0g0XCIsXG4gICAgXCJET01fVktfWEY4NlhLX0xBVU5DSDVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTEFVTkNINlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0g3XCIsXG4gICAgXCJET01fVktfWEY4NlhLX0xBVU5DSDhcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTEFVTkNIOVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfQVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfQlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfQ1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfRFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfRlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MSUdIVF9CVUxCXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0xPR19PRkZcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTUFJTFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19NQUlMX0ZPUldBUkRcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTUFSS0VUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX01FRVRJTkdcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTUVNT1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19NRU5VX0tCXCIsXG4gICAgXCJET01fVktfWEY4NlhLX01FTlVfUEJcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTUVTU0VOR0VSXCIsXG4gICAgXCJET01fVktfWEY4NlhLX01PTl9CUklHSFRORVNTX0RPV05cIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTU9OX0JSSUdIVE5FU1NfVVBcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTVVTSUNcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTVlfQ09NUFVURVJcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTVlfU0lURVNcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTkVXXCIsXG4gICAgXCJET01fVktfWEY4NlhLX05FV1NcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfT0ZGSUNFX0hPTUVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfT1BFTlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19PUEVOX1VSTFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19PUFRJT05cIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUEFTVEVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUEhPTkVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUElDVFVSRVNcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUE9XRVJfRE9XTlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19QT1dFUl9PRkZcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUkVEXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1JFRlJFU0hcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUkVMT0FEXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1JFUExZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1JPQ0tFUl9ET1dOXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1JPQ0tFUl9FTlRFUlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19ST0NLRVJfVVBcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUk9UQVRFX1dJTkRPV1NcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUk9UQVRJT05fS0JcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUk9UQVRJT05fUEJcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfU0FWRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19TQ1JFRU5fU0FWRVJcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfU0NST0xMX0NMSUNLXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NDUk9MTF9ET1dOXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NDUk9MTF9VUFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19TRUFSQ0hcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfU0VORFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19TSE9QXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NQRUxMXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NQTElUX1NDUkVFTlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19TVEFOREJZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NUQVJUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NUT1BcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfU1VCVElUTEVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfU1VQUE9SVFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19TVVNQRU5EXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1RBU0tfUEFORVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19URVJNSU5BTFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19USU1FXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1RPT0xTXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1RPUF9NRU5VXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1RPX0RPX0xJU1RcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfVFJBVkVMXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1VTRVIxS0JcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfVVNFUjJLQlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19VU0VSX1BCXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1VXQlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19WRU5ET1JfSE9NRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19WSURFT1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19WSUVXXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1dBS0VfVVBcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfV0VCX0NBTVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19XSEVFTF9CVVRUT05cIixcbiAgICBcIkRPTV9WS19YRjg2WEtfV0xBTlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19XT1JEXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1dXV1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19YRkVSXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1lFTExPV1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19aT09NX0lOXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1pPT01fT1VUXCIsXG4gICAgXCJET01fVktfWVwiLFxuICAgIFwiRE9NX1ZLX1pcIixcbiAgICBcIkRPTV9WS19aT09NXCIsXG4gICAgXCJET05FXCIsXG4gICAgXCJET05UX0NBUkVcIixcbiAgICBcIkRPV05MT0FESU5HXCIsXG4gICAgXCJEUkFHRFJPUFwiLFxuICAgIFwiRFJBV19CVUZGRVIwXCIsXG4gICAgXCJEUkFXX0JVRkZFUjFcIixcbiAgICBcIkRSQVdfQlVGRkVSMTBcIixcbiAgICBcIkRSQVdfQlVGRkVSMTFcIixcbiAgICBcIkRSQVdfQlVGRkVSMTJcIixcbiAgICBcIkRSQVdfQlVGRkVSMTNcIixcbiAgICBcIkRSQVdfQlVGRkVSMTRcIixcbiAgICBcIkRSQVdfQlVGRkVSMTVcIixcbiAgICBcIkRSQVdfQlVGRkVSMlwiLFxuICAgIFwiRFJBV19CVUZGRVIzXCIsXG4gICAgXCJEUkFXX0JVRkZFUjRcIixcbiAgICBcIkRSQVdfQlVGRkVSNVwiLFxuICAgIFwiRFJBV19CVUZGRVI2XCIsXG4gICAgXCJEUkFXX0JVRkZFUjdcIixcbiAgICBcIkRSQVdfQlVGRkVSOFwiLFxuICAgIFwiRFJBV19CVUZGRVI5XCIsXG4gICAgXCJEUkFXX0ZSQU1FQlVGRkVSXCIsXG4gICAgXCJEUkFXX0ZSQU1FQlVGRkVSX0JJTkRJTkdcIixcbiAgICBcIkRTVF9BTFBIQVwiLFxuICAgIFwiRFNUX0NPTE9SXCIsXG4gICAgXCJEWU5BTUlDX0NPUFlcIixcbiAgICBcIkRZTkFNSUNfRFJBV1wiLFxuICAgIFwiRFlOQU1JQ19SRUFEXCIsXG4gICAgXCJEYXRhQ2hhbm5lbFwiLFxuICAgIFwiRGF0YVRyYW5zZmVyXCIsXG4gICAgXCJEYXRhVHJhbnNmZXJJdGVtXCIsXG4gICAgXCJEYXRhVHJhbnNmZXJJdGVtTGlzdFwiLFxuICAgIFwiRGF0YVZpZXdcIixcbiAgICBcIkRhdGVcIixcbiAgICBcIkRhdGVUaW1lRm9ybWF0XCIsXG4gICAgXCJEZWNvbXByZXNzaW9uU3RyZWFtXCIsXG4gICAgXCJEZWxheU5vZGVcIixcbiAgICBcIkRlbGVnYXRlZElua1RyYWlsUHJlc2VudGVyXCIsXG4gICAgXCJEZXByZWNhdGlvblJlcG9ydEJvZHlcIixcbiAgICBcIkRlc2t0b3BOb3RpZmljYXRpb25cIixcbiAgICBcIkRlc2t0b3BOb3RpZmljYXRpb25DZW50ZXJcIixcbiAgICBcIkRldGFpbHNcIixcbiAgICBcIkRldmljZUxpZ2h0RXZlbnRcIixcbiAgICBcIkRldmljZU1vdGlvbkV2ZW50XCIsXG4gICAgXCJEZXZpY2VNb3Rpb25FdmVudEFjY2VsZXJhdGlvblwiLFxuICAgIFwiRGV2aWNlTW90aW9uRXZlbnRSb3RhdGlvblJhdGVcIixcbiAgICBcIkRldmljZU9yaWVudGF0aW9uRXZlbnRcIixcbiAgICBcIkRldmljZVByb3hpbWl0eUV2ZW50XCIsXG4gICAgXCJEZXZpY2VTdG9yYWdlXCIsXG4gICAgXCJEZXZpY2VTdG9yYWdlQ2hhbmdlRXZlbnRcIixcbiAgICBcIkRpcmVjdG9yeVwiLFxuICAgIFwiRGlzcGxheU5hbWVzXCIsXG4gICAgXCJEb2N1bWVudFwiLFxuICAgIFwiRG9jdW1lbnRGcmFnbWVudFwiLFxuICAgIFwiRG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlXCIsXG4gICAgXCJEb2N1bWVudFBpY3R1cmVJblBpY3R1cmVFdmVudFwiLFxuICAgIFwiRG9jdW1lbnRUaW1lbGluZVwiLFxuICAgIFwiRG9jdW1lbnRUeXBlXCIsXG4gICAgXCJEcmFnRXZlbnRcIixcbiAgICBcIkR1cmF0aW9uRm9ybWF0XCIsXG4gICAgXCJEeW5hbWljc0NvbXByZXNzb3JOb2RlXCIsXG4gICAgXCJFXCIsXG4gICAgXCJFTEVNRU5UX0FSUkFZX0JVRkZFUlwiLFxuICAgIFwiRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElOR1wiLFxuICAgIFwiRUxFTUVOVF9OT0RFXCIsXG4gICAgXCJFTVBUWVwiLFxuICAgIFwiRU5DT0RJTkdfRVJSXCIsXG4gICAgXCJFTkRFRFwiLFxuICAgIFwiRU5EX1RPX0VORFwiLFxuICAgIFwiRU5EX1RPX1NUQVJUXCIsXG4gICAgXCJFTlRJVFlfTk9ERVwiLFxuICAgIFwiRU5USVRZX1JFRkVSRU5DRV9OT0RFXCIsXG4gICAgXCJFUFNJTE9OXCIsXG4gICAgXCJFUVVBTFwiLFxuICAgIFwiRVFVQUxQT1dFUlwiLFxuICAgIFwiRVJST1JcIixcbiAgICBcIkVYUE9ORU5USUFMX0RJU1RBTkNFXCIsXG4gICAgXCJFZGl0Q29udGV4dFwiLFxuICAgIFwiRWxlbWVudFwiLFxuICAgIFwiRWxlbWVudEludGVybmFsc1wiLFxuICAgIFwiRWxlbWVudFF1ZXJ5XCIsXG4gICAgXCJFbmNvZGVkQXVkaW9DaHVua1wiLFxuICAgIFwiRW5jb2RlZFZpZGVvQ2h1bmtcIixcbiAgICBcIkVudGVyUGljdHVyZUluUGljdHVyZUV2ZW50XCIsXG4gICAgXCJFbnRpdHlcIixcbiAgICBcIkVudGl0eVJlZmVyZW5jZVwiLFxuICAgIFwiRXJyb3JcIixcbiAgICBcIkVycm9yRXZlbnRcIixcbiAgICBcIkV2YWxFcnJvclwiLFxuICAgIFwiRXZlbnRcIixcbiAgICBcIkV2ZW50Q291bnRzXCIsXG4gICAgXCJFdmVudEV4Y2VwdGlvblwiLFxuICAgIFwiRXZlbnRTb3VyY2VcIixcbiAgICBcIkV2ZW50VGFyZ2V0XCIsXG4gICAgXCJFeGNlcHRpb25cIixcbiAgICBcIkV4dGVuc2lvbkNvbnRleHRcIixcbiAgICBcIkV4dGVuc2lvbkRpc2FibGVkUmVhc29uXCIsXG4gICAgXCJFeHRlbnNpb25JbmZvXCIsXG4gICAgXCJFeHRlbnNpb25JbnN0YWxsVHlwZVwiLFxuICAgIFwiRXh0ZW5zaW9uVHlwZVwiLFxuICAgIFwiRXh0ZXJuYWxcIixcbiAgICBcIkV5ZURyb3BwZXJcIixcbiAgICBcIkZBU1RFU1RcIixcbiAgICBcIkZJRE9TREtcIixcbiAgICBcIkZJTFRFUl9BQ0NFUFRcIixcbiAgICBcIkZJTFRFUl9JTlRFUlJVUFRcIixcbiAgICBcIkZJTFRFUl9SRUpFQ1RcIixcbiAgICBcIkZJTFRFUl9TS0lQXCIsXG4gICAgXCJGSU5JU0hFRF9TVEFURVwiLFxuICAgIFwiRklSU1RfT1JERVJFRF9OT0RFX1RZUEVcIixcbiAgICBcIkZMT0FUXCIsXG4gICAgXCJGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVZcIixcbiAgICBcIkZMT0FUX01BVDJcIixcbiAgICBcIkZMT0FUX01BVDJ4M1wiLFxuICAgIFwiRkxPQVRfTUFUMng0XCIsXG4gICAgXCJGTE9BVF9NQVQzXCIsXG4gICAgXCJGTE9BVF9NQVQzeDJcIixcbiAgICBcIkZMT0FUX01BVDN4NFwiLFxuICAgIFwiRkxPQVRfTUFUNFwiLFxuICAgIFwiRkxPQVRfTUFUNHgyXCIsXG4gICAgXCJGTE9BVF9NQVQ0eDNcIixcbiAgICBcIkZMT0FUX1ZFQzJcIixcbiAgICBcIkZMT0FUX1ZFQzNcIixcbiAgICBcIkZMT0FUX1ZFQzRcIixcbiAgICBcIkZPQ1VTXCIsXG4gICAgXCJGT05UX0ZBQ0VfUlVMRVwiLFxuICAgIFwiRk9OVF9GRUFUVVJFX1ZBTFVFU19SVUxFXCIsXG4gICAgXCJGUkFHTUVOVFwiLFxuICAgIFwiRlJBR01FTlRfU0hBREVSXCIsXG4gICAgXCJGUkFHTUVOVF9TSEFERVJfREVSSVZBVElWRV9ISU5UXCIsXG4gICAgXCJGUkFHTUVOVF9TSEFERVJfREVSSVZBVElWRV9ISU5UX09FU1wiLFxuICAgIFwiRlJBTUVCVUZGRVJcIixcbiAgICBcIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQUxQSEFfU0laRVwiLFxuICAgIFwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9CTFVFX1NJWkVcIixcbiAgICBcIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQ09MT1JfRU5DT0RJTkdcIixcbiAgICBcIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQ09NUE9ORU5UX1RZUEVcIixcbiAgICBcIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfREVQVEhfU0laRVwiLFxuICAgIFwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9HUkVFTl9TSVpFXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9OQU1FXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1JFRF9TSVpFXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1NURU5DSUxfU0laRVwiLFxuICAgIFwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0NVQkVfTUFQX0ZBQ0VcIixcbiAgICBcIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MQVlFUlwiLFxuICAgIFwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xFVkVMXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9CSU5ESU5HXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9DT01QTEVURVwiLFxuICAgIFwiRlJBTUVCVUZGRVJfREVGQVVMVFwiLFxuICAgIFwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlNcIixcbiAgICBcIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01VTFRJU0FNUExFXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiLFxuICAgIFwiRlJPTlRcIixcbiAgICBcIkZST05UX0FORF9CQUNLXCIsXG4gICAgXCJGUk9OVF9GQUNFXCIsXG4gICAgXCJGVU5DX0FERFwiLFxuICAgIFwiRlVOQ19SRVZFUlNFX1NVQlRSQUNUXCIsXG4gICAgXCJGVU5DX1NVQlRSQUNUXCIsXG4gICAgXCJGZWF0dXJlUG9saWN5XCIsXG4gICAgXCJGZWF0dXJlUG9saWN5VmlvbGF0aW9uUmVwb3J0Qm9keVwiLFxuICAgIFwiRmVkZXJhdGVkQ3JlZGVudGlhbFwiLFxuICAgIFwiRmVlZFwiLFxuICAgIFwiRmVlZEVudHJ5XCIsXG4gICAgXCJGZW5jZVwiLFxuICAgIFwiRmVuY2VkRnJhbWVDb25maWdcIixcbiAgICBcIkZpbGVcIixcbiAgICBcIkZpbGVFcnJvclwiLFxuICAgIFwiRmlsZUxpc3RcIixcbiAgICBcIkZpbGVSZWFkZXJcIixcbiAgICBcIkZpbGVTeXN0ZW1cIixcbiAgICBcIkZpbGVTeXN0ZW1EaXJlY3RvcnlFbnRyeVwiLFxuICAgIFwiRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZVwiLFxuICAgIFwiRmlsZVN5c3RlbURpcmVjdG9yeVJlYWRlclwiLFxuICAgIFwiRmlsZVN5c3RlbUVudHJ5XCIsXG4gICAgXCJGaWxlU3lzdGVtRmlsZUVudHJ5XCIsXG4gICAgXCJGaWxlU3lzdGVtRmlsZUhhbmRsZVwiLFxuICAgIFwiRmlsZVN5c3RlbUhhbmRsZVwiLFxuICAgIFwiRmlsZVN5c3RlbVdyaXRhYmxlRmlsZVN0cmVhbVwiLFxuICAgIFwiRmluYWxpemF0aW9uUmVnaXN0cnlcIixcbiAgICBcIkZpbmRJblBhZ2VcIixcbiAgICBcIkZsb2F0MTZBcnJheVwiLFxuICAgIFwiRmxvYXQzMkFycmF5XCIsXG4gICAgXCJGbG9hdDY0QXJyYXlcIixcbiAgICBcIkZvY3VzRXZlbnRcIixcbiAgICBcIkZvbnREYXRhXCIsXG4gICAgXCJGb250RmFjZVwiLFxuICAgIFwiRm9udEZhY2VTZXRcIixcbiAgICBcIkZvbnRGYWNlU2V0TG9hZEV2ZW50XCIsXG4gICAgXCJGb3JtRGF0YVwiLFxuICAgIFwiRm9ybURhdGFFdmVudFwiLFxuICAgIFwiRnJhZ21lbnREaXJlY3RpdmVcIixcbiAgICBcIkZ1bmN0aW9uXCIsXG4gICAgXCJHRU5FUkFURV9NSVBNQVBfSElOVFwiLFxuICAgIFwiR0VRVUFMXCIsXG4gICAgXCJHUFVcIixcbiAgICBcIkdQVUFkYXB0ZXJcIixcbiAgICBcIkdQVUFkYXB0ZXJJbmZvXCIsXG4gICAgXCJHUFVCaW5kR3JvdXBcIixcbiAgICBcIkdQVUJpbmRHcm91cExheW91dFwiLFxuICAgIFwiR1BVQnVmZmVyXCIsXG4gICAgXCJHUFVCdWZmZXJVc2FnZVwiLFxuICAgIFwiR1BVQ2FudmFzQ29udGV4dFwiLFxuICAgIFwiR1BVQ29sb3JXcml0ZVwiLFxuICAgIFwiR1BVQ29tbWFuZEJ1ZmZlclwiLFxuICAgIFwiR1BVQ29tbWFuZEVuY29kZXJcIixcbiAgICBcIkdQVUNvbXBpbGF0aW9uSW5mb1wiLFxuICAgIFwiR1BVQ29tcGlsYXRpb25NZXNzYWdlXCIsXG4gICAgXCJHUFVDb21wdXRlUGFzc0VuY29kZXJcIixcbiAgICBcIkdQVUNvbXB1dGVQaXBlbGluZVwiLFxuICAgIFwiR1BVRGV2aWNlXCIsXG4gICAgXCJHUFVEZXZpY2VMb3N0SW5mb1wiLFxuICAgIFwiR1BVRXJyb3JcIixcbiAgICBcIkdQVUV4dGVybmFsVGV4dHVyZVwiLFxuICAgIFwiR1BVSW50ZXJuYWxFcnJvclwiLFxuICAgIFwiR1BVTWFwTW9kZVwiLFxuICAgIFwiR1BVT3V0T2ZNZW1vcnlFcnJvclwiLFxuICAgIFwiR1BVUGlwZWxpbmVFcnJvclwiLFxuICAgIFwiR1BVUGlwZWxpbmVMYXlvdXRcIixcbiAgICBcIkdQVVF1ZXJ5U2V0XCIsXG4gICAgXCJHUFVRdWV1ZVwiLFxuICAgIFwiR1BVUmVuZGVyQnVuZGxlXCIsXG4gICAgXCJHUFVSZW5kZXJCdW5kbGVFbmNvZGVyXCIsXG4gICAgXCJHUFVSZW5kZXJQYXNzRW5jb2RlclwiLFxuICAgIFwiR1BVUmVuZGVyUGlwZWxpbmVcIixcbiAgICBcIkdQVVNhbXBsZXJcIixcbiAgICBcIkdQVVNoYWRlck1vZHVsZVwiLFxuICAgIFwiR1BVU2hhZGVyU3RhZ2VcIixcbiAgICBcIkdQVVN1cHBvcnRlZEZlYXR1cmVzXCIsXG4gICAgXCJHUFVTdXBwb3J0ZWRMaW1pdHNcIixcbiAgICBcIkdQVVRleHR1cmVcIixcbiAgICBcIkdQVVRleHR1cmVVc2FnZVwiLFxuICAgIFwiR1BVVGV4dHVyZVZpZXdcIixcbiAgICBcIkdQVVVuY2FwdHVyZWRFcnJvckV2ZW50XCIsXG4gICAgXCJHUFVWYWxpZGF0aW9uRXJyb3JcIixcbiAgICBcIkdSRUFURVJcIixcbiAgICBcIkdSRUVOXCIsXG4gICAgXCJHUkVFTl9CSVRTXCIsXG4gICAgXCJHYWluTm9kZVwiLFxuICAgIFwiR2FtZXBhZFwiLFxuICAgIFwiR2FtZXBhZEF4aXNNb3ZlRXZlbnRcIixcbiAgICBcIkdhbWVwYWRCdXR0b25cIixcbiAgICBcIkdhbWVwYWRCdXR0b25FdmVudFwiLFxuICAgIFwiR2FtZXBhZEV2ZW50XCIsXG4gICAgXCJHYW1lcGFkSGFwdGljQWN0dWF0b3JcIixcbiAgICBcIkdhbWVwYWRQb3NlXCIsXG4gICAgXCJHZW9sb2NhdGlvblwiLFxuICAgIFwiR2VvbG9jYXRpb25Db29yZGluYXRlc1wiLFxuICAgIFwiR2VvbG9jYXRpb25Qb3NpdGlvblwiLFxuICAgIFwiR2VvbG9jYXRpb25Qb3NpdGlvbkVycm9yXCIsXG4gICAgXCJHZXN0dXJlRXZlbnRcIixcbiAgICBcIkdldEluZm9cIixcbiAgICBcIkdsb2JhbFwiLFxuICAgIFwiR3Jhdml0eVNlbnNvclwiLFxuICAgIFwiR3lyb3Njb3BlXCIsXG4gICAgXCJIQUxGX0ZMT0FUXCIsXG4gICAgXCJIQVZFX0NVUlJFTlRfREFUQVwiLFxuICAgIFwiSEFWRV9FTk9VR0hfREFUQVwiLFxuICAgIFwiSEFWRV9GVVRVUkVfREFUQVwiLFxuICAgIFwiSEFWRV9NRVRBREFUQVwiLFxuICAgIFwiSEFWRV9OT1RISU5HXCIsXG4gICAgXCJIRUFERVJTX1JFQ0VJVkVEXCIsXG4gICAgXCJISURcIixcbiAgICBcIkhJRENvbm5lY3Rpb25FdmVudFwiLFxuICAgIFwiSElEREVOXCIsXG4gICAgXCJISUREZXZpY2VcIixcbiAgICBcIkhJRElucHV0UmVwb3J0RXZlbnRcIixcbiAgICBcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiLFxuICAgIFwiSElHSFBBU1NcIixcbiAgICBcIkhJR0hTSEVMRlwiLFxuICAgIFwiSElHSF9GTE9BVFwiLFxuICAgIFwiSElHSF9JTlRcIixcbiAgICBcIkhPUklaT05UQUxcIixcbiAgICBcIkhPUklaT05UQUxfQVhJU1wiLFxuICAgIFwiSFJURlwiLFxuICAgIFwiSFRNTEFsbENvbGxlY3Rpb25cIixcbiAgICBcIkhUTUxBbmNob3JFbGVtZW50XCIsXG4gICAgXCJIVE1MQXBwbGV0RWxlbWVudFwiLFxuICAgIFwiSFRNTEFyZWFFbGVtZW50XCIsXG4gICAgXCJIVE1MQXVkaW9FbGVtZW50XCIsXG4gICAgXCJIVE1MQlJFbGVtZW50XCIsXG4gICAgXCJIVE1MQmFzZUVsZW1lbnRcIixcbiAgICBcIkhUTUxCYXNlRm9udEVsZW1lbnRcIixcbiAgICBcIkhUTUxCbG9ja3F1b3RlRWxlbWVudFwiLFxuICAgIFwiSFRNTEJvZHlFbGVtZW50XCIsXG4gICAgXCJIVE1MQnV0dG9uRWxlbWVudFwiLFxuICAgIFwiSFRNTENhbnZhc0VsZW1lbnRcIixcbiAgICBcIkhUTUxDb2xsZWN0aW9uXCIsXG4gICAgXCJIVE1MQ29tbWFuZEVsZW1lbnRcIixcbiAgICBcIkhUTUxDb250ZW50RWxlbWVudFwiLFxuICAgIFwiSFRNTERMaXN0RWxlbWVudFwiLFxuICAgIFwiSFRNTERhdGFFbGVtZW50XCIsXG4gICAgXCJIVE1MRGF0YUxpc3RFbGVtZW50XCIsXG4gICAgXCJIVE1MRGV0YWlsc0VsZW1lbnRcIixcbiAgICBcIkhUTUxEaWFsb2dFbGVtZW50XCIsXG4gICAgXCJIVE1MRGlyZWN0b3J5RWxlbWVudFwiLFxuICAgIFwiSFRNTERpdkVsZW1lbnRcIixcbiAgICBcIkhUTUxEb2N1bWVudFwiLFxuICAgIFwiSFRNTEVsZW1lbnRcIixcbiAgICBcIkhUTUxFbWJlZEVsZW1lbnRcIixcbiAgICBcIkhUTUxGZW5jZWRGcmFtZUVsZW1lbnRcIixcbiAgICBcIkhUTUxGaWVsZFNldEVsZW1lbnRcIixcbiAgICBcIkhUTUxGb250RWxlbWVudFwiLFxuICAgIFwiSFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb25cIixcbiAgICBcIkhUTUxGb3JtRWxlbWVudFwiLFxuICAgIFwiSFRNTEZyYW1lRWxlbWVudFwiLFxuICAgIFwiSFRNTEZyYW1lU2V0RWxlbWVudFwiLFxuICAgIFwiSFRNTEhSRWxlbWVudFwiLFxuICAgIFwiSFRNTEhlYWRFbGVtZW50XCIsXG4gICAgXCJIVE1MSGVhZGluZ0VsZW1lbnRcIixcbiAgICBcIkhUTUxIdG1sRWxlbWVudFwiLFxuICAgIFwiSFRNTElGcmFtZUVsZW1lbnRcIixcbiAgICBcIkhUTUxJbWFnZUVsZW1lbnRcIixcbiAgICBcIkhUTUxJbnB1dEVsZW1lbnRcIixcbiAgICBcIkhUTUxJc0luZGV4RWxlbWVudFwiLFxuICAgIFwiSFRNTEtleWdlbkVsZW1lbnRcIixcbiAgICBcIkhUTUxMSUVsZW1lbnRcIixcbiAgICBcIkhUTUxMYWJlbEVsZW1lbnRcIixcbiAgICBcIkhUTUxMZWdlbmRFbGVtZW50XCIsXG4gICAgXCJIVE1MTGlua0VsZW1lbnRcIixcbiAgICBcIkhUTUxNYXBFbGVtZW50XCIsXG4gICAgXCJIVE1MTWFycXVlZUVsZW1lbnRcIixcbiAgICBcIkhUTUxNZWRpYUVsZW1lbnRcIixcbiAgICBcIkhUTUxNZW51RWxlbWVudFwiLFxuICAgIFwiSFRNTE1lbnVJdGVtRWxlbWVudFwiLFxuICAgIFwiSFRNTE1ldGFFbGVtZW50XCIsXG4gICAgXCJIVE1MTWV0ZXJFbGVtZW50XCIsXG4gICAgXCJIVE1MTW9kRWxlbWVudFwiLFxuICAgIFwiSFRNTE9MaXN0RWxlbWVudFwiLFxuICAgIFwiSFRNTE9iamVjdEVsZW1lbnRcIixcbiAgICBcIkhUTUxPcHRHcm91cEVsZW1lbnRcIixcbiAgICBcIkhUTUxPcHRpb25FbGVtZW50XCIsXG4gICAgXCJIVE1MT3B0aW9uc0NvbGxlY3Rpb25cIixcbiAgICBcIkhUTUxPdXRwdXRFbGVtZW50XCIsXG4gICAgXCJIVE1MUGFyYWdyYXBoRWxlbWVudFwiLFxuICAgIFwiSFRNTFBhcmFtRWxlbWVudFwiLFxuICAgIFwiSFRNTFBpY3R1cmVFbGVtZW50XCIsXG4gICAgXCJIVE1MUHJlRWxlbWVudFwiLFxuICAgIFwiSFRNTFByb2dyZXNzRWxlbWVudFwiLFxuICAgIFwiSFRNTFByb3BlcnRpZXNDb2xsZWN0aW9uXCIsXG4gICAgXCJIVE1MUXVvdGVFbGVtZW50XCIsXG4gICAgXCJIVE1MU2NyaXB0RWxlbWVudFwiLFxuICAgIFwiSFRNTFNlbGVjdEVsZW1lbnRcIixcbiAgICBcIkhUTUxTaGFkb3dFbGVtZW50XCIsXG4gICAgXCJIVE1MU2xvdEVsZW1lbnRcIixcbiAgICBcIkhUTUxTb3VyY2VFbGVtZW50XCIsXG4gICAgXCJIVE1MU3BhbkVsZW1lbnRcIixcbiAgICBcIkhUTUxTdHlsZUVsZW1lbnRcIixcbiAgICBcIkhUTUxUYWJsZUNhcHRpb25FbGVtZW50XCIsXG4gICAgXCJIVE1MVGFibGVDZWxsRWxlbWVudFwiLFxuICAgIFwiSFRNTFRhYmxlQ29sRWxlbWVudFwiLFxuICAgIFwiSFRNTFRhYmxlRWxlbWVudFwiLFxuICAgIFwiSFRNTFRhYmxlUm93RWxlbWVudFwiLFxuICAgIFwiSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnRcIixcbiAgICBcIkhUTUxUZW1wbGF0ZUVsZW1lbnRcIixcbiAgICBcIkhUTUxUZXh0QXJlYUVsZW1lbnRcIixcbiAgICBcIkhUTUxUaW1lRWxlbWVudFwiLFxuICAgIFwiSFRNTFRpdGxlRWxlbWVudFwiLFxuICAgIFwiSFRNTFRyYWNrRWxlbWVudFwiLFxuICAgIFwiSFRNTFVMaXN0RWxlbWVudFwiLFxuICAgIFwiSFRNTFVua25vd25FbGVtZW50XCIsXG4gICAgXCJIVE1MVmlkZW9FbGVtZW50XCIsXG4gICAgXCJIYXNoQ2hhbmdlRXZlbnRcIixcbiAgICBcIkhlYWRlcnNcIixcbiAgICBcIkhpZ2hsaWdodFwiLFxuICAgIFwiSGlnaGxpZ2h0UmVnaXN0cnlcIixcbiAgICBcIkhpc3RvcnlcIixcbiAgICBcIkh6XCIsXG4gICAgXCJJQ0VfQ0hFQ0tJTkdcIixcbiAgICBcIklDRV9DTE9TRURcIixcbiAgICBcIklDRV9DT01QTEVURURcIixcbiAgICBcIklDRV9DT05ORUNURURcIixcbiAgICBcIklDRV9GQUlMRURcIixcbiAgICBcIklDRV9HQVRIRVJJTkdcIixcbiAgICBcIklDRV9XQUlUSU5HXCIsXG4gICAgXCJJREJDdXJzb3JcIixcbiAgICBcIklEQkN1cnNvcldpdGhWYWx1ZVwiLFxuICAgIFwiSURCRGF0YWJhc2VcIixcbiAgICBcIklEQkRhdGFiYXNlRXhjZXB0aW9uXCIsXG4gICAgXCJJREJGYWN0b3J5XCIsXG4gICAgXCJJREJGaWxlSGFuZGxlXCIsXG4gICAgXCJJREJGaWxlUmVxdWVzdFwiLFxuICAgIFwiSURCSW5kZXhcIixcbiAgICBcIklEQktleVJhbmdlXCIsXG4gICAgXCJJREJNdXRhYmxlRmlsZVwiLFxuICAgIFwiSURCT2JqZWN0U3RvcmVcIixcbiAgICBcIklEQk9wZW5EQlJlcXVlc3RcIixcbiAgICBcIklEQlJlcXVlc3RcIixcbiAgICBcIklEQlRyYW5zYWN0aW9uXCIsXG4gICAgXCJJREJWZXJzaW9uQ2hhbmdlRXZlbnRcIixcbiAgICBcIklETEVcIixcbiAgICBcIklJUkZpbHRlck5vZGVcIixcbiAgICBcIklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfRk9STUFUXCIsXG4gICAgXCJJTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEVcIixcbiAgICBcIklNUE9SVF9SVUxFXCIsXG4gICAgXCJJTkNSXCIsXG4gICAgXCJJTkNSX1dSQVBcIixcbiAgICBcIklOREVYXCIsXG4gICAgXCJJTkRFWF9TSVpFX0VSUlwiLFxuICAgIFwiSU5ESVJFQ1RcIixcbiAgICBcIklOVFwiLFxuICAgIFwiSU5URVJMRUFWRURfQVRUUklCU1wiLFxuICAgIFwiSU5UXzJfMTBfMTBfMTBfUkVWXCIsXG4gICAgXCJJTlRfU0FNUExFUl8yRFwiLFxuICAgIFwiSU5UX1NBTVBMRVJfMkRfQVJSQVlcIixcbiAgICBcIklOVF9TQU1QTEVSXzNEXCIsXG4gICAgXCJJTlRfU0FNUExFUl9DVUJFXCIsXG4gICAgXCJJTlRfVkVDMlwiLFxuICAgIFwiSU5UX1ZFQzNcIixcbiAgICBcIklOVF9WRUM0XCIsXG4gICAgXCJJTlVTRV9BVFRSSUJVVEVfRVJSXCIsXG4gICAgXCJJTlZBTElEX0FDQ0VTU19FUlJcIixcbiAgICBcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiLFxuICAgIFwiSU5WQUxJRF9FTlVNXCIsXG4gICAgXCJJTlZBTElEX0VYUFJFU1NJT05fRVJSXCIsXG4gICAgXCJJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTlwiLFxuICAgIFwiSU5WQUxJRF9JTkRFWFwiLFxuICAgIFwiSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSXCIsXG4gICAgXCJJTlZBTElEX05PREVfVFlQRV9FUlJcIixcbiAgICBcIklOVkFMSURfT1BFUkFUSU9OXCIsXG4gICAgXCJJTlZBTElEX1NUQVRFX0VSUlwiLFxuICAgIFwiSU5WQUxJRF9WQUxVRVwiLFxuICAgIFwiSU5WRVJTRV9ESVNUQU5DRVwiLFxuICAgIFwiSU5WRVJUXCIsXG4gICAgXCJJY2VDYW5kaWRhdGVcIixcbiAgICBcIkljb25JbmZvXCIsXG4gICAgXCJJZGVudGl0eUNyZWRlbnRpYWxcIixcbiAgICBcIklkZW50aXR5Q3JlZGVudGlhbEVycm9yXCIsXG4gICAgXCJJZGVudGl0eVByb3ZpZGVyXCIsXG4gICAgXCJJZGxlRGVhZGxpbmVcIixcbiAgICBcIklkbGVEZXRlY3RvclwiLFxuICAgIFwiSW1hZ2VcIixcbiAgICBcIkltYWdlQml0bWFwXCIsXG4gICAgXCJJbWFnZUJpdG1hcFJlbmRlcmluZ0NvbnRleHRcIixcbiAgICBcIkltYWdlQ2FwdHVyZVwiLFxuICAgIFwiSW1hZ2VEYXRhXCIsXG4gICAgXCJJbWFnZURhdGFUeXBlXCIsXG4gICAgXCJJbWFnZURlY29kZXJcIixcbiAgICBcIkltYWdlVHJhY2tcIixcbiAgICBcIkltYWdlVHJhY2tMaXN0XCIsXG4gICAgXCJJbmZpbml0eVwiLFxuICAgIFwiSW5rXCIsXG4gICAgXCJJbnB1dERldmljZUNhcGFiaWxpdGllc1wiLFxuICAgIFwiSW5wdXREZXZpY2VJbmZvXCIsXG4gICAgXCJJbnB1dEV2ZW50XCIsXG4gICAgXCJJbnB1dE1ldGhvZENvbnRleHRcIixcbiAgICBcIkluc3RhbGxUcmlnZ2VyXCIsXG4gICAgXCJJbnN0YWxsVHJpZ2dlckltcGxcIixcbiAgICBcIkluc3RhbmNlXCIsXG4gICAgXCJJbnQxNkFycmF5XCIsXG4gICAgXCJJbnQzMkFycmF5XCIsXG4gICAgXCJJbnQ4QXJyYXlcIixcbiAgICBcIkludGVudFwiLFxuICAgIFwiSW50ZXJuYWxFcnJvclwiLFxuICAgIFwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcIixcbiAgICBcIkludGVyc2VjdGlvbk9ic2VydmVyRW50cnlcIixcbiAgICBcIkludGxcIixcbiAgICBcIklzU2VhcmNoUHJvdmlkZXJJbnN0YWxsZWRcIixcbiAgICBcIkl0ZXJhdG9yXCIsXG4gICAgXCJKU09OXCIsXG4gICAgXCJKU1RhZ1wiLFxuICAgIFwiS0VFUFwiLFxuICAgIFwiS0VZRE9XTlwiLFxuICAgIFwiS0VZRlJBTUVTX1JVTEVcIixcbiAgICBcIktFWUZSQU1FX1JVTEVcIixcbiAgICBcIktFWVBSRVNTXCIsXG4gICAgXCJLRVlVUFwiLFxuICAgIFwiS2V5RXZlbnRcIixcbiAgICBcIktleWJvYXJkXCIsXG4gICAgXCJLZXlib2FyZEV2ZW50XCIsXG4gICAgXCJLZXlib2FyZExheW91dE1hcFwiLFxuICAgIFwiS2V5ZnJhbWVFZmZlY3RcIixcbiAgICBcIkxFTkdUSEFESlVTVF9TUEFDSU5HXCIsXG4gICAgXCJMRU5HVEhBREpVU1RfU1BBQ0lOR0FOREdMWVBIU1wiLFxuICAgIFwiTEVOR1RIQURKVVNUX1VOS05PV05cIixcbiAgICBcIkxFUVVBTFwiLFxuICAgIFwiTEVTU1wiLFxuICAgIFwiTElORUFSXCIsXG4gICAgXCJMSU5FQVJfRElTVEFOQ0VcIixcbiAgICBcIkxJTkVBUl9NSVBNQVBfTElORUFSXCIsXG4gICAgXCJMSU5FQVJfTUlQTUFQX05FQVJFU1RcIixcbiAgICBcIkxJTkVTXCIsXG4gICAgXCJMSU5FX0xPT1BcIixcbiAgICBcIkxJTkVfU1RSSVBcIixcbiAgICBcIkxJTkVfV0lEVEhcIixcbiAgICBcIkxJTktfU1RBVFVTXCIsXG4gICAgXCJMSVZFXCIsXG4gICAgXCJMTjEwXCIsXG4gICAgXCJMTjJcIixcbiAgICBcIkxPQURFRFwiLFxuICAgIFwiTE9BRElOR1wiLFxuICAgIFwiTE9HMTBFXCIsXG4gICAgXCJMT0cyRVwiLFxuICAgIFwiTE9XUEFTU1wiLFxuICAgIFwiTE9XU0hFTEZcIixcbiAgICBcIkxPV19GTE9BVFwiLFxuICAgIFwiTE9XX0lOVFwiLFxuICAgIFwiTFNFeGNlcHRpb25cIixcbiAgICBcIkxTUGFyc2VyRmlsdGVyXCIsXG4gICAgXCJMVU1JTkFOQ0VcIixcbiAgICBcIkxVTUlOQU5DRV9BTFBIQVwiLFxuICAgIFwiTGFuZ3VhZ2VDb2RlXCIsXG4gICAgXCJMYXJnZXN0Q29udGVudGZ1bFBhaW50XCIsXG4gICAgXCJMYXVuY2hQYXJhbXNcIixcbiAgICBcIkxhdW5jaFF1ZXVlXCIsXG4gICAgXCJMYXVuY2hUeXBlXCIsXG4gICAgXCJMYXlvdXRTaGlmdFwiLFxuICAgIFwiTGF5b3V0U2hpZnRBdHRyaWJ1dGlvblwiLFxuICAgIFwiTGluZWFyQWNjZWxlcmF0aW9uU2Vuc29yXCIsXG4gICAgXCJMaW5rRXJyb3JcIixcbiAgICBcIkxpc3RGb3JtYXRcIixcbiAgICBcIkxvY2FsTWVkaWFTdHJlYW1cIixcbiAgICBcIkxvY2FsZVwiLFxuICAgIFwiTG9jYXRpb25cIixcbiAgICBcIkxvY2tcIixcbiAgICBcIkxvY2tNYW5hZ2VyXCIsXG4gICAgXCJNQVBfUkVBRFwiLFxuICAgIFwiTUFQX1dSSVRFXCIsXG4gICAgXCJNQVJHSU5fUlVMRVwiLFxuICAgIFwiTUFYXCIsXG4gICAgXCJNQVhfM0RfVEVYVFVSRV9TSVpFXCIsXG4gICAgXCJNQVhfQVJSQVlfVEVYVFVSRV9MQVlFUlNcIixcbiAgICBcIk1BWF9DQVBUVVJFX1ZJU0lCTEVfVEFCX0NBTExTX1BFUl9TRUNPTkRcIixcbiAgICBcIk1BWF9DTElFTlRfV0FJVF9USU1FT1VUX1dFQkdMXCIsXG4gICAgXCJNQVhfQ09MT1JfQVRUQUNITUVOVFNcIixcbiAgICBcIk1BWF9DT01CSU5FRF9GUkFHTUVOVF9VTklGT1JNX0NPTVBPTkVOVFNcIixcbiAgICBcIk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTXCIsXG4gICAgXCJNQVhfQ09NQklORURfVU5JRk9STV9CTE9DS1NcIixcbiAgICBcIk1BWF9DT01CSU5FRF9WRVJURVhfVU5JRk9STV9DT01QT05FTlRTXCIsXG4gICAgXCJNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFXCIsXG4gICAgXCJNQVhfRFJBV19CVUZGRVJTXCIsXG4gICAgXCJNQVhfRUxFTUVOVFNfSU5ESUNFU1wiLFxuICAgIFwiTUFYX0VMRU1FTlRTX1ZFUlRJQ0VTXCIsXG4gICAgXCJNQVhfRUxFTUVOVF9JTkRFWFwiLFxuICAgIFwiTUFYX0ZSQUdNRU5UX0lOUFVUX0NPTVBPTkVOVFNcIixcbiAgICBcIk1BWF9GUkFHTUVOVF9VTklGT1JNX0JMT0NLU1wiLFxuICAgIFwiTUFYX0ZSQUdNRU5UX1VOSUZPUk1fQ09NUE9ORU5UU1wiLFxuICAgIFwiTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SU1wiLFxuICAgIFwiTUFYX1BST0dSQU1fVEVYRUxfT0ZGU0VUXCIsXG4gICAgXCJNQVhfUkVOREVSQlVGRkVSX1NJWkVcIixcbiAgICBcIk1BWF9TQUZFX0lOVEVHRVJcIixcbiAgICBcIk1BWF9TQU1QTEVTXCIsXG4gICAgXCJNQVhfU0VSVkVSX1dBSVRfVElNRU9VVFwiLFxuICAgIFwiTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFNcIixcbiAgICBcIk1BWF9URVhUVVJFX0xPRF9CSUFTXCIsXG4gICAgXCJNQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFRcIixcbiAgICBcIk1BWF9URVhUVVJFX1NJWkVcIixcbiAgICBcIk1BWF9UUkFOU0ZPUk1fRkVFREJBQ0tfSU5URVJMRUFWRURfQ09NUE9ORU5UU1wiLFxuICAgIFwiTUFYX1RSQU5TRk9STV9GRUVEQkFDS19TRVBBUkFURV9BVFRSSUJTXCIsXG4gICAgXCJNQVhfVFJBTlNGT1JNX0ZFRURCQUNLX1NFUEFSQVRFX0NPTVBPTkVOVFNcIixcbiAgICBcIk1BWF9VTklGT1JNX0JMT0NLX1NJWkVcIixcbiAgICBcIk1BWF9VTklGT1JNX0JVRkZFUl9CSU5ESU5HU1wiLFxuICAgIFwiTUFYX1ZBTFVFXCIsXG4gICAgXCJNQVhfVkFSWUlOR19DT01QT05FTlRTXCIsXG4gICAgXCJNQVhfVkFSWUlOR19WRUNUT1JTXCIsXG4gICAgXCJNQVhfVkVSVEVYX0FUVFJJQlNcIixcbiAgICBcIk1BWF9WRVJURVhfT1VUUFVUX0NPTVBPTkVOVFNcIixcbiAgICBcIk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUU1wiLFxuICAgIFwiTUFYX1ZFUlRFWF9VTklGT1JNX0JMT0NLU1wiLFxuICAgIFwiTUFYX1ZFUlRFWF9VTklGT1JNX0NPTVBPTkVOVFNcIixcbiAgICBcIk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTXCIsXG4gICAgXCJNQVhfVklFV1BPUlRfRElNU1wiLFxuICAgIFwiTUVESUFfRVJSX0FCT1JURURcIixcbiAgICBcIk1FRElBX0VSUl9ERUNPREVcIixcbiAgICBcIk1FRElBX0VSUl9FTkNSWVBURURcIixcbiAgICBcIk1FRElBX0VSUl9ORVRXT1JLXCIsXG4gICAgXCJNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURURcIixcbiAgICBcIk1FRElBX0tFWUVSUl9DTElFTlRcIixcbiAgICBcIk1FRElBX0tFWUVSUl9ET01BSU5cIixcbiAgICBcIk1FRElBX0tFWUVSUl9IQVJEV0FSRUNIQU5HRVwiLFxuICAgIFwiTUVESUFfS0VZRVJSX09VVFBVVFwiLFxuICAgIFwiTUVESUFfS0VZRVJSX1NFUlZJQ0VcIixcbiAgICBcIk1FRElBX0tFWUVSUl9VTktOT1dOXCIsXG4gICAgXCJNRURJQV9SVUxFXCIsXG4gICAgXCJNRURJVU1fRkxPQVRcIixcbiAgICBcIk1FRElVTV9JTlRcIixcbiAgICBcIk1FVEFfTUFTS1wiLFxuICAgIFwiTUlESUFjY2Vzc1wiLFxuICAgIFwiTUlESUNvbm5lY3Rpb25FdmVudFwiLFxuICAgIFwiTUlESUlucHV0XCIsXG4gICAgXCJNSURJSW5wdXRNYXBcIixcbiAgICBcIk1JRElNZXNzYWdlRXZlbnRcIixcbiAgICBcIk1JRElPdXRwdXRcIixcbiAgICBcIk1JRElPdXRwdXRNYXBcIixcbiAgICBcIk1JRElQb3J0XCIsXG4gICAgXCJNSU5cIixcbiAgICBcIk1JTl9QUk9HUkFNX1RFWEVMX09GRlNFVFwiLFxuICAgIFwiTUlOX1NBRkVfSU5URUdFUlwiLFxuICAgIFwiTUlOX1ZBTFVFXCIsXG4gICAgXCJNSVJST1JFRF9SRVBFQVRcIixcbiAgICBcIk1PREVfQVNZTkNIUk9OT1VTXCIsXG4gICAgXCJNT0RFX1NZTkNIUk9OT1VTXCIsXG4gICAgXCJNT0RJRklDQVRJT05cIixcbiAgICBcIk1PVVNFRE9XTlwiLFxuICAgIFwiTU9VU0VEUkFHXCIsXG4gICAgXCJNT1VTRU1PVkVcIixcbiAgICBcIk1PVVNFT1VUXCIsXG4gICAgXCJNT1VTRU9WRVJcIixcbiAgICBcIk1PVVNFVVBcIixcbiAgICBcIk1PWl9LRVlGUkFNRVNfUlVMRVwiLFxuICAgIFwiTU9aX0tFWUZSQU1FX1JVTEVcIixcbiAgICBcIk1PWl9TT1VSQ0VfQ1VSU09SXCIsXG4gICAgXCJNT1pfU09VUkNFX0VSQVNFUlwiLFxuICAgIFwiTU9aX1NPVVJDRV9LRVlCT0FSRFwiLFxuICAgIFwiTU9aX1NPVVJDRV9NT1VTRVwiLFxuICAgIFwiTU9aX1NPVVJDRV9QRU5cIixcbiAgICBcIk1PWl9TT1VSQ0VfVE9VQ0hcIixcbiAgICBcIk1PWl9TT1VSQ0VfVU5LTk9XTlwiLFxuICAgIFwiTVNHRVNUVVJFX0ZMQUdfQkVHSU5cIixcbiAgICBcIk1TR0VTVFVSRV9GTEFHX0NBTkNFTFwiLFxuICAgIFwiTVNHRVNUVVJFX0ZMQUdfRU5EXCIsXG4gICAgXCJNU0dFU1RVUkVfRkxBR19JTkVSVElBXCIsXG4gICAgXCJNU0dFU1RVUkVfRkxBR19OT05FXCIsXG4gICAgXCJNU1BPSU5URVJfVFlQRV9NT1VTRVwiLFxuICAgIFwiTVNQT0lOVEVSX1RZUEVfUEVOXCIsXG4gICAgXCJNU1BPSU5URVJfVFlQRV9UT1VDSFwiLFxuICAgIFwiTVNfQVNZTkNfQ0FMTEJBQ0tfU1RBVFVTX0FTU0lHTl9ERUxFR0FURVwiLFxuICAgIFwiTVNfQVNZTkNfQ0FMTEJBQ0tfU1RBVFVTX0NBTkNFTFwiLFxuICAgIFwiTVNfQVNZTkNfQ0FMTEJBQ0tfU1RBVFVTX0NIT09TRUFOWVwiLFxuICAgIFwiTVNfQVNZTkNfQ0FMTEJBQ0tfU1RBVFVTX0VSUk9SXCIsXG4gICAgXCJNU19BU1lOQ19DQUxMQkFDS19TVEFUVVNfSk9JTlwiLFxuICAgIFwiTVNfQVNZTkNfT1BfU1RBVFVTX0NBTkNFTEVEXCIsXG4gICAgXCJNU19BU1lOQ19PUF9TVEFUVVNfRVJST1JcIixcbiAgICBcIk1TX0FTWU5DX09QX1NUQVRVU19TVUNDRVNTXCIsXG4gICAgXCJNU19NQU5JUFVMQVRJT05fU1RBVEVfQUNUSVZFXCIsXG4gICAgXCJNU19NQU5JUFVMQVRJT05fU1RBVEVfQ0FOQ0VMTEVEXCIsXG4gICAgXCJNU19NQU5JUFVMQVRJT05fU1RBVEVfQ09NTUlUVEVEXCIsXG4gICAgXCJNU19NQU5JUFVMQVRJT05fU1RBVEVfRFJBR0dJTkdcIixcbiAgICBcIk1TX01BTklQVUxBVElPTl9TVEFURV9JTkVSVElBXCIsXG4gICAgXCJNU19NQU5JUFVMQVRJT05fU1RBVEVfUFJFU0VMRUNUXCIsXG4gICAgXCJNU19NQU5JUFVMQVRJT05fU1RBVEVfU0VMRUNUSU5HXCIsXG4gICAgXCJNU19NQU5JUFVMQVRJT05fU1RBVEVfU1RPUFBFRFwiLFxuICAgIFwiTVNfTUVESUFfRVJSX0VOQ1JZUFRFRFwiLFxuICAgIFwiTVNfTUVESUFfS0VZRVJSX0NMSUVOVFwiLFxuICAgIFwiTVNfTUVESUFfS0VZRVJSX0RPTUFJTlwiLFxuICAgIFwiTVNfTUVESUFfS0VZRVJSX0hBUkRXQVJFQ0hBTkdFXCIsXG4gICAgXCJNU19NRURJQV9LRVlFUlJfT1VUUFVUXCIsXG4gICAgXCJNU19NRURJQV9LRVlFUlJfU0VSVklDRVwiLFxuICAgIFwiTVNfTUVESUFfS0VZRVJSX1VOS05PV05cIixcbiAgICBcIk1hcFwiLFxuICAgIFwiTWF0aFwiLFxuICAgIFwiTWF0aE1MRWxlbWVudFwiLFxuICAgIFwiTWVkaWFDYXBhYmlsaXRpZXNcIixcbiAgICBcIk1lZGlhQ2FwYWJpbGl0aWVzSW5mb1wiLFxuICAgIFwiTWVkaWFDb250cm9sbGVyXCIsXG4gICAgXCJNZWRpYURldmljZUluZm9cIixcbiAgICBcIk1lZGlhRGV2aWNlc1wiLFxuICAgIFwiTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlXCIsXG4gICAgXCJNZWRpYUVuY3J5cHRlZEV2ZW50XCIsXG4gICAgXCJNZWRpYUVycm9yXCIsXG4gICAgXCJNZWRpYUtleUVycm9yXCIsXG4gICAgXCJNZWRpYUtleUV2ZW50XCIsXG4gICAgXCJNZWRpYUtleU1lc3NhZ2VFdmVudFwiLFxuICAgIFwiTWVkaWFLZXlOZWVkZWRFdmVudFwiLFxuICAgIFwiTWVkaWFLZXlTZXNzaW9uXCIsXG4gICAgXCJNZWRpYUtleVN0YXR1c01hcFwiLFxuICAgIFwiTWVkaWFLZXlTeXN0ZW1BY2Nlc3NcIixcbiAgICBcIk1lZGlhS2V5c1wiLFxuICAgIFwiTWVkaWFMaXN0XCIsXG4gICAgXCJNZWRpYU1ldGFkYXRhXCIsXG4gICAgXCJNZWRpYVF1ZXJ5TGlzdFwiLFxuICAgIFwiTWVkaWFRdWVyeUxpc3RFdmVudFwiLFxuICAgIFwiTWVkaWFSZWNvcmRlclwiLFxuICAgIFwiTWVkaWFSZWNvcmRlckVycm9yRXZlbnRcIixcbiAgICBcIk1lZGlhU2Vzc2lvblwiLFxuICAgIFwiTWVkaWFTZXR0aW5nc1JhbmdlXCIsXG4gICAgXCJNZWRpYVNvdXJjZVwiLFxuICAgIFwiTWVkaWFTb3VyY2VIYW5kbGVcIixcbiAgICBcIk1lZGlhU3RyZWFtXCIsXG4gICAgXCJNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlXCIsXG4gICAgXCJNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZVwiLFxuICAgIFwiTWVkaWFTdHJlYW1FdmVudFwiLFxuICAgIFwiTWVkaWFTdHJlYW1UcmFja1wiLFxuICAgIFwiTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZVwiLFxuICAgIFwiTWVkaWFTdHJlYW1UcmFja0F1ZGlvU3RhdHNcIixcbiAgICBcIk1lZGlhU3RyZWFtVHJhY2tFdmVudFwiLFxuICAgIFwiTWVkaWFTdHJlYW1UcmFja0dlbmVyYXRvclwiLFxuICAgIFwiTWVkaWFTdHJlYW1UcmFja1Byb2Nlc3NvclwiLFxuICAgIFwiTWVkaWFTdHJlYW1UcmFja1ZpZGVvU3RhdHNcIixcbiAgICBcIk1lbW9yeVwiLFxuICAgIFwiTWVzc2FnZUNoYW5uZWxcIixcbiAgICBcIk1lc3NhZ2VFdmVudFwiLFxuICAgIFwiTWVzc2FnZVBvcnRcIixcbiAgICBcIk1lc3NhZ2VTZW5kZXJcIixcbiAgICBcIk1ldGhvZHNcIixcbiAgICBcIk1pbWVUeXBlXCIsXG4gICAgXCJNaW1lVHlwZUFycmF5XCIsXG4gICAgXCJNb2R1bGVcIixcbiAgICBcIk1vdXNlRXZlbnRcIixcbiAgICBcIk1vdXNlU2Nyb2xsRXZlbnRcIixcbiAgICBcIk1vekFuaW1hdGlvblwiLFxuICAgIFwiTW96QW5pbWF0aW9uRGVsYXlcIixcbiAgICBcIk1vekFuaW1hdGlvbkRpcmVjdGlvblwiLFxuICAgIFwiTW96QW5pbWF0aW9uRHVyYXRpb25cIixcbiAgICBcIk1vekFuaW1hdGlvbkZpbGxNb2RlXCIsXG4gICAgXCJNb3pBbmltYXRpb25JdGVyYXRpb25Db3VudFwiLFxuICAgIFwiTW96QW5pbWF0aW9uTmFtZVwiLFxuICAgIFwiTW96QW5pbWF0aW9uUGxheVN0YXRlXCIsXG4gICAgXCJNb3pBbmltYXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICAgIFwiTW96QXBwZWFyYW5jZVwiLFxuICAgIFwiTW96QmFja2ZhY2VWaXNpYmlsaXR5XCIsXG4gICAgXCJNb3pCaW5kaW5nXCIsXG4gICAgXCJNb3pCb3JkZXJCb3R0b21Db2xvcnNcIixcbiAgICBcIk1vekJvcmRlckVuZFwiLFxuICAgIFwiTW96Qm9yZGVyRW5kQ29sb3JcIixcbiAgICBcIk1vekJvcmRlckVuZFN0eWxlXCIsXG4gICAgXCJNb3pCb3JkZXJFbmRXaWR0aFwiLFxuICAgIFwiTW96Qm9yZGVySW1hZ2VcIixcbiAgICBcIk1vekJvcmRlckxlZnRDb2xvcnNcIixcbiAgICBcIk1vekJvcmRlclJpZ2h0Q29sb3JzXCIsXG4gICAgXCJNb3pCb3JkZXJTdGFydFwiLFxuICAgIFwiTW96Qm9yZGVyU3RhcnRDb2xvclwiLFxuICAgIFwiTW96Qm9yZGVyU3RhcnRTdHlsZVwiLFxuICAgIFwiTW96Qm9yZGVyU3RhcnRXaWR0aFwiLFxuICAgIFwiTW96Qm9yZGVyVG9wQ29sb3JzXCIsXG4gICAgXCJNb3pCb3hBbGlnblwiLFxuICAgIFwiTW96Qm94RGlyZWN0aW9uXCIsXG4gICAgXCJNb3pCb3hGbGV4XCIsXG4gICAgXCJNb3pCb3hPcmRpbmFsR3JvdXBcIixcbiAgICBcIk1vekJveE9yaWVudFwiLFxuICAgIFwiTW96Qm94UGFja1wiLFxuICAgIFwiTW96Qm94U2l6aW5nXCIsXG4gICAgXCJNb3pDU1NLZXlmcmFtZVJ1bGVcIixcbiAgICBcIk1vekNTU0tleWZyYW1lc1J1bGVcIixcbiAgICBcIk1vekNvbHVtbkNvdW50XCIsXG4gICAgXCJNb3pDb2x1bW5GaWxsXCIsXG4gICAgXCJNb3pDb2x1bW5HYXBcIixcbiAgICBcIk1vekNvbHVtblJ1bGVcIixcbiAgICBcIk1vekNvbHVtblJ1bGVDb2xvclwiLFxuICAgIFwiTW96Q29sdW1uUnVsZVN0eWxlXCIsXG4gICAgXCJNb3pDb2x1bW5SdWxlV2lkdGhcIixcbiAgICBcIk1vekNvbHVtbldpZHRoXCIsXG4gICAgXCJNb3pDb2x1bW5zXCIsXG4gICAgXCJNb3pDb250YWN0Q2hhbmdlRXZlbnRcIixcbiAgICBcIk1vekZsb2F0RWRnZVwiLFxuICAgIFwiTW96Rm9udEZlYXR1cmVTZXR0aW5nc1wiLFxuICAgIFwiTW96Rm9udExhbmd1YWdlT3ZlcnJpZGVcIixcbiAgICBcIk1vekZvcmNlQnJva2VuSW1hZ2VJY29uXCIsXG4gICAgXCJNb3pIeXBoZW5zXCIsXG4gICAgXCJNb3pJbWFnZVJlZ2lvblwiLFxuICAgIFwiTW96TWFyZ2luRW5kXCIsXG4gICAgXCJNb3pNYXJnaW5TdGFydFwiLFxuICAgIFwiTW96TW1zRXZlbnRcIixcbiAgICBcIk1vek1tc01lc3NhZ2VcIixcbiAgICBcIk1vek1vYmlsZU1lc3NhZ2VUaHJlYWRcIixcbiAgICBcIk1vek9TWEZvbnRTbW9vdGhpbmdcIixcbiAgICBcIk1vek9yaWVudFwiLFxuICAgIFwiTW96T3N4Rm9udFNtb290aGluZ1wiLFxuICAgIFwiTW96T3V0bGluZVJhZGl1c1wiLFxuICAgIFwiTW96T3V0bGluZVJhZGl1c0JvdHRvbWxlZnRcIixcbiAgICBcIk1vek91dGxpbmVSYWRpdXNCb3R0b21yaWdodFwiLFxuICAgIFwiTW96T3V0bGluZVJhZGl1c1RvcGxlZnRcIixcbiAgICBcIk1vek91dGxpbmVSYWRpdXNUb3ByaWdodFwiLFxuICAgIFwiTW96UGFkZGluZ0VuZFwiLFxuICAgIFwiTW96UGFkZGluZ1N0YXJ0XCIsXG4gICAgXCJNb3pQZXJzcGVjdGl2ZVwiLFxuICAgIFwiTW96UGVyc3BlY3RpdmVPcmlnaW5cIixcbiAgICBcIk1velBvd2VyTWFuYWdlclwiLFxuICAgIFwiTW96U2V0dGluZ3NFdmVudFwiLFxuICAgIFwiTW96U21zRXZlbnRcIixcbiAgICBcIk1velNtc01lc3NhZ2VcIixcbiAgICBcIk1velN0YWNrU2l6aW5nXCIsXG4gICAgXCJNb3pUYWJTaXplXCIsXG4gICAgXCJNb3pUZXh0QWxpZ25MYXN0XCIsXG4gICAgXCJNb3pUZXh0RGVjb3JhdGlvbkNvbG9yXCIsXG4gICAgXCJNb3pUZXh0RGVjb3JhdGlvbkxpbmVcIixcbiAgICBcIk1velRleHREZWNvcmF0aW9uU3R5bGVcIixcbiAgICBcIk1velRleHRTaXplQWRqdXN0XCIsXG4gICAgXCJNb3pUcmFuc2Zvcm1cIixcbiAgICBcIk1velRyYW5zZm9ybU9yaWdpblwiLFxuICAgIFwiTW96VHJhbnNmb3JtU3R5bGVcIixcbiAgICBcIk1velRyYW5zaXRpb25cIixcbiAgICBcIk1velRyYW5zaXRpb25EZWxheVwiLFxuICAgIFwiTW96VHJhbnNpdGlvbkR1cmF0aW9uXCIsXG4gICAgXCJNb3pUcmFuc2l0aW9uUHJvcGVydHlcIixcbiAgICBcIk1velRyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICAgIFwiTW96VXNlckZvY3VzXCIsXG4gICAgXCJNb3pVc2VySW5wdXRcIixcbiAgICBcIk1velVzZXJNb2RpZnlcIixcbiAgICBcIk1velVzZXJTZWxlY3RcIixcbiAgICBcIk1veldpbmRvd0RyYWdnaW5nXCIsXG4gICAgXCJNb3pXaW5kb3dTaGFkb3dcIixcbiAgICBcIk11dGF0aW9uRXZlbnRcIixcbiAgICBcIk11dGF0aW9uT2JzZXJ2ZXJcIixcbiAgICBcIk11dGF0aW9uUmVjb3JkXCIsXG4gICAgXCJNdXRlZEluZm9cIixcbiAgICBcIk11dGVkSW5mb1JlYXNvblwiLFxuICAgIFwiTkFNRVNQQUNFX0VSUlwiLFxuICAgIFwiTkFNRVNQQUNFX1JVTEVcIixcbiAgICBcIk5FQVJFU1RcIixcbiAgICBcIk5FQVJFU1RfTUlQTUFQX0xJTkVBUlwiLFxuICAgIFwiTkVBUkVTVF9NSVBNQVBfTkVBUkVTVFwiLFxuICAgIFwiTkVHQVRJVkVfSU5GSU5JVFlcIixcbiAgICBcIk5FVFdPUktfRU1QVFlcIixcbiAgICBcIk5FVFdPUktfRVJSXCIsXG4gICAgXCJORVRXT1JLX0lETEVcIixcbiAgICBcIk5FVFdPUktfTE9BREVEXCIsXG4gICAgXCJORVRXT1JLX0xPQURJTkdcIixcbiAgICBcIk5FVFdPUktfTk9fU09VUkNFXCIsXG4gICAgXCJORVZFUlwiLFxuICAgIFwiTkVXXCIsXG4gICAgXCJORVhUXCIsXG4gICAgXCJORVhUX05PX0RVUExJQ0FURVwiLFxuICAgIFwiTklDRVNUXCIsXG4gICAgXCJOT0RFX0FGVEVSXCIsXG4gICAgXCJOT0RFX0JFRk9SRVwiLFxuICAgIFwiTk9ERV9CRUZPUkVfQU5EX0FGVEVSXCIsXG4gICAgXCJOT0RFX0lOU0lERVwiLFxuICAgIFwiTk9ORVwiLFxuICAgIFwiTk9OX1RSQU5TSUVOVF9FUlJcIixcbiAgICBcIk5PVEFUSU9OX05PREVcIixcbiAgICBcIk5PVENIXCIsXG4gICAgXCJOT1RFUVVBTFwiLFxuICAgIFwiTk9UX0FMTE9XRURfRVJSXCIsXG4gICAgXCJOT1RfRk9VTkRfRVJSXCIsXG4gICAgXCJOT1RfUkVBREFCTEVfRVJSXCIsXG4gICAgXCJOT1RfU1VQUE9SVEVEX0VSUlwiLFxuICAgIFwiTk9fREFUQV9BTExPV0VEX0VSUlwiLFxuICAgIFwiTk9fRVJSXCIsXG4gICAgXCJOT19FUlJPUlwiLFxuICAgIFwiTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSXCIsXG4gICAgXCJOVU1CRVJfVFlQRVwiLFxuICAgIFwiTlVNX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTXCIsXG4gICAgXCJOYU5cIixcbiAgICBcIk5hbWVkTm9kZU1hcFwiLFxuICAgIFwiTmF2aWdhdGVFdmVudFwiLFxuICAgIFwiTmF2aWdhdGlvblwiLFxuICAgIFwiTmF2aWdhdGlvbkFjdGl2YXRpb25cIixcbiAgICBcIk5hdmlnYXRpb25DdXJyZW50RW50cnlDaGFuZ2VFdmVudFwiLFxuICAgIFwiTmF2aWdhdGlvbkRlc3RpbmF0aW9uXCIsXG4gICAgXCJOYXZpZ2F0aW9uSGlzdG9yeUVudHJ5XCIsXG4gICAgXCJOYXZpZ2F0aW9uUHJlbG9hZE1hbmFnZXJcIixcbiAgICBcIk5hdmlnYXRpb25UcmFuc2l0aW9uXCIsXG4gICAgXCJOYXZpZ2F0b3JcIixcbiAgICBcIk5hdmlnYXRvckxvZ2luXCIsXG4gICAgXCJOYXZpZ2F0b3JNYW5hZ2VkRGF0YVwiLFxuICAgIFwiTmF2aWdhdG9yVUFEYXRhXCIsXG4gICAgXCJOZWFyYnlMaW5rc1wiLFxuICAgIFwiTmV0d29ya0luZm9ybWF0aW9uXCIsXG4gICAgXCJOb2RlXCIsXG4gICAgXCJOb2RlRmlsdGVyXCIsXG4gICAgXCJOb2RlSXRlcmF0b3JcIixcbiAgICBcIk5vZGVMaXN0XCIsXG4gICAgXCJOb3RSZXN0b3JlZFJlYXNvbkRldGFpbHNcIixcbiAgICBcIk5vdFJlc3RvcmVkUmVhc29uc1wiLFxuICAgIFwiTm90YXRpb25cIixcbiAgICBcIk5vdGlmaWNhdGlvblwiLFxuICAgIFwiTm90aWZ5UGFpbnRFdmVudFwiLFxuICAgIFwiTnVtYmVyXCIsXG4gICAgXCJOdW1iZXJGb3JtYXRcIixcbiAgICBcIk9CSkVDVF9UWVBFXCIsXG4gICAgXCJPQlNPTEVURVwiLFxuICAgIFwiT0tcIixcbiAgICBcIk9ORVwiLFxuICAgIFwiT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBXCIsXG4gICAgXCJPTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1JcIixcbiAgICBcIk9ORV9NSU5VU19EU1RfQUxQSEFcIixcbiAgICBcIk9ORV9NSU5VU19EU1RfQ09MT1JcIixcbiAgICBcIk9ORV9NSU5VU19TUkNfQUxQSEFcIixcbiAgICBcIk9ORV9NSU5VU19TUkNfQ09MT1JcIixcbiAgICBcIk9QRU5cIixcbiAgICBcIk9QRU5FRFwiLFxuICAgIFwiT1BFTklOR1wiLFxuICAgIFwiT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEVcIixcbiAgICBcIk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFXCIsXG4gICAgXCJPVEhFUl9FUlJPUlwiLFxuICAgIFwiT1RQQ3JlZGVudGlhbFwiLFxuICAgIFwiT1VUX09GX01FTU9SWVwiLFxuICAgIFwiT2JqZWN0XCIsXG4gICAgXCJPZmZsaW5lQXVkaW9Db21wbGV0aW9uRXZlbnRcIixcbiAgICBcIk9mZmxpbmVBdWRpb0NvbnRleHRcIixcbiAgICBcIk9mZmxpbmVSZXNvdXJjZUxpc3RcIixcbiAgICBcIk9mZnNjcmVlbkNhbnZhc1wiLFxuICAgIFwiT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXCIsXG4gICAgXCJPbkNsaWNrRGF0YVwiLFxuICAgIFwiT25JbnN0YWxsZWRSZWFzb25cIixcbiAgICBcIk9uUGVyZm9ybWFuY2VXYXJuaW5nQ2F0ZWdvcnlcIixcbiAgICBcIk9uUGVyZm9ybWFuY2VXYXJuaW5nU2V2ZXJpdHlcIixcbiAgICBcIk9uUmVzdGFydFJlcXVpcmVkUmVhc29uXCIsXG4gICAgXCJPcHRpb25cIixcbiAgICBcIk9yaWVudGF0aW9uU2Vuc29yXCIsXG4gICAgXCJPc2NpbGxhdG9yTm9kZVwiLFxuICAgIFwiT3ZlcmNvbnN0cmFpbmVkRXJyb3JcIixcbiAgICBcIk92ZXJmbG93RXZlbnRcIixcbiAgICBcIlBBQ0tfQUxJR05NRU5UXCIsXG4gICAgXCJQQUNLX1JPV19MRU5HVEhcIixcbiAgICBcIlBBQ0tfU0tJUF9QSVhFTFNcIixcbiAgICBcIlBBQ0tfU0tJUF9ST1dTXCIsXG4gICAgXCJQQUdFX1JVTEVcIixcbiAgICBcIlBBUlNFX0VSUlwiLFxuICAgIFwiUEFUSFNFR19BUkNfQUJTXCIsXG4gICAgXCJQQVRIU0VHX0FSQ19SRUxcIixcbiAgICBcIlBBVEhTRUdfQ0xPU0VQQVRIXCIsXG4gICAgXCJQQVRIU0VHX0NVUlZFVE9fQ1VCSUNfQUJTXCIsXG4gICAgXCJQQVRIU0VHX0NVUlZFVE9fQ1VCSUNfUkVMXCIsXG4gICAgXCJQQVRIU0VHX0NVUlZFVE9fQ1VCSUNfU01PT1RIX0FCU1wiLFxuICAgIFwiUEFUSFNFR19DVVJWRVRPX0NVQklDX1NNT09USF9SRUxcIixcbiAgICBcIlBBVEhTRUdfQ1VSVkVUT19RVUFEUkFUSUNfQUJTXCIsXG4gICAgXCJQQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1JFTFwiLFxuICAgIFwiUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19TTU9PVEhfQUJTXCIsXG4gICAgXCJQQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1NNT09USF9SRUxcIixcbiAgICBcIlBBVEhTRUdfTElORVRPX0FCU1wiLFxuICAgIFwiUEFUSFNFR19MSU5FVE9fSE9SSVpPTlRBTF9BQlNcIixcbiAgICBcIlBBVEhTRUdfTElORVRPX0hPUklaT05UQUxfUkVMXCIsXG4gICAgXCJQQVRIU0VHX0xJTkVUT19SRUxcIixcbiAgICBcIlBBVEhTRUdfTElORVRPX1ZFUlRJQ0FMX0FCU1wiLFxuICAgIFwiUEFUSFNFR19MSU5FVE9fVkVSVElDQUxfUkVMXCIsXG4gICAgXCJQQVRIU0VHX01PVkVUT19BQlNcIixcbiAgICBcIlBBVEhTRUdfTU9WRVRPX1JFTFwiLFxuICAgIFwiUEFUSFNFR19VTktOT1dOXCIsXG4gICAgXCJQQVRIX0VYSVNUU19FUlJcIixcbiAgICBcIlBFQUtJTkdcIixcbiAgICBcIlBFUk1JU1NJT05fREVOSUVEXCIsXG4gICAgXCJQRVJTSVNURU5UXCIsXG4gICAgXCJQSVwiLFxuICAgIFwiUElYRUxfUEFDS19CVUZGRVJcIixcbiAgICBcIlBJWEVMX1BBQ0tfQlVGRkVSX0JJTkRJTkdcIixcbiAgICBcIlBJWEVMX1VOUEFDS19CVUZGRVJcIixcbiAgICBcIlBJWEVMX1VOUEFDS19CVUZGRVJfQklORElOR1wiLFxuICAgIFwiUExBWUlOR19TVEFURVwiLFxuICAgIFwiUE9JTlRTXCIsXG4gICAgXCJQT0xZR09OX09GRlNFVF9GQUNUT1JcIixcbiAgICBcIlBPTFlHT05fT0ZGU0VUX0ZJTExcIixcbiAgICBcIlBPTFlHT05fT0ZGU0VUX1VOSVRTXCIsXG4gICAgXCJQT1NJVElPTl9VTkFWQUlMQUJMRVwiLFxuICAgIFwiUE9TSVRJVkVfSU5GSU5JVFlcIixcbiAgICBcIlBSRVZcIixcbiAgICBcIlBSRVZfTk9fRFVQTElDQVRFXCIsXG4gICAgXCJQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREVcIixcbiAgICBcIlBhZ2VDaGFuZ2VFdmVudFwiLFxuICAgIFwiUGFnZVJldmVhbEV2ZW50XCIsXG4gICAgXCJQYWdlU2V0dGluZ3NcIixcbiAgICBcIlBhZ2VTd2FwRXZlbnRcIixcbiAgICBcIlBhZ2VUcmFuc2l0aW9uRXZlbnRcIixcbiAgICBcIlBhaW50UmVxdWVzdFwiLFxuICAgIFwiUGFpbnRSZXF1ZXN0TGlzdFwiLFxuICAgIFwiUGFubmVyTm9kZVwiLFxuICAgIFwiUGFzc3dvcmRDcmVkZW50aWFsXCIsXG4gICAgXCJQYXRoMkRcIixcbiAgICBcIlBheW1lbnRBZGRyZXNzXCIsXG4gICAgXCJQYXltZW50SW5zdHJ1bWVudHNcIixcbiAgICBcIlBheW1lbnRNYW5hZ2VyXCIsXG4gICAgXCJQYXltZW50TWV0aG9kQ2hhbmdlRXZlbnRcIixcbiAgICBcIlBheW1lbnRSZXF1ZXN0XCIsXG4gICAgXCJQYXltZW50UmVxdWVzdFVwZGF0ZUV2ZW50XCIsXG4gICAgXCJQYXltZW50UmVzcG9uc2VcIixcbiAgICBcIlBlcmZvcm1hbmNlXCIsXG4gICAgXCJQZXJmb3JtYW5jZUVsZW1lbnRUaW1pbmdcIixcbiAgICBcIlBlcmZvcm1hbmNlRW50cnlcIixcbiAgICBcIlBlcmZvcm1hbmNlRXZlbnRUaW1pbmdcIixcbiAgICBcIlBlcmZvcm1hbmNlTG9uZ0FuaW1hdGlvbkZyYW1lVGltaW5nXCIsXG4gICAgXCJQZXJmb3JtYW5jZUxvbmdUYXNrVGltaW5nXCIsXG4gICAgXCJQZXJmb3JtYW5jZU1hcmtcIixcbiAgICBcIlBlcmZvcm1hbmNlTWVhc3VyZVwiLFxuICAgIFwiUGVyZm9ybWFuY2VOYXZpZ2F0aW9uXCIsXG4gICAgXCJQZXJmb3JtYW5jZU5hdmlnYXRpb25UaW1pbmdcIixcbiAgICBcIlBlcmZvcm1hbmNlT2JzZXJ2ZXJcIixcbiAgICBcIlBlcmZvcm1hbmNlT2JzZXJ2ZXJFbnRyeUxpc3RcIixcbiAgICBcIlBlcmZvcm1hbmNlUGFpbnRUaW1pbmdcIixcbiAgICBcIlBlcmZvcm1hbmNlUmVzb3VyY2VUaW1pbmdcIixcbiAgICBcIlBlcmZvcm1hbmNlU2NyaXB0VGltaW5nXCIsXG4gICAgXCJQZXJmb3JtYW5jZVNlcnZlclRpbWluZ1wiLFxuICAgIFwiUGVyZm9ybWFuY2VUaW1pbmdcIixcbiAgICBcIlBlcmlvZGljU3luY01hbmFnZXJcIixcbiAgICBcIlBlcmlvZGljV2F2ZVwiLFxuICAgIFwiUGVybWlzc2lvblN0YXR1c1wiLFxuICAgIFwiUGVybWlzc2lvbnNcIixcbiAgICBcIlBob3RvQ2FwYWJpbGl0aWVzXCIsXG4gICAgXCJQaWN0dXJlSW5QaWN0dXJlRXZlbnRcIixcbiAgICBcIlBpY3R1cmVJblBpY3R1cmVXaW5kb3dcIixcbiAgICBcIlBsYXRmb3JtQXJjaFwiLFxuICAgIFwiUGxhdGZvcm1JbmZvXCIsXG4gICAgXCJQbGF0Zm9ybU5hY2xBcmNoXCIsXG4gICAgXCJQbGF0Zm9ybU9zXCIsXG4gICAgXCJQbHVnaW5cIixcbiAgICBcIlBsdWdpbkFycmF5XCIsXG4gICAgXCJQbHVyYWxSdWxlc1wiLFxuICAgIFwiUG9pbnRlckV2ZW50XCIsXG4gICAgXCJQb3BTdGF0ZUV2ZW50XCIsXG4gICAgXCJQb3B1cEJsb2NrZWRFdmVudFwiLFxuICAgIFwiUG9ydFwiLFxuICAgIFwiUHJlc2VudGF0aW9uXCIsXG4gICAgXCJQcmVzZW50YXRpb25BdmFpbGFiaWxpdHlcIixcbiAgICBcIlByZXNlbnRhdGlvbkNvbm5lY3Rpb25cIixcbiAgICBcIlByZXNlbnRhdGlvbkNvbm5lY3Rpb25BdmFpbGFibGVFdmVudFwiLFxuICAgIFwiUHJlc2VudGF0aW9uQ29ubmVjdGlvbkNsb3NlRXZlbnRcIixcbiAgICBcIlByZXNlbnRhdGlvbkNvbm5lY3Rpb25MaXN0XCIsXG4gICAgXCJQcmVzZW50YXRpb25SZWNlaXZlclwiLFxuICAgIFwiUHJlc2VudGF0aW9uUmVxdWVzdFwiLFxuICAgIFwiUHJlc3N1cmVPYnNlcnZlclwiLFxuICAgIFwiUHJlc3N1cmVSZWNvcmRcIixcbiAgICBcIlByb2Nlc3NpbmdJbnN0cnVjdGlvblwiLFxuICAgIFwiUHJvZmlsZXJcIixcbiAgICBcIlByb2dyZXNzRXZlbnRcIixcbiAgICBcIlByb21pc2VcIixcbiAgICBcIlByb21pc2VSZWplY3Rpb25FdmVudFwiLFxuICAgIFwiUHJvcGVydHlOb2RlTGlzdFwiLFxuICAgIFwiUHJvdGVjdGVkQXVkaWVuY2VcIixcbiAgICBcIlByb3h5XCIsXG4gICAgXCJQdWJsaWNLZXlDcmVkZW50aWFsXCIsXG4gICAgXCJQdXNoTWFuYWdlclwiLFxuICAgIFwiUHVzaFN1YnNjcmlwdGlvblwiLFxuICAgIFwiUHVzaFN1YnNjcmlwdGlvbk9wdGlvbnNcIixcbiAgICBcIlFcIixcbiAgICBcIlFVRVJZX1JFU09MVkVcIixcbiAgICBcIlFVRVJZX1JFU1VMVFwiLFxuICAgIFwiUVVFUllfUkVTVUxUX0FWQUlMQUJMRVwiLFxuICAgIFwiUVVPVEFfRVJSXCIsXG4gICAgXCJRVU9UQV9FWENFRURFRF9FUlJcIixcbiAgICBcIlF1ZXJ5SW50ZXJmYWNlXCIsXG4gICAgXCJSMTFGX0cxMUZfQjEwRlwiLFxuICAgIFwiUjE2RlwiLFxuICAgIFwiUjE2SVwiLFxuICAgIFwiUjE2VUlcIixcbiAgICBcIlIzMkZcIixcbiAgICBcIlIzMklcIixcbiAgICBcIlIzMlVJXCIsXG4gICAgXCJSOFwiLFxuICAgIFwiUjhJXCIsXG4gICAgXCJSOFVJXCIsXG4gICAgXCJSOF9TTk9STVwiLFxuICAgIFwiUkFTVEVSSVpFUl9ESVNDQVJEXCIsXG4gICAgXCJSRUFEXCIsXG4gICAgXCJSRUFEX0JVRkZFUlwiLFxuICAgIFwiUkVBRF9GUkFNRUJVRkZFUlwiLFxuICAgIFwiUkVBRF9GUkFNRUJVRkZFUl9CSU5ESU5HXCIsXG4gICAgXCJSRUFEX09OTFlcIixcbiAgICBcIlJFQURfT05MWV9FUlJcIixcbiAgICBcIlJFQURfV1JJVEVcIixcbiAgICBcIlJFRFwiLFxuICAgIFwiUkVEX0JJVFNcIixcbiAgICBcIlJFRF9JTlRFR0VSXCIsXG4gICAgXCJSRU1PVkFMXCIsXG4gICAgXCJSRU5ERVJCVUZGRVJcIixcbiAgICBcIlJFTkRFUkJVRkZFUl9BTFBIQV9TSVpFXCIsXG4gICAgXCJSRU5ERVJCVUZGRVJfQklORElOR1wiLFxuICAgIFwiUkVOREVSQlVGRkVSX0JMVUVfU0laRVwiLFxuICAgIFwiUkVOREVSQlVGRkVSX0RFUFRIX1NJWkVcIixcbiAgICBcIlJFTkRFUkJVRkZFUl9HUkVFTl9TSVpFXCIsXG4gICAgXCJSRU5ERVJCVUZGRVJfSEVJR0hUXCIsXG4gICAgXCJSRU5ERVJCVUZGRVJfSU5URVJOQUxfRk9STUFUXCIsXG4gICAgXCJSRU5ERVJCVUZGRVJfUkVEX1NJWkVcIixcbiAgICBcIlJFTkRFUkJVRkZFUl9TQU1QTEVTXCIsXG4gICAgXCJSRU5ERVJCVUZGRVJfU1RFTkNJTF9TSVpFXCIsXG4gICAgXCJSRU5ERVJCVUZGRVJfV0lEVEhcIixcbiAgICBcIlJFTkRFUkVSXCIsXG4gICAgXCJSRU5ERVJJTkdfSU5URU5UX0FCU09MVVRFX0NPTE9SSU1FVFJJQ1wiLFxuICAgIFwiUkVOREVSSU5HX0lOVEVOVF9BVVRPXCIsXG4gICAgXCJSRU5ERVJJTkdfSU5URU5UX1BFUkNFUFRVQUxcIixcbiAgICBcIlJFTkRFUklOR19JTlRFTlRfUkVMQVRJVkVfQ09MT1JJTUVUUklDXCIsXG4gICAgXCJSRU5ERVJJTkdfSU5URU5UX1NBVFVSQVRJT05cIixcbiAgICBcIlJFTkRFUklOR19JTlRFTlRfVU5LTk9XTlwiLFxuICAgIFwiUkVOREVSX0FUVEFDSE1FTlRcIixcbiAgICBcIlJFUEVBVFwiLFxuICAgIFwiUkVQTEFDRVwiLFxuICAgIFwiUkdcIixcbiAgICBcIlJHMTZGXCIsXG4gICAgXCJSRzE2SVwiLFxuICAgIFwiUkcxNlVJXCIsXG4gICAgXCJSRzMyRlwiLFxuICAgIFwiUkczMklcIixcbiAgICBcIlJHMzJVSVwiLFxuICAgIFwiUkc4XCIsXG4gICAgXCJSRzhJXCIsXG4gICAgXCJSRzhVSVwiLFxuICAgIFwiUkc4X1NOT1JNXCIsXG4gICAgXCJSR0JcIixcbiAgICBcIlJHQjEwX0EyXCIsXG4gICAgXCJSR0IxMF9BMlVJXCIsXG4gICAgXCJSR0IxNkZcIixcbiAgICBcIlJHQjE2SVwiLFxuICAgIFwiUkdCMTZVSVwiLFxuICAgIFwiUkdCMzJGXCIsXG4gICAgXCJSR0IzMklcIixcbiAgICBcIlJHQjMyVUlcIixcbiAgICBcIlJHQjU2NVwiLFxuICAgIFwiUkdCNV9BMVwiLFxuICAgIFwiUkdCOFwiLFxuICAgIFwiUkdCOElcIixcbiAgICBcIlJHQjhVSVwiLFxuICAgIFwiUkdCOF9TTk9STVwiLFxuICAgIFwiUkdCOV9FNVwiLFxuICAgIFwiUkdCQVwiLFxuICAgIFwiUkdCQTE2RlwiLFxuICAgIFwiUkdCQTE2SVwiLFxuICAgIFwiUkdCQTE2VUlcIixcbiAgICBcIlJHQkEzMkZcIixcbiAgICBcIlJHQkEzMklcIixcbiAgICBcIlJHQkEzMlVJXCIsXG4gICAgXCJSR0JBNFwiLFxuICAgIFwiUkdCQThcIixcbiAgICBcIlJHQkE4SVwiLFxuICAgIFwiUkdCQThVSVwiLFxuICAgIFwiUkdCQThfU05PUk1cIixcbiAgICBcIlJHQkFfSU5URUdFUlwiLFxuICAgIFwiUkdCQ29sb3JcIixcbiAgICBcIlJHQl9JTlRFR0VSXCIsXG4gICAgXCJSR19JTlRFR0VSXCIsXG4gICAgXCJST1RBVElPTl9DTE9DS1dJU0VcIixcbiAgICBcIlJPVEFUSU9OX0NPVU5URVJDTE9DS1dJU0VcIixcbiAgICBcIlJUQ0NlcnRpZmljYXRlXCIsXG4gICAgXCJSVENEVE1GU2VuZGVyXCIsXG4gICAgXCJSVENEVE1GVG9uZUNoYW5nZUV2ZW50XCIsXG4gICAgXCJSVENEYXRhQ2hhbm5lbFwiLFxuICAgIFwiUlRDRGF0YUNoYW5uZWxFdmVudFwiLFxuICAgIFwiUlRDRHRsc1RyYW5zcG9ydFwiLFxuICAgIFwiUlRDRW5jb2RlZEF1ZGlvRnJhbWVcIixcbiAgICBcIlJUQ0VuY29kZWRWaWRlb0ZyYW1lXCIsXG4gICAgXCJSVENFcnJvclwiLFxuICAgIFwiUlRDRXJyb3JFdmVudFwiLFxuICAgIFwiUlRDSWNlQ2FuZGlkYXRlXCIsXG4gICAgXCJSVENJY2VUcmFuc3BvcnRcIixcbiAgICBcIlJUQ1BlZXJDb25uZWN0aW9uXCIsXG4gICAgXCJSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnRcIixcbiAgICBcIlJUQ1BlZXJDb25uZWN0aW9uSWNlRXZlbnRcIixcbiAgICBcIlJUQ1J0cFJlY2VpdmVyXCIsXG4gICAgXCJSVENSdHBTY3JpcHRUcmFuc2Zvcm1cIixcbiAgICBcIlJUQ1J0cFNlbmRlclwiLFxuICAgIFwiUlRDUnRwVHJhbnNjZWl2ZXJcIixcbiAgICBcIlJUQ1NjdHBUcmFuc3BvcnRcIixcbiAgICBcIlJUQ1Nlc3Npb25EZXNjcmlwdGlvblwiLFxuICAgIFwiUlRDU3RhdHNSZXBvcnRcIixcbiAgICBcIlJUQ1RyYWNrRXZlbnRcIixcbiAgICBcIlJhZGlvTm9kZUxpc3RcIixcbiAgICBcIlJhbmdlXCIsXG4gICAgXCJSYW5nZUVycm9yXCIsXG4gICAgXCJSYW5nZUV4Y2VwdGlvblwiLFxuICAgIFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclwiLFxuICAgIFwiUmVhZGFibGVTdHJlYW1cIixcbiAgICBcIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclwiLFxuICAgIFwiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdFwiLFxuICAgIFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiLFxuICAgIFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyXCIsXG4gICAgXCJSZWNvcmRFcnJvckV2ZW50XCIsXG4gICAgXCJSZWN0XCIsXG4gICAgXCJSZWZlcmVuY2VFcnJvclwiLFxuICAgIFwiUmVmbGVjdFwiLFxuICAgIFwiUmVnRXhwXCIsXG4gICAgXCJSZWxhdGl2ZU9yaWVudGF0aW9uU2Vuc29yXCIsXG4gICAgXCJSZWxhdGl2ZVRpbWVGb3JtYXRcIixcbiAgICBcIlJlbW90ZVBsYXliYWNrXCIsXG4gICAgXCJSZXBvcnRcIixcbiAgICBcIlJlcG9ydEJvZHlcIixcbiAgICBcIlJlcG9ydGluZ09ic2VydmVyXCIsXG4gICAgXCJSZXF1ZXN0XCIsXG4gICAgXCJSZXF1ZXN0VXBkYXRlQ2hlY2tTdGF0dXNcIixcbiAgICBcIlJlc2l6ZU9ic2VydmVyXCIsXG4gICAgXCJSZXNpemVPYnNlcnZlckVudHJ5XCIsXG4gICAgXCJSZXNpemVPYnNlcnZlclNpemVcIixcbiAgICBcIlJlc3BvbnNlXCIsXG4gICAgXCJSdW50aW1lRXJyb3JcIixcbiAgICBcIlNBTVBMRVJfMkRcIixcbiAgICBcIlNBTVBMRVJfMkRfQVJSQVlcIixcbiAgICBcIlNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XXCIsXG4gICAgXCJTQU1QTEVSXzJEX1NIQURPV1wiLFxuICAgIFwiU0FNUExFUl8zRFwiLFxuICAgIFwiU0FNUExFUl9CSU5ESU5HXCIsXG4gICAgXCJTQU1QTEVSX0NVQkVcIixcbiAgICBcIlNBTVBMRVJfQ1VCRV9TSEFET1dcIixcbiAgICBcIlNBTVBMRVNcIixcbiAgICBcIlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRVwiLFxuICAgIFwiU0FNUExFX0JVRkZFUlNcIixcbiAgICBcIlNBTVBMRV9DT1ZFUkFHRVwiLFxuICAgIFwiU0FNUExFX0NPVkVSQUdFX0lOVkVSVFwiLFxuICAgIFwiU0FNUExFX0NPVkVSQUdFX1ZBTFVFXCIsXG4gICAgXCJTQVdUT09USFwiLFxuICAgIFwiU0NIRURVTEVEX1NUQVRFXCIsXG4gICAgXCJTQ0lTU09SX0JPWFwiLFxuICAgIFwiU0NJU1NPUl9URVNUXCIsXG4gICAgXCJTQ1JPTExfUEFHRV9ET1dOXCIsXG4gICAgXCJTQ1JPTExfUEFHRV9VUFwiLFxuICAgIFwiU0RQX0FOU1dFUlwiLFxuICAgIFwiU0RQX09GRkVSXCIsXG4gICAgXCJTRFBfUFJBTlNXRVJcIixcbiAgICBcIlNFQ1VSSVRZX0VSUlwiLFxuICAgIFwiU0VMRUNUXCIsXG4gICAgXCJTRVBBUkFURV9BVFRSSUJTXCIsXG4gICAgXCJTRVJJQUxJWkVfRVJSXCIsXG4gICAgXCJTRVZFUklUWV9FUlJPUlwiLFxuICAgIFwiU0VWRVJJVFlfRkFUQUxfRVJST1JcIixcbiAgICBcIlNFVkVSSVRZX1dBUk5JTkdcIixcbiAgICBcIlNIQURFUl9DT01QSUxFUlwiLFxuICAgIFwiU0hBREVSX1RZUEVcIixcbiAgICBcIlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTlwiLFxuICAgIFwiU0hJRlRfTUFTS1wiLFxuICAgIFwiU0hPUlRcIixcbiAgICBcIlNIT1dJTkdcIixcbiAgICBcIlNIT1dfQUxMXCIsXG4gICAgXCJTSE9XX0FUVFJJQlVURVwiLFxuICAgIFwiU0hPV19DREFUQV9TRUNUSU9OXCIsXG4gICAgXCJTSE9XX0NPTU1FTlRcIixcbiAgICBcIlNIT1dfRE9DVU1FTlRcIixcbiAgICBcIlNIT1dfRE9DVU1FTlRfRlJBR01FTlRcIixcbiAgICBcIlNIT1dfRE9DVU1FTlRfVFlQRVwiLFxuICAgIFwiU0hPV19FTEVNRU5UXCIsXG4gICAgXCJTSE9XX0VOVElUWVwiLFxuICAgIFwiU0hPV19FTlRJVFlfUkVGRVJFTkNFXCIsXG4gICAgXCJTSE9XX05PVEFUSU9OXCIsXG4gICAgXCJTSE9XX1BST0NFU1NJTkdfSU5TVFJVQ1RJT05cIixcbiAgICBcIlNIT1dfVEVYVFwiLFxuICAgIFwiU0lHTkFMRURcIixcbiAgICBcIlNJR05FRF9OT1JNQUxJWkVEXCIsXG4gICAgXCJTSU5FXCIsXG4gICAgXCJTT1VOREZJRUxEXCIsXG4gICAgXCJTUUxFeGNlcHRpb25cIixcbiAgICBcIlNRUlQxXzJcIixcbiAgICBcIlNRUlQyXCIsXG4gICAgXCJTUVVBUkVcIixcbiAgICBcIlNSQ19BTFBIQVwiLFxuICAgIFwiU1JDX0FMUEhBX1NBVFVSQVRFXCIsXG4gICAgXCJTUkNfQ09MT1JcIixcbiAgICBcIlNSR0JcIixcbiAgICBcIlNSR0I4XCIsXG4gICAgXCJTUkdCOF9BTFBIQThcIixcbiAgICBcIlNUQVJUX1RPX0VORFwiLFxuICAgIFwiU1RBUlRfVE9fU1RBUlRcIixcbiAgICBcIlNUQVRJQ19DT1BZXCIsXG4gICAgXCJTVEFUSUNfRFJBV1wiLFxuICAgIFwiU1RBVElDX1JFQURcIixcbiAgICBcIlNURU5DSUxcIixcbiAgICBcIlNURU5DSUxfQVRUQUNITUVOVFwiLFxuICAgIFwiU1RFTkNJTF9CQUNLX0ZBSUxcIixcbiAgICBcIlNURU5DSUxfQkFDS19GVU5DXCIsXG4gICAgXCJTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9GQUlMXCIsXG4gICAgXCJTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9QQVNTXCIsXG4gICAgXCJTVEVOQ0lMX0JBQ0tfUkVGXCIsXG4gICAgXCJTVEVOQ0lMX0JBQ0tfVkFMVUVfTUFTS1wiLFxuICAgIFwiU1RFTkNJTF9CQUNLX1dSSVRFTUFTS1wiLFxuICAgIFwiU1RFTkNJTF9CSVRTXCIsXG4gICAgXCJTVEVOQ0lMX0JVRkZFUl9CSVRcIixcbiAgICBcIlNURU5DSUxfQ0xFQVJfVkFMVUVcIixcbiAgICBcIlNURU5DSUxfRkFJTFwiLFxuICAgIFwiU1RFTkNJTF9GVU5DXCIsXG4gICAgXCJTVEVOQ0lMX0lOREVYXCIsXG4gICAgXCJTVEVOQ0lMX0lOREVYOFwiLFxuICAgIFwiU1RFTkNJTF9QQVNTX0RFUFRIX0ZBSUxcIixcbiAgICBcIlNURU5DSUxfUEFTU19ERVBUSF9QQVNTXCIsXG4gICAgXCJTVEVOQ0lMX1JFRlwiLFxuICAgIFwiU1RFTkNJTF9URVNUXCIsXG4gICAgXCJTVEVOQ0lMX1ZBTFVFX01BU0tcIixcbiAgICBcIlNURU5DSUxfV1JJVEVNQVNLXCIsXG4gICAgXCJTVE9SQUdFXCIsXG4gICAgXCJTVE9SQUdFX0JJTkRJTkdcIixcbiAgICBcIlNUUkVBTV9DT1BZXCIsXG4gICAgXCJTVFJFQU1fRFJBV1wiLFxuICAgIFwiU1RSRUFNX1JFQURcIixcbiAgICBcIlNUUklOR19UWVBFXCIsXG4gICAgXCJTVFlMRV9SVUxFXCIsXG4gICAgXCJTVUJQSVhFTF9CSVRTXCIsXG4gICAgXCJTVVBQT1JUU19SVUxFXCIsXG4gICAgXCJTVkdBRWxlbWVudFwiLFxuICAgIFwiU1ZHQWx0R2x5cGhEZWZFbGVtZW50XCIsXG4gICAgXCJTVkdBbHRHbHlwaEVsZW1lbnRcIixcbiAgICBcIlNWR0FsdEdseXBoSXRlbUVsZW1lbnRcIixcbiAgICBcIlNWR0FuZ2xlXCIsXG4gICAgXCJTVkdBbmltYXRlQ29sb3JFbGVtZW50XCIsXG4gICAgXCJTVkdBbmltYXRlRWxlbWVudFwiLFxuICAgIFwiU1ZHQW5pbWF0ZU1vdGlvbkVsZW1lbnRcIixcbiAgICBcIlNWR0FuaW1hdGVUcmFuc2Zvcm1FbGVtZW50XCIsXG4gICAgXCJTVkdBbmltYXRlZEFuZ2xlXCIsXG4gICAgXCJTVkdBbmltYXRlZEJvb2xlYW5cIixcbiAgICBcIlNWR0FuaW1hdGVkRW51bWVyYXRpb25cIixcbiAgICBcIlNWR0FuaW1hdGVkSW50ZWdlclwiLFxuICAgIFwiU1ZHQW5pbWF0ZWRMZW5ndGhcIixcbiAgICBcIlNWR0FuaW1hdGVkTGVuZ3RoTGlzdFwiLFxuICAgIFwiU1ZHQW5pbWF0ZWROdW1iZXJcIixcbiAgICBcIlNWR0FuaW1hdGVkTnVtYmVyTGlzdFwiLFxuICAgIFwiU1ZHQW5pbWF0ZWRQcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsXG4gICAgXCJTVkdBbmltYXRlZFJlY3RcIixcbiAgICBcIlNWR0FuaW1hdGVkU3RyaW5nXCIsXG4gICAgXCJTVkdBbmltYXRlZFRyYW5zZm9ybUxpc3RcIixcbiAgICBcIlNWR0FuaW1hdGlvbkVsZW1lbnRcIixcbiAgICBcIlNWR0NpcmNsZUVsZW1lbnRcIixcbiAgICBcIlNWR0NsaXBQYXRoRWxlbWVudFwiLFxuICAgIFwiU1ZHQ29sb3JcIixcbiAgICBcIlNWR0NvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25FbGVtZW50XCIsXG4gICAgXCJTVkdDdXJzb3JFbGVtZW50XCIsXG4gICAgXCJTVkdEZWZzRWxlbWVudFwiLFxuICAgIFwiU1ZHRGVzY0VsZW1lbnRcIixcbiAgICBcIlNWR0Rpc2NhcmRFbGVtZW50XCIsXG4gICAgXCJTVkdEb2N1bWVudFwiLFxuICAgIFwiU1ZHRWxlbWVudFwiLFxuICAgIFwiU1ZHRWxlbWVudEluc3RhbmNlXCIsXG4gICAgXCJTVkdFbGVtZW50SW5zdGFuY2VMaXN0XCIsXG4gICAgXCJTVkdFbGxpcHNlRWxlbWVudFwiLFxuICAgIFwiU1ZHRXhjZXB0aW9uXCIsXG4gICAgXCJTVkdGRUJsZW5kRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVDb2xvck1hdHJpeEVsZW1lbnRcIixcbiAgICBcIlNWR0ZFQ29tcG9uZW50VHJhbnNmZXJFbGVtZW50XCIsXG4gICAgXCJTVkdGRUNvbXBvc2l0ZUVsZW1lbnRcIixcbiAgICBcIlNWR0ZFQ29udm9sdmVNYXRyaXhFbGVtZW50XCIsXG4gICAgXCJTVkdGRURpZmZ1c2VMaWdodGluZ0VsZW1lbnRcIixcbiAgICBcIlNWR0ZFRGlzcGxhY2VtZW50TWFwRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVEaXN0YW50TGlnaHRFbGVtZW50XCIsXG4gICAgXCJTVkdGRURyb3BTaGFkb3dFbGVtZW50XCIsXG4gICAgXCJTVkdGRUZsb29kRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVGdW5jQUVsZW1lbnRcIixcbiAgICBcIlNWR0ZFRnVuY0JFbGVtZW50XCIsXG4gICAgXCJTVkdGRUZ1bmNHRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVGdW5jUkVsZW1lbnRcIixcbiAgICBcIlNWR0ZFR2F1c3NpYW5CbHVyRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVJbWFnZUVsZW1lbnRcIixcbiAgICBcIlNWR0ZFTWVyZ2VFbGVtZW50XCIsXG4gICAgXCJTVkdGRU1lcmdlTm9kZUVsZW1lbnRcIixcbiAgICBcIlNWR0ZFTW9ycGhvbG9neUVsZW1lbnRcIixcbiAgICBcIlNWR0ZFT2Zmc2V0RWxlbWVudFwiLFxuICAgIFwiU1ZHRkVQb2ludExpZ2h0RWxlbWVudFwiLFxuICAgIFwiU1ZHRkVTcGVjdWxhckxpZ2h0aW5nRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVTcG90TGlnaHRFbGVtZW50XCIsXG4gICAgXCJTVkdGRVRpbGVFbGVtZW50XCIsXG4gICAgXCJTVkdGRVR1cmJ1bGVuY2VFbGVtZW50XCIsXG4gICAgXCJTVkdGaWx0ZXJFbGVtZW50XCIsXG4gICAgXCJTVkdGb250RWxlbWVudFwiLFxuICAgIFwiU1ZHRm9udEZhY2VFbGVtZW50XCIsXG4gICAgXCJTVkdGb250RmFjZUZvcm1hdEVsZW1lbnRcIixcbiAgICBcIlNWR0ZvbnRGYWNlTmFtZUVsZW1lbnRcIixcbiAgICBcIlNWR0ZvbnRGYWNlU3JjRWxlbWVudFwiLFxuICAgIFwiU1ZHRm9udEZhY2VVcmlFbGVtZW50XCIsXG4gICAgXCJTVkdGb3JlaWduT2JqZWN0RWxlbWVudFwiLFxuICAgIFwiU1ZHR0VsZW1lbnRcIixcbiAgICBcIlNWR0dlb21ldHJ5RWxlbWVudFwiLFxuICAgIFwiU1ZHR2x5cGhFbGVtZW50XCIsXG4gICAgXCJTVkdHbHlwaFJlZkVsZW1lbnRcIixcbiAgICBcIlNWR0dyYWRpZW50RWxlbWVudFwiLFxuICAgIFwiU1ZHR3JhcGhpY3NFbGVtZW50XCIsXG4gICAgXCJTVkdIS2VybkVsZW1lbnRcIixcbiAgICBcIlNWR0ltYWdlRWxlbWVudFwiLFxuICAgIFwiU1ZHTGVuZ3RoXCIsXG4gICAgXCJTVkdMZW5ndGhMaXN0XCIsXG4gICAgXCJTVkdMaW5lRWxlbWVudFwiLFxuICAgIFwiU1ZHTGluZWFyR3JhZGllbnRFbGVtZW50XCIsXG4gICAgXCJTVkdNUGF0aEVsZW1lbnRcIixcbiAgICBcIlNWR01hcmtlckVsZW1lbnRcIixcbiAgICBcIlNWR01hc2tFbGVtZW50XCIsXG4gICAgXCJTVkdNYXRyaXhcIixcbiAgICBcIlNWR01ldGFkYXRhRWxlbWVudFwiLFxuICAgIFwiU1ZHTWlzc2luZ0dseXBoRWxlbWVudFwiLFxuICAgIFwiU1ZHTnVtYmVyXCIsXG4gICAgXCJTVkdOdW1iZXJMaXN0XCIsXG4gICAgXCJTVkdQYWludFwiLFxuICAgIFwiU1ZHUGF0aEVsZW1lbnRcIixcbiAgICBcIlNWR1BhdGhTZWdcIixcbiAgICBcIlNWR1BhdGhTZWdBcmNBYnNcIixcbiAgICBcIlNWR1BhdGhTZWdBcmNSZWxcIixcbiAgICBcIlNWR1BhdGhTZWdDbG9zZVBhdGhcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnNcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWxcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnNcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhSZWxcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzXCIsXG4gICAgXCJTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbFwiLFxuICAgIFwiU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnNcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoUmVsXCIsXG4gICAgXCJTVkdQYXRoU2VnTGluZXRvQWJzXCIsXG4gICAgXCJTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFic1wiLFxuICAgIFwiU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxSZWxcIixcbiAgICBcIlNWR1BhdGhTZWdMaW5ldG9SZWxcIixcbiAgICBcIlNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbEFic1wiLFxuICAgIFwiU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsUmVsXCIsXG4gICAgXCJTVkdQYXRoU2VnTGlzdFwiLFxuICAgIFwiU1ZHUGF0aFNlZ01vdmV0b0Fic1wiLFxuICAgIFwiU1ZHUGF0aFNlZ01vdmV0b1JlbFwiLFxuICAgIFwiU1ZHUGF0dGVybkVsZW1lbnRcIixcbiAgICBcIlNWR1BvaW50XCIsXG4gICAgXCJTVkdQb2ludExpc3RcIixcbiAgICBcIlNWR1BvbHlnb25FbGVtZW50XCIsXG4gICAgXCJTVkdQb2x5bGluZUVsZW1lbnRcIixcbiAgICBcIlNWR1ByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgICBcIlNWR1JhZGlhbEdyYWRpZW50RWxlbWVudFwiLFxuICAgIFwiU1ZHUmVjdFwiLFxuICAgIFwiU1ZHUmVjdEVsZW1lbnRcIixcbiAgICBcIlNWR1JlbmRlcmluZ0ludGVudFwiLFxuICAgIFwiU1ZHU1ZHRWxlbWVudFwiLFxuICAgIFwiU1ZHU2NyaXB0RWxlbWVudFwiLFxuICAgIFwiU1ZHU2V0RWxlbWVudFwiLFxuICAgIFwiU1ZHU3RvcEVsZW1lbnRcIixcbiAgICBcIlNWR1N0cmluZ0xpc3RcIixcbiAgICBcIlNWR1N0eWxlRWxlbWVudFwiLFxuICAgIFwiU1ZHU3dpdGNoRWxlbWVudFwiLFxuICAgIFwiU1ZHU3ltYm9sRWxlbWVudFwiLFxuICAgIFwiU1ZHVFJlZkVsZW1lbnRcIixcbiAgICBcIlNWR1RTcGFuRWxlbWVudFwiLFxuICAgIFwiU1ZHVGV4dENvbnRlbnRFbGVtZW50XCIsXG4gICAgXCJTVkdUZXh0RWxlbWVudFwiLFxuICAgIFwiU1ZHVGV4dFBhdGhFbGVtZW50XCIsXG4gICAgXCJTVkdUZXh0UG9zaXRpb25pbmdFbGVtZW50XCIsXG4gICAgXCJTVkdUaXRsZUVsZW1lbnRcIixcbiAgICBcIlNWR1RyYW5zZm9ybVwiLFxuICAgIFwiU1ZHVHJhbnNmb3JtTGlzdFwiLFxuICAgIFwiU1ZHVW5pdFR5cGVzXCIsXG4gICAgXCJTVkdVc2VFbGVtZW50XCIsXG4gICAgXCJTVkdWS2VybkVsZW1lbnRcIixcbiAgICBcIlNWR1ZpZXdFbGVtZW50XCIsXG4gICAgXCJTVkdWaWV3U3BlY1wiLFxuICAgIFwiU1ZHWm9vbUFuZFBhblwiLFxuICAgIFwiU1ZHWm9vbUV2ZW50XCIsXG4gICAgXCJTVkdfQU5HTEVUWVBFX0RFR1wiLFxuICAgIFwiU1ZHX0FOR0xFVFlQRV9HUkFEXCIsXG4gICAgXCJTVkdfQU5HTEVUWVBFX1JBRFwiLFxuICAgIFwiU1ZHX0FOR0xFVFlQRV9VTktOT1dOXCIsXG4gICAgXCJTVkdfQU5HTEVUWVBFX1VOU1BFQ0lGSUVEXCIsXG4gICAgXCJTVkdfQ0hBTk5FTF9BXCIsXG4gICAgXCJTVkdfQ0hBTk5FTF9CXCIsXG4gICAgXCJTVkdfQ0hBTk5FTF9HXCIsXG4gICAgXCJTVkdfQ0hBTk5FTF9SXCIsXG4gICAgXCJTVkdfQ0hBTk5FTF9VTktOT1dOXCIsXG4gICAgXCJTVkdfQ09MT1JUWVBFX0NVUlJFTlRDT0xPUlwiLFxuICAgIFwiU1ZHX0NPTE9SVFlQRV9SR0JDT0xPUlwiLFxuICAgIFwiU1ZHX0NPTE9SVFlQRV9SR0JDT0xPUl9JQ0NDT0xPUlwiLFxuICAgIFwiU1ZHX0NPTE9SVFlQRV9VTktOT1dOXCIsXG4gICAgXCJTVkdfRURHRU1PREVfRFVQTElDQVRFXCIsXG4gICAgXCJTVkdfRURHRU1PREVfTk9ORVwiLFxuICAgIFwiU1ZHX0VER0VNT0RFX1VOS05PV05cIixcbiAgICBcIlNWR19FREdFTU9ERV9XUkFQXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX0NPTE9SXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX0NPTE9SX0JVUk5cIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfQ09MT1JfRE9ER0VcIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfREFSS0VOXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX0RJRkZFUkVOQ0VcIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfRVhDTFVTSU9OXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX0hBUkRfTElHSFRcIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfSFVFXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX0xJR0hURU5cIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfTFVNSU5PU0lUWVwiLFxuICAgIFwiU1ZHX0ZFQkxFTkRfTU9ERV9NVUxUSVBMWVwiLFxuICAgIFwiU1ZHX0ZFQkxFTkRfTU9ERV9OT1JNQUxcIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfT1ZFUkxBWVwiLFxuICAgIFwiU1ZHX0ZFQkxFTkRfTU9ERV9TQVRVUkFUSU9OXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX1NDUkVFTlwiLFxuICAgIFwiU1ZHX0ZFQkxFTkRfTU9ERV9TT0ZUX0xJR0hUXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX1VOS05PV05cIixcbiAgICBcIlNWR19GRUNPTE9STUFUUklYX1RZUEVfSFVFUk9UQVRFXCIsXG4gICAgXCJTVkdfRkVDT0xPUk1BVFJJWF9UWVBFX0xVTUlOQU5DRVRPQUxQSEFcIixcbiAgICBcIlNWR19GRUNPTE9STUFUUklYX1RZUEVfTUFUUklYXCIsXG4gICAgXCJTVkdfRkVDT0xPUk1BVFJJWF9UWVBFX1NBVFVSQVRFXCIsXG4gICAgXCJTVkdfRkVDT0xPUk1BVFJJWF9UWVBFX1VOS05PV05cIixcbiAgICBcIlNWR19GRUNPTVBPTkVOVFRSQU5TRkVSX1RZUEVfRElTQ1JFVEVcIixcbiAgICBcIlNWR19GRUNPTVBPTkVOVFRSQU5TRkVSX1RZUEVfR0FNTUFcIixcbiAgICBcIlNWR19GRUNPTVBPTkVOVFRSQU5TRkVSX1RZUEVfSURFTlRJVFlcIixcbiAgICBcIlNWR19GRUNPTVBPTkVOVFRSQU5TRkVSX1RZUEVfTElORUFSXCIsXG4gICAgXCJTVkdfRkVDT01QT05FTlRUUkFOU0ZFUl9UWVBFX1RBQkxFXCIsXG4gICAgXCJTVkdfRkVDT01QT05FTlRUUkFOU0ZFUl9UWVBFX1VOS05PV05cIixcbiAgICBcIlNWR19GRUNPTVBPU0lURV9PUEVSQVRPUl9BUklUSE1FVElDXCIsXG4gICAgXCJTVkdfRkVDT01QT1NJVEVfT1BFUkFUT1JfQVRPUFwiLFxuICAgIFwiU1ZHX0ZFQ09NUE9TSVRFX09QRVJBVE9SX0lOXCIsXG4gICAgXCJTVkdfRkVDT01QT1NJVEVfT1BFUkFUT1JfTElHSFRFUlwiLFxuICAgIFwiU1ZHX0ZFQ09NUE9TSVRFX09QRVJBVE9SX09VVFwiLFxuICAgIFwiU1ZHX0ZFQ09NUE9TSVRFX09QRVJBVE9SX09WRVJcIixcbiAgICBcIlNWR19GRUNPTVBPU0lURV9PUEVSQVRPUl9VTktOT1dOXCIsXG4gICAgXCJTVkdfRkVDT01QT1NJVEVfT1BFUkFUT1JfWE9SXCIsXG4gICAgXCJTVkdfSU5WQUxJRF9WQUxVRV9FUlJcIixcbiAgICBcIlNWR19MRU5HVEhUWVBFX0NNXCIsXG4gICAgXCJTVkdfTEVOR1RIVFlQRV9FTVNcIixcbiAgICBcIlNWR19MRU5HVEhUWVBFX0VYU1wiLFxuICAgIFwiU1ZHX0xFTkdUSFRZUEVfSU5cIixcbiAgICBcIlNWR19MRU5HVEhUWVBFX01NXCIsXG4gICAgXCJTVkdfTEVOR1RIVFlQRV9OVU1CRVJcIixcbiAgICBcIlNWR19MRU5HVEhUWVBFX1BDXCIsXG4gICAgXCJTVkdfTEVOR1RIVFlQRV9QRVJDRU5UQUdFXCIsXG4gICAgXCJTVkdfTEVOR1RIVFlQRV9QVFwiLFxuICAgIFwiU1ZHX0xFTkdUSFRZUEVfUFhcIixcbiAgICBcIlNWR19MRU5HVEhUWVBFX1VOS05PV05cIixcbiAgICBcIlNWR19NQVJLRVJVTklUU19TVFJPS0VXSURUSFwiLFxuICAgIFwiU1ZHX01BUktFUlVOSVRTX1VOS05PV05cIixcbiAgICBcIlNWR19NQVJLRVJVTklUU19VU0VSU1BBQ0VPTlVTRVwiLFxuICAgIFwiU1ZHX01BUktFUl9PUklFTlRfQU5HTEVcIixcbiAgICBcIlNWR19NQVJLRVJfT1JJRU5UX0FVVE9cIixcbiAgICBcIlNWR19NQVJLRVJfT1JJRU5UX0FVVE9fU1RBUlRfUkVWRVJTRVwiLFxuICAgIFwiU1ZHX01BUktFUl9PUklFTlRfVU5LTk9XTlwiLFxuICAgIFwiU1ZHX01BU0tUWVBFX0FMUEhBXCIsXG4gICAgXCJTVkdfTUFTS1RZUEVfTFVNSU5BTkNFXCIsXG4gICAgXCJTVkdfTUFUUklYX05PVF9JTlZFUlRBQkxFXCIsXG4gICAgXCJTVkdfTUVFVE9SU0xJQ0VfTUVFVFwiLFxuICAgIFwiU1ZHX01FRVRPUlNMSUNFX1NMSUNFXCIsXG4gICAgXCJTVkdfTUVFVE9SU0xJQ0VfVU5LTk9XTlwiLFxuICAgIFwiU1ZHX01PUlBIT0xPR1lfT1BFUkFUT1JfRElMQVRFXCIsXG4gICAgXCJTVkdfTU9SUEhPTE9HWV9PUEVSQVRPUl9FUk9ERVwiLFxuICAgIFwiU1ZHX01PUlBIT0xPR1lfT1BFUkFUT1JfVU5LTk9XTlwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9DVVJSRU5UQ09MT1JcIixcbiAgICBcIlNWR19QQUlOVFRZUEVfTk9ORVwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9SR0JDT0xPUlwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9SR0JDT0xPUl9JQ0NDT0xPUlwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9VTktOT1dOXCIsXG4gICAgXCJTVkdfUEFJTlRUWVBFX1VSSVwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9VUklfQ1VSUkVOVENPTE9SXCIsXG4gICAgXCJTVkdfUEFJTlRUWVBFX1VSSV9OT05FXCIsXG4gICAgXCJTVkdfUEFJTlRUWVBFX1VSSV9SR0JDT0xPUlwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9VUklfUkdCQ09MT1JfSUNDQ09MT1JcIixcbiAgICBcIlNWR19QUkVTRVJWRUFTUEVDVFJBVElPX05PTkVcIixcbiAgICBcIlNWR19QUkVTRVJWRUFTUEVDVFJBVElPX1VOS05PV05cIixcbiAgICBcIlNWR19QUkVTRVJWRUFTUEVDVFJBVElPX1hNQVhZTUFYXCIsXG4gICAgXCJTVkdfUFJFU0VSVkVBU1BFQ1RSQVRJT19YTUFYWU1JRFwiLFxuICAgIFwiU1ZHX1BSRVNFUlZFQVNQRUNUUkFUSU9fWE1BWFlNSU5cIixcbiAgICBcIlNWR19QUkVTRVJWRUFTUEVDVFJBVElPX1hNSURZTUFYXCIsXG4gICAgXCJTVkdfUFJFU0VSVkVBU1BFQ1RSQVRJT19YTUlEWU1JRFwiLFxuICAgIFwiU1ZHX1BSRVNFUlZFQVNQRUNUUkFUSU9fWE1JRFlNSU5cIixcbiAgICBcIlNWR19QUkVTRVJWRUFTUEVDVFJBVElPX1hNSU5ZTUFYXCIsXG4gICAgXCJTVkdfUFJFU0VSVkVBU1BFQ1RSQVRJT19YTUlOWU1JRFwiLFxuICAgIFwiU1ZHX1BSRVNFUlZFQVNQRUNUUkFUSU9fWE1JTllNSU5cIixcbiAgICBcIlNWR19TUFJFQURNRVRIT0RfUEFEXCIsXG4gICAgXCJTVkdfU1BSRUFETUVUSE9EX1JFRkxFQ1RcIixcbiAgICBcIlNWR19TUFJFQURNRVRIT0RfUkVQRUFUXCIsXG4gICAgXCJTVkdfU1BSRUFETUVUSE9EX1VOS05PV05cIixcbiAgICBcIlNWR19TVElUQ0hUWVBFX05PU1RJVENIXCIsXG4gICAgXCJTVkdfU1RJVENIVFlQRV9TVElUQ0hcIixcbiAgICBcIlNWR19TVElUQ0hUWVBFX1VOS05PV05cIixcbiAgICBcIlNWR19UUkFOU0ZPUk1fTUFUUklYXCIsXG4gICAgXCJTVkdfVFJBTlNGT1JNX1JPVEFURVwiLFxuICAgIFwiU1ZHX1RSQU5TRk9STV9TQ0FMRVwiLFxuICAgIFwiU1ZHX1RSQU5TRk9STV9TS0VXWFwiLFxuICAgIFwiU1ZHX1RSQU5TRk9STV9TS0VXWVwiLFxuICAgIFwiU1ZHX1RSQU5TRk9STV9UUkFOU0xBVEVcIixcbiAgICBcIlNWR19UUkFOU0ZPUk1fVU5LTk9XTlwiLFxuICAgIFwiU1ZHX1RVUkJVTEVOQ0VfVFlQRV9GUkFDVEFMTk9JU0VcIixcbiAgICBcIlNWR19UVVJCVUxFTkNFX1RZUEVfVFVSQlVMRU5DRVwiLFxuICAgIFwiU1ZHX1RVUkJVTEVOQ0VfVFlQRV9VTktOT1dOXCIsXG4gICAgXCJTVkdfVU5JVF9UWVBFX09CSkVDVEJPVU5ESU5HQk9YXCIsXG4gICAgXCJTVkdfVU5JVF9UWVBFX1VOS05PV05cIixcbiAgICBcIlNWR19VTklUX1RZUEVfVVNFUlNQQUNFT05VU0VcIixcbiAgICBcIlNWR19XUk9OR19UWVBFX0VSUlwiLFxuICAgIFwiU1ZHX1pPT01BTkRQQU5fRElTQUJMRVwiLFxuICAgIFwiU1ZHX1pPT01BTkRQQU5fTUFHTklGWVwiLFxuICAgIFwiU1ZHX1pPT01BTkRQQU5fVU5LTk9XTlwiLFxuICAgIFwiU1lOQ19DT05ESVRJT05cIixcbiAgICBcIlNZTkNfRkVOQ0VcIixcbiAgICBcIlNZTkNfRkxBR1NcIixcbiAgICBcIlNZTkNfRkxVU0hfQ09NTUFORFNfQklUXCIsXG4gICAgXCJTWU5DX0dQVV9DT01NQU5EU19DT01QTEVURVwiLFxuICAgIFwiU1lOQ19TVEFUVVNcIixcbiAgICBcIlNZTlRBWF9FUlJcIixcbiAgICBcIlNhdmVkUGFnZXNcIixcbiAgICBcIlNjaGVkdWxlclwiLFxuICAgIFwiU2NoZWR1bGluZ1wiLFxuICAgIFwiU2NyZWVuXCIsXG4gICAgXCJTY3JlZW5EZXRhaWxlZFwiLFxuICAgIFwiU2NyZWVuRGV0YWlsc1wiLFxuICAgIFwiU2NyZWVuT3JpZW50YXRpb25cIixcbiAgICBcIlNjcmlwdFwiLFxuICAgIFwiU2NyaXB0UHJvY2Vzc29yTm9kZVwiLFxuICAgIFwiU2Nyb2xsQXJlYUV2ZW50XCIsXG4gICAgXCJTY3JvbGxUaW1lbGluZVwiLFxuICAgIFwiU2VjdXJpdHlQb2xpY3lWaW9sYXRpb25FdmVudFwiLFxuICAgIFwiU2VnbWVudGVyXCIsXG4gICAgXCJTZWxlY3Rpb25cIixcbiAgICBcIlNlbnNvclwiLFxuICAgIFwiU2Vuc29yRXJyb3JFdmVudFwiLFxuICAgIFwiU2VyaWFsXCIsXG4gICAgXCJTZXJpYWxQb3J0XCIsXG4gICAgXCJTZXJ2aWNlV29ya2VyXCIsXG4gICAgXCJTZXJ2aWNlV29ya2VyQ29udGFpbmVyXCIsXG4gICAgXCJTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uXCIsXG4gICAgXCJTZXNzaW9uRGVzY3JpcHRpb25cIixcbiAgICBcIlNldFwiLFxuICAgIFwiU2hhZG93Um9vdFwiLFxuICAgIFwiU2hhcmVkQXJyYXlCdWZmZXJcIixcbiAgICBcIlNoYXJlZFN0b3JhZ2VcIixcbiAgICBcIlNoYXJlZFN0b3JhZ2VXb3JrbGV0XCIsXG4gICAgXCJTaGFyZWRXb3JrZXJcIixcbiAgICBcIlNoYXJpbmdTdGF0ZVwiLFxuICAgIFwiU2ltcGxlR2VzdHVyZUV2ZW50XCIsXG4gICAgXCJTbmFwRXZlbnRcIixcbiAgICBcIlNvdXJjZUJ1ZmZlclwiLFxuICAgIFwiU291cmNlQnVmZmVyTGlzdFwiLFxuICAgIFwiU3BlZWNoU3ludGhlc2lzXCIsXG4gICAgXCJTcGVlY2hTeW50aGVzaXNFcnJvckV2ZW50XCIsXG4gICAgXCJTcGVlY2hTeW50aGVzaXNFdmVudFwiLFxuICAgIFwiU3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlXCIsXG4gICAgXCJTcGVlY2hTeW50aGVzaXNWb2ljZVwiLFxuICAgIFwiU3RhdGljUmFuZ2VcIixcbiAgICBcIlN0ZXJlb1Bhbm5lck5vZGVcIixcbiAgICBcIlN0b3BJdGVyYXRpb25cIixcbiAgICBcIlN0b3JhZ2VcIixcbiAgICBcIlN0b3JhZ2VCdWNrZXRcIixcbiAgICBcIlN0b3JhZ2VCdWNrZXRNYW5hZ2VyXCIsXG4gICAgXCJTdG9yYWdlRXZlbnRcIixcbiAgICBcIlN0b3JhZ2VNYW5hZ2VyXCIsXG4gICAgXCJTdHJpbmdcIixcbiAgICBcIlN0cnVjdFR5cGVcIixcbiAgICBcIlN0eWxlUHJvcGVydHlNYXBcIixcbiAgICBcIlN0eWxlUHJvcGVydHlNYXBSZWFkT25seVwiLFxuICAgIFwiU3R5bGVTaGVldFwiLFxuICAgIFwiU3R5bGVTaGVldExpc3RcIixcbiAgICBcIlN1Ym1pdEV2ZW50XCIsXG4gICAgXCJTdWJ0bGVDcnlwdG9cIixcbiAgICBcIlN5bWJvbFwiLFxuICAgIFwiU3luY01hbmFnZXJcIixcbiAgICBcIlN5bnRheEVycm9yXCIsXG4gICAgXCJUQUJfSURfTk9ORVwiLFxuICAgIFwiVEFCX0lOREVYX05PTkVcIixcbiAgICBcIlRFTVBPUkFSWVwiLFxuICAgIFwiVEVYVFBBVEhfTUVUSE9EVFlQRV9BTElHTlwiLFxuICAgIFwiVEVYVFBBVEhfTUVUSE9EVFlQRV9TVFJFVENIXCIsXG4gICAgXCJURVhUUEFUSF9NRVRIT0RUWVBFX1VOS05PV05cIixcbiAgICBcIlRFWFRQQVRIX1NQQUNJTkdUWVBFX0FVVE9cIixcbiAgICBcIlRFWFRQQVRIX1NQQUNJTkdUWVBFX0VYQUNUXCIsXG4gICAgXCJURVhUUEFUSF9TUEFDSU5HVFlQRV9VTktOT1dOXCIsXG4gICAgXCJURVhUVVJFXCIsXG4gICAgXCJURVhUVVJFMFwiLFxuICAgIFwiVEVYVFVSRTFcIixcbiAgICBcIlRFWFRVUkUxMFwiLFxuICAgIFwiVEVYVFVSRTExXCIsXG4gICAgXCJURVhUVVJFMTJcIixcbiAgICBcIlRFWFRVUkUxM1wiLFxuICAgIFwiVEVYVFVSRTE0XCIsXG4gICAgXCJURVhUVVJFMTVcIixcbiAgICBcIlRFWFRVUkUxNlwiLFxuICAgIFwiVEVYVFVSRTE3XCIsXG4gICAgXCJURVhUVVJFMThcIixcbiAgICBcIlRFWFRVUkUxOVwiLFxuICAgIFwiVEVYVFVSRTJcIixcbiAgICBcIlRFWFRVUkUyMFwiLFxuICAgIFwiVEVYVFVSRTIxXCIsXG4gICAgXCJURVhUVVJFMjJcIixcbiAgICBcIlRFWFRVUkUyM1wiLFxuICAgIFwiVEVYVFVSRTI0XCIsXG4gICAgXCJURVhUVVJFMjVcIixcbiAgICBcIlRFWFRVUkUyNlwiLFxuICAgIFwiVEVYVFVSRTI3XCIsXG4gICAgXCJURVhUVVJFMjhcIixcbiAgICBcIlRFWFRVUkUyOVwiLFxuICAgIFwiVEVYVFVSRTNcIixcbiAgICBcIlRFWFRVUkUzMFwiLFxuICAgIFwiVEVYVFVSRTMxXCIsXG4gICAgXCJURVhUVVJFNFwiLFxuICAgIFwiVEVYVFVSRTVcIixcbiAgICBcIlRFWFRVUkU2XCIsXG4gICAgXCJURVhUVVJFN1wiLFxuICAgIFwiVEVYVFVSRThcIixcbiAgICBcIlRFWFRVUkU5XCIsXG4gICAgXCJURVhUVVJFXzJEXCIsXG4gICAgXCJURVhUVVJFXzJEX0FSUkFZXCIsXG4gICAgXCJURVhUVVJFXzNEXCIsXG4gICAgXCJURVhUVVJFX0JBU0VfTEVWRUxcIixcbiAgICBcIlRFWFRVUkVfQklORElOR1wiLFxuICAgIFwiVEVYVFVSRV9CSU5ESU5HXzJEXCIsXG4gICAgXCJURVhUVVJFX0JJTkRJTkdfMkRfQVJSQVlcIixcbiAgICBcIlRFWFRVUkVfQklORElOR18zRFwiLFxuICAgIFwiVEVYVFVSRV9CSU5ESU5HX0NVQkVfTUFQXCIsXG4gICAgXCJURVhUVVJFX0NPTVBBUkVfRlVOQ1wiLFxuICAgIFwiVEVYVFVSRV9DT01QQVJFX01PREVcIixcbiAgICBcIlRFWFRVUkVfQ1VCRV9NQVBcIixcbiAgICBcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWFwiLFxuICAgIFwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZXCIsXG4gICAgXCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pcIixcbiAgICBcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWFwiLFxuICAgIFwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZXCIsXG4gICAgXCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1pcIixcbiAgICBcIlRFWFRVUkVfSU1NVVRBQkxFX0ZPUk1BVFwiLFxuICAgIFwiVEVYVFVSRV9JTU1VVEFCTEVfTEVWRUxTXCIsXG4gICAgXCJURVhUVVJFX01BR19GSUxURVJcIixcbiAgICBcIlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUXCIsXG4gICAgXCJURVhUVVJFX01BWF9MRVZFTFwiLFxuICAgIFwiVEVYVFVSRV9NQVhfTE9EXCIsXG4gICAgXCJURVhUVVJFX01JTl9GSUxURVJcIixcbiAgICBcIlRFWFRVUkVfTUlOX0xPRFwiLFxuICAgIFwiVEVYVFVSRV9XUkFQX1JcIixcbiAgICBcIlRFWFRVUkVfV1JBUF9TXCIsXG4gICAgXCJURVhUVVJFX1dSQVBfVFwiLFxuICAgIFwiVEVYVF9OT0RFXCIsXG4gICAgXCJUSU1FT1VUXCIsXG4gICAgXCJUSU1FT1VUX0VSUlwiLFxuICAgIFwiVElNRU9VVF9FWFBJUkVEXCIsXG4gICAgXCJUSU1FT1VUX0lHTk9SRURcIixcbiAgICBcIlRPT19MQVJHRV9FUlJcIixcbiAgICBcIlRSQU5TQUNUSU9OX0lOQUNUSVZFX0VSUlwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLXCIsXG4gICAgXCJUUkFOU0ZPUk1fRkVFREJBQ0tfQUNUSVZFXCIsXG4gICAgXCJUUkFOU0ZPUk1fRkVFREJBQ0tfQklORElOR1wiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUlwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUl9CSU5ESU5HXCIsXG4gICAgXCJUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSX01PREVcIixcbiAgICBcIlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfU0laRVwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUl9TVEFSVFwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX1BBVVNFRFwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX1BSSU1JVElWRVNfV1JJVFRFTlwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX1ZBUllJTkdTXCIsXG4gICAgXCJUUklBTkdMRVwiLFxuICAgIFwiVFJJQU5HTEVTXCIsXG4gICAgXCJUUklBTkdMRV9GQU5cIixcbiAgICBcIlRSSUFOR0xFX1NUUklQXCIsXG4gICAgXCJUWVBFX0JBQ0tfRk9SV0FSRFwiLFxuICAgIFwiVFlQRV9FUlJcIixcbiAgICBcIlRZUEVfTUlTTUFUQ0hfRVJSXCIsXG4gICAgXCJUWVBFX05BVklHQVRFXCIsXG4gICAgXCJUWVBFX1JFTE9BRFwiLFxuICAgIFwiVFlQRV9SRVNFUlZFRFwiLFxuICAgIFwiVGFiXCIsXG4gICAgXCJUYWJTdGF0dXNcIixcbiAgICBcIlRhYmxlXCIsXG4gICAgXCJUYWdcIixcbiAgICBcIlRhc2tBdHRyaWJ1dGlvblRpbWluZ1wiLFxuICAgIFwiVGFza0NvbnRyb2xsZXJcIixcbiAgICBcIlRhc2tQcmlvcml0eUNoYW5nZUV2ZW50XCIsXG4gICAgXCJUYXNrU2lnbmFsXCIsXG4gICAgXCJUZXh0XCIsXG4gICAgXCJUZXh0RGVjb2RlclwiLFxuICAgIFwiVGV4dERlY29kZXJTdHJlYW1cIixcbiAgICBcIlRleHRFbmNvZGVyXCIsXG4gICAgXCJUZXh0RW5jb2RlclN0cmVhbVwiLFxuICAgIFwiVGV4dEV2ZW50XCIsXG4gICAgXCJUZXh0Rm9ybWF0XCIsXG4gICAgXCJUZXh0Rm9ybWF0VXBkYXRlRXZlbnRcIixcbiAgICBcIlRleHRNZXRyaWNzXCIsXG4gICAgXCJUZXh0VHJhY2tcIixcbiAgICBcIlRleHRUcmFja0N1ZVwiLFxuICAgIFwiVGV4dFRyYWNrQ3VlTGlzdFwiLFxuICAgIFwiVGV4dFRyYWNrTGlzdFwiLFxuICAgIFwiVGV4dFVwZGF0ZUV2ZW50XCIsXG4gICAgXCJUaW1lRXZlbnRcIixcbiAgICBcIlRpbWVSYW5nZXNcIixcbiAgICBcIlRvZ2dsZUV2ZW50XCIsXG4gICAgXCJUb3VjaFwiLFxuICAgIFwiVG91Y2hFdmVudFwiLFxuICAgIFwiVG91Y2hMaXN0XCIsXG4gICAgXCJUcmFja0V2ZW50XCIsXG4gICAgXCJUcmFuc2Zvcm1TdHJlYW1cIixcbiAgICBcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIsXG4gICAgXCJUcmFuc2l0aW9uRXZlbnRcIixcbiAgICBcIlRyZWVXYWxrZXJcIixcbiAgICBcIlRydXN0ZWRIVE1MXCIsXG4gICAgXCJUcnVzdGVkU2NyaXB0XCIsXG4gICAgXCJUcnVzdGVkU2NyaXB0VVJMXCIsXG4gICAgXCJUcnVzdGVkVHlwZVBvbGljeVwiLFxuICAgIFwiVHJ1c3RlZFR5cGVQb2xpY3lGYWN0b3J5XCIsXG4gICAgXCJUeXBlRXJyb3JcIixcbiAgICBcIlR5cGVkT2JqZWN0XCIsXG4gICAgXCJVMkZcIixcbiAgICBcIlVJRXZlbnRcIixcbiAgICBcIlVOQ0FDSEVEXCIsXG4gICAgXCJVTklGT1JNXCIsXG4gICAgXCJVTklGT1JNX0FSUkFZX1NUUklERVwiLFxuICAgIFwiVU5JRk9STV9CTE9DS19BQ1RJVkVfVU5JRk9STVNcIixcbiAgICBcIlVOSUZPUk1fQkxPQ0tfQUNUSVZFX1VOSUZPUk1fSU5ESUNFU1wiLFxuICAgIFwiVU5JRk9STV9CTE9DS19CSU5ESU5HXCIsXG4gICAgXCJVTklGT1JNX0JMT0NLX0RBVEFfU0laRVwiLFxuICAgIFwiVU5JRk9STV9CTE9DS19JTkRFWFwiLFxuICAgIFwiVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX0ZSQUdNRU5UX1NIQURFUlwiLFxuICAgIFwiVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX1ZFUlRFWF9TSEFERVJcIixcbiAgICBcIlVOSUZPUk1fQlVGRkVSXCIsXG4gICAgXCJVTklGT1JNX0JVRkZFUl9CSU5ESU5HXCIsXG4gICAgXCJVTklGT1JNX0JVRkZFUl9PRkZTRVRfQUxJR05NRU5UXCIsXG4gICAgXCJVTklGT1JNX0JVRkZFUl9TSVpFXCIsXG4gICAgXCJVTklGT1JNX0JVRkZFUl9TVEFSVFwiLFxuICAgIFwiVU5JRk9STV9JU19ST1dfTUFKT1JcIixcbiAgICBcIlVOSUZPUk1fTUFUUklYX1NUUklERVwiLFxuICAgIFwiVU5JRk9STV9PRkZTRVRcIixcbiAgICBcIlVOSUZPUk1fU0laRVwiLFxuICAgIFwiVU5JRk9STV9UWVBFXCIsXG4gICAgXCJVTktOT1dOX0VSUlwiLFxuICAgIFwiVU5LTk9XTl9SVUxFXCIsXG4gICAgXCJVTk1BU0tFRF9SRU5ERVJFUl9XRUJHTFwiLFxuICAgIFwiVU5NQVNLRURfVkVORE9SX1dFQkdMXCIsXG4gICAgXCJVTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFXCIsXG4gICAgXCJVTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFXCIsXG4gICAgXCJVTlBBQ0tfQUxJR05NRU5UXCIsXG4gICAgXCJVTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMXCIsXG4gICAgXCJVTlBBQ0tfRkxJUF9ZX1dFQkdMXCIsXG4gICAgXCJVTlBBQ0tfSU1BR0VfSEVJR0hUXCIsXG4gICAgXCJVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0xcIixcbiAgICBcIlVOUEFDS19ST1dfTEVOR1RIXCIsXG4gICAgXCJVTlBBQ0tfU0tJUF9JTUFHRVNcIixcbiAgICBcIlVOUEFDS19TS0lQX1BJWEVMU1wiLFxuICAgIFwiVU5QQUNLX1NLSVBfUk9XU1wiLFxuICAgIFwiVU5TQ0hFRFVMRURfU1RBVEVcIixcbiAgICBcIlVOU0VOVFwiLFxuICAgIFwiVU5TSUdOQUxFRFwiLFxuICAgIFwiVU5TSUdORURfQllURVwiLFxuICAgIFwiVU5TSUdORURfSU5UXCIsXG4gICAgXCJVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWXCIsXG4gICAgXCJVTlNJR05FRF9JTlRfMjRfOFwiLFxuICAgIFwiVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWXCIsXG4gICAgXCJVTlNJR05FRF9JTlRfNV85XzlfOV9SRVZcIixcbiAgICBcIlVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEXCIsXG4gICAgXCJVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWVwiLFxuICAgIFwiVU5TSUdORURfSU5UX1NBTVBMRVJfM0RcIixcbiAgICBcIlVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkVcIixcbiAgICBcIlVOU0lHTkVEX0lOVF9WRUMyXCIsXG4gICAgXCJVTlNJR05FRF9JTlRfVkVDM1wiLFxuICAgIFwiVU5TSUdORURfSU5UX1ZFQzRcIixcbiAgICBcIlVOU0lHTkVEX05PUk1BTElaRURcIixcbiAgICBcIlVOU0lHTkVEX1NIT1JUXCIsXG4gICAgXCJVTlNJR05FRF9TSE9SVF80XzRfNF80XCIsXG4gICAgXCJVTlNJR05FRF9TSE9SVF81XzVfNV8xXCIsXG4gICAgXCJVTlNJR05FRF9TSE9SVF81XzZfNVwiLFxuICAgIFwiVU5TUEVDSUZJRURfRVZFTlRfVFlQRV9FUlJcIixcbiAgICBcIlVQREFURVJFQURZXCIsXG4gICAgXCJVUklFcnJvclwiLFxuICAgIFwiVVJMXCIsXG4gICAgXCJVUkxQYXR0ZXJuXCIsXG4gICAgXCJVUkxTZWFyY2hQYXJhbXNcIixcbiAgICBcIlVSTFVuZW5jb2RlZFwiLFxuICAgIFwiVVJMX01JU01BVENIX0VSUlwiLFxuICAgIFwiVVNCXCIsXG4gICAgXCJVU0JBbHRlcm5hdGVJbnRlcmZhY2VcIixcbiAgICBcIlVTQkNvbmZpZ3VyYXRpb25cIixcbiAgICBcIlVTQkNvbm5lY3Rpb25FdmVudFwiLFxuICAgIFwiVVNCRGV2aWNlXCIsXG4gICAgXCJVU0JFbmRwb2ludFwiLFxuICAgIFwiVVNCSW5UcmFuc2ZlclJlc3VsdFwiLFxuICAgIFwiVVNCSW50ZXJmYWNlXCIsXG4gICAgXCJVU0JJc29jaHJvbm91c0luVHJhbnNmZXJQYWNrZXRcIixcbiAgICBcIlVTQklzb2Nocm9ub3VzSW5UcmFuc2ZlclJlc3VsdFwiLFxuICAgIFwiVVNCSXNvY2hyb25vdXNPdXRUcmFuc2ZlclBhY2tldFwiLFxuICAgIFwiVVNCSXNvY2hyb25vdXNPdXRUcmFuc2ZlclJlc3VsdFwiLFxuICAgIFwiVVNCT3V0VHJhbnNmZXJSZXN1bHRcIixcbiAgICBcIlVUQ1wiLFxuICAgIFwiVWludDE2QXJyYXlcIixcbiAgICBcIlVpbnQzMkFycmF5XCIsXG4gICAgXCJVaW50OEFycmF5XCIsXG4gICAgXCJVaW50OENsYW1wZWRBcnJheVwiLFxuICAgIFwiVXBkYXRlRmlsdGVyXCIsXG4gICAgXCJVcGRhdGVQcm9wZXJ0eU5hbWVcIixcbiAgICBcIlVzZXJBY3RpdmF0aW9uXCIsXG4gICAgXCJVc2VyTWVzc2FnZUhhbmRsZXJcIixcbiAgICBcIlVzZXJNZXNzYWdlSGFuZGxlcnNOYW1lc3BhY2VcIixcbiAgICBcIlVzZXJQcm94aW1pdHlFdmVudFwiLFxuICAgIFwiVkFMSURBVEVfU1RBVFVTXCIsXG4gICAgXCJWQUxJREFUSU9OX0VSUlwiLFxuICAgIFwiVkFSSUFCTEVTX1JVTEVcIixcbiAgICBcIlZFTkRPUlwiLFxuICAgIFwiVkVSU0lPTlwiLFxuICAgIFwiVkVSU0lPTl9DSEFOR0VcIixcbiAgICBcIlZFUlNJT05fRVJSXCIsXG4gICAgXCJWRVJURVhcIixcbiAgICBcIlZFUlRFWF9BUlJBWV9CSU5ESU5HXCIsXG4gICAgXCJWRVJURVhfQVRUUklCX0FSUkFZX0JVRkZFUl9CSU5ESU5HXCIsXG4gICAgXCJWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1JcIixcbiAgICBcIlZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUl9BTkdMRVwiLFxuICAgIFwiVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEXCIsXG4gICAgXCJWRVJURVhfQVRUUklCX0FSUkFZX0lOVEVHRVJcIixcbiAgICBcIlZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRFwiLFxuICAgIFwiVkVSVEVYX0FUVFJJQl9BUlJBWV9QT0lOVEVSXCIsXG4gICAgXCJWRVJURVhfQVRUUklCX0FSUkFZX1NJWkVcIixcbiAgICBcIlZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFXCIsXG4gICAgXCJWRVJURVhfQVRUUklCX0FSUkFZX1RZUEVcIixcbiAgICBcIlZFUlRFWF9TSEFERVJcIixcbiAgICBcIlZFUlRJQ0FMXCIsXG4gICAgXCJWRVJUSUNBTF9BWElTXCIsXG4gICAgXCJWRVJfRVJSXCIsXG4gICAgXCJWSUVXUE9SVFwiLFxuICAgIFwiVklFV1BPUlRfUlVMRVwiLFxuICAgIFwiVlJEaXNwbGF5XCIsXG4gICAgXCJWUkRpc3BsYXlDYXBhYmlsaXRpZXNcIixcbiAgICBcIlZSRGlzcGxheUV2ZW50XCIsXG4gICAgXCJWUkV5ZVBhcmFtZXRlcnNcIixcbiAgICBcIlZSRmllbGRPZlZpZXdcIixcbiAgICBcIlZSRnJhbWVEYXRhXCIsXG4gICAgXCJWUlBvc2VcIixcbiAgICBcIlZSU3RhZ2VQYXJhbWV0ZXJzXCIsXG4gICAgXCJWVFRDdWVcIixcbiAgICBcIlZUVFJlZ2lvblwiLFxuICAgIFwiVmFsaWRpdHlTdGF0ZVwiLFxuICAgIFwiVmlkZW9Db2xvclNwYWNlXCIsXG4gICAgXCJWaWRlb0RlY29kZXJcIixcbiAgICBcIlZpZGVvRW5jb2RlclwiLFxuICAgIFwiVmlkZW9GcmFtZVwiLFxuICAgIFwiVmlkZW9QbGF5YmFja1F1YWxpdHlcIixcbiAgICBcIlZpZGVvU3RyZWFtVHJhY2tcIixcbiAgICBcIlZpZXdUaW1lbGluZVwiLFxuICAgIFwiVmlld1RyYW5zaXRpb25cIixcbiAgICBcIlZpZXdUcmFuc2l0aW9uVHlwZVNldFwiLFxuICAgIFwiVmlld1R5cGVcIixcbiAgICBcIlZpcnR1YWxLZXlib2FyZFwiLFxuICAgIFwiVmlydHVhbEtleWJvYXJkR2VvbWV0cnlDaGFuZ2VFdmVudFwiLFxuICAgIFwiVmlzaWJpbGl0eVN0YXRlRW50cnlcIixcbiAgICBcIlZpc3VhbFZpZXdwb3J0XCIsXG4gICAgXCJXQUlUX0ZBSUxFRFwiLFxuICAgIFwiV0VCS0lUX0ZJTFRFUl9SVUxFXCIsXG4gICAgXCJXRUJLSVRfS0VZRlJBTUVTX1JVTEVcIixcbiAgICBcIldFQktJVF9LRVlGUkFNRV9SVUxFXCIsXG4gICAgXCJXRUJLSVRfUkVHSU9OX1JVTEVcIixcbiAgICBcIldHU0xMYW5ndWFnZUZlYXR1cmVzXCIsXG4gICAgXCJXSU5ET1dfSURfQ1VSUkVOVFwiLFxuICAgIFwiV0lORE9XX0lEX05PTkVcIixcbiAgICBcIldSSVRFXCIsXG4gICAgXCJXUk9OR19ET0NVTUVOVF9FUlJcIixcbiAgICBcIldha2VMb2NrXCIsXG4gICAgXCJXYWtlTG9ja1NlbnRpbmVsXCIsXG4gICAgXCJXYXNtQW55UmVmXCIsXG4gICAgXCJXYXZlU2hhcGVyTm9kZVwiLFxuICAgIFwiV2Vha01hcFwiLFxuICAgIFwiV2Vha1JlZlwiLFxuICAgIFwiV2Vha1NldFwiLFxuICAgIFwiV2ViQXNzZW1ibHlcIixcbiAgICBcIldlYkdMMlJlbmRlcmluZ0NvbnRleHRcIixcbiAgICBcIldlYkdMQWN0aXZlSW5mb1wiLFxuICAgIFwiV2ViR0xCdWZmZXJcIixcbiAgICBcIldlYkdMQ29udGV4dEV2ZW50XCIsXG4gICAgXCJXZWJHTEZyYW1lYnVmZmVyXCIsXG4gICAgXCJXZWJHTE9iamVjdFwiLFxuICAgIFwiV2ViR0xQcm9ncmFtXCIsXG4gICAgXCJXZWJHTFF1ZXJ5XCIsXG4gICAgXCJXZWJHTFJlbmRlcmJ1ZmZlclwiLFxuICAgIFwiV2ViR0xSZW5kZXJpbmdDb250ZXh0XCIsXG4gICAgXCJXZWJHTFNhbXBsZXJcIixcbiAgICBcIldlYkdMU2hhZGVyXCIsXG4gICAgXCJXZWJHTFNoYWRlclByZWNpc2lvbkZvcm1hdFwiLFxuICAgIFwiV2ViR0xTeW5jXCIsXG4gICAgXCJXZWJHTFRleHR1cmVcIixcbiAgICBcIldlYkdMVHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICBcIldlYkdMVW5pZm9ybUxvY2F0aW9uXCIsXG4gICAgXCJXZWJHTFZlcnRleEFycmF5XCIsXG4gICAgXCJXZWJHTFZlcnRleEFycmF5T2JqZWN0XCIsXG4gICAgXCJXZWJLaXRBbmltYXRpb25FdmVudFwiLFxuICAgIFwiV2ViS2l0QmxvYkJ1aWxkZXJcIixcbiAgICBcIldlYktpdENTU0ZpbHRlclJ1bGVcIixcbiAgICBcIldlYktpdENTU0ZpbHRlclZhbHVlXCIsXG4gICAgXCJXZWJLaXRDU1NLZXlmcmFtZVJ1bGVcIixcbiAgICBcIldlYktpdENTU0tleWZyYW1lc1J1bGVcIixcbiAgICBcIldlYktpdENTU01hdHJpeFwiLFxuICAgIFwiV2ViS2l0Q1NTUmVnaW9uUnVsZVwiLFxuICAgIFwiV2ViS2l0Q1NTVHJhbnNmb3JtVmFsdWVcIixcbiAgICBcIldlYktpdERhdGFDdWVcIixcbiAgICBcIldlYktpdEdhbWVwYWRcIixcbiAgICBcIldlYktpdE1lZGlhS2V5RXJyb3JcIixcbiAgICBcIldlYktpdE1lZGlhS2V5TWVzc2FnZUV2ZW50XCIsXG4gICAgXCJXZWJLaXRNZWRpYUtleVNlc3Npb25cIixcbiAgICBcIldlYktpdE1lZGlhS2V5c1wiLFxuICAgIFwiV2ViS2l0TWVkaWFTb3VyY2VcIixcbiAgICBcIldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcIixcbiAgICBcIldlYktpdE5hbWVzcGFjZVwiLFxuICAgIFwiV2ViS2l0UGxheWJhY2tUYXJnZXRBdmFpbGFiaWxpdHlFdmVudFwiLFxuICAgIFwiV2ViS2l0UG9pbnRcIixcbiAgICBcIldlYktpdFNoYWRvd1Jvb3RcIixcbiAgICBcIldlYktpdFNvdXJjZUJ1ZmZlclwiLFxuICAgIFwiV2ViS2l0U291cmNlQnVmZmVyTGlzdFwiLFxuICAgIFwiV2ViS2l0VHJhbnNpdGlvbkV2ZW50XCIsXG4gICAgXCJXZWJTb2NrZXRcIixcbiAgICBcIldlYlNvY2tldEVycm9yXCIsXG4gICAgXCJXZWJTb2NrZXRTdHJlYW1cIixcbiAgICBcIldlYlRyYW5zcG9ydFwiLFxuICAgIFwiV2ViVHJhbnNwb3J0QmlkaXJlY3Rpb25hbFN0cmVhbVwiLFxuICAgIFwiV2ViVHJhbnNwb3J0RGF0YWdyYW1EdXBsZXhTdHJlYW1cIixcbiAgICBcIldlYlRyYW5zcG9ydEVycm9yXCIsXG4gICAgXCJXZWJUcmFuc3BvcnRSZWNlaXZlU3RyZWFtXCIsXG4gICAgXCJXZWJUcmFuc3BvcnRTZW5kU3RyZWFtXCIsXG4gICAgXCJXZWJraXRBbGlnbkNvbnRlbnRcIixcbiAgICBcIldlYmtpdEFsaWduSXRlbXNcIixcbiAgICBcIldlYmtpdEFsaWduU2VsZlwiLFxuICAgIFwiV2Via2l0QW5pbWF0aW9uXCIsXG4gICAgXCJXZWJraXRBbmltYXRpb25EZWxheVwiLFxuICAgIFwiV2Via2l0QW5pbWF0aW9uRGlyZWN0aW9uXCIsXG4gICAgXCJXZWJraXRBbmltYXRpb25EdXJhdGlvblwiLFxuICAgIFwiV2Via2l0QW5pbWF0aW9uRmlsbE1vZGVcIixcbiAgICBcIldlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCIsXG4gICAgXCJXZWJraXRBbmltYXRpb25OYW1lXCIsXG4gICAgXCJXZWJraXRBbmltYXRpb25QbGF5U3RhdGVcIixcbiAgICBcIldlYmtpdEFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gICAgXCJXZWJraXRBcHBlYXJhbmNlXCIsXG4gICAgXCJXZWJraXRCYWNrZmFjZVZpc2liaWxpdHlcIixcbiAgICBcIldlYmtpdEJhY2tncm91bmRDbGlwXCIsXG4gICAgXCJXZWJraXRCYWNrZ3JvdW5kT3JpZ2luXCIsXG4gICAgXCJXZWJraXRCYWNrZ3JvdW5kU2l6ZVwiLFxuICAgIFwiV2Via2l0Qm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiLFxuICAgIFwiV2Via2l0Qm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcbiAgICBcIldlYmtpdEJvcmRlckltYWdlXCIsXG4gICAgXCJXZWJraXRCb3JkZXJSYWRpdXNcIixcbiAgICBcIldlYmtpdEJvcmRlclRvcExlZnRSYWRpdXNcIixcbiAgICBcIldlYmtpdEJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXG4gICAgXCJXZWJraXRCb3hBbGlnblwiLFxuICAgIFwiV2Via2l0Qm94RGlyZWN0aW9uXCIsXG4gICAgXCJXZWJraXRCb3hGbGV4XCIsXG4gICAgXCJXZWJraXRCb3hPcmRpbmFsR3JvdXBcIixcbiAgICBcIldlYmtpdEJveE9yaWVudFwiLFxuICAgIFwiV2Via2l0Qm94UGFja1wiLFxuICAgIFwiV2Via2l0Qm94U2hhZG93XCIsXG4gICAgXCJXZWJraXRCb3hTaXppbmdcIixcbiAgICBcIldlYmtpdENsaXBQYXRoXCIsXG4gICAgXCJXZWJraXRGaWx0ZXJcIixcbiAgICBcIldlYmtpdEZsZXhcIixcbiAgICBcIldlYmtpdEZsZXhCYXNpc1wiLFxuICAgIFwiV2Via2l0RmxleERpcmVjdGlvblwiLFxuICAgIFwiV2Via2l0RmxleEZsb3dcIixcbiAgICBcIldlYmtpdEZsZXhHcm93XCIsXG4gICAgXCJXZWJraXRGbGV4U2hyaW5rXCIsXG4gICAgXCJXZWJraXRGbGV4V3JhcFwiLFxuICAgIFwiV2Via2l0Rm9udEZlYXR1cmVTZXR0aW5nc1wiLFxuICAgIFwiV2Via2l0SnVzdGlmeUNvbnRlbnRcIixcbiAgICBcIldlYmtpdExpbmVDbGFtcFwiLFxuICAgIFwiV2Via2l0TWFza1wiLFxuICAgIFwiV2Via2l0TWFza0NsaXBcIixcbiAgICBcIldlYmtpdE1hc2tDb21wb3NpdGVcIixcbiAgICBcIldlYmtpdE1hc2tJbWFnZVwiLFxuICAgIFwiV2Via2l0TWFza09yaWdpblwiLFxuICAgIFwiV2Via2l0TWFza1Bvc2l0aW9uXCIsXG4gICAgXCJXZWJraXRNYXNrUG9zaXRpb25YXCIsXG4gICAgXCJXZWJraXRNYXNrUG9zaXRpb25ZXCIsXG4gICAgXCJXZWJraXRNYXNrUmVwZWF0XCIsXG4gICAgXCJXZWJraXRNYXNrU2l6ZVwiLFxuICAgIFwiV2Via2l0T3JkZXJcIixcbiAgICBcIldlYmtpdFBlcnNwZWN0aXZlXCIsXG4gICAgXCJXZWJraXRQZXJzcGVjdGl2ZU9yaWdpblwiLFxuICAgIFwiV2Via2l0VGV4dEZpbGxDb2xvclwiLFxuICAgIFwiV2Via2l0VGV4dFNlY3VyaXR5XCIsXG4gICAgXCJXZWJraXRUZXh0U2l6ZUFkanVzdFwiLFxuICAgIFwiV2Via2l0VGV4dFN0cm9rZVwiLFxuICAgIFwiV2Via2l0VGV4dFN0cm9rZUNvbG9yXCIsXG4gICAgXCJXZWJraXRUZXh0U3Ryb2tlV2lkdGhcIixcbiAgICBcIldlYmtpdFRyYW5zZm9ybVwiLFxuICAgIFwiV2Via2l0VHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgXCJXZWJraXRUcmFuc2Zvcm1TdHlsZVwiLFxuICAgIFwiV2Via2l0VHJhbnNpdGlvblwiLFxuICAgIFwiV2Via2l0VHJhbnNpdGlvbkRlbGF5XCIsXG4gICAgXCJXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cIixcbiAgICBcIldlYmtpdFRyYW5zaXRpb25Qcm9wZXJ0eVwiLFxuICAgIFwiV2Via2l0VHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gICAgXCJXZWJraXRVc2VyU2VsZWN0XCIsXG4gICAgXCJXaGVlbEV2ZW50XCIsXG4gICAgXCJXaW5kb3dcIixcbiAgICBcIldpbmRvd0NvbnRyb2xzT3ZlcmxheVwiLFxuICAgIFwiV2luZG93Q29udHJvbHNPdmVybGF5R2VvbWV0cnlDaGFuZ2VFdmVudFwiLFxuICAgIFwiV2luZG93U3RhdGVcIixcbiAgICBcIldpbmRvd1R5cGVcIixcbiAgICBcIldvcmtlclwiLFxuICAgIFwiV29ya2xldFwiLFxuICAgIFwiV3JpdGFibGVTdHJlYW1cIixcbiAgICBcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcIixcbiAgICBcIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclwiLFxuICAgIFwiWE1MRG9jdW1lbnRcIixcbiAgICBcIlhNTEh0dHBSZXF1ZXN0XCIsXG4gICAgXCJYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0XCIsXG4gICAgXCJYTUxIdHRwUmVxdWVzdEV4Y2VwdGlvblwiLFxuICAgIFwiWE1MSHR0cFJlcXVlc3RQcm9ncmVzc0V2ZW50XCIsXG4gICAgXCJYTUxIdHRwUmVxdWVzdFVwbG9hZFwiLFxuICAgIFwiWE1MU2VyaWFsaXplclwiLFxuICAgIFwiWE1MU3R5bGVzaGVldFByb2Nlc3NpbmdJbnN0cnVjdGlvblwiLFxuICAgIFwiWFBhdGhFdmFsdWF0b3JcIixcbiAgICBcIlhQYXRoRXhjZXB0aW9uXCIsXG4gICAgXCJYUGF0aEV4cHJlc3Npb25cIixcbiAgICBcIlhQYXRoTlNSZXNvbHZlclwiLFxuICAgIFwiWFBhdGhSZXN1bHRcIixcbiAgICBcIlhSQW5jaG9yXCIsXG4gICAgXCJYUkFuY2hvclNldFwiLFxuICAgIFwiWFJCb3VuZGVkUmVmZXJlbmNlU3BhY2VcIixcbiAgICBcIlhSQ1BVRGVwdGhJbmZvcm1hdGlvblwiLFxuICAgIFwiWFJDYW1lcmFcIixcbiAgICBcIlhSRE9NT3ZlcmxheVN0YXRlXCIsXG4gICAgXCJYUkRlcHRoSW5mb3JtYXRpb25cIixcbiAgICBcIlhSRnJhbWVcIixcbiAgICBcIlhSSGFuZFwiLFxuICAgIFwiWFJIaXRUZXN0UmVzdWx0XCIsXG4gICAgXCJYUkhpdFRlc3RTb3VyY2VcIixcbiAgICBcIlhSSW5wdXRTb3VyY2VcIixcbiAgICBcIlhSSW5wdXRTb3VyY2VBcnJheVwiLFxuICAgIFwiWFJJbnB1dFNvdXJjZUV2ZW50XCIsXG4gICAgXCJYUklucHV0U291cmNlc0NoYW5nZUV2ZW50XCIsXG4gICAgXCJYUkpvaW50UG9zZVwiLFxuICAgIFwiWFJKb2ludFNwYWNlXCIsXG4gICAgXCJYUkxheWVyXCIsXG4gICAgXCJYUkxpZ2h0RXN0aW1hdGVcIixcbiAgICBcIlhSTGlnaHRQcm9iZVwiLFxuICAgIFwiWFJQb3NlXCIsXG4gICAgXCJYUlJheVwiLFxuICAgIFwiWFJSZWZlcmVuY2VTcGFjZVwiLFxuICAgIFwiWFJSZWZlcmVuY2VTcGFjZUV2ZW50XCIsXG4gICAgXCJYUlJlbmRlclN0YXRlXCIsXG4gICAgXCJYUlJpZ2lkVHJhbnNmb3JtXCIsXG4gICAgXCJYUlNlc3Npb25cIixcbiAgICBcIlhSU2Vzc2lvbkV2ZW50XCIsXG4gICAgXCJYUlNwYWNlXCIsXG4gICAgXCJYUlN5c3RlbVwiLFxuICAgIFwiWFJUcmFuc2llbnRJbnB1dEhpdFRlc3RSZXN1bHRcIixcbiAgICBcIlhSVHJhbnNpZW50SW5wdXRIaXRUZXN0U291cmNlXCIsXG4gICAgXCJYUlZpZXdcIixcbiAgICBcIlhSVmlld2VyUG9zZVwiLFxuICAgIFwiWFJWaWV3cG9ydFwiLFxuICAgIFwiWFJXZWJHTEJpbmRpbmdcIixcbiAgICBcIlhSV2ViR0xEZXB0aEluZm9ybWF0aW9uXCIsXG4gICAgXCJYUldlYkdMTGF5ZXJcIixcbiAgICBcIlhTTFRQcm9jZXNzb3JcIixcbiAgICBcIlpFUk9cIixcbiAgICBcIlpvb21TZXR0aW5nc1wiLFxuICAgIFwiWm9vbVNldHRpbmdzTW9kZVwiLFxuICAgIFwiWm9vbVNldHRpbmdzU2NvcGVcIixcbiAgICBcIl9YRDBNX1wiLFxuICAgIFwiX1lEME1fXCIsXG4gICAgXCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX19cIixcbiAgICBcIl9fYnJhbmRcIixcbiAgICBcIl9fZGVmaW5lR2V0dGVyX19cIixcbiAgICBcIl9fZGVmaW5lU2V0dGVyX19cIixcbiAgICBcIl9fbG9va3VwR2V0dGVyX19cIixcbiAgICBcIl9fbG9va3VwU2V0dGVyX19cIixcbiAgICBcIl9fb3BlcmFcIixcbiAgICBcIl9fcHJvdG9fX1wiLFxuICAgIFwiX2Jyb3dzZXJqc3JhblwiLFxuICAgIFwiYVwiLFxuICAgIFwiYUxpbmtcIixcbiAgICBcImFiYnJcIixcbiAgICBcImFib3J0XCIsXG4gICAgXCJhYm9ydGVkXCIsXG4gICAgXCJhYm91dENvbmZpZ1ByZWZzXCIsXG4gICAgXCJhYnNcIixcbiAgICBcImFic29sdXRlXCIsXG4gICAgXCJhY2NlbGVyYXRpb25cIixcbiAgICBcImFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlcIixcbiAgICBcImFjY2VsZXJhdG9yXCIsXG4gICAgXCJhY2NlbnQtY29sb3JcIixcbiAgICBcImFjY2VudENvbG9yXCIsXG4gICAgXCJhY2NlcHRcIixcbiAgICBcImFjY2VwdENoYXJzZXRcIixcbiAgICBcImFjY2VwdE5vZGVcIixcbiAgICBcImFjY2Vzc1wiLFxuICAgIFwiYWNjZXNzS2V5XCIsXG4gICAgXCJhY2Nlc3NLZXlMYWJlbFwiLFxuICAgIFwiYWNjdXJhY3lcIixcbiAgICBcImFjb3NcIixcbiAgICBcImFjb3NoXCIsXG4gICAgXCJhY3Rpb25cIixcbiAgICBcImFjdGlvblVSTFwiLFxuICAgIFwiYWN0aW9uc1wiLFxuICAgIFwiYWN0aXZhdGVkXCIsXG4gICAgXCJhY3RpdmF0aW9uXCIsXG4gICAgXCJhY3RpdmF0aW9uU3RhcnRcIixcbiAgICBcImFjdGl2ZVwiLFxuICAgIFwiYWN0aXZlQ3Vlc1wiLFxuICAgIFwiYWN0aXZlRWxlbWVudFwiLFxuICAgIFwiYWN0aXZlU291cmNlQnVmZmVyc1wiLFxuICAgIFwiYWN0aXZlU291cmNlQ291bnRcIixcbiAgICBcImFjdGl2ZVRleHR1cmVcIixcbiAgICBcImFjdGl2ZVZSRGlzcGxheXNcIixcbiAgICBcImFjdGl2aXR5TG9nXCIsXG4gICAgXCJhY3R1YWxCb3VuZGluZ0JveEFzY2VudFwiLFxuICAgIFwiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50XCIsXG4gICAgXCJhY3R1YWxCb3VuZGluZ0JveExlZnRcIixcbiAgICBcImFjdHVhbEJvdW5kaW5nQm94UmlnaHRcIixcbiAgICBcImFkQXVjdGlvbkNvbXBvbmVudHNcIixcbiAgICBcImFkQXVjdGlvbkhlYWRlcnNcIixcbiAgICBcImFkZFwiLFxuICAgIFwiYWRkQWxsXCIsXG4gICAgXCJhZGRCZWhhdmlvclwiLFxuICAgIFwiYWRkQ2FuZGlkYXRlXCIsXG4gICAgXCJhZGRDb2xvclN0b3BcIixcbiAgICBcImFkZEN1ZVwiLFxuICAgIFwiYWRkRWxlbWVudFwiLFxuICAgIFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgIFwiYWRkRmlsdGVyXCIsXG4gICAgXCJhZGRGcm9tU3RyaW5nXCIsXG4gICAgXCJhZGRGcm9tVXJpXCIsXG4gICAgXCJhZGRJY2VDYW5kaWRhdGVcIixcbiAgICBcImFkZEltcG9ydFwiLFxuICAgIFwiYWRkTGlzdGVuZXJcIixcbiAgICBcImFkZE1vZHVsZVwiLFxuICAgIFwiYWRkTmFtZWRcIixcbiAgICBcImFkZFBhZ2VSdWxlXCIsXG4gICAgXCJhZGRQYXRoXCIsXG4gICAgXCJhZGRQb2ludGVyXCIsXG4gICAgXCJhZGRSYW5nZVwiLFxuICAgIFwiYWRkUmVnaW9uXCIsXG4gICAgXCJhZGRSdWxlXCIsXG4gICAgXCJhZGRTZWFyY2hFbmdpbmVcIixcbiAgICBcImFkZFNvdXJjZUJ1ZmZlclwiLFxuICAgIFwiYWRkU3RyZWFtXCIsXG4gICAgXCJhZGRUZXh0VHJhY2tcIixcbiAgICBcImFkZFRyYWNrXCIsXG4gICAgXCJhZGRUcmFuc2NlaXZlclwiLFxuICAgIFwiYWRkV2FrZUxvY2tMaXN0ZW5lclwiLFxuICAgIFwiYWRkZWRcIixcbiAgICBcImFkZGVkTm9kZXNcIixcbiAgICBcImFkZGl0aW9uYWxOYW1lXCIsXG4gICAgXCJhZGRpdGl2ZVN5bWJvbHNcIixcbiAgICBcImFkZG9uc1wiLFxuICAgIFwiYWRkcmVzc1wiLFxuICAgIFwiYWRkcmVzc0xpbmVcIixcbiAgICBcImFkZHJlc3NNb2RlVVwiLFxuICAgIFwiYWRkcmVzc01vZGVWXCIsXG4gICAgXCJhZGRyZXNzTW9kZVdcIixcbiAgICBcImFkb3B0Tm9kZVwiLFxuICAgIFwiYWRvcHRlZENhbGxiYWNrXCIsXG4gICAgXCJhZG9wdGVkU3R5bGVTaGVldHNcIixcbiAgICBcImFkclwiLFxuICAgIFwiYWR2YW5jZVwiLFxuICAgIFwiYWZ0ZXJcIixcbiAgICBcImFsYXJtc1wiLFxuICAgIFwiYWxidW1cIixcbiAgICBcImFsZXJ0XCIsXG4gICAgXCJhbGdvcml0aG1cIixcbiAgICBcImFsaWduXCIsXG4gICAgXCJhbGlnbi1jb250ZW50XCIsXG4gICAgXCJhbGlnbi1pdGVtc1wiLFxuICAgIFwiYWxpZ24tc2VsZlwiLFxuICAgIFwiYWxpZ25Db250ZW50XCIsXG4gICAgXCJhbGlnbkl0ZW1zXCIsXG4gICAgXCJhbGlnblNlbGZcIixcbiAgICBcImFsaWdubWVudEJhc2VsaW5lXCIsXG4gICAgXCJhbGlua0NvbG9yXCIsXG4gICAgXCJhbGxcIixcbiAgICBcImFsbFNldHRsZWRcIixcbiAgICBcImFsbG9jYXRpb25TaXplXCIsXG4gICAgXCJhbGxvd1wiLFxuICAgIFwiYWxsb3dGdWxsc2NyZWVuXCIsXG4gICAgXCJhbGxvd1BheW1lbnRSZXF1ZXN0XCIsXG4gICAgXCJhbGxvd2VkRGlyZWN0aW9uc1wiLFxuICAgIFwiYWxsb3dlZEZlYXR1cmVzXCIsXG4gICAgXCJhbGxvd2VkVG9QbGF5XCIsXG4gICAgXCJhbGxvd3NGZWF0dXJlXCIsXG4gICAgXCJhbHBoYVwiLFxuICAgIFwiYWxwaGFNb2RlXCIsXG4gICAgXCJhbHBoYVRvQ292ZXJhZ2VFbmFibGVkXCIsXG4gICAgXCJhbHBoYWJldGljQmFzZWxpbmVcIixcbiAgICBcImFsdFwiLFxuICAgIFwiYWx0R3JhcGhLZXlcIixcbiAgICBcImFsdEh0bWxcIixcbiAgICBcImFsdEtleVwiLFxuICAgIFwiYWx0TGVmdFwiLFxuICAgIFwiYWx0ZXJuYXRlXCIsXG4gICAgXCJhbHRlcm5hdGVTZXR0aW5nXCIsXG4gICAgXCJhbHRlcm5hdGVzXCIsXG4gICAgXCJhbHRpdHVkZVwiLFxuICAgIFwiYWx0aXR1ZGVBY2N1cmFjeVwiLFxuICAgIFwiYWx0aXR1ZGVBbmdsZVwiLFxuICAgIFwiYW1wbGl0dWRlXCIsXG4gICAgXCJhbmNlc3Rvck9yaWdpbnNcIixcbiAgICBcImFuY2hvclwiLFxuICAgIFwiYW5jaG9yTm9kZVwiLFxuICAgIFwiYW5jaG9yT2Zmc2V0XCIsXG4gICAgXCJhbmNob3JTcGFjZVwiLFxuICAgIFwiYW5jaG9yc1wiLFxuICAgIFwiYW5kXCIsXG4gICAgXCJhbmdsZVwiLFxuICAgIFwiYW5ndWxhckFjY2VsZXJhdGlvblwiLFxuICAgIFwiYW5ndWxhclZlbG9jaXR5XCIsXG4gICAgXCJhbmltVmFsXCIsXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJhbmltYXRlZFwiLFxuICAgIFwiYW5pbWF0ZWRJbnN0YW5jZVJvb3RcIixcbiAgICBcImFuaW1hdGVkTm9ybWFsaXplZFBhdGhTZWdMaXN0XCIsXG4gICAgXCJhbmltYXRlZFBhdGhTZWdMaXN0XCIsXG4gICAgXCJhbmltYXRlZFBvaW50c1wiLFxuICAgIFwiYW5pbWF0aW9uXCIsXG4gICAgXCJhbmltYXRpb24tY29tcG9zaXRpb25cIixcbiAgICBcImFuaW1hdGlvbi1kZWxheVwiLFxuICAgIFwiYW5pbWF0aW9uLWRpcmVjdGlvblwiLFxuICAgIFwiYW5pbWF0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCJhbmltYXRpb24tZmlsbC1tb2RlXCIsXG4gICAgXCJhbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIsXG4gICAgXCJhbmltYXRpb24tbmFtZVwiLFxuICAgIFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIixcbiAgICBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb25cIixcbiAgICBcImFuaW1hdGlvbkNvbXBvc2l0aW9uXCIsXG4gICAgXCJhbmltYXRpb25EZWxheVwiLFxuICAgIFwiYW5pbWF0aW9uRGlyZWN0aW9uXCIsXG4gICAgXCJhbmltYXRpb25EdXJhdGlvblwiLFxuICAgIFwiYW5pbWF0aW9uRmlsbE1vZGVcIixcbiAgICBcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCIsXG4gICAgXCJhbmltYXRpb25OYW1lXCIsXG4gICAgXCJhbmltYXRpb25QbGF5U3RhdGVcIixcbiAgICBcImFuaW1hdGlvblN0YXJ0VGltZVwiLFxuICAgIFwiYW5pbWF0aW9uVGltaW5nRnVuY3Rpb25cIixcbiAgICBcImFuaW1hdGlvbnNQYXVzZWRcIixcbiAgICBcImFubml2ZXJzYXJ5XCIsXG4gICAgXCJhbnRpYWxpYXNcIixcbiAgICBcImFudGljaXBhdGVkUmVtb3ZhbFwiLFxuICAgIFwiYW55XCIsXG4gICAgXCJhcHBcIixcbiAgICBcImFwcENvZGVOYW1lXCIsXG4gICAgXCJhcHBNaW5vclZlcnNpb25cIixcbiAgICBcImFwcE5hbWVcIixcbiAgICBcImFwcE5vdGlmaWNhdGlvbnNcIixcbiAgICBcImFwcFZlcnNpb25cIixcbiAgICBcImFwcGVhcmFuY2VcIixcbiAgICBcImFwcGVuZFwiLFxuICAgIFwiYXBwZW5kQnVmZmVyXCIsXG4gICAgXCJhcHBlbmRDaGlsZFwiLFxuICAgIFwiYXBwZW5kRGF0YVwiLFxuICAgIFwiYXBwZW5kSXRlbVwiLFxuICAgIFwiYXBwZW5kTWVkaXVtXCIsXG4gICAgXCJhcHBlbmROYW1lZFwiLFxuICAgIFwiYXBwZW5kUnVsZVwiLFxuICAgIFwiYXBwZW5kU3RyZWFtXCIsXG4gICAgXCJhcHBlbmRXaW5kb3dFbmRcIixcbiAgICBcImFwcGVuZFdpbmRvd1N0YXJ0XCIsXG4gICAgXCJhcHBsZXRzXCIsXG4gICAgXCJhcHBsaWNhdGlvbkNhY2hlXCIsXG4gICAgXCJhcHBsaWNhdGlvblNlcnZlcktleVwiLFxuICAgIFwiYXBwbHlcIixcbiAgICBcImFwcGx5Q29uc3RyYWludHNcIixcbiAgICBcImFwcGx5RWxlbWVudFwiLFxuICAgIFwiYXJjXCIsXG4gICAgXCJhcmNUb1wiLFxuICAgIFwiYXJjaFwiLFxuICAgIFwiYXJjaGl0ZWN0dXJlXCIsXG4gICAgXCJhcmNoaXZlXCIsXG4gICAgXCJhcmVhc1wiLFxuICAgIFwiYXJndW1lbnRzXCIsXG4gICAgXCJhcmlhQXRvbWljXCIsXG4gICAgXCJhcmlhQXV0b0NvbXBsZXRlXCIsXG4gICAgXCJhcmlhQnJhaWxsZUxhYmVsXCIsXG4gICAgXCJhcmlhQnJhaWxsZVJvbGVEZXNjcmlwdGlvblwiLFxuICAgIFwiYXJpYUJ1c3lcIixcbiAgICBcImFyaWFDaGVja2VkXCIsXG4gICAgXCJhcmlhQ29sQ291bnRcIixcbiAgICBcImFyaWFDb2xJbmRleFwiLFxuICAgIFwiYXJpYUNvbEluZGV4VGV4dFwiLFxuICAgIFwiYXJpYUNvbFNwYW5cIixcbiAgICBcImFyaWFDdXJyZW50XCIsXG4gICAgXCJhcmlhRGVzY3JpcHRpb25cIixcbiAgICBcImFyaWFEaXNhYmxlZFwiLFxuICAgIFwiYXJpYUV4cGFuZGVkXCIsXG4gICAgXCJhcmlhSGFzUG9wdXBcIixcbiAgICBcImFyaWFIaWRkZW5cIixcbiAgICBcImFyaWFJbnZhbGlkXCIsXG4gICAgXCJhcmlhS2V5U2hvcnRjdXRzXCIsXG4gICAgXCJhcmlhTGFiZWxcIixcbiAgICBcImFyaWFMZXZlbFwiLFxuICAgIFwiYXJpYUxpdmVcIixcbiAgICBcImFyaWFNb2RhbFwiLFxuICAgIFwiYXJpYU11bHRpTGluZVwiLFxuICAgIFwiYXJpYU11bHRpU2VsZWN0YWJsZVwiLFxuICAgIFwiYXJpYU9yaWVudGF0aW9uXCIsXG4gICAgXCJhcmlhUGxhY2Vob2xkZXJcIixcbiAgICBcImFyaWFQb3NJblNldFwiLFxuICAgIFwiYXJpYVByZXNzZWRcIixcbiAgICBcImFyaWFSZWFkT25seVwiLFxuICAgIFwiYXJpYVJlbGV2YW50XCIsXG4gICAgXCJhcmlhUmVxdWlyZWRcIixcbiAgICBcImFyaWFSb2xlRGVzY3JpcHRpb25cIixcbiAgICBcImFyaWFSb3dDb3VudFwiLFxuICAgIFwiYXJpYVJvd0luZGV4XCIsXG4gICAgXCJhcmlhUm93SW5kZXhUZXh0XCIsXG4gICAgXCJhcmlhUm93U3BhblwiLFxuICAgIFwiYXJpYVNlbGVjdGVkXCIsXG4gICAgXCJhcmlhU2V0U2l6ZVwiLFxuICAgIFwiYXJpYVNvcnRcIixcbiAgICBcImFyaWFWYWx1ZU1heFwiLFxuICAgIFwiYXJpYVZhbHVlTWluXCIsXG4gICAgXCJhcmlhVmFsdWVOb3dcIixcbiAgICBcImFyaWFWYWx1ZVRleHRcIixcbiAgICBcImFycmF5QnVmZmVyXCIsXG4gICAgXCJhcnJheUxheWVyQ291bnRcIixcbiAgICBcImFycmF5U3RyaWRlXCIsXG4gICAgXCJhcnRpc3RcIixcbiAgICBcImFydHdvcmtcIixcbiAgICBcImFzXCIsXG4gICAgXCJhc0ludE5cIixcbiAgICBcImFzVWludE5cIixcbiAgICBcImFzY2VudE92ZXJyaWRlXCIsXG4gICAgXCJhc2luXCIsXG4gICAgXCJhc2luaFwiLFxuICAgIFwiYXNwZWN0XCIsXG4gICAgXCJhc3BlY3QtcmF0aW9cIixcbiAgICBcImFzcGVjdFJhdGlvXCIsXG4gICAgXCJhc3NlcnRcIixcbiAgICBcImFzc2lnblwiLFxuICAgIFwiYXNzaWduZWRFbGVtZW50c1wiLFxuICAgIFwiYXNzaWduZWROb2Rlc1wiLFxuICAgIFwiYXNzaWduZWRTbG90XCIsXG4gICAgXCJhc3luY1wiLFxuICAgIFwiYXN5bmNEaXNwb3NlXCIsXG4gICAgXCJhc3luY0l0ZXJhdG9yXCIsXG4gICAgXCJhdFwiLFxuICAgIFwiYXRFbmRcIixcbiAgICBcImF0YW5cIixcbiAgICBcImF0YW4yXCIsXG4gICAgXCJhdGFuaFwiLFxuICAgIFwiYXRvYlwiLFxuICAgIFwiYXR0YWNoRXZlbnRcIixcbiAgICBcImF0dGFjaEludGVybmFsc1wiLFxuICAgIFwiYXR0YWNoU2hhZGVyXCIsXG4gICAgXCJhdHRhY2hTaGFkb3dcIixcbiAgICBcImF0dGFjaGVkRWxlbWVudHNcIixcbiAgICBcImF0dGFjaG1lbnRzXCIsXG4gICAgXCJhdHRhY2tcIixcbiAgICBcImF0dGVzdGF0aW9uT2JqZWN0XCIsXG4gICAgXCJhdHRyQ2hhbmdlXCIsXG4gICAgXCJhdHRyTmFtZVwiLFxuICAgIFwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrXCIsXG4gICAgXCJhdHRyaWJ1dGVGaWx0ZXJcIixcbiAgICBcImF0dHJpYnV0ZU5hbWVcIixcbiAgICBcImF0dHJpYnV0ZU5hbWVzcGFjZVwiLFxuICAgIFwiYXR0cmlidXRlT2xkVmFsdWVcIixcbiAgICBcImF0dHJpYnV0ZVN0eWxlTWFwXCIsXG4gICAgXCJhdHRyaWJ1dGVzXCIsXG4gICAgXCJhdHRyaWJ1dGlvblwiLFxuICAgIFwiYXR0cmlidXRpb25TcmNcIixcbiAgICBcImF1ZGlvQml0cmF0ZU1vZGVcIixcbiAgICBcImF1ZGlvQml0c1BlclNlY29uZFwiLFxuICAgIFwiYXVkaW9UcmFja3NcIixcbiAgICBcImF1ZGlvV29ya2xldFwiLFxuICAgIFwiYXV0aGVudGljYXRlZFNpZ25lZFdyaXRlc1wiLFxuICAgIFwiYXV0aGVudGljYXRvckF0dGFjaG1lbnRcIixcbiAgICBcImF1dGhlbnRpY2F0b3JEYXRhXCIsXG4gICAgXCJhdXRvSW5jcmVtZW50XCIsXG4gICAgXCJhdXRvYnVmZmVyXCIsXG4gICAgXCJhdXRvY2FwaXRhbGl6ZVwiLFxuICAgIFwiYXV0b2NvbXBsZXRlXCIsXG4gICAgXCJhdXRvY29ycmVjdFwiLFxuICAgIFwiYXV0b2ZvY3VzXCIsXG4gICAgXCJhdXRvbWF0aW9uUmF0ZVwiLFxuICAgIFwiYXV0b3BsYXlcIixcbiAgICBcImF2YWlsSGVpZ2h0XCIsXG4gICAgXCJhdmFpbExlZnRcIixcbiAgICBcImF2YWlsVG9wXCIsXG4gICAgXCJhdmFpbFdpZHRoXCIsXG4gICAgXCJhdmFpbGFiaWxpdHlcIixcbiAgICBcImF2YWlsYWJsZVwiLFxuICAgIFwiYXZlcmFnZUxhdGVuY3lcIixcbiAgICBcImF2ZXJzaW9uXCIsXG4gICAgXCJheFwiLFxuICAgIFwiYXhlc1wiLFxuICAgIFwiYXhpc1wiLFxuICAgIFwiYXlcIixcbiAgICBcImF6aW11dGhcIixcbiAgICBcImF6aW11dGhBbmdsZVwiLFxuICAgIFwiYlwiLFxuICAgIFwiYmFja1wiLFxuICAgIFwiYmFja2Ryb3AtZmlsdGVyXCIsXG4gICAgXCJiYWNrZHJvcEZpbHRlclwiLFxuICAgIFwiYmFja2VuZHNcIixcbiAgICBcImJhY2tmYWNlLXZpc2liaWxpdHlcIixcbiAgICBcImJhY2tmYWNlVmlzaWJpbGl0eVwiLFxuICAgIFwiYmFja2dyb3VuZFwiLFxuICAgIFwiYmFja2dyb3VuZC1hdHRhY2htZW50XCIsXG4gICAgXCJiYWNrZ3JvdW5kLWJsZW5kLW1vZGVcIixcbiAgICBcImJhY2tncm91bmQtY2xpcFwiLFxuICAgIFwiYmFja2dyb3VuZC1jb2xvclwiLFxuICAgIFwiYmFja2dyb3VuZC1pbWFnZVwiLFxuICAgIFwiYmFja2dyb3VuZC1vcmlnaW5cIixcbiAgICBcImJhY2tncm91bmQtcG9zaXRpb25cIixcbiAgICBcImJhY2tncm91bmQtcG9zaXRpb24teFwiLFxuICAgIFwiYmFja2dyb3VuZC1wb3NpdGlvbi15XCIsXG4gICAgXCJiYWNrZ3JvdW5kLXJlcGVhdFwiLFxuICAgIFwiYmFja2dyb3VuZC1zaXplXCIsXG4gICAgXCJiYWNrZ3JvdW5kQXR0YWNobWVudFwiLFxuICAgIFwiYmFja2dyb3VuZEJsZW5kTW9kZVwiLFxuICAgIFwiYmFja2dyb3VuZENsaXBcIixcbiAgICBcImJhY2tncm91bmRDb2xvclwiLFxuICAgIFwiYmFja2dyb3VuZEZldGNoXCIsXG4gICAgXCJiYWNrZ3JvdW5kSW1hZ2VcIixcbiAgICBcImJhY2tncm91bmRPcmlnaW5cIixcbiAgICBcImJhY2tncm91bmRQb3NpdGlvblwiLFxuICAgIFwiYmFja2dyb3VuZFBvc2l0aW9uWFwiLFxuICAgIFwiYmFja2dyb3VuZFBvc2l0aW9uWVwiLFxuICAgIFwiYmFja2dyb3VuZFJlcGVhdFwiLFxuICAgIFwiYmFja2dyb3VuZFNpemVcIixcbiAgICBcImJhZElucHV0XCIsXG4gICAgXCJiYWRnZVwiLFxuICAgIFwiYmFsYW5jZVwiLFxuICAgIFwiYmFzZUFycmF5TGF5ZXJcIixcbiAgICBcImJhc2VGcmVxdWVuY3lYXCIsXG4gICAgXCJiYXNlRnJlcXVlbmN5WVwiLFxuICAgIFwiYmFzZUxhdGVuY3lcIixcbiAgICBcImJhc2VMYXllclwiLFxuICAgIFwiYmFzZU1pcExldmVsXCIsXG4gICAgXCJiYXNlTm9kZVwiLFxuICAgIFwiYmFzZU9mZnNldFwiLFxuICAgIFwiYmFzZVBhbGV0dGVcIixcbiAgICBcImJhc2VVUklcIixcbiAgICBcImJhc2VWYWxcIixcbiAgICBcImJhc2VsaW5lLXNvdXJjZVwiLFxuICAgIFwiYmFzZWxpbmVTaGlmdFwiLFxuICAgIFwiYmFzZWxpbmVTb3VyY2VcIixcbiAgICBcImJhdHRlcnlcIixcbiAgICBcImJkYXlcIixcbiAgICBcImJlZm9yZVwiLFxuICAgIFwiYmVnaW5Db21wdXRlUGFzc1wiLFxuICAgIFwiYmVnaW5FbGVtZW50XCIsXG4gICAgXCJiZWdpbkVsZW1lbnRBdFwiLFxuICAgIFwiYmVnaW5PY2NsdXNpb25RdWVyeVwiLFxuICAgIFwiYmVnaW5QYXRoXCIsXG4gICAgXCJiZWdpblF1ZXJ5XCIsXG4gICAgXCJiZWdpblJlbmRlclBhc3NcIixcbiAgICBcImJlZ2luVHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICBcImJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXhcIixcbiAgICBcImJlaGF2aW9yXCIsXG4gICAgXCJiZWhhdmlvckNvb2tpZVwiLFxuICAgIFwiYmVoYXZpb3JQYXJ0XCIsXG4gICAgXCJiZWhhdmlvclVybnNcIixcbiAgICBcImJldGFcIixcbiAgICBcImJlemllckN1cnZlVG9cIixcbiAgICBcImJnQ29sb3JcIixcbiAgICBcImJnUHJvcGVydGllc1wiLFxuICAgIFwiYmlhc1wiLFxuICAgIFwiYmlnXCIsXG4gICAgXCJiaWdpbnQ2NFwiLFxuICAgIFwiYmlndWludDY0XCIsXG4gICAgXCJiaW5hcnlUeXBlXCIsXG4gICAgXCJiaW5kXCIsXG4gICAgXCJiaW5kQXR0cmliTG9jYXRpb25cIixcbiAgICBcImJpbmRCdWZmZXJcIixcbiAgICBcImJpbmRCdWZmZXJCYXNlXCIsXG4gICAgXCJiaW5kQnVmZmVyUmFuZ2VcIixcbiAgICBcImJpbmRGcmFtZWJ1ZmZlclwiLFxuICAgIFwiYmluZEdyb3VwTGF5b3V0c1wiLFxuICAgIFwiYmluZFJlbmRlcmJ1ZmZlclwiLFxuICAgIFwiYmluZFNhbXBsZXJcIixcbiAgICBcImJpbmRUZXh0dXJlXCIsXG4gICAgXCJiaW5kVHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICBcImJpbmRWZXJ0ZXhBcnJheVwiLFxuICAgIFwiYmluZGluZ1wiLFxuICAgIFwiYml0bmVzc1wiLFxuICAgIFwiYmxlbmRcIixcbiAgICBcImJsZW5kQ29sb3JcIixcbiAgICBcImJsZW5kRXF1YXRpb25cIixcbiAgICBcImJsZW5kRXF1YXRpb25TZXBhcmF0ZVwiLFxuICAgIFwiYmxlbmRGdW5jXCIsXG4gICAgXCJibGVuZEZ1bmNTZXBhcmF0ZVwiLFxuICAgIFwiYmxpbmtcIixcbiAgICBcImJsaXRGcmFtZWJ1ZmZlclwiLFxuICAgIFwiYmxvYlwiLFxuICAgIFwiYmxvY2stc2l6ZVwiLFxuICAgIFwiYmxvY2tEaXJlY3Rpb25cIixcbiAgICBcImJsb2NrU2l6ZVwiLFxuICAgIFwiYmxvY2tlZFVSSVwiLFxuICAgIFwiYmxvY2tpbmdcIixcbiAgICBcImJsb2NraW5nRHVyYXRpb25cIixcbiAgICBcImJsdWVcIixcbiAgICBcImJsdWV0b290aFwiLFxuICAgIFwiYmx1clwiLFxuICAgIFwiYm9keVwiLFxuICAgIFwiYm9keVVzZWRcIixcbiAgICBcImJvbGRcIixcbiAgICBcImJvb2ttYXJrc1wiLFxuICAgIFwiYm9vbGVhblZhbHVlXCIsXG4gICAgXCJib3JkZXJcIixcbiAgICBcImJvcmRlci1ibG9ja1wiLFxuICAgIFwiYm9yZGVyLWJsb2NrLWNvbG9yXCIsXG4gICAgXCJib3JkZXItYmxvY2stZW5kXCIsXG4gICAgXCJib3JkZXItYmxvY2stZW5kLWNvbG9yXCIsXG4gICAgXCJib3JkZXItYmxvY2stZW5kLXN0eWxlXCIsXG4gICAgXCJib3JkZXItYmxvY2stZW5kLXdpZHRoXCIsXG4gICAgXCJib3JkZXItYmxvY2stc3RhcnRcIixcbiAgICBcImJvcmRlci1ibG9jay1zdGFydC1jb2xvclwiLFxuICAgIFwiYm9yZGVyLWJsb2NrLXN0YXJ0LXN0eWxlXCIsXG4gICAgXCJib3JkZXItYmxvY2stc3RhcnQtd2lkdGhcIixcbiAgICBcImJvcmRlci1ibG9jay1zdHlsZVwiLFxuICAgIFwiYm9yZGVyLWJsb2NrLXdpZHRoXCIsXG4gICAgXCJib3JkZXItYm90dG9tXCIsXG4gICAgXCJib3JkZXItYm90dG9tLWNvbG9yXCIsXG4gICAgXCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXG4gICAgXCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1c1wiLFxuICAgIFwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiLFxuICAgIFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiLFxuICAgIFwiYm9yZGVyLWNvbGxhcHNlXCIsXG4gICAgXCJib3JkZXItY29sb3JcIixcbiAgICBcImJvcmRlci1lbmQtZW5kLXJhZGl1c1wiLFxuICAgIFwiYm9yZGVyLWVuZC1zdGFydC1yYWRpdXNcIixcbiAgICBcImJvcmRlci1pbWFnZVwiLFxuICAgIFwiYm9yZGVyLWltYWdlLW91dHNldFwiLFxuICAgIFwiYm9yZGVyLWltYWdlLXJlcGVhdFwiLFxuICAgIFwiYm9yZGVyLWltYWdlLXNsaWNlXCIsXG4gICAgXCJib3JkZXItaW1hZ2Utc291cmNlXCIsXG4gICAgXCJib3JkZXItaW1hZ2Utd2lkdGhcIixcbiAgICBcImJvcmRlci1pbmxpbmVcIixcbiAgICBcImJvcmRlci1pbmxpbmUtY29sb3JcIixcbiAgICBcImJvcmRlci1pbmxpbmUtZW5kXCIsXG4gICAgXCJib3JkZXItaW5saW5lLWVuZC1jb2xvclwiLFxuICAgIFwiYm9yZGVyLWlubGluZS1lbmQtc3R5bGVcIixcbiAgICBcImJvcmRlci1pbmxpbmUtZW5kLXdpZHRoXCIsXG4gICAgXCJib3JkZXItaW5saW5lLXN0YXJ0XCIsXG4gICAgXCJib3JkZXItaW5saW5lLXN0YXJ0LWNvbG9yXCIsXG4gICAgXCJib3JkZXItaW5saW5lLXN0YXJ0LXN0eWxlXCIsXG4gICAgXCJib3JkZXItaW5saW5lLXN0YXJ0LXdpZHRoXCIsXG4gICAgXCJib3JkZXItaW5saW5lLXN0eWxlXCIsXG4gICAgXCJib3JkZXItaW5saW5lLXdpZHRoXCIsXG4gICAgXCJib3JkZXItbGVmdFwiLFxuICAgIFwiYm9yZGVyLWxlZnQtY29sb3JcIixcbiAgICBcImJvcmRlci1sZWZ0LXN0eWxlXCIsXG4gICAgXCJib3JkZXItbGVmdC13aWR0aFwiLFxuICAgIFwiYm9yZGVyLXJhZGl1c1wiLFxuICAgIFwiYm9yZGVyLXJpZ2h0XCIsXG4gICAgXCJib3JkZXItcmlnaHQtY29sb3JcIixcbiAgICBcImJvcmRlci1yaWdodC1zdHlsZVwiLFxuICAgIFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIsXG4gICAgXCJib3JkZXItc3BhY2luZ1wiLFxuICAgIFwiYm9yZGVyLXN0YXJ0LWVuZC1yYWRpdXNcIixcbiAgICBcImJvcmRlci1zdGFydC1zdGFydC1yYWRpdXNcIixcbiAgICBcImJvcmRlci1zdHlsZVwiLFxuICAgIFwiYm9yZGVyLXRvcFwiLFxuICAgIFwiYm9yZGVyLXRvcC1jb2xvclwiLFxuICAgIFwiYm9yZGVyLXRvcC1sZWZ0LXJhZGl1c1wiLFxuICAgIFwiYm9yZGVyLXRvcC1yaWdodC1yYWRpdXNcIixcbiAgICBcImJvcmRlci10b3Atc3R5bGVcIixcbiAgICBcImJvcmRlci10b3Atd2lkdGhcIixcbiAgICBcImJvcmRlci13aWR0aFwiLFxuICAgIFwiYm9yZGVyQmxvY2tcIixcbiAgICBcImJvcmRlckJsb2NrQ29sb3JcIixcbiAgICBcImJvcmRlckJsb2NrRW5kXCIsXG4gICAgXCJib3JkZXJCbG9ja0VuZENvbG9yXCIsXG4gICAgXCJib3JkZXJCbG9ja0VuZFN0eWxlXCIsXG4gICAgXCJib3JkZXJCbG9ja0VuZFdpZHRoXCIsXG4gICAgXCJib3JkZXJCbG9ja1N0YXJ0XCIsXG4gICAgXCJib3JkZXJCbG9ja1N0YXJ0Q29sb3JcIixcbiAgICBcImJvcmRlckJsb2NrU3RhcnRTdHlsZVwiLFxuICAgIFwiYm9yZGVyQmxvY2tTdGFydFdpZHRoXCIsXG4gICAgXCJib3JkZXJCbG9ja1N0eWxlXCIsXG4gICAgXCJib3JkZXJCbG9ja1dpZHRoXCIsXG4gICAgXCJib3JkZXJCb3R0b21cIixcbiAgICBcImJvcmRlckJvdHRvbUNvbG9yXCIsXG4gICAgXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzXCIsXG4gICAgXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiLFxuICAgIFwiYm9yZGVyQm90dG9tU3R5bGVcIixcbiAgICBcImJvcmRlckJvdHRvbVdpZHRoXCIsXG4gICAgXCJib3JkZXJCb3hTaXplXCIsXG4gICAgXCJib3JkZXJDb2xsYXBzZVwiLFxuICAgIFwiYm9yZGVyQ29sb3JcIixcbiAgICBcImJvcmRlckNvbG9yRGFya1wiLFxuICAgIFwiYm9yZGVyQ29sb3JMaWdodFwiLFxuICAgIFwiYm9yZGVyRW5kRW5kUmFkaXVzXCIsXG4gICAgXCJib3JkZXJFbmRTdGFydFJhZGl1c1wiLFxuICAgIFwiYm9yZGVySW1hZ2VcIixcbiAgICBcImJvcmRlckltYWdlT3V0c2V0XCIsXG4gICAgXCJib3JkZXJJbWFnZVJlcGVhdFwiLFxuICAgIFwiYm9yZGVySW1hZ2VTbGljZVwiLFxuICAgIFwiYm9yZGVySW1hZ2VTb3VyY2VcIixcbiAgICBcImJvcmRlckltYWdlV2lkdGhcIixcbiAgICBcImJvcmRlcklubGluZVwiLFxuICAgIFwiYm9yZGVySW5saW5lQ29sb3JcIixcbiAgICBcImJvcmRlcklubGluZUVuZFwiLFxuICAgIFwiYm9yZGVySW5saW5lRW5kQ29sb3JcIixcbiAgICBcImJvcmRlcklubGluZUVuZFN0eWxlXCIsXG4gICAgXCJib3JkZXJJbmxpbmVFbmRXaWR0aFwiLFxuICAgIFwiYm9yZGVySW5saW5lU3RhcnRcIixcbiAgICBcImJvcmRlcklubGluZVN0YXJ0Q29sb3JcIixcbiAgICBcImJvcmRlcklubGluZVN0YXJ0U3R5bGVcIixcbiAgICBcImJvcmRlcklubGluZVN0YXJ0V2lkdGhcIixcbiAgICBcImJvcmRlcklubGluZVN0eWxlXCIsXG4gICAgXCJib3JkZXJJbmxpbmVXaWR0aFwiLFxuICAgIFwiYm9yZGVyTGVmdFwiLFxuICAgIFwiYm9yZGVyTGVmdENvbG9yXCIsXG4gICAgXCJib3JkZXJMZWZ0U3R5bGVcIixcbiAgICBcImJvcmRlckxlZnRXaWR0aFwiLFxuICAgIFwiYm9yZGVyUmFkaXVzXCIsXG4gICAgXCJib3JkZXJSaWdodFwiLFxuICAgIFwiYm9yZGVyUmlnaHRDb2xvclwiLFxuICAgIFwiYm9yZGVyUmlnaHRTdHlsZVwiLFxuICAgIFwiYm9yZGVyUmlnaHRXaWR0aFwiLFxuICAgIFwiYm9yZGVyU3BhY2luZ1wiLFxuICAgIFwiYm9yZGVyU3RhcnRFbmRSYWRpdXNcIixcbiAgICBcImJvcmRlclN0YXJ0U3RhcnRSYWRpdXNcIixcbiAgICBcImJvcmRlclN0eWxlXCIsXG4gICAgXCJib3JkZXJUb3BcIixcbiAgICBcImJvcmRlclRvcENvbG9yXCIsXG4gICAgXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gICAgXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFxuICAgIFwiYm9yZGVyVG9wU3R5bGVcIixcbiAgICBcImJvcmRlclRvcFdpZHRoXCIsXG4gICAgXCJib3JkZXJXaWR0aFwiLFxuICAgIFwiYm90dG9tXCIsXG4gICAgXCJib3R0b21NYXJnaW5cIixcbiAgICBcImJvdW5kXCIsXG4gICAgXCJib3VuZEVsZW1lbnRzXCIsXG4gICAgXCJib3VuZGluZ0NsaWVudFJlY3RcIixcbiAgICBcImJvdW5kaW5nSGVpZ2h0XCIsXG4gICAgXCJib3VuZGluZ0xlZnRcIixcbiAgICBcImJvdW5kaW5nUmVjdFwiLFxuICAgIFwiYm91bmRpbmdUb3BcIixcbiAgICBcImJvdW5kaW5nV2lkdGhcIixcbiAgICBcImJvdW5kc1wiLFxuICAgIFwiYm91bmRzR2VvbWV0cnlcIixcbiAgICBcImJveC1kZWNvcmF0aW9uLWJyZWFrXCIsXG4gICAgXCJib3gtc2hhZG93XCIsXG4gICAgXCJib3gtc2l6aW5nXCIsXG4gICAgXCJib3hEZWNvcmF0aW9uQnJlYWtcIixcbiAgICBcImJveFNoYWRvd1wiLFxuICAgIFwiYm94U2l6aW5nXCIsXG4gICAgXCJicmFuZFwiLFxuICAgIFwiYnJhbmRzXCIsXG4gICAgXCJicmVhay1hZnRlclwiLFxuICAgIFwiYnJlYWstYmVmb3JlXCIsXG4gICAgXCJicmVhay1pbnNpZGVcIixcbiAgICBcImJyZWFrQWZ0ZXJcIixcbiAgICBcImJyZWFrQmVmb3JlXCIsXG4gICAgXCJicmVha0luc2lkZVwiLFxuICAgIFwiYnJvYWRjYXN0XCIsXG4gICAgXCJicm93c2VyXCIsXG4gICAgXCJicm93c2VyTGFuZ3VhZ2VcIixcbiAgICBcImJyb3dzZXJTZXR0aW5nc1wiLFxuICAgIFwiYnJvd3NpbmdEYXRhXCIsXG4gICAgXCJicm93c2luZ1RvcGljc1wiLFxuICAgIFwiYnRvYVwiLFxuICAgIFwiYnViYmxlc1wiLFxuICAgIFwiYnVmZmVyXCIsXG4gICAgXCJidWZmZXJEYXRhXCIsXG4gICAgXCJidWZmZXJEZXB0aFwiLFxuICAgIFwiYnVmZmVyU2l6ZVwiLFxuICAgIFwiYnVmZmVyU3ViRGF0YVwiLFxuICAgIFwiYnVmZmVyZWRcIixcbiAgICBcImJ1ZmZlcmVkQW1vdW50XCIsXG4gICAgXCJidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZFwiLFxuICAgIFwiYnVmZmVyc1wiLFxuICAgIFwiYnVpbGRJRFwiLFxuICAgIFwiYnVpbGROdW1iZXJcIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwiYnV0dG9uSURcIixcbiAgICBcImJ1dHRvbnNcIixcbiAgICBcImJ5b2JSZXF1ZXN0XCIsXG4gICAgXCJieXRlTGVuZ3RoXCIsXG4gICAgXCJieXRlT2Zmc2V0XCIsXG4gICAgXCJieXRlc1wiLFxuICAgIFwiYnl0ZXNQZXJSb3dcIixcbiAgICBcImJ5dGVzV3JpdHRlblwiLFxuICAgIFwiY1wiLFxuICAgIFwiY2FjaGVcIixcbiAgICBcImNhY2hlc1wiLFxuICAgIFwiY2FsbFwiLFxuICAgIFwiY2FsbGVyXCIsXG4gICAgXCJjYW1lcmFcIixcbiAgICBcImNhbkJlRm9ybWF0dGVkXCIsXG4gICAgXCJjYW5CZU1vdW50ZWRcIixcbiAgICBcImNhbkJlU2hhcmVkXCIsXG4gICAgXCJjYW5Db25zdHJ1Y3RJbkRlZGljYXRlZFdvcmtlclwiLFxuICAgIFwiY2FuR29CYWNrXCIsXG4gICAgXCJjYW5Hb0ZvcndhcmRcIixcbiAgICBcImNhbkhhdmVDaGlsZHJlblwiLFxuICAgIFwiY2FuSGF2ZUhUTUxcIixcbiAgICBcImNhbkluc2VydERUTUZcIixcbiAgICBcImNhbkludGVyY2VwdFwiLFxuICAgIFwiY2FuTG9hZEFkQXVjdGlvbkZlbmNlZEZyYW1lXCIsXG4gICAgXCJjYW5Mb2FkT3BhcXVlVVJMXCIsXG4gICAgXCJjYW5NYWtlUGF5bWVudFwiLFxuICAgIFwiY2FuUGFyc2VcIixcbiAgICBcImNhblBsYXlUeXBlXCIsXG4gICAgXCJjYW5QcmVzZW50XCIsXG4gICAgXCJjYW5TaGFyZVwiLFxuICAgIFwiY2FuVHJhbnNpdGlvblwiLFxuICAgIFwiY2FuVHJpY2tsZUljZUNhbmRpZGF0ZXNcIixcbiAgICBcImNhbmNlbFwiLFxuICAgIFwiY2FuY2VsQW5kSG9sZEF0VGltZVwiLFxuICAgIFwiY2FuY2VsQW5pbWF0aW9uRnJhbWVcIixcbiAgICBcImNhbmNlbEJ1YmJsZVwiLFxuICAgIFwiY2FuY2VsSWRsZUNhbGxiYWNrXCIsXG4gICAgXCJjYW5jZWxTY2hlZHVsZWRWYWx1ZXNcIixcbiAgICBcImNhbmNlbFZpZGVvRnJhbWVDYWxsYmFja1wiLFxuICAgIFwiY2FuY2VsV2F0Y2hBdmFpbGFiaWxpdHlcIixcbiAgICBcImNhbmNlbGFibGVcIixcbiAgICBcImNhbmRpZGF0ZVwiLFxuICAgIFwiY2Fub25pY2FsVVVJRFwiLFxuICAgIFwiY2FudmFzXCIsXG4gICAgXCJjYXBcIixcbiAgICBcImNhcGFiaWxpdGllc1wiLFxuICAgIFwiY2FwdGlvblwiLFxuICAgIFwiY2FwdGlvbi1zaWRlXCIsXG4gICAgXCJjYXB0aW9uU2lkZVwiLFxuICAgIFwiY2FwdGl2ZVBvcnRhbFwiLFxuICAgIFwiY2FwdHVyZVwiLFxuICAgIFwiY2FwdHVyZUV2ZW50c1wiLFxuICAgIFwiY2FwdHVyZVN0YWNrVHJhY2VcIixcbiAgICBcImNhcHR1cmVTdHJlYW1cIixcbiAgICBcImNhcHR1cmVUYWJcIixcbiAgICBcImNhcHR1cmVWaXNpYmxlVGFiXCIsXG4gICAgXCJjYXJldC1jb2xvclwiLFxuICAgIFwiY2FyZXRCaWRpTGV2ZWxcIixcbiAgICBcImNhcmV0Q29sb3JcIixcbiAgICBcImNhcmV0UG9zaXRpb25Gcm9tUG9pbnRcIixcbiAgICBcImNhcmV0UmFuZ2VGcm9tUG9pbnRcIixcbiAgICBcImNhc3RcIixcbiAgICBcImNhdGNoXCIsXG4gICAgXCJjYXRlZ29yeVwiLFxuICAgIFwiY2JydFwiLFxuICAgIFwiY2RcIixcbiAgICBcImNlaWxcIixcbiAgICBcImNlbGxJbmRleFwiLFxuICAgIFwiY2VsbFBhZGRpbmdcIixcbiAgICBcImNlbGxTcGFjaW5nXCIsXG4gICAgXCJjZWxsc1wiLFxuICAgIFwiY2hcIixcbiAgICBcImNoT2ZmXCIsXG4gICAgXCJjaGFpblwiLFxuICAgIFwiY2hhbGxlbmdlXCIsXG4gICAgXCJjaGFuZ2VUeXBlXCIsXG4gICAgXCJjaGFuZ2VkXCIsXG4gICAgXCJjaGFuZ2VkVG91Y2hlc1wiLFxuICAgIFwiY2hhbm5lbFwiLFxuICAgIFwiY2hhbm5lbENvdW50XCIsXG4gICAgXCJjaGFubmVsQ291bnRNb2RlXCIsXG4gICAgXCJjaGFubmVsSW50ZXJwcmV0YXRpb25cIixcbiAgICBcImNoYXB0ZXJJbmZvXCIsXG4gICAgXCJjaGFyXCIsXG4gICAgXCJjaGFyQXRcIixcbiAgICBcImNoYXJDb2RlXCIsXG4gICAgXCJjaGFyQ29kZUF0XCIsXG4gICAgXCJjaGFySW5kZXhcIixcbiAgICBcImNoYXJMZW5ndGhcIixcbiAgICBcImNoYXJhY3RlckJvdW5kc1wiLFxuICAgIFwiY2hhcmFjdGVyQm91bmRzUmFuZ2VTdGFydFwiLFxuICAgIFwiY2hhcmFjdGVyRGF0YVwiLFxuICAgIFwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlXCIsXG4gICAgXCJjaGFyYWN0ZXJTZXRcIixcbiAgICBcImNoYXJhY3RlcmlzdGljXCIsXG4gICAgXCJjaGFyZ2luZ1wiLFxuICAgIFwiY2hhcmdpbmdUaW1lXCIsXG4gICAgXCJjaGFyc2V0XCIsXG4gICAgXCJjaGVja1wiLFxuICAgIFwiY2hlY2tEQ0VcIixcbiAgICBcImNoZWNrRW5jbG9zdXJlXCIsXG4gICAgXCJjaGVja0ZyYW1lYnVmZmVyU3RhdHVzXCIsXG4gICAgXCJjaGVja0ludGVyc2VjdGlvblwiLFxuICAgIFwiY2hlY2tWYWxpZGl0eVwiLFxuICAgIFwiY2hlY2tWaXNpYmlsaXR5XCIsXG4gICAgXCJjaGVja2VkXCIsXG4gICAgXCJjaGlsZEVsZW1lbnRDb3VudFwiLFxuICAgIFwiY2hpbGRMaXN0XCIsXG4gICAgXCJjaGlsZE5vZGVzXCIsXG4gICAgXCJjaGlsZHJlblwiLFxuICAgIFwiY2hyb21lXCIsXG4gICAgXCJjaXBoZXJ0ZXh0XCIsXG4gICAgXCJjaXRlXCIsXG4gICAgXCJjaXR5XCIsXG4gICAgXCJjbGFpbUludGVyZmFjZVwiLFxuICAgIFwiY2xhaW1lZFwiLFxuICAgIFwiY2xhc3NMaXN0XCIsXG4gICAgXCJjbGFzc05hbWVcIixcbiAgICBcImNsYXNzaWRcIixcbiAgICBcImNsZWFyXCIsXG4gICAgXCJjbGVhckFwcEJhZGdlXCIsXG4gICAgXCJjbGVhckF0dHJpYnV0ZXNcIixcbiAgICBcImNsZWFyQnVmZmVyXCIsXG4gICAgXCJjbGVhckJ1ZmZlcmZpXCIsXG4gICAgXCJjbGVhckJ1ZmZlcmZ2XCIsXG4gICAgXCJjbGVhckJ1ZmZlcml2XCIsXG4gICAgXCJjbGVhckJ1ZmZlcnVpdlwiLFxuICAgIFwiY2xlYXJDb2xvclwiLFxuICAgIFwiY2xlYXJEYXRhXCIsXG4gICAgXCJjbGVhckRlcHRoXCIsXG4gICAgXCJjbGVhckhhbHRcIixcbiAgICBcImNsZWFySW1tZWRpYXRlXCIsXG4gICAgXCJjbGVhckludGVydmFsXCIsXG4gICAgXCJjbGVhckxpdmVTZWVrYWJsZVJhbmdlXCIsXG4gICAgXCJjbGVhck1hcmtzXCIsXG4gICAgXCJjbGVhck1heEdDUGF1c2VBY2N1bXVsYXRvclwiLFxuICAgIFwiY2xlYXJNZWFzdXJlc1wiLFxuICAgIFwiY2xlYXJPcmlnaW5Kb2luZWRBZEludGVyZXN0R3JvdXBzXCIsXG4gICAgXCJjbGVhclBhcmFtZXRlcnNcIixcbiAgICBcImNsZWFyUmVjdFwiLFxuICAgIFwiY2xlYXJSZXNvdXJjZVRpbWluZ3NcIixcbiAgICBcImNsZWFyU2hhZG93XCIsXG4gICAgXCJjbGVhclN0ZW5jaWxcIixcbiAgICBcImNsZWFyVGltZW91dFwiLFxuICAgIFwiY2xlYXJWYWx1ZVwiLFxuICAgIFwiY2xlYXJXYXRjaFwiLFxuICAgIFwiY2xpY2tcIixcbiAgICBcImNsaWNrQ291bnRcIixcbiAgICBcImNsaWVudERhdGFKU09OXCIsXG4gICAgXCJjbGllbnRIZWlnaHRcIixcbiAgICBcImNsaWVudEluZm9ybWF0aW9uXCIsXG4gICAgXCJjbGllbnRMZWZ0XCIsXG4gICAgXCJjbGllbnRSZWN0XCIsXG4gICAgXCJjbGllbnRSZWN0c1wiLFxuICAgIFwiY2xpZW50VG9wXCIsXG4gICAgXCJjbGllbnRXYWl0U3luY1wiLFxuICAgIFwiY2xpZW50V2lkdGhcIixcbiAgICBcImNsaWVudFhcIixcbiAgICBcImNsaWVudFlcIixcbiAgICBcImNsaXBcIixcbiAgICBcImNsaXAtcGF0aFwiLFxuICAgIFwiY2xpcC1ydWxlXCIsXG4gICAgXCJjbGlwQm90dG9tXCIsXG4gICAgXCJjbGlwTGVmdFwiLFxuICAgIFwiY2xpcFBhdGhcIixcbiAgICBcImNsaXBQYXRoVW5pdHNcIixcbiAgICBcImNsaXBSaWdodFwiLFxuICAgIFwiY2xpcFJ1bGVcIixcbiAgICBcImNsaXBUb3BcIixcbiAgICBcImNsaXBib2FyZFwiLFxuICAgIFwiY2xpcGJvYXJkRGF0YVwiLFxuICAgIFwiY2xvbmFibGVcIixcbiAgICBcImNsb25lXCIsXG4gICAgXCJjbG9uZUNvbnRlbnRzXCIsXG4gICAgXCJjbG9uZU5vZGVcIixcbiAgICBcImNsb25lUmFuZ2VcIixcbiAgICBcImNsb3NlXCIsXG4gICAgXCJjbG9zZUNvZGVcIixcbiAgICBcImNsb3NlUGF0aFwiLFxuICAgIFwiY2xvc2VkXCIsXG4gICAgXCJjbG9zZXN0XCIsXG4gICAgXCJjbHpcIixcbiAgICBcImNsejMyXCIsXG4gICAgXCJjbVwiLFxuICAgIFwiY21wXCIsXG4gICAgXCJjb2RlXCIsXG4gICAgXCJjb2RlQmFzZVwiLFxuICAgIFwiY29kZVBvaW50QXRcIixcbiAgICBcImNvZGVUeXBlXCIsXG4gICAgXCJjb2RlZEhlaWdodFwiLFxuICAgIFwiY29kZWRSZWN0XCIsXG4gICAgXCJjb2RlZFdpZHRoXCIsXG4gICAgXCJjb2xTcGFuXCIsXG4gICAgXCJjb2xsYXBzZVwiLFxuICAgIFwiY29sbGFwc2VUb0VuZFwiLFxuICAgIFwiY29sbGFwc2VUb1N0YXJ0XCIsXG4gICAgXCJjb2xsYXBzZWRcIixcbiAgICBcImNvbGxlY3RcIixcbiAgICBcImNvbGxlY3Rpb25zXCIsXG4gICAgXCJjb2xub1wiLFxuICAgIFwiY29sb3JcIixcbiAgICBcImNvbG9yLWFkanVzdFwiLFxuICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiLFxuICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsXG4gICAgXCJjb2xvci1zY2hlbWVcIixcbiAgICBcImNvbG9yQWRqdXN0XCIsXG4gICAgXCJjb2xvckF0dGFjaG1lbnRzXCIsXG4gICAgXCJjb2xvckRlcHRoXCIsXG4gICAgXCJjb2xvckZvcm1hdHNcIixcbiAgICBcImNvbG9ySW50ZXJwb2xhdGlvblwiLFxuICAgIFwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc1wiLFxuICAgIFwiY29sb3JNYXNrXCIsXG4gICAgXCJjb2xvclNjaGVtZVwiLFxuICAgIFwiY29sb3JTcGFjZVwiLFxuICAgIFwiY29sb3JUeXBlXCIsXG4gICAgXCJjb2xzXCIsXG4gICAgXCJjb2x1bW4tY291bnRcIixcbiAgICBcImNvbHVtbi1maWxsXCIsXG4gICAgXCJjb2x1bW4tZ2FwXCIsXG4gICAgXCJjb2x1bW4tcnVsZVwiLFxuICAgIFwiY29sdW1uLXJ1bGUtY29sb3JcIixcbiAgICBcImNvbHVtbi1ydWxlLXN0eWxlXCIsXG4gICAgXCJjb2x1bW4tcnVsZS13aWR0aFwiLFxuICAgIFwiY29sdW1uLXNwYW5cIixcbiAgICBcImNvbHVtbi13aWR0aFwiLFxuICAgIFwiY29sdW1uQ291bnRcIixcbiAgICBcImNvbHVtbkZpbGxcIixcbiAgICBcImNvbHVtbkdhcFwiLFxuICAgIFwiY29sdW1uTnVtYmVyXCIsXG4gICAgXCJjb2x1bW5SdWxlXCIsXG4gICAgXCJjb2x1bW5SdWxlQ29sb3JcIixcbiAgICBcImNvbHVtblJ1bGVTdHlsZVwiLFxuICAgIFwiY29sdW1uUnVsZVdpZHRoXCIsXG4gICAgXCJjb2x1bW5TcGFuXCIsXG4gICAgXCJjb2x1bW5XaWR0aFwiLFxuICAgIFwiY29sdW1uc1wiLFxuICAgIFwiY29tbWFuZFwiLFxuICAgIFwiY29tbWFuZHNcIixcbiAgICBcImNvbW1pdFwiLFxuICAgIFwiY29tbWl0TG9hZFRpbWVcIixcbiAgICBcImNvbW1pdFByZWZlcmVuY2VzXCIsXG4gICAgXCJjb21taXRTdHlsZXNcIixcbiAgICBcImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyXCIsXG4gICAgXCJjb21wYWN0XCIsXG4gICAgXCJjb21wYXJlXCIsXG4gICAgXCJjb21wYXJlQm91bmRhcnlQb2ludHNcIixcbiAgICBcImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXCIsXG4gICAgXCJjb21wYXJlRW5kUG9pbnRzXCIsXG4gICAgXCJjb21wYXJlRXhjaGFuZ2VcIixcbiAgICBcImNvbXBhcmVOb2RlXCIsXG4gICAgXCJjb21wYXJlUG9pbnRcIixcbiAgICBcImNvbXBhdE1vZGVcIixcbiAgICBcImNvbXBhdGlibGVcIixcbiAgICBcImNvbXBpbGVcIixcbiAgICBcImNvbXBpbGVTaGFkZXJcIixcbiAgICBcImNvbXBpbGVTdHJlYW1pbmdcIixcbiAgICBcImNvbXBsZXRlXCIsXG4gICAgXCJjb21wbGV0ZWRcIixcbiAgICBcImNvbXBvbmVudFwiLFxuICAgIFwiY29tcG9uZW50RnJvbVBvaW50XCIsXG4gICAgXCJjb21wb3NlZFwiLFxuICAgIFwiY29tcG9zZWRQYXRoXCIsXG4gICAgXCJjb21wb3NpdGVcIixcbiAgICBcImNvbXBvc2l0aW9uRW5kT2Zmc2V0XCIsXG4gICAgXCJjb21wb3NpdGlvblN0YXJ0T2Zmc2V0XCIsXG4gICAgXCJjb21wcmVzc2VkVGV4SW1hZ2UyRFwiLFxuICAgIFwiY29tcHJlc3NlZFRleEltYWdlM0RcIixcbiAgICBcImNvbXByZXNzZWRUZXhTdWJJbWFnZTJEXCIsXG4gICAgXCJjb21wcmVzc2VkVGV4U3ViSW1hZ2UzRFwiLFxuICAgIFwiY29tcHV0ZVwiLFxuICAgIFwiY29tcHV0ZWRTdHlsZU1hcFwiLFxuICAgIFwiY29uY2F0XCIsXG4gICAgXCJjb25kaXRpb25UZXh0XCIsXG4gICAgXCJjb25lSW5uZXJBbmdsZVwiLFxuICAgIFwiY29uZU91dGVyQW5nbGVcIixcbiAgICBcImNvbmVPdXRlckdhaW5cIixcbiAgICBcImNvbmZpZ1wiLFxuICAgIFwiY29uZmlndXJhYmxlXCIsXG4gICAgXCJjb25maWd1cmF0aW9uXCIsXG4gICAgXCJjb25maWd1cmF0aW9uTmFtZVwiLFxuICAgIFwiY29uZmlndXJhdGlvblZhbHVlXCIsXG4gICAgXCJjb25maWd1cmF0aW9uc1wiLFxuICAgIFwiY29uZmlndXJlXCIsXG4gICAgXCJjb25maXJtXCIsXG4gICAgXCJjb25maXJtQ29tcG9zaXRpb25cIixcbiAgICBcImNvbmZpcm1TaXRlU3BlY2lmaWNUcmFja2luZ0V4Y2VwdGlvblwiLFxuICAgIFwiY29uZmlybVdlYldpZGVUcmFja2luZ0V4Y2VwdGlvblwiLFxuICAgIFwiY29uZ2VzdGlvbkNvbnRyb2xcIixcbiAgICBcImNvbm5lY3RcIixcbiAgICBcImNvbm5lY3RFbmRcIixcbiAgICBcImNvbm5lY3ROYXRpdmVcIixcbiAgICBcImNvbm5lY3RTaGFya1wiLFxuICAgIFwiY29ubmVjdFN0YXJ0XCIsXG4gICAgXCJjb25uZWN0ZWRcIixcbiAgICBcImNvbm5lY3RlZENhbGxiYWNrXCIsXG4gICAgXCJjb25uZWN0aW9uXCIsXG4gICAgXCJjb25uZWN0aW9uSW5mb1wiLFxuICAgIFwiY29ubmVjdGlvbkxpc3RcIixcbiAgICBcImNvbm5lY3Rpb25TcGVlZFwiLFxuICAgIFwiY29ubmVjdGlvblN0YXRlXCIsXG4gICAgXCJjb25uZWN0aW9uc1wiLFxuICAgIFwiY29uc29sZVwiLFxuICAgIFwiY29uc29saWRhdGVcIixcbiAgICBcImNvbnN0YW50c1wiLFxuICAgIFwiY29uc3RyYWludFwiLFxuICAgIFwiY29uc3RyaWN0aW9uQWN0aXZlXCIsXG4gICAgXCJjb25zdHJ1Y3RcIixcbiAgICBcImNvbnN0cnVjdG9yXCIsXG4gICAgXCJjb250YWN0SURcIixcbiAgICBcImNvbnRhaW5cIixcbiAgICBcImNvbnRhaW4taW50cmluc2ljLWJsb2NrLXNpemVcIixcbiAgICBcImNvbnRhaW4taW50cmluc2ljLWhlaWdodFwiLFxuICAgIFwiY29udGFpbi1pbnRyaW5zaWMtaW5saW5lLXNpemVcIixcbiAgICBcImNvbnRhaW4taW50cmluc2ljLXNpemVcIixcbiAgICBcImNvbnRhaW4taW50cmluc2ljLXdpZHRoXCIsXG4gICAgXCJjb250YWluSW50cmluc2ljQmxvY2tTaXplXCIsXG4gICAgXCJjb250YWluSW50cmluc2ljSGVpZ2h0XCIsXG4gICAgXCJjb250YWluSW50cmluc2ljSW5saW5lU2l6ZVwiLFxuICAgIFwiY29udGFpbkludHJpbnNpY1NpemVcIixcbiAgICBcImNvbnRhaW5JbnRyaW5zaWNXaWR0aFwiLFxuICAgIFwiY29udGFpbmVyXCIsXG4gICAgXCJjb250YWluZXItbmFtZVwiLFxuICAgIFwiY29udGFpbmVyLXR5cGVcIixcbiAgICBcImNvbnRhaW5lcklkXCIsXG4gICAgXCJjb250YWluZXJOYW1lXCIsXG4gICAgXCJjb250YWluZXJRdWVyeVwiLFxuICAgIFwiY29udGFpbmVyU3JjXCIsXG4gICAgXCJjb250YWluZXJUeXBlXCIsXG4gICAgXCJjb250YWluc1wiLFxuICAgIFwiY29udGFpbnNOb2RlXCIsXG4gICAgXCJjb250ZW50XCIsXG4gICAgXCJjb250ZW50LXZpc2liaWxpdHlcIixcbiAgICBcImNvbnRlbnRCb3hTaXplXCIsXG4gICAgXCJjb250ZW50RG9jdW1lbnRcIixcbiAgICBcImNvbnRlbnRFZGl0YWJsZVwiLFxuICAgIFwiY29udGVudEhpbnRcIixcbiAgICBcImNvbnRlbnRPdmVyZmxvd1wiLFxuICAgIFwiY29udGVudFJlY3RcIixcbiAgICBcImNvbnRlbnRTY3JpcHRUeXBlXCIsXG4gICAgXCJjb250ZW50U3R5bGVUeXBlXCIsXG4gICAgXCJjb250ZW50VHlwZVwiLFxuICAgIFwiY29udGVudFZpc2liaWxpdHlcIixcbiAgICBcImNvbnRlbnRXaW5kb3dcIixcbiAgICBcImNvbnRleHRcIixcbiAgICBcImNvbnRleHRJZFwiLFxuICAgIFwiY29udGV4dElkc1wiLFxuICAgIFwiY29udGV4dE1lbnVcIixcbiAgICBcImNvbnRleHRNZW51c1wiLFxuICAgIFwiY29udGV4dFR5cGVcIixcbiAgICBcImNvbnRleHRUeXBlc1wiLFxuICAgIFwiY29udGV4dG1lbnVcIixcbiAgICBcImNvbnRleHR1YWxJZGVudGl0aWVzXCIsXG4gICAgXCJjb250aW51ZVwiLFxuICAgIFwiY29udGludWVQcmltYXJ5S2V5XCIsXG4gICAgXCJjb250aW51b3VzXCIsXG4gICAgXCJjb250cm9sXCIsXG4gICAgXCJjb250cm9sVHJhbnNmZXJJblwiLFxuICAgIFwiY29udHJvbFRyYW5zZmVyT3V0XCIsXG4gICAgXCJjb250cm9sbGVyXCIsXG4gICAgXCJjb250cm9sc1wiLFxuICAgIFwiY29udHJvbHNMaXN0XCIsXG4gICAgXCJjb252ZXJ0UG9pbnRGcm9tTm9kZVwiLFxuICAgIFwiY29udmVydFF1YWRGcm9tTm9kZVwiLFxuICAgIFwiY29udmVydFJlY3RGcm9tTm9kZVwiLFxuICAgIFwiY29udmVydFRvQmxvYlwiLFxuICAgIFwiY29udmVydFRvU3BlY2lmaWVkVW5pdHNcIixcbiAgICBcImNvb2tpZVwiLFxuICAgIFwiY29va2llRW5hYmxlZFwiLFxuICAgIFwiY29va2llU3RvcmVcIixcbiAgICBcImNvb2tpZXNcIixcbiAgICBcImNvb3Jkc1wiLFxuICAgIFwiY29weUJ1ZmZlclN1YkRhdGFcIixcbiAgICBcImNvcHlCdWZmZXJUb0J1ZmZlclwiLFxuICAgIFwiY29weUJ1ZmZlclRvVGV4dHVyZVwiLFxuICAgIFwiY29weUV4dGVybmFsSW1hZ2VUb1RleHR1cmVcIixcbiAgICBcImNvcHlGcm9tQ2hhbm5lbFwiLFxuICAgIFwiY29weVRleEltYWdlMkRcIixcbiAgICBcImNvcHlUZXhTdWJJbWFnZTJEXCIsXG4gICAgXCJjb3B5VGV4U3ViSW1hZ2UzRFwiLFxuICAgIFwiY29weVRleHR1cmVUb0J1ZmZlclwiLFxuICAgIFwiY29weVRleHR1cmVUb1RleHR1cmVcIixcbiAgICBcImNvcHlUb1wiLFxuICAgIFwiY29weVRvQ2hhbm5lbFwiLFxuICAgIFwiY29weVdpdGhpblwiLFxuICAgIFwiY29ycmVzcG9uZGluZ0VsZW1lbnRcIixcbiAgICBcImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50XCIsXG4gICAgXCJjb3JydXB0ZWRWaWRlb0ZyYW1lc1wiLFxuICAgIFwiY29zXCIsXG4gICAgXCJjb3NoXCIsXG4gICAgXCJjb3VudFwiLFxuICAgIFwiY291bnRSZXNldFwiLFxuICAgIFwiY291bnRlci1pbmNyZW1lbnRcIixcbiAgICBcImNvdW50ZXItcmVzZXRcIixcbiAgICBcImNvdW50ZXItc2V0XCIsXG4gICAgXCJjb3VudGVySW5jcmVtZW50XCIsXG4gICAgXCJjb3VudGVyUmVzZXRcIixcbiAgICBcImNvdW50ZXJTZXRcIixcbiAgICBcImNvdW50cnlcIixcbiAgICBcImNwdUNsYXNzXCIsXG4gICAgXCJjcHVTbGVlcEFsbG93ZWRcIixcbiAgICBcImNxYlwiLFxuICAgIFwiY3FoXCIsXG4gICAgXCJjcWlcIixcbiAgICBcImNxbWF4XCIsXG4gICAgXCJjcW1pblwiLFxuICAgIFwiY3F3XCIsXG4gICAgXCJjcmVhdGVcIixcbiAgICBcImNyZWF0ZUFuYWx5c2VyXCIsXG4gICAgXCJjcmVhdGVBbmNob3JcIixcbiAgICBcImNyZWF0ZUFuc3dlclwiLFxuICAgIFwiY3JlYXRlQXR0cmlidXRlXCIsXG4gICAgXCJjcmVhdGVBdHRyaWJ1dGVOU1wiLFxuICAgIFwiY3JlYXRlQXVjdGlvbk5vbmNlXCIsXG4gICAgXCJjcmVhdGVCaWRpcmVjdGlvbmFsU3RyZWFtXCIsXG4gICAgXCJjcmVhdGVCaW5kR3JvdXBcIixcbiAgICBcImNyZWF0ZUJpbmRHcm91cExheW91dFwiLFxuICAgIFwiY3JlYXRlQmlxdWFkRmlsdGVyXCIsXG4gICAgXCJjcmVhdGVCdWZmZXJcIixcbiAgICBcImNyZWF0ZUJ1ZmZlclNvdXJjZVwiLFxuICAgIFwiY3JlYXRlQ0RBVEFTZWN0aW9uXCIsXG4gICAgXCJjcmVhdGVDU1NTdHlsZVNoZWV0XCIsXG4gICAgXCJjcmVhdGVDYXB0aW9uXCIsXG4gICAgXCJjcmVhdGVDaGFubmVsTWVyZ2VyXCIsXG4gICAgXCJjcmVhdGVDaGFubmVsU3BsaXR0ZXJcIixcbiAgICBcImNyZWF0ZUNvbW1hbmRFbmNvZGVyXCIsXG4gICAgXCJjcmVhdGVDb21tZW50XCIsXG4gICAgXCJjcmVhdGVDb21wdXRlUGlwZWxpbmVcIixcbiAgICBcImNyZWF0ZUNvbXB1dGVQaXBlbGluZUFzeW5jXCIsXG4gICAgXCJjcmVhdGVDb25pY0dyYWRpZW50XCIsXG4gICAgXCJjcmVhdGVDb25zdGFudFNvdXJjZVwiLFxuICAgIFwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50XCIsXG4gICAgXCJjcmVhdGVDb250cm9sUmFuZ2VcIixcbiAgICBcImNyZWF0ZUNvbnZvbHZlclwiLFxuICAgIFwiY3JlYXRlRFRNRlNlbmRlclwiLFxuICAgIFwiY3JlYXRlRGF0YUNoYW5uZWxcIixcbiAgICBcImNyZWF0ZURlbGF5XCIsXG4gICAgXCJjcmVhdGVEZWxheU5vZGVcIixcbiAgICBcImNyZWF0ZURvY3VtZW50XCIsXG4gICAgXCJjcmVhdGVEb2N1bWVudEZyYWdtZW50XCIsXG4gICAgXCJjcmVhdGVEb2N1bWVudFR5cGVcIixcbiAgICBcImNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvclwiLFxuICAgIFwiY3JlYXRlRWxlbWVudFwiLFxuICAgIFwiY3JlYXRlRWxlbWVudE5TXCIsXG4gICAgXCJjcmVhdGVFbmNvZGVkU3RyZWFtc1wiLFxuICAgIFwiY3JlYXRlRW50aXR5UmVmZXJlbmNlXCIsXG4gICAgXCJjcmVhdGVFdmVudFwiLFxuICAgIFwiY3JlYXRlRXZlbnRPYmplY3RcIixcbiAgICBcImNyZWF0ZUV4cHJlc3Npb25cIixcbiAgICBcImNyZWF0ZUZyYW1lYnVmZmVyXCIsXG4gICAgXCJjcmVhdGVGdW5jdGlvblwiLFxuICAgIFwiY3JlYXRlR2FpblwiLFxuICAgIFwiY3JlYXRlR2Fpbk5vZGVcIixcbiAgICBcImNyZWF0ZUhUTUxcIixcbiAgICBcImNyZWF0ZUhUTUxEb2N1bWVudFwiLFxuICAgIFwiY3JlYXRlSUlSRmlsdGVyXCIsXG4gICAgXCJjcmVhdGVJbWFnZUJpdG1hcFwiLFxuICAgIFwiY3JlYXRlSW1hZ2VEYXRhXCIsXG4gICAgXCJjcmVhdGVJbmRleFwiLFxuICAgIFwiY3JlYXRlSmF2YVNjcmlwdE5vZGVcIixcbiAgICBcImNyZWF0ZUxpbmVhckdyYWRpZW50XCIsXG4gICAgXCJjcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2VcIixcbiAgICBcImNyZWF0ZU1lZGlhS2V5c1wiLFxuICAgIFwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvblwiLFxuICAgIFwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2VcIixcbiAgICBcImNyZWF0ZU1lZGlhU3RyZWFtVHJhY2tTb3VyY2VcIixcbiAgICBcImNyZWF0ZU11dGFibGVGaWxlXCIsXG4gICAgXCJjcmVhdGVOU1Jlc29sdmVyXCIsXG4gICAgXCJjcmVhdGVOb2RlSXRlcmF0b3JcIixcbiAgICBcImNyZWF0ZU5vdGlmaWNhdGlvblwiLFxuICAgIFwiY3JlYXRlT2JqZWN0U3RvcmVcIixcbiAgICBcImNyZWF0ZU9iamVjdFVSTFwiLFxuICAgIFwiY3JlYXRlT2ZmZXJcIixcbiAgICBcImNyZWF0ZU9zY2lsbGF0b3JcIixcbiAgICBcImNyZWF0ZVBhbm5lclwiLFxuICAgIFwiY3JlYXRlUGF0dGVyblwiLFxuICAgIFwiY3JlYXRlUGVyaW9kaWNXYXZlXCIsXG4gICAgXCJjcmVhdGVQaXBlbGluZUxheW91dFwiLFxuICAgIFwiY3JlYXRlUG9saWN5XCIsXG4gICAgXCJjcmVhdGVQb3B1cFwiLFxuICAgIFwiY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uXCIsXG4gICAgXCJjcmVhdGVQcm9ncmFtXCIsXG4gICAgXCJjcmVhdGVRdWVyeVwiLFxuICAgIFwiY3JlYXRlUXVlcnlTZXRcIixcbiAgICBcImNyZWF0ZVJhZGlhbEdyYWRpZW50XCIsXG4gICAgXCJjcmVhdGVSYW5nZVwiLFxuICAgIFwiY3JlYXRlUmFuZ2VDb2xsZWN0aW9uXCIsXG4gICAgXCJjcmVhdGVSZWFkZXJcIixcbiAgICBcImNyZWF0ZVJlbmRlckJ1bmRsZUVuY29kZXJcIixcbiAgICBcImNyZWF0ZVJlbmRlclBpcGVsaW5lXCIsXG4gICAgXCJjcmVhdGVSZW5kZXJQaXBlbGluZUFzeW5jXCIsXG4gICAgXCJjcmVhdGVSZW5kZXJidWZmZXJcIixcbiAgICBcImNyZWF0ZVNWR0FuZ2xlXCIsXG4gICAgXCJjcmVhdGVTVkdMZW5ndGhcIixcbiAgICBcImNyZWF0ZVNWR01hdHJpeFwiLFxuICAgIFwiY3JlYXRlU1ZHTnVtYmVyXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQXJjQWJzXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQXJjUmVsXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ2xvc2VQYXRoXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljQWJzXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljUmVsXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoQWJzXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoUmVsXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0Fic1wiLFxuICAgIFwiY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNSZWxcIixcbiAgICBcImNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aFJlbFwiLFxuICAgIFwiY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0Fic1wiLFxuICAgIFwiY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxBYnNcIixcbiAgICBcImNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsUmVsXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnTGluZXRvUmVsXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnTGluZXRvVmVydGljYWxBYnNcIixcbiAgICBcImNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbFwiLFxuICAgIFwiY3JlYXRlU1ZHUGF0aFNlZ01vdmV0b0Fic1wiLFxuICAgIFwiY3JlYXRlU1ZHUGF0aFNlZ01vdmV0b1JlbFwiLFxuICAgIFwiY3JlYXRlU1ZHUG9pbnRcIixcbiAgICBcImNyZWF0ZVNWR1JlY3RcIixcbiAgICBcImNyZWF0ZVNWR1RyYW5zZm9ybVwiLFxuICAgIFwiY3JlYXRlU1ZHVHJhbnNmb3JtRnJvbU1hdHJpeFwiLFxuICAgIFwiY3JlYXRlU2FtcGxlclwiLFxuICAgIFwiY3JlYXRlU2NyaXB0XCIsXG4gICAgXCJjcmVhdGVTY3JpcHRQcm9jZXNzb3JcIixcbiAgICBcImNyZWF0ZVNjcmlwdFVSTFwiLFxuICAgIFwiY3JlYXRlU2Vzc2lvblwiLFxuICAgIFwiY3JlYXRlU2hhZGVyXCIsXG4gICAgXCJjcmVhdGVTaGFkZXJNb2R1bGVcIixcbiAgICBcImNyZWF0ZVNoYWRvd1Jvb3RcIixcbiAgICBcImNyZWF0ZVN0ZXJlb1Bhbm5lclwiLFxuICAgIFwiY3JlYXRlU3R5bGVTaGVldFwiLFxuICAgIFwiY3JlYXRlVEJvZHlcIixcbiAgICBcImNyZWF0ZVRGb290XCIsXG4gICAgXCJjcmVhdGVUSGVhZFwiLFxuICAgIFwiY3JlYXRlVGFza1wiLFxuICAgIFwiY3JlYXRlVGV4dE5vZGVcIixcbiAgICBcImNyZWF0ZVRleHRSYW5nZVwiLFxuICAgIFwiY3JlYXRlVGV4dHVyZVwiLFxuICAgIFwiY3JlYXRlVG91Y2hcIixcbiAgICBcImNyZWF0ZVRvdWNoTGlzdFwiLFxuICAgIFwiY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICBcImNyZWF0ZVRyZWVXYWxrZXJcIixcbiAgICBcImNyZWF0ZVVuaWRpcmVjdGlvbmFsU3RyZWFtXCIsXG4gICAgXCJjcmVhdGVWZXJ0ZXhBcnJheVwiLFxuICAgIFwiY3JlYXRlVmlld1wiLFxuICAgIFwiY3JlYXRlV2F2ZVNoYXBlclwiLFxuICAgIFwiY3JlYXRlV29ya2xldFwiLFxuICAgIFwiY3JlYXRlV3JpdGFibGVcIixcbiAgICBcImNyZWF0aW9uVGltZVwiLFxuICAgIFwiY3JlZGVudGlhbGxlc3NcIixcbiAgICBcImNyZWRlbnRpYWxzXCIsXG4gICAgXCJjcml0aWNhbENIUmVzdGFydFwiLFxuICAgIFwiY3JvcFRvXCIsXG4gICAgXCJjcm9zc09yaWdpblwiLFxuICAgIFwiY3Jvc3NPcmlnaW5Jc29sYXRlZFwiLFxuICAgIFwiY3J5cHRvXCIsXG4gICAgXCJjc2lcIixcbiAgICBcImNzcFwiLFxuICAgIFwiY3NzRmxvYXRcIixcbiAgICBcImNzc1J1bGVzXCIsXG4gICAgXCJjc3NUZXh0XCIsXG4gICAgXCJjc3NWYWx1ZVR5cGVcIixcbiAgICBcImN0cmxLZXlcIixcbiAgICBcImN0cmxMZWZ0XCIsXG4gICAgXCJjdWVzXCIsXG4gICAgXCJjdWxsRmFjZVwiLFxuICAgIFwiY3VsbE1vZGVcIixcbiAgICBcImN1cnJlbnRDU1Nab29tXCIsXG4gICAgXCJjdXJyZW50RGlyZWN0aW9uXCIsXG4gICAgXCJjdXJyZW50RW50cnlcIixcbiAgICBcImN1cnJlbnRMb2NhbERlc2NyaXB0aW9uXCIsXG4gICAgXCJjdXJyZW50Tm9kZVwiLFxuICAgIFwiY3VycmVudFBhZ2VcIixcbiAgICBcImN1cnJlbnRSZWN0XCIsXG4gICAgXCJjdXJyZW50UmVtb3RlRGVzY3JpcHRpb25cIixcbiAgICBcImN1cnJlbnRTY2FsZVwiLFxuICAgIFwiY3VycmVudFNjcmVlblwiLFxuICAgIFwiY3VycmVudFNjcmlwdFwiLFxuICAgIFwiY3VycmVudFNyY1wiLFxuICAgIFwiY3VycmVudFN0YXRlXCIsXG4gICAgXCJjdXJyZW50U3R5bGVcIixcbiAgICBcImN1cnJlbnRUYXJnZXRcIixcbiAgICBcImN1cnJlbnRUaW1lXCIsXG4gICAgXCJjdXJyZW50VHJhbnNsYXRlXCIsXG4gICAgXCJjdXJyZW50Vmlld1wiLFxuICAgIFwiY3Vyc29yXCIsXG4gICAgXCJjdXJ2ZVwiLFxuICAgIFwiY3VzdG9tRWxlbWVudHNcIixcbiAgICBcImN1c3RvbUVycm9yXCIsXG4gICAgXCJjeFwiLFxuICAgIFwiY3lcIixcbiAgICBcImRcIixcbiAgICBcImRhdGFcIixcbiAgICBcImRhdGFGbGRcIixcbiAgICBcImRhdGFGb3JtYXRBc1wiLFxuICAgIFwiZGF0YUxvc3NcIixcbiAgICBcImRhdGFMb3NzTWVzc2FnZVwiLFxuICAgIFwiZGF0YVBhZ2VTaXplXCIsXG4gICAgXCJkYXRhU3JjXCIsXG4gICAgXCJkYXRhVHJhbnNmZXJcIixcbiAgICBcImRhdGFiYXNlXCIsXG4gICAgXCJkYXRhYmFzZXNcIixcbiAgICBcImRhdGFncmFtc1wiLFxuICAgIFwiZGF0YXNldFwiLFxuICAgIFwiZGF0ZVRpbWVcIixcbiAgICBcImRiXCIsXG4gICAgXCJkZWJ1Z1wiLFxuICAgIFwiZGVidWdnZXJFbmFibGVkXCIsXG4gICAgXCJkZWNsYXJhdGl2ZU5ldFJlcXVlc3RcIixcbiAgICBcImRlY2xhcmVcIixcbiAgICBcImRlY29kZVwiLFxuICAgIFwiZGVjb2RlQXVkaW9EYXRhXCIsXG4gICAgXCJkZWNvZGVRdWV1ZVNpemVcIixcbiAgICBcImRlY29kZVVSSVwiLFxuICAgIFwiZGVjb2RlVVJJQ29tcG9uZW50XCIsXG4gICAgXCJkZWNvZGVkQm9keVNpemVcIixcbiAgICBcImRlY29kaW5nXCIsXG4gICAgXCJkZWNvZGluZ0luZm9cIixcbiAgICBcImRlY3J5cHRcIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImRlZmF1bHRDaGFyc2V0XCIsXG4gICAgXCJkZWZhdWx0Q2hlY2tlZFwiLFxuICAgIFwiZGVmYXVsdE11dGVkXCIsXG4gICAgXCJkZWZhdWx0UGxheWJhY2tSYXRlXCIsXG4gICAgXCJkZWZhdWx0UG9saWN5XCIsXG4gICAgXCJkZWZhdWx0UHJldmVudGVkXCIsXG4gICAgXCJkZWZhdWx0UXVldWVcIixcbiAgICBcImRlZmF1bHRSZXF1ZXN0XCIsXG4gICAgXCJkZWZhdWx0U2VsZWN0ZWRcIixcbiAgICBcImRlZmF1bHRTdGF0dXNcIixcbiAgICBcImRlZmF1bHRVUkxcIixcbiAgICBcImRlZmF1bHRWYWx1ZVwiLFxuICAgIFwiZGVmYXVsdFZpZXdcIixcbiAgICBcImRlZmF1bHRzdGF0dXNcIixcbiAgICBcImRlZmVyXCIsXG4gICAgXCJkZWZpbmVcIixcbiAgICBcImRlZmluZU1hZ2ljRnVuY3Rpb25cIixcbiAgICBcImRlZmluZU1hZ2ljVmFyaWFibGVcIixcbiAgICBcImRlZmluZVByb3BlcnRpZXNcIixcbiAgICBcImRlZmluZVByb3BlcnR5XCIsXG4gICAgXCJkZWdcIixcbiAgICBcImRlbGF5XCIsXG4gICAgXCJkZWxheVRpbWVcIixcbiAgICBcImRlbGVnYXRlc0ZvY3VzXCIsXG4gICAgXCJkZWxldGVcIixcbiAgICBcImRlbGV0ZUJ1ZmZlclwiLFxuICAgIFwiZGVsZXRlQ2FwdGlvblwiLFxuICAgIFwiZGVsZXRlQ2VsbFwiLFxuICAgIFwiZGVsZXRlQ29udGVudHNcIixcbiAgICBcImRlbGV0ZURhdGFcIixcbiAgICBcImRlbGV0ZURhdGFiYXNlXCIsXG4gICAgXCJkZWxldGVGcmFtZWJ1ZmZlclwiLFxuICAgIFwiZGVsZXRlRnJvbURvY3VtZW50XCIsXG4gICAgXCJkZWxldGVJbmRleFwiLFxuICAgIFwiZGVsZXRlTWVkaXVtXCIsXG4gICAgXCJkZWxldGVPYmplY3RTdG9yZVwiLFxuICAgIFwiZGVsZXRlUHJvZ3JhbVwiLFxuICAgIFwiZGVsZXRlUHJvcGVydHlcIixcbiAgICBcImRlbGV0ZVF1ZXJ5XCIsXG4gICAgXCJkZWxldGVSZW5kZXJidWZmZXJcIixcbiAgICBcImRlbGV0ZVJvd1wiLFxuICAgIFwiZGVsZXRlUnVsZVwiLFxuICAgIFwiZGVsZXRlU2FtcGxlclwiLFxuICAgIFwiZGVsZXRlU2hhZGVyXCIsXG4gICAgXCJkZWxldGVTeW5jXCIsXG4gICAgXCJkZWxldGVURm9vdFwiLFxuICAgIFwiZGVsZXRlVEhlYWRcIixcbiAgICBcImRlbGV0ZVRleHR1cmVcIixcbiAgICBcImRlbGV0ZVRyYW5zZm9ybUZlZWRiYWNrXCIsXG4gICAgXCJkZWxldGVWZXJ0ZXhBcnJheVwiLFxuICAgIFwiZGVsZXRlZFwiLFxuICAgIFwiZGVsaXZlckNoYW5nZVJlY29yZHNcIixcbiAgICBcImRlbGl2ZXJlZEZyYW1lc1wiLFxuICAgIFwiZGVsaXZlcmVkRnJhbWVzRHVyYXRpb25cIixcbiAgICBcImRlbGl2ZXJ5XCIsXG4gICAgXCJkZWxpdmVyeUluZm9cIixcbiAgICBcImRlbGl2ZXJ5U3RhdHVzXCIsXG4gICAgXCJkZWxpdmVyeVRpbWVzdGFtcFwiLFxuICAgIFwiZGVsaXZlcnlUeXBlXCIsXG4gICAgXCJkZWx0YVwiLFxuICAgIFwiZGVsdGFNb2RlXCIsXG4gICAgXCJkZWx0YVhcIixcbiAgICBcImRlbHRhWVwiLFxuICAgIFwiZGVsdGFaXCIsXG4gICAgXCJkZXBlbmRlbnRMb2NhbGl0eVwiLFxuICAgIFwiZGVwcmVjYXRlZFJlcGxhY2VJblVSTlwiLFxuICAgIFwiZGVwcmVjYXRlZFJ1bkFkQXVjdGlvbkVuZm9yY2VzS0Fub255bWl0eVwiLFxuICAgIFwiZGVwcmVjYXRlZFVSTlRvVVJMXCIsXG4gICAgXCJkZXB0aEJpYXNcIixcbiAgICBcImRlcHRoQmlhc0NsYW1wXCIsXG4gICAgXCJkZXB0aEJpYXNTbG9wZVNjYWxlXCIsXG4gICAgXCJkZXB0aENsZWFyVmFsdWVcIixcbiAgICBcImRlcHRoQ29tcGFyZVwiLFxuICAgIFwiZGVwdGhEYXRhRm9ybWF0XCIsXG4gICAgXCJkZXB0aEZhaWxPcFwiLFxuICAgIFwiZGVwdGhGYXJcIixcbiAgICBcImRlcHRoRnVuY1wiLFxuICAgIFwiZGVwdGhMb2FkT3BcIixcbiAgICBcImRlcHRoTWFza1wiLFxuICAgIFwiZGVwdGhOZWFyXCIsXG4gICAgXCJkZXB0aE9yQXJyYXlMYXllcnNcIixcbiAgICBcImRlcHRoUmFuZ2VcIixcbiAgICBcImRlcHRoUmVhZE9ubHlcIixcbiAgICBcImRlcHRoU3RlbmNpbFwiLFxuICAgIFwiZGVwdGhTdGVuY2lsQXR0YWNobWVudFwiLFxuICAgIFwiZGVwdGhTdGVuY2lsRm9ybWF0XCIsXG4gICAgXCJkZXB0aFN0b3JlT3BcIixcbiAgICBcImRlcHRoVXNhZ2VcIixcbiAgICBcImRlcHRoV3JpdGVFbmFibGVkXCIsXG4gICAgXCJkZXJlZlwiLFxuICAgIFwiZGVyaXZlQml0c1wiLFxuICAgIFwiZGVyaXZlS2V5XCIsXG4gICAgXCJkZXNjZW50T3ZlcnJpZGVcIixcbiAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgXCJkZXNlbGVjdEFsbFwiLFxuICAgIFwiZGVzaWduTW9kZVwiLFxuICAgIFwiZGVzaXJlZFNpemVcIixcbiAgICBcImRlc3RpbmF0aW9uXCIsXG4gICAgXCJkZXN0aW5hdGlvblVSTFwiLFxuICAgIFwiZGVzdHJveVwiLFxuICAgIFwiZGV0YWNoXCIsXG4gICAgXCJkZXRhY2hFdmVudFwiLFxuICAgIFwiZGV0YWNoU2hhZGVyXCIsXG4gICAgXCJkZXRhY2hlZFwiLFxuICAgIFwiZGV0YWlsXCIsXG4gICAgXCJkZXRhaWxzXCIsXG4gICAgXCJkZXRlY3RcIixcbiAgICBcImRldGVjdExhbmd1YWdlXCIsXG4gICAgXCJkZXR1bmVcIixcbiAgICBcImRldmljZVwiLFxuICAgIFwiZGV2aWNlQ2xhc3NcIixcbiAgICBcImRldmljZUlkXCIsXG4gICAgXCJkZXZpY2VNZW1vcnlcIixcbiAgICBcImRldmljZVBpeGVsQ29udGVudEJveFNpemVcIixcbiAgICBcImRldmljZVBpeGVsUmF0aW9cIixcbiAgICBcImRldmljZVByb3RvY29sXCIsXG4gICAgXCJkZXZpY2VTdWJjbGFzc1wiLFxuICAgIFwiZGV2aWNlVmVyc2lvbk1ham9yXCIsXG4gICAgXCJkZXZpY2VWZXJzaW9uTWlub3JcIixcbiAgICBcImRldmljZVZlcnNpb25TdWJtaW5vclwiLFxuICAgIFwiZGV2aWNlWERQSVwiLFxuICAgIFwiZGV2aWNlWURQSVwiLFxuICAgIFwiZGV2dG9vbHNcIixcbiAgICBcImRldnRvb2xzX3BhbmVsc1wiLFxuICAgIFwiZGlkVGltZW91dFwiLFxuICAgIFwiZGlmZmVyZW5jZVwiLFxuICAgIFwiZGlmZnVzZUNvbnN0YW50XCIsXG4gICAgXCJkaWdlc3RcIixcbiAgICBcImRpbWVuc2lvblwiLFxuICAgIFwiZGltZW5zaW9uc1wiLFxuICAgIFwiZGlyXCIsXG4gICAgXCJkaXJOYW1lXCIsXG4gICAgXCJkaXJlY3Rpb25cIixcbiAgICBcImRpcnhtbFwiLFxuICAgIFwiZGlzYWJsZVwiLFxuICAgIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIixcbiAgICBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiLFxuICAgIFwiZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5XCIsXG4gICAgXCJkaXNhYmxlZFwiLFxuICAgIFwiZGlzY2FyZFwiLFxuICAgIFwiZGlzY2FyZGVkRnJhbWVzXCIsXG4gICAgXCJkaXNjaGFyZ2luZ1RpbWVcIixcbiAgICBcImRpc2Nvbm5lY3RcIixcbiAgICBcImRpc2Nvbm5lY3RTaGFya1wiLFxuICAgIFwiZGlzY29ubmVjdGVkQ2FsbGJhY2tcIixcbiAgICBcImRpc3BhdGNoRXZlbnRcIixcbiAgICBcImRpc3BhdGNoV29ya2dyb3Vwc1wiLFxuICAgIFwiZGlzcGF0Y2hXb3JrZ3JvdXBzSW5kaXJlY3RcIixcbiAgICBcImRpc3BsYXlcIixcbiAgICBcImRpc3BsYXlIZWlnaHRcIixcbiAgICBcImRpc3BsYXlJZFwiLFxuICAgIFwiZGlzcGxheU5hbWVcIixcbiAgICBcImRpc3BsYXlXaWR0aFwiLFxuICAgIFwiZGlzcG9zZVwiLFxuICAgIFwiZGlzcG9zaXRpb25cIixcbiAgICBcImRpc3RhbmNlTW9kZWxcIixcbiAgICBcImRpdlwiLFxuICAgIFwiZGl2aXNvclwiLFxuICAgIFwiZGpzYXBpXCIsXG4gICAgXCJkanNwcm94eVwiLFxuICAgIFwiZG5zXCIsXG4gICAgXCJkb0ltcG9ydFwiLFxuICAgIFwiZG9Ob3RUcmFja1wiLFxuICAgIFwiZG9TY3JvbGxcIixcbiAgICBcImRvY3R5cGVcIixcbiAgICBcImRvY3VtZW50XCIsXG4gICAgXCJkb2N1bWVudEVsZW1lbnRcIixcbiAgICBcImRvY3VtZW50SWRcIixcbiAgICBcImRvY3VtZW50SWRzXCIsXG4gICAgXCJkb2N1bWVudExpZmVjeWNsZVwiLFxuICAgIFwiZG9jdW1lbnRNb2RlXCIsXG4gICAgXCJkb2N1bWVudE9yaWdpblwiLFxuICAgIFwiZG9jdW1lbnRPcmlnaW5zXCIsXG4gICAgXCJkb2N1bWVudFBpY3R1cmVJblBpY3R1cmVcIixcbiAgICBcImRvY3VtZW50VVJJXCIsXG4gICAgXCJkb2N1bWVudFVybFwiLFxuICAgIFwiZG9jdW1lbnRVcmxzXCIsXG4gICAgXCJkb2xwaGluXCIsXG4gICAgXCJkb2xwaGluR2FtZUNlbnRlclwiLFxuICAgIFwiZG9scGhpbmluZm9cIixcbiAgICBcImRvbHBoaW5tZXRhXCIsXG4gICAgXCJkb21cIixcbiAgICBcImRvbUNvbXBsZXRlXCIsXG4gICAgXCJkb21Db250ZW50TG9hZGVkRXZlbnRFbmRcIixcbiAgICBcImRvbUNvbnRlbnRMb2FkZWRFdmVudFN0YXJ0XCIsXG4gICAgXCJkb21JbnRlcmFjdGl2ZVwiLFxuICAgIFwiZG9tTG9hZGluZ1wiLFxuICAgIFwiZG9tT3ZlcmxheVN0YXRlXCIsXG4gICAgXCJkb21haW5cIixcbiAgICBcImRvbWFpbkxvb2t1cEVuZFwiLFxuICAgIFwiZG9tYWluTG9va3VwU3RhcnRcIixcbiAgICBcImRvbWluYW50LWJhc2VsaW5lXCIsXG4gICAgXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgXCJkb25lXCIsXG4gICAgXCJkb3BwbGVyRmFjdG9yXCIsXG4gICAgXCJkb3RBbGxcIixcbiAgICBcImRvd25EZWdyZWVzXCIsXG4gICAgXCJkb3dubGlua1wiLFxuICAgIFwiZG93bmxvYWRcIixcbiAgICBcImRvd25sb2FkUmVxdWVzdFwiLFxuICAgIFwiZG93bmxvYWRUb3RhbFwiLFxuICAgIFwiZG93bmxvYWRlZFwiLFxuICAgIFwiZG93bmxvYWRzXCIsXG4gICAgXCJkcGNtXCIsXG4gICAgXCJkcGlcIixcbiAgICBcImRwcHhcIixcbiAgICBcImRyYWdEcm9wXCIsXG4gICAgXCJkcmFnZ2FibGVcIixcbiAgICBcImRyYXdcIixcbiAgICBcImRyYXdBcnJheXNcIixcbiAgICBcImRyYXdBcnJheXNJbnN0YW5jZWRcIixcbiAgICBcImRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRVwiLFxuICAgIFwiZHJhd0J1ZmZlcnNcIixcbiAgICBcImRyYXdDdXN0b21Gb2N1c1JpbmdcIixcbiAgICBcImRyYXdFbGVtZW50c1wiLFxuICAgIFwiZHJhd0VsZW1lbnRzSW5zdGFuY2VkXCIsXG4gICAgXCJkcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRVwiLFxuICAgIFwiZHJhd0ZvY3VzSWZOZWVkZWRcIixcbiAgICBcImRyYXdJbWFnZVwiLFxuICAgIFwiZHJhd0ltYWdlRnJvbVJlY3RcIixcbiAgICBcImRyYXdJbmRleGVkXCIsXG4gICAgXCJkcmF3SW5kZXhlZEluZGlyZWN0XCIsXG4gICAgXCJkcmF3SW5kaXJlY3RcIixcbiAgICBcImRyYXdSYW5nZUVsZW1lbnRzXCIsXG4gICAgXCJkcmF3U3lzdGVtRm9jdXNSaW5nXCIsXG4gICAgXCJkcmF3aW5nQnVmZmVyQ29sb3JTcGFjZVwiLFxuICAgIFwiZHJhd2luZ0J1ZmZlckZvcm1hdFwiLFxuICAgIFwiZHJhd2luZ0J1ZmZlckhlaWdodFwiLFxuICAgIFwiZHJhd2luZ0J1ZmZlclN0b3JhZ2VcIixcbiAgICBcImRyYXdpbmdCdWZmZXJXaWR0aFwiLFxuICAgIFwiZHJvcFwiLFxuICAgIFwiZHJvcEVmZmVjdFwiLFxuICAgIFwiZHJvcHBlZFZpZGVvRnJhbWVzXCIsXG4gICAgXCJkcm9wem9uZVwiLFxuICAgIFwiZHN0RmFjdG9yXCIsXG4gICAgXCJkdG1mXCIsXG4gICAgXCJkdW1wXCIsXG4gICAgXCJkdW1wUHJvZmlsZVwiLFxuICAgIFwiZHVwbGV4XCIsXG4gICAgXCJkdXBsaWNhdGVcIixcbiAgICBcImR1cmFiaWxpdHlcIixcbiAgICBcImR1cmF0aW9uXCIsXG4gICAgXCJkdmJcIixcbiAgICBcImR2aFwiLFxuICAgIFwiZHZpXCIsXG4gICAgXCJkdm1heFwiLFxuICAgIFwiZHZtaW5cIixcbiAgICBcImR2bmFtZVwiLFxuICAgIFwiZHZudW1cIixcbiAgICBcImR2d1wiLFxuICAgIFwiZHhcIixcbiAgICBcImR5XCIsXG4gICAgXCJkeW5hbWljSWRcIixcbiAgICBcImR5bnNyY1wiLFxuICAgIFwiZVwiLFxuICAgIFwiZWRnZU1vZGVcIixcbiAgICBcImVkaXRDb250ZXh0XCIsXG4gICAgXCJlZmZlY3RcIixcbiAgICBcImVmZmVjdEFsbG93ZWRcIixcbiAgICBcImVmZmVjdGl2ZURpcmVjdGl2ZVwiLFxuICAgIFwiZWZmZWN0aXZlVHlwZVwiLFxuICAgIFwiZWZmZWN0c1wiLFxuICAgIFwiZWxhcHNlZFRpbWVcIixcbiAgICBcImVsZW1lbnRcIixcbiAgICBcImVsZW1lbnRGcm9tUG9pbnRcIixcbiAgICBcImVsZW1lbnRUaW1pbmdcIixcbiAgICBcImVsZW1lbnRzXCIsXG4gICAgXCJlbGVtZW50c0Zyb21Qb2ludFwiLFxuICAgIFwiZWxldmF0aW9uXCIsXG4gICAgXCJlbGxpcHNlXCIsXG4gICAgXCJlbVwiLFxuICAgIFwiZW1IZWlnaHRBc2NlbnRcIixcbiAgICBcImVtSGVpZ2h0RGVzY2VudFwiLFxuICAgIFwiZW1haWxcIixcbiAgICBcImVtYmVkc1wiLFxuICAgIFwiZW1pdFwiLFxuICAgIFwiZW1tYVwiLFxuICAgIFwiZW1wdHlcIixcbiAgICBcImVtcHR5LWNlbGxzXCIsXG4gICAgXCJlbXB0eUNlbGxzXCIsXG4gICAgXCJlbXB0eUhUTUxcIixcbiAgICBcImVtcHR5U2NyaXB0XCIsXG4gICAgXCJlbXVsYXRlZFBvc2l0aW9uXCIsXG4gICAgXCJlbmFibGVcIixcbiAgICBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICBcImVuYWJsZURlbGVnYXRpb25zXCIsXG4gICAgXCJlbmFibGVTdHlsZVNoZWV0c0ZvclNldFwiLFxuICAgIFwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXlcIixcbiAgICBcImVuYWJsZWRcIixcbiAgICBcImVuYWJsZWRGZWF0dXJlc1wiLFxuICAgIFwiZW5hYmxlZFBsdWdpblwiLFxuICAgIFwiZW5jb2RlXCIsXG4gICAgXCJlbmNvZGVJbnRvXCIsXG4gICAgXCJlbmNvZGVRdWV1ZVNpemVcIixcbiAgICBcImVuY29kZVVSSVwiLFxuICAgIFwiZW5jb2RlVVJJQ29tcG9uZW50XCIsXG4gICAgXCJlbmNvZGVkQm9keVNpemVcIixcbiAgICBcImVuY29kaW5nXCIsXG4gICAgXCJlbmNvZGluZ0luZm9cIixcbiAgICBcImVuY3J5cHRcIixcbiAgICBcImVuY3R5cGVcIixcbiAgICBcImVuZFwiLFxuICAgIFwiZW5kQ29udGFpbmVyXCIsXG4gICAgXCJlbmRFbGVtZW50XCIsXG4gICAgXCJlbmRFbGVtZW50QXRcIixcbiAgICBcImVuZE9jY2x1c2lvblF1ZXJ5XCIsXG4gICAgXCJlbmRPZlBhc3NXcml0ZUluZGV4XCIsXG4gICAgXCJlbmRPZlN0cmVhbVwiLFxuICAgIFwiZW5kT2Zmc2V0XCIsXG4gICAgXCJlbmRRdWVyeVwiLFxuICAgIFwiZW5kVGltZVwiLFxuICAgIFwiZW5kVHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICBcImVuZGVkXCIsXG4gICAgXCJlbmRwb2ludFwiLFxuICAgIFwiZW5kcG9pbnROdW1iZXJcIixcbiAgICBcImVuZHBvaW50c1wiLFxuICAgIFwiZW5kc1dpdGhcIixcbiAgICBcImVucXVldWVcIixcbiAgICBcImVudGVyS2V5SGludFwiLFxuICAgIFwiZW50aXRpZXNcIixcbiAgICBcImVudHJpZXNcIixcbiAgICBcImVudHJ5XCIsXG4gICAgXCJlbnRyeVBvaW50XCIsXG4gICAgXCJlbnRyeVR5cGVcIixcbiAgICBcImVudW1lcmFibGVcIixcbiAgICBcImVudW1lcmF0ZVwiLFxuICAgIFwiZW51bWVyYXRlRGV2aWNlc1wiLFxuICAgIFwiZW51bWVyYXRlRWRpdGFibGVcIixcbiAgICBcImVudmlyb25tZW50QmxlbmRNb2RlXCIsXG4gICAgXCJlcXVhbHNcIixcbiAgICBcImVycm9yXCIsXG4gICAgXCJlcnJvckNvZGVcIixcbiAgICBcImVycm9yRGV0YWlsXCIsXG4gICAgXCJlcnJvclRleHRcIixcbiAgICBcImVzY2FwZVwiLFxuICAgIFwiZXN0aW1hdGVcIixcbiAgICBcImV2YWxcIixcbiAgICBcImV2YWx1YXRlXCIsXG4gICAgXCJldmVudFwiLFxuICAgIFwiZXZlbnRDb3VudHNcIixcbiAgICBcImV2ZW50UGhhc2VcIixcbiAgICBcImV2ZW50c1wiLFxuICAgIFwiZXZlcnlcIixcbiAgICBcImV4XCIsXG4gICAgXCJleGNlcHRpb25cIixcbiAgICBcImV4Y2hhbmdlXCIsXG4gICAgXCJleGVjXCIsXG4gICAgXCJleGVjQ29tbWFuZFwiLFxuICAgIFwiZXhlY0NvbW1hbmRTaG93SGVscFwiLFxuICAgIFwiZXhlY1NjcmlwdFwiLFxuICAgIFwiZXhlY3V0ZUJ1bmRsZXNcIixcbiAgICBcImV4ZWN1dGlvblN0YXJ0XCIsXG4gICAgXCJleGl0RnVsbHNjcmVlblwiLFxuICAgIFwiZXhpdFBpY3R1cmVJblBpY3R1cmVcIixcbiAgICBcImV4aXRQb2ludGVyTG9ja1wiLFxuICAgIFwiZXhpdFByZXNlbnRcIixcbiAgICBcImV4cFwiLFxuICAgIFwiZXhwYW5kXCIsXG4gICAgXCJleHBhbmRFbnRpdHlSZWZlcmVuY2VzXCIsXG4gICAgXCJleHBhbmRvXCIsXG4gICAgXCJleHBhbnNpb25cIixcbiAgICBcImV4cGVjdGVkSW1wcm92ZW1lbnRcIixcbiAgICBcImV4cGVyaW1lbnRzXCIsXG4gICAgXCJleHBpcmF0aW9uXCIsXG4gICAgXCJleHBpcmF0aW9uVGltZVwiLFxuICAgIFwiZXhwaXJlc1wiLFxuICAgIFwiZXhwaXJ5RGF0ZVwiLFxuICAgIFwiZXhwbGljaXRPcmlnaW5hbFRhcmdldFwiLFxuICAgIFwiZXhwbTFcIixcbiAgICBcImV4cG9uZW50XCIsXG4gICAgXCJleHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lXCIsXG4gICAgXCJleHBvcnRLZXlcIixcbiAgICBcImV4cG9ydHNcIixcbiAgICBcImV4dGVuZFwiLFxuICAgIFwiZXh0ZW5zaW9uXCIsXG4gICAgXCJleHRlbnNpb25UeXBlc1wiLFxuICAgIFwiZXh0ZW5zaW9uc1wiLFxuICAgIFwiZXh0ZW50Tm9kZVwiLFxuICAgIFwiZXh0ZW50T2Zmc2V0XCIsXG4gICAgXCJleHRlcm5hbFwiLFxuICAgIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLFxuICAgIFwiZXh0ZXJuYWxUZXh0dXJlXCIsXG4gICAgXCJleHRyYWN0Q29udGVudHNcIixcbiAgICBcImV4dHJhY3RhYmxlXCIsXG4gICAgXCJleWVcIixcbiAgICBcImZcIixcbiAgICBcImYxNnJvdW5kXCIsXG4gICAgXCJmYWNlXCIsXG4gICAgXCJmYWN0b3J5UmVzZXRcIixcbiAgICBcImZhaWxPcFwiLFxuICAgIFwiZmFpbHVyZVJlYXNvblwiLFxuICAgIFwiZmFsbGJhY2tcIixcbiAgICBcImZhbWlseVwiLFxuICAgIFwiZmFtaWx5TmFtZVwiLFxuICAgIFwiZmFydGhlc3RWaWV3cG9ydEVsZW1lbnRcIixcbiAgICBcImZhc3RTZWVrXCIsXG4gICAgXCJmYXRhbFwiLFxuICAgIFwiZmVhdHVyZUlkXCIsXG4gICAgXCJmZWF0dXJlUG9saWN5XCIsXG4gICAgXCJmZWF0dXJlU2V0dGluZ3NcIixcbiAgICBcImZlYXR1cmVzXCIsXG4gICAgXCJmZW5jZVwiLFxuICAgIFwiZmVuY2VTeW5jXCIsXG4gICAgXCJmZXRjaFwiLFxuICAgIFwiZmV0Y2hQcmlvcml0eVwiLFxuICAgIFwiZmV0Y2hTdGFydFwiLFxuICAgIFwiZmZ0U2l6ZVwiLFxuICAgIFwiZmdDb2xvclwiLFxuICAgIFwiZmllbGRPZlZpZXdcIixcbiAgICBcImZpbGVcIixcbiAgICBcImZpbGVDcmVhdGVkRGF0ZVwiLFxuICAgIFwiZmlsZUhhbmRsZVwiLFxuICAgIFwiZmlsZU1vZGlmaWVkRGF0ZVwiLFxuICAgIFwiZmlsZU5hbWVcIixcbiAgICBcImZpbGVTaXplXCIsXG4gICAgXCJmaWxlVXBkYXRlZERhdGVcIixcbiAgICBcImZpbGVuYW1lXCIsXG4gICAgXCJmaWxlc1wiLFxuICAgIFwiZmlsZXN5c3RlbVwiLFxuICAgIFwiZmlsbFwiLFxuICAgIFwiZmlsbC1vcGFjaXR5XCIsXG4gICAgXCJmaWxsLXJ1bGVcIixcbiAgICBcImZpbGxKb2ludFJhZGlpXCIsXG4gICAgXCJmaWxsTGlnaHRNb2RlXCIsXG4gICAgXCJmaWxsT3BhY2l0eVwiLFxuICAgIFwiZmlsbFBvc2VzXCIsXG4gICAgXCJmaWxsUmVjdFwiLFxuICAgIFwiZmlsbFJ1bGVcIixcbiAgICBcImZpbGxTdHlsZVwiLFxuICAgIFwiZmlsbFRleHRcIixcbiAgICBcImZpbHRlclwiLFxuICAgIFwiZmlsdGVyUmVzWFwiLFxuICAgIFwiZmlsdGVyUmVzWVwiLFxuICAgIFwiZmlsdGVyVW5pdHNcIixcbiAgICBcImZpbHRlcnNcIixcbiAgICBcImZpbmFsbHlcIixcbiAgICBcImZpbmRcIixcbiAgICBcImZpbmRJbmRleFwiLFxuICAgIFwiZmluZExhc3RcIixcbiAgICBcImZpbmRMYXN0SW5kZXhcIixcbiAgICBcImZpbmRSdWxlXCIsXG4gICAgXCJmaW5kVGV4dFwiLFxuICAgIFwiZmluaXNoXCIsXG4gICAgXCJmaW5pc2hEb2N1bWVudExvYWRUaW1lXCIsXG4gICAgXCJmaW5pc2hMb2FkVGltZVwiLFxuICAgIFwiZmluaXNoZWRcIixcbiAgICBcImZpcmVFdmVudFwiLFxuICAgIFwiZmlyZXNUb3VjaEV2ZW50c1wiLFxuICAgIFwiZmlyc3RDaGlsZFwiLFxuICAgIFwiZmlyc3RFbGVtZW50Q2hpbGRcIixcbiAgICBcImZpcnN0SW50ZXJpbVJlc3BvbnNlU3RhcnRcIixcbiAgICBcImZpcnN0UGFnZVwiLFxuICAgIFwiZmlyc3RQYWludEFmdGVyTG9hZFRpbWVcIixcbiAgICBcImZpcnN0UGFpbnRUaW1lXCIsXG4gICAgXCJmaXJzdFVJRXZlbnRUaW1lc3RhbXBcIixcbiAgICBcImZpeGVkXCIsXG4gICAgXCJmbGFnc1wiLFxuICAgIFwiZmxhdFwiLFxuICAgIFwiZmxhdE1hcFwiLFxuICAgIFwiZmxleFwiLFxuICAgIFwiZmxleC1iYXNpc1wiLFxuICAgIFwiZmxleC1kaXJlY3Rpb25cIixcbiAgICBcImZsZXgtZmxvd1wiLFxuICAgIFwiZmxleC1ncm93XCIsXG4gICAgXCJmbGV4LXNocmlua1wiLFxuICAgIFwiZmxleC13cmFwXCIsXG4gICAgXCJmbGV4QmFzaXNcIixcbiAgICBcImZsZXhEaXJlY3Rpb25cIixcbiAgICBcImZsZXhGbG93XCIsXG4gICAgXCJmbGV4R3Jvd1wiLFxuICAgIFwiZmxleFNocmlua1wiLFxuICAgIFwiZmxleFdyYXBcIixcbiAgICBcImZsaXBYXCIsXG4gICAgXCJmbGlwWVwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImZsb2F0MzJcIixcbiAgICBcImZsb2F0NjRcIixcbiAgICBcImZsb29kLWNvbG9yXCIsXG4gICAgXCJmbG9vZC1vcGFjaXR5XCIsXG4gICAgXCJmbG9vZENvbG9yXCIsXG4gICAgXCJmbG9vZE9wYWNpdHlcIixcbiAgICBcImZsb29yXCIsXG4gICAgXCJmbHVzaFwiLFxuICAgIFwiZm9jdXNcIixcbiAgICBcImZvY3VzTm9kZVwiLFxuICAgIFwiZm9jdXNPZmZzZXRcIixcbiAgICBcImZvbnRcIixcbiAgICBcImZvbnQtZmFtaWx5XCIsXG4gICAgXCJmb250LWZlYXR1cmUtc2V0dGluZ3NcIixcbiAgICBcImZvbnQta2VybmluZ1wiLFxuICAgIFwiZm9udC1sYW5ndWFnZS1vdmVycmlkZVwiLFxuICAgIFwiZm9udC1vcHRpY2FsLXNpemluZ1wiLFxuICAgIFwiZm9udC1wYWxldHRlXCIsXG4gICAgXCJmb250LXNpemVcIixcbiAgICBcImZvbnQtc2l6ZS1hZGp1c3RcIixcbiAgICBcImZvbnQtc3RyZXRjaFwiLFxuICAgIFwiZm9udC1zdHlsZVwiLFxuICAgIFwiZm9udC1zeW50aGVzaXNcIixcbiAgICBcImZvbnQtc3ludGhlc2lzLXBvc2l0aW9uXCIsXG4gICAgXCJmb250LXN5bnRoZXNpcy1zbWFsbC1jYXBzXCIsXG4gICAgXCJmb250LXN5bnRoZXNpcy1zdHlsZVwiLFxuICAgIFwiZm9udC1zeW50aGVzaXMtd2VpZ2h0XCIsXG4gICAgXCJmb250LXZhcmlhbnRcIixcbiAgICBcImZvbnQtdmFyaWFudC1hbHRlcm5hdGVzXCIsXG4gICAgXCJmb250LXZhcmlhbnQtY2Fwc1wiLFxuICAgIFwiZm9udC12YXJpYW50LWVhc3QtYXNpYW5cIixcbiAgICBcImZvbnQtdmFyaWFudC1saWdhdHVyZXNcIixcbiAgICBcImZvbnQtdmFyaWFudC1udW1lcmljXCIsXG4gICAgXCJmb250LXZhcmlhbnQtcG9zaXRpb25cIixcbiAgICBcImZvbnQtdmFyaWF0aW9uLXNldHRpbmdzXCIsXG4gICAgXCJmb250LXdlaWdodFwiLFxuICAgIFwiZm9udEJvdW5kaW5nQm94QXNjZW50XCIsXG4gICAgXCJmb250Qm91bmRpbmdCb3hEZXNjZW50XCIsXG4gICAgXCJmb250RmFtaWx5XCIsXG4gICAgXCJmb250RmVhdHVyZVNldHRpbmdzXCIsXG4gICAgXCJmb250S2VybmluZ1wiLFxuICAgIFwiZm9udExhbmd1YWdlT3ZlcnJpZGVcIixcbiAgICBcImZvbnRPcHRpY2FsU2l6aW5nXCIsXG4gICAgXCJmb250UGFsZXR0ZVwiLFxuICAgIFwiZm9udFNpemVcIixcbiAgICBcImZvbnRTaXplQWRqdXN0XCIsXG4gICAgXCJmb250U21vb3RoaW5nRW5hYmxlZFwiLFxuICAgIFwiZm9udFN0cmV0Y2hcIixcbiAgICBcImZvbnRTdHlsZVwiLFxuICAgIFwiZm9udFN5bnRoZXNpc1wiLFxuICAgIFwiZm9udFN5bnRoZXNpc1Bvc2l0aW9uXCIsXG4gICAgXCJmb250U3ludGhlc2lzU21hbGxDYXBzXCIsXG4gICAgXCJmb250U3ludGhlc2lzU3R5bGVcIixcbiAgICBcImZvbnRTeW50aGVzaXNXZWlnaHRcIixcbiAgICBcImZvbnRWYXJpYW50XCIsXG4gICAgXCJmb250VmFyaWFudEFsdGVybmF0ZXNcIixcbiAgICBcImZvbnRWYXJpYW50Q2Fwc1wiLFxuICAgIFwiZm9udFZhcmlhbnRFYXN0QXNpYW5cIixcbiAgICBcImZvbnRWYXJpYW50TGlnYXR1cmVzXCIsXG4gICAgXCJmb250VmFyaWFudE51bWVyaWNcIixcbiAgICBcImZvbnRWYXJpYW50UG9zaXRpb25cIixcbiAgICBcImZvbnRWYXJpYXRpb25TZXR0aW5nc1wiLFxuICAgIFwiZm9udFdlaWdodFwiLFxuICAgIFwiZm9udGNvbG9yXCIsXG4gICAgXCJmb250ZmFjZXNcIixcbiAgICBcImZvbnRzXCIsXG4gICAgXCJmb250c2l6ZVwiLFxuICAgIFwiZm9yXCIsXG4gICAgXCJmb3JFYWNoXCIsXG4gICAgXCJmb3JjZVwiLFxuICAgIFwiZm9yY2VGYWxsYmFja0FkYXB0ZXJcIixcbiAgICBcImZvcmNlUmVkcmF3XCIsXG4gICAgXCJmb3JjZWQtY29sb3ItYWRqdXN0XCIsXG4gICAgXCJmb3JjZWRDb2xvckFkanVzdFwiLFxuICAgIFwiZm9yY2VkU3R5bGVBbmRMYXlvdXREdXJhdGlvblwiLFxuICAgIFwiZm9yZ2V0XCIsXG4gICAgXCJmb3JtXCIsXG4gICAgXCJmb3JtQWN0aW9uXCIsXG4gICAgXCJmb3JtRGF0YVwiLFxuICAgIFwiZm9ybUVuY3R5cGVcIixcbiAgICBcImZvcm1NZXRob2RcIixcbiAgICBcImZvcm1Ob1ZhbGlkYXRlXCIsXG4gICAgXCJmb3JtVGFyZ2V0XCIsXG4gICAgXCJmb3JtYXRcIixcbiAgICBcImZvcm1hdFRvUGFydHNcIixcbiAgICBcImZvcm1zXCIsXG4gICAgXCJmb3J3YXJkXCIsXG4gICAgXCJmb3J3YXJkWFwiLFxuICAgIFwiZm9yd2FyZFlcIixcbiAgICBcImZvcndhcmRaXCIsXG4gICAgXCJmb3VuZGF0aW9uXCIsXG4gICAgXCJmclwiLFxuICAgIFwiZnJhZ21lbnRcIixcbiAgICBcImZyYWdtZW50RGlyZWN0aXZlXCIsXG4gICAgXCJmcmFtZVwiLFxuICAgIFwiZnJhbWVCb3JkZXJcIixcbiAgICBcImZyYW1lQ291bnRcIixcbiAgICBcImZyYW1lRWxlbWVudFwiLFxuICAgIFwiZnJhbWVJZFwiLFxuICAgIFwiZnJhbWVJZHNcIixcbiAgICBcImZyYW1lU3BhY2luZ1wiLFxuICAgIFwiZnJhbWVidWZmZXJcIixcbiAgICBcImZyYW1lYnVmZmVySGVpZ2h0XCIsXG4gICAgXCJmcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlclwiLFxuICAgIFwiZnJhbWVidWZmZXJUZXh0dXJlMkRcIixcbiAgICBcImZyYW1lYnVmZmVyVGV4dHVyZUxheWVyXCIsXG4gICAgXCJmcmFtZWJ1ZmZlcldpZHRoXCIsXG4gICAgXCJmcmFtZXNcIixcbiAgICBcImZyZWVTcGFjZVwiLFxuICAgIFwiZnJlZXplXCIsXG4gICAgXCJmcmVxdWVuY3lcIixcbiAgICBcImZyZXF1ZW5jeUJpbkNvdW50XCIsXG4gICAgXCJmcm9tXCIsXG4gICAgXCJmcm9tQXN5bmNcIixcbiAgICBcImZyb21CYXNlNjRcIixcbiAgICBcImZyb21DaGFyQ29kZVwiLFxuICAgIFwiZnJvbUNvZGVQb2ludFwiLFxuICAgIFwiZnJvbUVsZW1lbnRcIixcbiAgICBcImZyb21FbnRyaWVzXCIsXG4gICAgXCJmcm9tRmxvYXQzMkFycmF5XCIsXG4gICAgXCJmcm9tRmxvYXQ2NEFycmF5XCIsXG4gICAgXCJmcm9tSGV4XCIsXG4gICAgXCJmcm9tTWF0cml4XCIsXG4gICAgXCJmcm9tUG9pbnRcIixcbiAgICBcImZyb21RdWFkXCIsXG4gICAgXCJmcm9tUmVjdFwiLFxuICAgIFwiZnJvbnRGYWNlXCIsXG4gICAgXCJmcm91bmRcIixcbiAgICBcImZ1bGxOYW1lXCIsXG4gICAgXCJmdWxsUGF0aFwiLFxuICAgIFwiZnVsbFJhbmdlXCIsXG4gICAgXCJmdWxsU2NyZWVuXCIsXG4gICAgXCJmdWxsVmVyc2lvbkxpc3RcIixcbiAgICBcImZ1bGxzY3JlZW5cIixcbiAgICBcImZ1bGxzY3JlZW5FbGVtZW50XCIsXG4gICAgXCJmdWxsc2NyZWVuRW5hYmxlZFwiLFxuICAgIFwiZnhcIixcbiAgICBcImZ5XCIsXG4gICAgXCJnXCIsXG4gICAgXCJnYWluXCIsXG4gICAgXCJnYW1lcGFkXCIsXG4gICAgXCJnYW1tYVwiLFxuICAgIFwiZ2FwXCIsXG4gICAgXCJnYXRoZXJpbmdTdGF0ZVwiLFxuICAgIFwiZ2F0dFwiLFxuICAgIFwiZ2Vja29Qcm9maWxlclwiLFxuICAgIFwiZ2VuZGVySWRlbnRpdHlcIixcbiAgICBcImdlbmVyYXRlQ2VydGlmaWNhdGVcIixcbiAgICBcImdlbmVyYXRlS2V5XCIsXG4gICAgXCJnZW5lcmF0ZU1pcG1hcFwiLFxuICAgIFwiZ2VuZXJhdGVSZXF1ZXN0XCIsXG4gICAgXCJnZW9sb2NhdGlvblwiLFxuICAgIFwiZ2VzdHVyZU9iamVjdFwiLFxuICAgIFwiZ2V0XCIsXG4gICAgXCJnZXRBY2NlcHRMYW5ndWFnZXNcIixcbiAgICBcImdldEFjdGl2ZUF0dHJpYlwiLFxuICAgIFwiZ2V0QWN0aXZlVW5pZm9ybVwiLFxuICAgIFwiZ2V0QWN0aXZlVW5pZm9ybUJsb2NrTmFtZVwiLFxuICAgIFwiZ2V0QWN0aXZlVW5pZm9ybUJsb2NrUGFyYW1ldGVyXCIsXG4gICAgXCJnZXRBY3RpdmVVbmlmb3Jtc1wiLFxuICAgIFwiZ2V0QWRqYWNlbnRUZXh0XCIsXG4gICAgXCJnZXRBbGxcIixcbiAgICBcImdldEFsbEtleXNcIixcbiAgICBcImdldEFsbFJlc3BvbnNlSGVhZGVyc1wiLFxuICAgIFwiZ2V0QWxsb3dsaXN0Rm9yRmVhdHVyZVwiLFxuICAgIFwiZ2V0QW5pbWF0aW9uc1wiLFxuICAgIFwiZ2V0QXNGaWxlXCIsXG4gICAgXCJnZXRBc0ZpbGVTeXN0ZW1IYW5kbGVcIixcbiAgICBcImdldEFzU3RyaW5nXCIsXG4gICAgXCJnZXRBdHRhY2hlZFNoYWRlcnNcIixcbiAgICBcImdldEF0dHJpYkxvY2F0aW9uXCIsXG4gICAgXCJnZXRBdHRyaWJ1dGVcIixcbiAgICBcImdldEF0dHJpYnV0ZU5TXCIsXG4gICAgXCJnZXRBdHRyaWJ1dGVOYW1lc1wiLFxuICAgIFwiZ2V0QXR0cmlidXRlTm9kZVwiLFxuICAgIFwiZ2V0QXR0cmlidXRlTm9kZU5TXCIsXG4gICAgXCJnZXRBdHRyaWJ1dGVUeXBlXCIsXG4gICAgXCJnZXRBdWRpb1RyYWNrc1wiLFxuICAgIFwiZ2V0QXV0aGVudGljYXRvckRhdGFcIixcbiAgICBcImdldEF1dG9wbGF5UG9saWN5XCIsXG4gICAgXCJnZXRBdmFpbGFiaWxpdHlcIixcbiAgICBcImdldEJCb3hcIixcbiAgICBcImdldEJhY2tncm91bmRQYWdlXCIsXG4gICAgXCJnZXRCYWRnZUJhY2tncm91bmRDb2xvclwiLFxuICAgIFwiZ2V0QmFkZ2VUZXh0XCIsXG4gICAgXCJnZXRCYWRnZVRleHRDb2xvclwiLFxuICAgIFwiZ2V0QmF0dGVyeVwiLFxuICAgIFwiZ2V0QmlnSW50NjRcIixcbiAgICBcImdldEJpZ1VpbnQ2NFwiLFxuICAgIFwiZ2V0QmluZEdyb3VwTGF5b3V0XCIsXG4gICAgXCJnZXRCbG9iXCIsXG4gICAgXCJnZXRCb29rbWFya1wiLFxuICAgIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIsXG4gICAgXCJnZXRCb3VuZHNcIixcbiAgICBcImdldEJveFF1YWRzXCIsXG4gICAgXCJnZXRCcm93c2VySW5mb1wiLFxuICAgIFwiZ2V0QnVmZmVyUGFyYW1ldGVyXCIsXG4gICAgXCJnZXRCdWZmZXJTdWJEYXRhXCIsXG4gICAgXCJnZXRCeXRlRnJlcXVlbmN5RGF0YVwiLFxuICAgIFwiZ2V0Qnl0ZVRpbWVEb21haW5EYXRhXCIsXG4gICAgXCJnZXRDU1NDYW52YXNDb250ZXh0XCIsXG4gICAgXCJnZXRDVE1cIixcbiAgICBcImdldENhbWVyYUltYWdlXCIsXG4gICAgXCJnZXRDYW5kaWRhdGVXaW5kb3dDbGllbnRSZWN0XCIsXG4gICAgXCJnZXRDYW5vbmljYWxMb2NhbGVzXCIsXG4gICAgXCJnZXRDYXBhYmlsaXRpZXNcIixcbiAgICBcImdldENhcHR1cmVIYW5kbGVcIixcbiAgICBcImdldENoYW5uZWxEYXRhXCIsXG4gICAgXCJnZXRDaGFyTnVtQXRQb3NpdGlvblwiLFxuICAgIFwiZ2V0Q2hhcmFjdGVyaXN0aWNcIixcbiAgICBcImdldENoYXJhY3RlcmlzdGljc1wiLFxuICAgIFwiZ2V0Q2xpZW50RXh0ZW5zaW9uUmVzdWx0c1wiLFxuICAgIFwiZ2V0Q2xpZW50UmVjdFwiLFxuICAgIFwiZ2V0Q2xpZW50UmVjdHNcIixcbiAgICBcImdldENvYWxlc2NlZEV2ZW50c1wiLFxuICAgIFwiZ2V0Q29tcGlsYXRpb25JbmZvXCIsXG4gICAgXCJnZXRDb21wb3NpdGlvbkFsdGVybmF0aXZlc1wiLFxuICAgIFwiZ2V0Q29tcHV0ZWRTdHlsZVwiLFxuICAgIFwiZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoXCIsXG4gICAgXCJnZXRDb21wdXRlZFRpbWluZ1wiLFxuICAgIFwiZ2V0Q29uZmlndXJhdGlvblwiLFxuICAgIFwiZ2V0Q29uc3RyYWludHNcIixcbiAgICBcImdldENvbnRleHRcIixcbiAgICBcImdldENvbnRleHRBdHRyaWJ1dGVzXCIsXG4gICAgXCJnZXRDb250ZXh0c1wiLFxuICAgIFwiZ2V0Q29udHJpYnV0aW5nU291cmNlc1wiLFxuICAgIFwiZ2V0Q291bnRlclZhbHVlXCIsXG4gICAgXCJnZXRDdWVBc0hUTUxcIixcbiAgICBcImdldEN1ZUJ5SWRcIixcbiAgICBcImdldEN1cnJlbnRcIixcbiAgICBcImdldEN1cnJlbnRQb3NpdGlvblwiLFxuICAgIFwiZ2V0Q3VycmVudFRleHR1cmVcIixcbiAgICBcImdldEN1cnJlbnRUaW1lXCIsXG4gICAgXCJnZXREYXRhXCIsXG4gICAgXCJnZXREYXRhYmFzZU5hbWVzXCIsXG4gICAgXCJnZXREYXRlXCIsXG4gICAgXCJnZXREYXlcIixcbiAgICBcImdldERlZmF1bHRDb21wdXRlZFN0eWxlXCIsXG4gICAgXCJnZXREZXB0aEluTWV0ZXJzXCIsXG4gICAgXCJnZXREZXB0aEluZm9ybWF0aW9uXCIsXG4gICAgXCJnZXREZXNjcmlwdG9yXCIsXG4gICAgXCJnZXREZXNjcmlwdG9yc1wiLFxuICAgIFwiZ2V0RGVzdGluYXRpb25JbnNlcnRpb25Qb2ludHNcIixcbiAgICBcImdldERldmljZXNcIixcbiAgICBcImdldERpcmVjdG9yeVwiLFxuICAgIFwiZ2V0RGlyZWN0b3J5SGFuZGxlXCIsXG4gICAgXCJnZXREaXNwbGF5TWVkaWFcIixcbiAgICBcImdldERpc3RyaWJ1dGVkTm9kZXNcIixcbiAgICBcImdldEVkaXRhYmxlXCIsXG4gICAgXCJnZXRFbGVtZW50QnlJZFwiLFxuICAgIFwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZVwiLFxuICAgIFwiZ2V0RWxlbWVudHNCeU5hbWVcIixcbiAgICBcImdldEVsZW1lbnRzQnlUYWdOYW1lXCIsXG4gICAgXCJnZXRFbGVtZW50c0J5VGFnTmFtZU5TXCIsXG4gICAgXCJnZXRFbmNsb3N1cmVMaXN0XCIsXG4gICAgXCJnZXRFbmRQb3NpdGlvbk9mQ2hhclwiLFxuICAgIFwiZ2V0RW50cmllc1wiLFxuICAgIFwiZ2V0RW50cmllc0J5TmFtZVwiLFxuICAgIFwiZ2V0RW50cmllc0J5VHlwZVwiLFxuICAgIFwiZ2V0RXJyb3JcIixcbiAgICBcImdldEV4dGVuc2lvblwiLFxuICAgIFwiZ2V0RXh0ZW50T2ZDaGFyXCIsXG4gICAgXCJnZXRFeWVQYXJhbWV0ZXJzXCIsXG4gICAgXCJnZXRGZWF0dXJlXCIsXG4gICAgXCJnZXRGaWJlclJvb3RzXCIsXG4gICAgXCJnZXRGaWxlXCIsXG4gICAgXCJnZXRGaWxlSGFuZGxlXCIsXG4gICAgXCJnZXRGaWxlc1wiLFxuICAgIFwiZ2V0RmlsZXNBbmREaXJlY3Rvcmllc1wiLFxuICAgIFwiZ2V0RmluZ2VycHJpbnRzXCIsXG4gICAgXCJnZXRGbG9hdDE2XCIsXG4gICAgXCJnZXRGbG9hdDMyXCIsXG4gICAgXCJnZXRGbG9hdDY0XCIsXG4gICAgXCJnZXRGbG9hdEZyZXF1ZW5jeURhdGFcIixcbiAgICBcImdldEZsb2F0VGltZURvbWFpbkRhdGFcIixcbiAgICBcImdldEZsb2F0VmFsdWVcIixcbiAgICBcImdldEZyYWdEYXRhTG9jYXRpb25cIixcbiAgICBcImdldEZyYW1lRGF0YVwiLFxuICAgIFwiZ2V0RnJhbWVJZFwiLFxuICAgIFwiZ2V0RnJhbWVidWZmZXJBdHRhY2htZW50UGFyYW1ldGVyXCIsXG4gICAgXCJnZXRGcmVxdWVuY3lSZXNwb25zZVwiLFxuICAgIFwiZ2V0RnVsbFllYXJcIixcbiAgICBcImdldEdhbWVwYWRzXCIsXG4gICAgXCJnZXRIVE1MXCIsXG4gICAgXCJnZXRIZWFkZXJFeHRlbnNpb25zVG9OZWdvdGlhdGVcIixcbiAgICBcImdldEhpZ2hFbnRyb3B5VmFsdWVzXCIsXG4gICAgXCJnZXRIaXRUZXN0UmVzdWx0c1wiLFxuICAgIFwiZ2V0SGl0VGVzdFJlc3VsdHNGb3JUcmFuc2llbnRJbnB1dFwiLFxuICAgIFwiZ2V0SG91cnNcIixcbiAgICBcImdldElkZW50aXR5QXNzZXJ0aW9uXCIsXG4gICAgXCJnZXRJZHNcIixcbiAgICBcImdldEltYWdlRGF0YVwiLFxuICAgIFwiZ2V0SW5kZXhlZFBhcmFtZXRlclwiLFxuICAgIFwiZ2V0SW5mb1wiLFxuICAgIFwiZ2V0SW5uZXJIVE1MXCIsXG4gICAgXCJnZXRJbnN0YWxsZWRSZWxhdGVkQXBwc1wiLFxuICAgIFwiZ2V0SW50MTZcIixcbiAgICBcImdldEludDMyXCIsXG4gICAgXCJnZXRJbnQ4XCIsXG4gICAgXCJnZXRJbnRlcmVzdEdyb3VwQWRBdWN0aW9uRGF0YVwiLFxuICAgIFwiZ2V0SW50ZXJuYWxNb2R1bGVSYW5nZXNcIixcbiAgICBcImdldEludGVybmFsZm9ybWF0UGFyYW1ldGVyXCIsXG4gICAgXCJnZXRJbnRlcnNlY3Rpb25MaXN0XCIsXG4gICAgXCJnZXRJdGVtXCIsXG4gICAgXCJnZXRJdGVtc1wiLFxuICAgIFwiZ2V0Sm9pbnRQb3NlXCIsXG4gICAgXCJnZXRLZXlcIixcbiAgICBcImdldEtleWZyYW1lc1wiLFxuICAgIFwiZ2V0TGFzdEZvY3VzZWRcIixcbiAgICBcImdldExheWVyc1wiLFxuICAgIFwiZ2V0TGF5b3V0TWFwXCIsXG4gICAgXCJnZXRMaWdodEVzdGltYXRlXCIsXG4gICAgXCJnZXRMaW5lRGFzaFwiLFxuICAgIFwiZ2V0TG9jYWxDYW5kaWRhdGVzXCIsXG4gICAgXCJnZXRMb2NhbFBhcmFtZXRlcnNcIixcbiAgICBcImdldExvY2FsU3RyZWFtc1wiLFxuICAgIFwiZ2V0TWFuYWdlZENvbmZpZ3VyYXRpb25cIixcbiAgICBcImdldE1hbmlmZXN0XCIsXG4gICAgXCJnZXRNYXBwZWRSYW5nZVwiLFxuICAgIFwiZ2V0TWFya3NcIixcbiAgICBcImdldE1hdGNoZWRDU1NSdWxlc1wiLFxuICAgIFwiZ2V0TWF4R0NQYXVzZVNpbmNlQ2xlYXJcIixcbiAgICBcImdldE1lYXN1cmVzXCIsXG4gICAgXCJnZXRNZXNzYWdlXCIsXG4gICAgXCJnZXRNZXRhZGF0YVwiLFxuICAgIFwiZ2V0TWlsbGlzZWNvbmRzXCIsXG4gICAgXCJnZXRNaW51dGVzXCIsXG4gICAgXCJnZXRNb2RpZmllclN0YXRlXCIsXG4gICAgXCJnZXRNb250aFwiLFxuICAgIFwiZ2V0TmFtZVwiLFxuICAgIFwiZ2V0TmFtZWRJdGVtXCIsXG4gICAgXCJnZXROYW1lZEl0ZW1OU1wiLFxuICAgIFwiZ2V0TmF0aXZlRnJhbWVidWZmZXJTY2FsZUZhY3RvclwiLFxuICAgIFwiZ2V0TmVnb3RpYXRlZEhlYWRlckV4dGVuc2lvbnNcIixcbiAgICBcImdldE5lc3RlZENvbmZpZ3NcIixcbiAgICBcImdldE5vdGlmaWNhdGlvbnNcIixcbiAgICBcImdldE5vdGlmaWVyXCIsXG4gICAgXCJnZXROdW1iZXJPZkNoYXJzXCIsXG4gICAgXCJnZXRPZmZzZXRSZWZlcmVuY2VTcGFjZVwiLFxuICAgIFwiZ2V0T3V0cHV0VGltZXN0YW1wXCIsXG4gICAgXCJnZXRPdmVycmlkZUhpc3RvcnlOYXZpZ2F0aW9uTW9kZVwiLFxuICAgIFwiZ2V0T3ZlcnJpZGVTdHlsZVwiLFxuICAgIFwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXCIsXG4gICAgXCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzXCIsXG4gICAgXCJnZXRPd25Qcm9wZXJ0eU5hbWVzXCIsXG4gICAgXCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcIixcbiAgICBcImdldFBhY2thZ2VEaXJlY3RvcnlFbnRyeVwiLFxuICAgIFwiZ2V0UGFyYW1ldGVyXCIsXG4gICAgXCJnZXRQYXJhbWV0ZXJzXCIsXG4gICAgXCJnZXRQYXJlbnRcIixcbiAgICBcImdldFBhdGhTZWdBdExlbmd0aFwiLFxuICAgIFwiZ2V0UGVybWlzc2lvbldhcm5pbmdzQnlNYW5pZmVzdFwiLFxuICAgIFwiZ2V0UGhvdG9DYXBhYmlsaXRpZXNcIixcbiAgICBcImdldFBob3RvU2V0dGluZ3NcIixcbiAgICBcImdldFBsYXRmb3JtSW5mb1wiLFxuICAgIFwiZ2V0UG9pbnRBdExlbmd0aFwiLFxuICAgIFwiZ2V0UG9wdXBcIixcbiAgICBcImdldFBvcnRzXCIsXG4gICAgXCJnZXRQb3NlXCIsXG4gICAgXCJnZXRQcmVkaWN0ZWRFdmVudHNcIixcbiAgICBcImdldFByZWZlcmVuY2VcIixcbiAgICBcImdldFByZWZlcmVuY2VEZWZhdWx0XCIsXG4gICAgXCJnZXRQcmVmZXJyZWRDYW52YXNGb3JtYXRcIixcbiAgICBcImdldFByZXNlbnRhdGlvbkF0dHJpYnV0ZVwiLFxuICAgIFwiZ2V0UHJldmVudERlZmF1bHRcIixcbiAgICBcImdldFByaW1hcnlTZXJ2aWNlXCIsXG4gICAgXCJnZXRQcmltYXJ5U2VydmljZXNcIixcbiAgICBcImdldFByb2dyYW1JbmZvTG9nXCIsXG4gICAgXCJnZXRQcm9ncmFtUGFyYW1ldGVyXCIsXG4gICAgXCJnZXRQcm9wZXJ0eUNTU1ZhbHVlXCIsXG4gICAgXCJnZXRQcm9wZXJ0eVByaW9yaXR5XCIsXG4gICAgXCJnZXRQcm9wZXJ0eVNob3J0aGFuZFwiLFxuICAgIFwiZ2V0UHJvcGVydHlUeXBlXCIsXG4gICAgXCJnZXRQcm9wZXJ0eVZhbHVlXCIsXG4gICAgXCJnZXRQcm90b3R5cGVPZlwiLFxuICAgIFwiZ2V0UHVibGljS2V5XCIsXG4gICAgXCJnZXRQdWJsaWNLZXlBbGdvcml0aG1cIixcbiAgICBcImdldFF1ZXJ5XCIsXG4gICAgXCJnZXRRdWVyeVBhcmFtZXRlclwiLFxuICAgIFwiZ2V0UkdCQ29sb3JWYWx1ZVwiLFxuICAgIFwiZ2V0UmFuZG9tVmFsdWVzXCIsXG4gICAgXCJnZXRSYW5nZUF0XCIsXG4gICAgXCJnZXRSZWFkZXJcIixcbiAgICBcImdldFJlY2VpdmVyc1wiLFxuICAgIFwiZ2V0UmVjdFZhbHVlXCIsXG4gICAgXCJnZXRSZWZsZWN0aW9uQ3ViZU1hcFwiLFxuICAgIFwiZ2V0UmVnaXN0cmF0aW9uXCIsXG4gICAgXCJnZXRSZWdpc3RyYXRpb25zXCIsXG4gICAgXCJnZXRSZW1vdGVDYW5kaWRhdGVzXCIsXG4gICAgXCJnZXRSZW1vdGVDZXJ0aWZpY2F0ZXNcIixcbiAgICBcImdldFJlbW90ZVBhcmFtZXRlcnNcIixcbiAgICBcImdldFJlbW90ZVN0cmVhbXNcIixcbiAgICBcImdldFJlbmRlcmJ1ZmZlclBhcmFtZXRlclwiLFxuICAgIFwiZ2V0UmVzcG9uc2VIZWFkZXJcIixcbiAgICBcImdldFJvb3RcIixcbiAgICBcImdldFJvb3ROb2RlXCIsXG4gICAgXCJnZXRSb3RhdGlvbk9mQ2hhclwiLFxuICAgIFwiZ2V0U1ZHRG9jdW1lbnRcIixcbiAgICBcImdldFNhbXBsZXJQYXJhbWV0ZXJcIixcbiAgICBcImdldFNjcmVlbkNUTVwiLFxuICAgIFwiZ2V0U2NyZWVuRGV0YWlsc1wiLFxuICAgIFwiZ2V0U2Vjb25kc1wiLFxuICAgIFwiZ2V0U2VsZWN0ZWRDYW5kaWRhdGVQYWlyXCIsXG4gICAgXCJnZXRTZWxlY3Rpb25cIixcbiAgICBcImdldFNlbGZcIixcbiAgICBcImdldFNlbmRlcnNcIixcbiAgICBcImdldFNlcnZpY2VcIixcbiAgICBcImdldFNldENvb2tpZVwiLFxuICAgIFwiZ2V0U2V0dGluZ3NcIixcbiAgICBcImdldFNoYWRlckluZm9Mb2dcIixcbiAgICBcImdldFNoYWRlclBhcmFtZXRlclwiLFxuICAgIFwiZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0XCIsXG4gICAgXCJnZXRTaGFkZXJTb3VyY2VcIixcbiAgICBcImdldFNpZ25hbHNcIixcbiAgICBcImdldFNpbXBsZUR1cmF0aW9uXCIsXG4gICAgXCJnZXRTaXRlSWNvbnNcIixcbiAgICBcImdldFNvdXJjZXNcIixcbiAgICBcImdldFNwZWN1bGF0aXZlUGFyc2VyVXJsc1wiLFxuICAgIFwiZ2V0U3RhcnRQb3NpdGlvbk9mQ2hhclwiLFxuICAgIFwiZ2V0U3RhcnRUaW1lXCIsXG4gICAgXCJnZXRTdGF0ZVwiLFxuICAgIFwiZ2V0U3RhdHNcIixcbiAgICBcImdldFN0YXR1c0ZvclBvbGljeVwiLFxuICAgIFwiZ2V0U3RvcmFnZVVwZGF0ZXNcIixcbiAgICBcImdldFN0cmVhbUJ5SWRcIixcbiAgICBcImdldFN0cmluZ1ZhbHVlXCIsXG4gICAgXCJnZXRTdWJTdHJpbmdMZW5ndGhcIixcbiAgICBcImdldFN1YnNjcmlwdGlvblwiLFxuICAgIFwiZ2V0U3Vic2NyaXB0aW9uc1wiLFxuICAgIFwiZ2V0U3VwcG9ydGVkQ29uc3RyYWludHNcIixcbiAgICBcImdldFN1cHBvcnRlZEV4dGVuc2lvbnNcIixcbiAgICBcImdldFN1cHBvcnRlZEZvcm1hdHNcIixcbiAgICBcImdldFN5bmNQYXJhbWV0ZXJcIixcbiAgICBcImdldFN5bmNocm9uaXphdGlvblNvdXJjZXNcIixcbiAgICBcImdldFRhZ3NcIixcbiAgICBcImdldFRhcmdldFJhbmdlc1wiLFxuICAgIFwiZ2V0VGV4UGFyYW1ldGVyXCIsXG4gICAgXCJnZXRUZXh0Rm9ybWF0c1wiLFxuICAgIFwiZ2V0VGltZVwiLFxuICAgIFwiZ2V0VGltZXpvbmVPZmZzZXRcIixcbiAgICBcImdldFRpbWluZ1wiLFxuICAgIFwiZ2V0VGl0bGVcIixcbiAgICBcImdldFRpdGxlYmFyQXJlYVJlY3RcIixcbiAgICBcImdldFRvdGFsTGVuZ3RoXCIsXG4gICAgXCJnZXRUcmFja0J5SWRcIixcbiAgICBcImdldFRyYWNrc1wiLFxuICAgIFwiZ2V0VHJhbnNjZWl2ZXJzXCIsXG4gICAgXCJnZXRUcmFuc2Zvcm1cIixcbiAgICBcImdldFRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ1wiLFxuICAgIFwiZ2V0VHJhbnNmb3JtVG9FbGVtZW50XCIsXG4gICAgXCJnZXRUcmFuc3BvcnRzXCIsXG4gICAgXCJnZXRUeXBlXCIsXG4gICAgXCJnZXRUeXBlTWFwcGluZ1wiLFxuICAgIFwiZ2V0VUlMYW5ndWFnZVwiLFxuICAgIFwiZ2V0VVJMXCIsXG4gICAgXCJnZXRVVENEYXRlXCIsXG4gICAgXCJnZXRVVENEYXlcIixcbiAgICBcImdldFVUQ0Z1bGxZZWFyXCIsXG4gICAgXCJnZXRVVENIb3Vyc1wiLFxuICAgIFwiZ2V0VVRDTWlsbGlzZWNvbmRzXCIsXG4gICAgXCJnZXRVVENNaW51dGVzXCIsXG4gICAgXCJnZXRVVENNb250aFwiLFxuICAgIFwiZ2V0VVRDU2Vjb25kc1wiLFxuICAgIFwiZ2V0VWludDE2XCIsXG4gICAgXCJnZXRVaW50MzJcIixcbiAgICBcImdldFVpbnQ4XCIsXG4gICAgXCJnZXRVbmlmb3JtXCIsXG4gICAgXCJnZXRVbmlmb3JtQmxvY2tJbmRleFwiLFxuICAgIFwiZ2V0VW5pZm9ybUluZGljZXNcIixcbiAgICBcImdldFVuaWZvcm1Mb2NhdGlvblwiLFxuICAgIFwiZ2V0VXNlckluZm9cIixcbiAgICBcImdldFVzZXJNZWRpYVwiLFxuICAgIFwiZ2V0VXNlclNldHRpbmdzXCIsXG4gICAgXCJnZXRWUkRpc3BsYXlzXCIsXG4gICAgXCJnZXRWYWx1ZXNcIixcbiAgICBcImdldFZhckRhdGVcIixcbiAgICBcImdldFZhcmlhYmxlVmFsdWVcIixcbiAgICBcImdldFZlcnRleEF0dHJpYlwiLFxuICAgIFwiZ2V0VmVydGV4QXR0cmliT2Zmc2V0XCIsXG4gICAgXCJnZXRWaWRlb1BsYXliYWNrUXVhbGl0eVwiLFxuICAgIFwiZ2V0VmlkZW9UcmFja3NcIixcbiAgICBcImdldFZpZXdlclBvc2VcIixcbiAgICBcImdldFZpZXdwb3J0XCIsXG4gICAgXCJnZXRWaWV3c1wiLFxuICAgIFwiZ2V0Vm9pY2VzXCIsXG4gICAgXCJnZXRXYWtlTG9ja1N0YXRlXCIsXG4gICAgXCJnZXRXcml0ZXJcIixcbiAgICBcImdldFllYXJcIixcbiAgICBcImdldFpvb21cIixcbiAgICBcImdldFpvb21TZXR0aW5nc1wiLFxuICAgIFwiZ2l2ZW5OYW1lXCIsXG4gICAgXCJnbG9iYWxcIixcbiAgICBcImdsb2JhbEFscGhhXCIsXG4gICAgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIixcbiAgICBcImdsb2JhbFByaXZhY3lDb250cm9sXCIsXG4gICAgXCJnbG9iYWxUaGlzXCIsXG4gICAgXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgIFwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsXG4gICAgXCJnbHlwaFJlZlwiLFxuICAgIFwiZ29cIixcbiAgICBcImdvQmFja1wiLFxuICAgIFwiZ29Gb3J3YXJkXCIsXG4gICAgXCJncHVcIixcbiAgICBcImdyYWJGcmFtZVwiLFxuICAgIFwiZ3JhZFwiLFxuICAgIFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgICBcImdyYWRpZW50VW5pdHNcIixcbiAgICBcImdyYW1tYXJzXCIsXG4gICAgXCJncmVlblwiLFxuICAgIFwiZ3JpZFwiLFxuICAgIFwiZ3JpZC1hcmVhXCIsXG4gICAgXCJncmlkLWF1dG8tY29sdW1uc1wiLFxuICAgIFwiZ3JpZC1hdXRvLWZsb3dcIixcbiAgICBcImdyaWQtYXV0by1yb3dzXCIsXG4gICAgXCJncmlkLWNvbHVtblwiLFxuICAgIFwiZ3JpZC1jb2x1bW4tZW5kXCIsXG4gICAgXCJncmlkLWNvbHVtbi1nYXBcIixcbiAgICBcImdyaWQtY29sdW1uLXN0YXJ0XCIsXG4gICAgXCJncmlkLWdhcFwiLFxuICAgIFwiZ3JpZC1yb3dcIixcbiAgICBcImdyaWQtcm93LWVuZFwiLFxuICAgIFwiZ3JpZC1yb3ctZ2FwXCIsXG4gICAgXCJncmlkLXJvdy1zdGFydFwiLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZVwiLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZS1hcmVhc1wiLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zXCIsXG4gICAgXCJncmlkLXRlbXBsYXRlLXJvd3NcIixcbiAgICBcImdyaWRBcmVhXCIsXG4gICAgXCJncmlkQXV0b0NvbHVtbnNcIixcbiAgICBcImdyaWRBdXRvRmxvd1wiLFxuICAgIFwiZ3JpZEF1dG9Sb3dzXCIsXG4gICAgXCJncmlkQ29sdW1uXCIsXG4gICAgXCJncmlkQ29sdW1uRW5kXCIsXG4gICAgXCJncmlkQ29sdW1uR2FwXCIsXG4gICAgXCJncmlkQ29sdW1uU3RhcnRcIixcbiAgICBcImdyaWRHYXBcIixcbiAgICBcImdyaWRSb3dcIixcbiAgICBcImdyaWRSb3dFbmRcIixcbiAgICBcImdyaWRSb3dHYXBcIixcbiAgICBcImdyaWRSb3dTdGFydFwiLFxuICAgIFwiZ3JpZFRlbXBsYXRlXCIsXG4gICAgXCJncmlkVGVtcGxhdGVBcmVhc1wiLFxuICAgIFwiZ3JpZFRlbXBsYXRlQ29sdW1uc1wiLFxuICAgIFwiZ3JpZFRlbXBsYXRlUm93c1wiLFxuICAgIFwiZ3JpcFNwYWNlXCIsXG4gICAgXCJncm91cFwiLFxuICAgIFwiZ3JvdXBCeVwiLFxuICAgIFwiZ3JvdXBDb2xsYXBzZWRcIixcbiAgICBcImdyb3VwRW5kXCIsXG4gICAgXCJncm91cElkXCIsXG4gICAgXCJncm91cHNcIixcbiAgICBcImdyb3dcIixcbiAgICBcImdyb3dhYmxlXCIsXG4gICAgXCJndWVzdFByb2Nlc3NJZFwiLFxuICAgIFwiZ3Vlc3RSZW5kZXJGcmFtZVJvdXRpbmdJZFwiLFxuICAgIFwiaGFkUmVjZW50SW5wdXRcIixcbiAgICBcImhhbmRcIixcbiAgICBcImhhbmRlZG5lc3NcIixcbiAgICBcImhhbmdpbmdCYXNlbGluZVwiLFxuICAgIFwiaGFwdGljQWN0dWF0b3JzXCIsXG4gICAgXCJoYXJkd2FyZUNvbmN1cnJlbmN5XCIsXG4gICAgXCJoYXNcIixcbiAgICBcImhhc0F0dHJpYnV0ZVwiLFxuICAgIFwiaGFzQXR0cmlidXRlTlNcIixcbiAgICBcImhhc0F0dHJpYnV0ZXNcIixcbiAgICBcImhhc0JlZW5BY3RpdmVcIixcbiAgICBcImhhc0NoaWxkTm9kZXNcIixcbiAgICBcImhhc0NvbXBvc2l0aW9uXCIsXG4gICAgXCJoYXNEeW5hbWljT2Zmc2V0XCIsXG4gICAgXCJoYXNFbnJvbGxlZEluc3RydW1lbnRcIixcbiAgICBcImhhc0V4dGVuc2lvblwiLFxuICAgIFwiaGFzRXh0ZXJuYWxEaXNwbGF5XCIsXG4gICAgXCJoYXNGZWF0dXJlXCIsXG4gICAgXCJoYXNGb2N1c1wiLFxuICAgIFwiaGFzSW5kaWNlc1wiLFxuICAgIFwiaGFzSW5zdGFuY2VcIixcbiAgICBcImhhc0xheW91dFwiLFxuICAgIFwiaGFzT3JpZW50YXRpb25cIixcbiAgICBcImhhc093blwiLFxuICAgIFwiaGFzT3duUHJvcGVydHlcIixcbiAgICBcImhhc1BvaW50ZXJDYXB0dXJlXCIsXG4gICAgXCJoYXNQb3NpdGlvblwiLFxuICAgIFwiaGFzUHJpdmF0ZVRva2VuXCIsXG4gICAgXCJoYXNSZWFkaW5nXCIsXG4gICAgXCJoYXNSZWRlbXB0aW9uUmVjb3JkXCIsXG4gICAgXCJoYXNSZWdFeHBHcm91cHNcIixcbiAgICBcImhhc1N0b3JhZ2VBY2Nlc3NcIixcbiAgICBcImhhc1VBVmlzdWFsVHJhbnNpdGlvblwiLFxuICAgIFwiaGFzVW5wYXJ0aXRpb25lZENvb2tpZUFjY2Vzc1wiLFxuICAgIFwiaGFzaFwiLFxuICAgIFwiaGFzaENoYW5nZVwiLFxuICAgIFwiaGVhZFwiLFxuICAgIFwiaGVhZGVyc1wiLFxuICAgIFwiaGVhZGluZ1wiLFxuICAgIFwiaGVpZ2h0XCIsXG4gICAgXCJoaWRcIixcbiAgICBcImhpZGRlblwiLFxuICAgIFwiaGlkZVwiLFxuICAgIFwiaGlkZUZvY3VzXCIsXG4gICAgXCJoaWRlUG9wb3ZlclwiLFxuICAgIFwiaGlnaFwiLFxuICAgIFwiaGlnaFdhdGVyTWFya1wiLFxuICAgIFwiaGlnaGxpZ2h0XCIsXG4gICAgXCJoaWdobGlnaHRzXCIsXG4gICAgXCJoaW50XCIsXG4gICAgXCJoaW50c1wiLFxuICAgIFwiaGlzdG9yeVwiLFxuICAgIFwiaG9ub3JpZmljUHJlZml4XCIsXG4gICAgXCJob25vcmlmaWNTdWZmaXhcIixcbiAgICBcImhvcml6b250YWxPdmVyZmxvd1wiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwiaG9zdENhbmRpZGF0ZVwiLFxuICAgIFwiaG9zdG5hbWVcIixcbiAgICBcImhyZWZcIixcbiAgICBcImhyZWZUcmFuc2xhdGVcIixcbiAgICBcImhyZWZsYW5nXCIsXG4gICAgXCJoc3BhY2VcIixcbiAgICBcImh0bWw1VGFnQ2hlY2tJbmVyZmFjZVwiLFxuICAgIFwiaHRtbEZvclwiLFxuICAgIFwiaHRtbFRleHRcIixcbiAgICBcImh0dHBFcXVpdlwiLFxuICAgIFwiaHR0cFJlcXVlc3RTdGF0dXNDb2RlXCIsXG4gICAgXCJod1RpbWVzdGFtcFwiLFxuICAgIFwiaHlwaGVuYXRlLWNoYXJhY3RlclwiLFxuICAgIFwiaHlwaGVuYXRlQ2hhcmFjdGVyXCIsXG4gICAgXCJoeXBoZW5zXCIsXG4gICAgXCJoeXBvdFwiLFxuICAgIFwiaTE4blwiLFxuICAgIFwiaWNcIixcbiAgICBcImljY0lkXCIsXG4gICAgXCJpY2VDb25uZWN0aW9uU3RhdGVcIixcbiAgICBcImljZUdhdGhlcmluZ1N0YXRlXCIsXG4gICAgXCJpY2VUcmFuc3BvcnRcIixcbiAgICBcImljb25cIixcbiAgICBcImljb25VUkxcIixcbiAgICBcImlkXCIsXG4gICAgXCJpZGVudGlmaWVyXCIsXG4gICAgXCJpZGVudGl0eVwiLFxuICAgIFwiaWRlb2dyYXBoaWNCYXNlbGluZVwiLFxuICAgIFwiaWRsZVwiLFxuICAgIFwiaWRwTG9naW5VcmxcIixcbiAgICBcImlnbm9yZUJPTVwiLFxuICAgIFwiaWdub3JlQ2FzZVwiLFxuICAgIFwiaWdub3JlRGVwdGhWYWx1ZXNcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJpbWFnZS1vcmllbnRhdGlvblwiLFxuICAgIFwiaW1hZ2UtcmVuZGVyaW5nXCIsXG4gICAgXCJpbWFnZUhlaWdodFwiLFxuICAgIFwiaW1hZ2VPcmllbnRhdGlvblwiLFxuICAgIFwiaW1hZ2VSZW5kZXJpbmdcIixcbiAgICBcImltYWdlU2l6ZXNcIixcbiAgICBcImltYWdlU21vb3RoaW5nRW5hYmxlZFwiLFxuICAgIFwiaW1hZ2VTbW9vdGhpbmdRdWFsaXR5XCIsXG4gICAgXCJpbWFnZVNyY3NldFwiLFxuICAgIFwiaW1hZ2VXaWR0aFwiLFxuICAgIFwiaW1hZ2VzXCIsXG4gICAgXCJpbWUtbW9kZVwiLFxuICAgIFwiaW1lTW9kZVwiLFxuICAgIFwiaW1wbGVtZW50YXRpb25cIixcbiAgICBcImltcG9ydEV4dGVybmFsVGV4dHVyZVwiLFxuICAgIFwiaW1wb3J0S2V5XCIsXG4gICAgXCJpbXBvcnROb2RlXCIsXG4gICAgXCJpbXBvcnRTdHlsZXNoZWV0XCIsXG4gICAgXCJpbXBvcnRzXCIsXG4gICAgXCJpbXBwXCIsXG4gICAgXCJpbXVsXCIsXG4gICAgXCJpblwiLFxuICAgIFwiaW4xXCIsXG4gICAgXCJpbjJcIixcbiAgICBcImluQmFuZE1ldGFkYXRhVHJhY2tEaXNwYXRjaFR5cGVcIixcbiAgICBcImluSW5jb2duaXRvQ29udGV4dFwiLFxuICAgIFwiaW5SYW5nZVwiLFxuICAgIFwiaW5jbHVkZXNcIixcbiAgICBcImluY29nbml0b1wiLFxuICAgIFwiaW5jb21pbmdCaWRpcmVjdGlvbmFsU3RyZWFtc1wiLFxuICAgIFwiaW5jb21pbmdIaWdoV2F0ZXJNYXJrXCIsXG4gICAgXCJpbmNvbWluZ01heEFnZVwiLFxuICAgIFwiaW5jb21pbmdVbmlkaXJlY3Rpb25hbFN0cmVhbXNcIixcbiAgICBcImluY3JlbWVudGFsXCIsXG4gICAgXCJpbmRldGVybWluYXRlXCIsXG4gICAgXCJpbmRleFwiLFxuICAgIFwiaW5kZXhOYW1lc1wiLFxuICAgIFwiaW5kZXhPZlwiLFxuICAgIFwiaW5kZXhlZERCXCIsXG4gICAgXCJpbmRpY2F0ZVwiLFxuICAgIFwiaW5kaWNlc1wiLFxuICAgIFwiaW5lcnRcIixcbiAgICBcImluZXJ0aWFEZXN0aW5hdGlvblhcIixcbiAgICBcImluZXJ0aWFEZXN0aW5hdGlvbllcIixcbiAgICBcImluZm9cIixcbiAgICBcImluaGVyaXRzXCIsXG4gICAgXCJpbml0XCIsXG4gICAgXCJpbml0QW5pbWF0aW9uRXZlbnRcIixcbiAgICBcImluaXRCZWZvcmVMb2FkRXZlbnRcIixcbiAgICBcImluaXRDbGlwYm9hcmRFdmVudFwiLFxuICAgIFwiaW5pdENsb3NlRXZlbnRcIixcbiAgICBcImluaXRDb21tYW5kRXZlbnRcIixcbiAgICBcImluaXRDb21wb3NpdGlvbkV2ZW50XCIsXG4gICAgXCJpbml0Q3VzdG9tRXZlbnRcIixcbiAgICBcImluaXREYXRhXCIsXG4gICAgXCJpbml0RGF0YVR5cGVcIixcbiAgICBcImluaXREZXZpY2VNb3Rpb25FdmVudFwiLFxuICAgIFwiaW5pdERldmljZU9yaWVudGF0aW9uRXZlbnRcIixcbiAgICBcImluaXREcmFnRXZlbnRcIixcbiAgICBcImluaXRFcnJvckV2ZW50XCIsXG4gICAgXCJpbml0RXZlbnRcIixcbiAgICBcImluaXRGb2N1c0V2ZW50XCIsXG4gICAgXCJpbml0R2VzdHVyZUV2ZW50XCIsXG4gICAgXCJpbml0SGFzaENoYW5nZUV2ZW50XCIsXG4gICAgXCJpbml0S2V5RXZlbnRcIixcbiAgICBcImluaXRLZXlib2FyZEV2ZW50XCIsXG4gICAgXCJpbml0TVNNYW5pcHVsYXRpb25FdmVudFwiLFxuICAgIFwiaW5pdE1lc3NhZ2VFdmVudFwiLFxuICAgIFwiaW5pdE1vdXNlRXZlbnRcIixcbiAgICBcImluaXRNb3VzZVNjcm9sbEV2ZW50XCIsXG4gICAgXCJpbml0TW91c2VXaGVlbEV2ZW50XCIsXG4gICAgXCJpbml0TXV0YXRpb25FdmVudFwiLFxuICAgIFwiaW5pdE5TTW91c2VFdmVudFwiLFxuICAgIFwiaW5pdE92ZXJmbG93RXZlbnRcIixcbiAgICBcImluaXRQYWdlRXZlbnRcIixcbiAgICBcImluaXRQYWdlVHJhbnNpdGlvbkV2ZW50XCIsXG4gICAgXCJpbml0UG9pbnRlckV2ZW50XCIsXG4gICAgXCJpbml0UG9wU3RhdGVFdmVudFwiLFxuICAgIFwiaW5pdFByb2dyZXNzRXZlbnRcIixcbiAgICBcImluaXRTY3JvbGxBcmVhRXZlbnRcIixcbiAgICBcImluaXRTaW1wbGVHZXN0dXJlRXZlbnRcIixcbiAgICBcImluaXRTdG9yYWdlRXZlbnRcIixcbiAgICBcImluaXRUZXh0RXZlbnRcIixcbiAgICBcImluaXRUaW1lRXZlbnRcIixcbiAgICBcImluaXRUb3VjaEV2ZW50XCIsXG4gICAgXCJpbml0VHJhbnNpdGlvbkV2ZW50XCIsXG4gICAgXCJpbml0VUlFdmVudFwiLFxuICAgIFwiaW5pdFdlYktpdEFuaW1hdGlvbkV2ZW50XCIsXG4gICAgXCJpbml0V2ViS2l0VHJhbnNpdGlvbkV2ZW50XCIsXG4gICAgXCJpbml0V2ViS2l0V2hlZWxFdmVudFwiLFxuICAgIFwiaW5pdFdoZWVsRXZlbnRcIixcbiAgICBcImluaXRpYWxUaW1lXCIsXG4gICAgXCJpbml0aWFsVmFsdWVcIixcbiAgICBcImluaXRpYWxpemVcIixcbiAgICBcImluaXRpYXRvclR5cGVcIixcbiAgICBcImluamVjdFwiLFxuICAgIFwiaW5rXCIsXG4gICAgXCJpbmxpbmUtc2l6ZVwiLFxuICAgIFwiaW5saW5lU2l6ZVwiLFxuICAgIFwiaW5saW5lVmVydGljYWxGaWVsZE9mVmlld1wiLFxuICAgIFwiaW5uZXJcIixcbiAgICBcImlubmVySFRNTFwiLFxuICAgIFwiaW5uZXJIZWlnaHRcIixcbiAgICBcImlubmVyVGV4dFwiLFxuICAgIFwiaW5uZXJXaWR0aFwiLFxuICAgIFwiaW5wdXRcIixcbiAgICBcImlucHV0QnVmZmVyXCIsXG4gICAgXCJpbnB1dEVuY29kaW5nXCIsXG4gICAgXCJpbnB1dE1ldGhvZFwiLFxuICAgIFwiaW5wdXRNb2RlXCIsXG4gICAgXCJpbnB1dFNvdXJjZVwiLFxuICAgIFwiaW5wdXRTb3VyY2VzXCIsXG4gICAgXCJpbnB1dFR5cGVcIixcbiAgICBcImlucHV0c1wiLFxuICAgIFwiaW5zZXJ0QWRqYWNlbnRFbGVtZW50XCIsXG4gICAgXCJpbnNlcnRBZGphY2VudEhUTUxcIixcbiAgICBcImluc2VydEFkamFjZW50VGV4dFwiLFxuICAgIFwiaW5zZXJ0QmVmb3JlXCIsXG4gICAgXCJpbnNlcnRDZWxsXCIsXG4gICAgXCJpbnNlcnREVE1GXCIsXG4gICAgXCJpbnNlcnREYXRhXCIsXG4gICAgXCJpbnNlcnREZWJ1Z01hcmtlclwiLFxuICAgIFwiaW5zZXJ0SXRlbUJlZm9yZVwiLFxuICAgIFwiaW5zZXJ0Tm9kZVwiLFxuICAgIFwiaW5zZXJ0Um93XCIsXG4gICAgXCJpbnNlcnRSdWxlXCIsXG4gICAgXCJpbnNldFwiLFxuICAgIFwiaW5zZXQtYmxvY2tcIixcbiAgICBcImluc2V0LWJsb2NrLWVuZFwiLFxuICAgIFwiaW5zZXQtYmxvY2stc3RhcnRcIixcbiAgICBcImluc2V0LWlubGluZVwiLFxuICAgIFwiaW5zZXQtaW5saW5lLWVuZFwiLFxuICAgIFwiaW5zZXQtaW5saW5lLXN0YXJ0XCIsXG4gICAgXCJpbnNldEJsb2NrXCIsXG4gICAgXCJpbnNldEJsb2NrRW5kXCIsXG4gICAgXCJpbnNldEJsb2NrU3RhcnRcIixcbiAgICBcImluc2V0SW5saW5lXCIsXG4gICAgXCJpbnNldElubGluZUVuZFwiLFxuICAgIFwiaW5zZXRJbmxpbmVTdGFydFwiLFxuICAgIFwiaW5zdGFsbFwiLFxuICAgIFwiaW5zdGFsbGluZ1wiLFxuICAgIFwiaW5zdGFuY2VSb290XCIsXG4gICAgXCJpbnN0YW50aWF0ZVwiLFxuICAgIFwiaW5zdGFudGlhdGVTdHJlYW1pbmdcIixcbiAgICBcImluc3RydW1lbnRzXCIsXG4gICAgXCJpbnQxNlwiLFxuICAgIFwiaW50MzJcIixcbiAgICBcImludDhcIixcbiAgICBcImludGVncml0eVwiLFxuICAgIFwiaW50ZXJhY3Rpb25JZFwiLFxuICAgIFwiaW50ZXJhY3Rpb25Nb2RlXCIsXG4gICAgXCJpbnRlcmNlcHRcIixcbiAgICBcImludGVyZmFjZUNsYXNzXCIsXG4gICAgXCJpbnRlcmZhY2VOYW1lXCIsXG4gICAgXCJpbnRlcmZhY2VOdW1iZXJcIixcbiAgICBcImludGVyZmFjZVByb3RvY29sXCIsXG4gICAgXCJpbnRlcmZhY2VTdWJjbGFzc1wiLFxuICAgIFwiaW50ZXJmYWNlc1wiLFxuICAgIFwiaW50ZXJpbVJlc3VsdHNcIixcbiAgICBcImludGVybmFsU3Vic2V0XCIsXG4gICAgXCJpbnRlcnByZXRhdGlvblwiLFxuICAgIFwiaW50ZXJzZWN0aW9uXCIsXG4gICAgXCJpbnRlcnNlY3Rpb25SYXRpb1wiLFxuICAgIFwiaW50ZXJzZWN0aW9uUmVjdFwiLFxuICAgIFwiaW50ZXJzZWN0c05vZGVcIixcbiAgICBcImludGVydmFsXCIsXG4gICAgXCJpbnZhbGlkSXRlcmF0b3JTdGF0ZVwiLFxuICAgIFwiaW52YWxpZGF0ZUZyYW1lYnVmZmVyXCIsXG4gICAgXCJpbnZhbGlkYXRlU3ViRnJhbWVidWZmZXJcIixcbiAgICBcImludmVyc2VcIixcbiAgICBcImludmVydFNlbGZcIixcbiAgICBcImludm9rZXJcIixcbiAgICBcImludm9rZXJUeXBlXCIsXG4gICAgXCJpc1wiLFxuICAgIFwiaXMyRFwiLFxuICAgIFwiaXNBY3RpdmVcIixcbiAgICBcImlzQWxsb3dlZEZpbGVTY2hlbWVBY2Nlc3NcIixcbiAgICBcImlzQWxsb3dlZEluY29nbml0b0FjY2Vzc1wiLFxuICAgIFwiaXNBbHRlcm5hdGVcIixcbiAgICBcImlzQXJyYXlcIixcbiAgICBcImlzQXV0b1NlbGVjdGVkXCIsXG4gICAgXCJpc0JpbmdDdXJyZW50U2VhcmNoRGVmYXVsdFwiLFxuICAgIFwiaXNCdWZmZXJcIixcbiAgICBcImlzQ2FuZGlkYXRlV2luZG93VmlzaWJsZVwiLFxuICAgIFwiaXNDaGFyXCIsXG4gICAgXCJpc0NvbGxhcHNlZFwiLFxuICAgIFwiaXNDb21wb3NpbmdcIixcbiAgICBcImlzQ29uY2F0U3ByZWFkYWJsZVwiLFxuICAgIFwiaXNDb25kaXRpb25hbE1lZGlhdGlvbkF2YWlsYWJsZVwiLFxuICAgIFwiaXNDb25maWdTdXBwb3J0ZWRcIixcbiAgICBcImlzQ29ubmVjdGVkXCIsXG4gICAgXCJpc0NvbnRlbnRFZGl0YWJsZVwiLFxuICAgIFwiaXNDb250ZW50SGFuZGxlclJlZ2lzdGVyZWRcIixcbiAgICBcImlzQ29udGV4dExvc3RcIixcbiAgICBcImlzRGVmYXVsdE5hbWVzcGFjZVwiLFxuICAgIFwiaXNEaXJlY3RvcnlcIixcbiAgICBcImlzRGlzYWJsZWRcIixcbiAgICBcImlzRGlzam9pbnRGcm9tXCIsXG4gICAgXCJpc0VuYWJsZWRcIixcbiAgICBcImlzRXF1YWxcIixcbiAgICBcImlzRXF1YWxOb2RlXCIsXG4gICAgXCJpc0V4dGVuZGVkXCIsXG4gICAgXCJpc0V4dGVuc2libGVcIixcbiAgICBcImlzRXh0ZXJuYWxDVEFQMlNlY3VyaXR5S2V5U3VwcG9ydGVkXCIsXG4gICAgXCJpc0ZhbGxiYWNrQWRhcHRlclwiLFxuICAgIFwiaXNGaWxlXCIsXG4gICAgXCJpc0Zpbml0ZVwiLFxuICAgIFwiaXNGaXJzdFBlcnNvbk9ic2VydmVyXCIsXG4gICAgXCJpc0ZyYW1lYnVmZmVyXCIsXG4gICAgXCJpc0Zyb3plblwiLFxuICAgIFwiaXNHZW5lcmF0b3JcIixcbiAgICBcImlzSFRNTFwiLFxuICAgIFwiaXNIaXN0b3J5TmF2aWdhdGlvblwiLFxuICAgIFwiaXNJZFwiLFxuICAgIFwiaXNJZGVudGl0eVwiLFxuICAgIFwiaXNJbmplY3RlZFwiLFxuICAgIFwiaXNJbnB1dFBlbmRpbmdcIixcbiAgICBcImlzSW50ZWdlclwiLFxuICAgIFwiaXNJbnRlcm5hbFwiLFxuICAgIFwiaXNJbnRlcnNlY3RpbmdcIixcbiAgICBcImlzTG9ja0ZyZWVcIixcbiAgICBcImlzTWFwXCIsXG4gICAgXCJpc011bHRpTGluZVwiLFxuICAgIFwiaXNOYU5cIixcbiAgICBcImlzT3BlblwiLFxuICAgIFwiaXNQb2ludEluRmlsbFwiLFxuICAgIFwiaXNQb2ludEluUGF0aFwiLFxuICAgIFwiaXNQb2ludEluUmFuZ2VcIixcbiAgICBcImlzUG9pbnRJblN0cm9rZVwiLFxuICAgIFwiaXNQcmVmQWx0ZXJuYXRlXCIsXG4gICAgXCJpc1ByZXNlbnRpbmdcIixcbiAgICBcImlzUHJpbWFyeVwiLFxuICAgIFwiaXNQcm9ncmFtXCIsXG4gICAgXCJpc1Byb3BlcnR5SW1wbGljaXRcIixcbiAgICBcImlzUHJvdG9jb2xIYW5kbGVyUmVnaXN0ZXJlZFwiLFxuICAgIFwiaXNQcm90b3R5cGVPZlwiLFxuICAgIFwiaXNRdWVyeVwiLFxuICAgIFwiaXNSYXdKU09OXCIsXG4gICAgXCJpc1JlbmRlcmJ1ZmZlclwiLFxuICAgIFwiaXNTYWZlSW50ZWdlclwiLFxuICAgIFwiaXNTYW1lRW50cnlcIixcbiAgICBcImlzU2FtZU5vZGVcIixcbiAgICBcImlzU2FtcGxlclwiLFxuICAgIFwiaXNTY3JpcHRcIixcbiAgICBcImlzU2NyaXB0VVJMXCIsXG4gICAgXCJpc1NlYWxlZFwiLFxuICAgIFwiaXNTZWN1cmVDb250ZXh0XCIsXG4gICAgXCJpc1Nlc3Npb25TdXBwb3J0ZWRcIixcbiAgICBcImlzU2hhZGVyXCIsXG4gICAgXCJpc1N1YnNldE9mXCIsXG4gICAgXCJpc1N1cGVyc2V0T2ZcIixcbiAgICBcImlzU3VwcG9ydGVkXCIsXG4gICAgXCJpc1N5bmNcIixcbiAgICBcImlzVGV4dEVkaXRcIixcbiAgICBcImlzVGV4dHVyZVwiLFxuICAgIFwiaXNUcmFuc2Zvcm1GZWVkYmFja1wiLFxuICAgIFwiaXNUcnVzdGVkXCIsXG4gICAgXCJpc1R5cGVTdXBwb3J0ZWRcIixcbiAgICBcImlzVXNlclZlcmlmeWluZ1BsYXRmb3JtQXV0aGVudGljYXRvckF2YWlsYWJsZVwiLFxuICAgIFwiaXNWZXJ0ZXhBcnJheVwiLFxuICAgIFwiaXNWaWV3XCIsXG4gICAgXCJpc1Zpc2libGVcIixcbiAgICBcImlzV2VsbEZvcm1lZFwiLFxuICAgIFwiaXNvY2hyb25vdXNUcmFuc2ZlckluXCIsXG4gICAgXCJpc29jaHJvbm91c1RyYW5zZmVyT3V0XCIsXG4gICAgXCJpc29sYXRpb25cIixcbiAgICBcIml0YWxpY3NcIixcbiAgICBcIml0ZW1cIixcbiAgICBcIml0ZW1JZFwiLFxuICAgIFwiaXRlbVByb3BcIixcbiAgICBcIml0ZW1SZWZcIixcbiAgICBcIml0ZW1TY29wZVwiLFxuICAgIFwiaXRlbVR5cGVcIixcbiAgICBcIml0ZW1WYWx1ZVwiLFxuICAgIFwiaXRlbXNcIixcbiAgICBcIml0ZXJhdGVOZXh0XCIsXG4gICAgXCJpdGVyYXRpb25Db21wb3NpdGVcIixcbiAgICBcIml0ZXJhdG9yXCIsXG4gICAgXCJqYXZhRW5hYmxlZFwiLFxuICAgIFwiaml0dGVyQnVmZmVyVGFyZ2V0XCIsXG4gICAgXCJqb2JUaXRsZVwiLFxuICAgIFwiam9pblwiLFxuICAgIFwiam9pbkFkSW50ZXJlc3RHcm91cFwiLFxuICAgIFwiam9pbnROYW1lXCIsXG4gICAgXCJqc29uXCIsXG4gICAgXCJqdXN0aWZ5LWNvbnRlbnRcIixcbiAgICBcImp1c3RpZnktaXRlbXNcIixcbiAgICBcImp1c3RpZnktc2VsZlwiLFxuICAgIFwianVzdGlmeUNvbnRlbnRcIixcbiAgICBcImp1c3RpZnlJdGVtc1wiLFxuICAgIFwianVzdGlmeVNlbGZcIixcbiAgICBcImsxXCIsXG4gICAgXCJrMlwiLFxuICAgIFwiazNcIixcbiAgICBcIms0XCIsXG4gICAgXCJrSHpcIixcbiAgICBcImtlZXBhbGl2ZVwiLFxuICAgIFwia2VybmVsTWF0cml4XCIsXG4gICAgXCJrZXJuZWxVbml0TGVuZ3RoWFwiLFxuICAgIFwia2VybmVsVW5pdExlbmd0aFlcIixcbiAgICBcImtlcm5pbmdcIixcbiAgICBcImtleVwiLFxuICAgIFwia2V5Q29kZVwiLFxuICAgIFwia2V5Rm9yXCIsXG4gICAgXCJrZXlJZGVudGlmaWVyXCIsXG4gICAgXCJrZXlMaWdodEVuYWJsZWRcIixcbiAgICBcImtleUxvY2F0aW9uXCIsXG4gICAgXCJrZXlQYXRoXCIsXG4gICAgXCJrZXlTdGF0dXNlc1wiLFxuICAgIFwia2V5U3lzdGVtXCIsXG4gICAgXCJrZXlUZXh0XCIsXG4gICAgXCJrZXlVc2FnZVwiLFxuICAgIFwia2V5Ym9hcmRcIixcbiAgICBcImtleXNcIixcbiAgICBcImtleXR5cGVcIixcbiAgICBcImtpbmRcIixcbiAgICBcImtuZWVcIixcbiAgICBcImtub3duU291cmNlc1wiLFxuICAgIFwibGFiZWxcIixcbiAgICBcImxhYmVsc1wiLFxuICAgIFwibGFuZ1wiLFxuICAgIFwibGFuZ3VhZ2VcIixcbiAgICBcImxhbmd1YWdlc1wiLFxuICAgIFwibGFyZ2VBcmNGbGFnXCIsXG4gICAgXCJsYXN0Q2hpbGRcIixcbiAgICBcImxhc3RFbGVtZW50Q2hpbGRcIixcbiAgICBcImxhc3RFcnJvclwiLFxuICAgIFwibGFzdEV2ZW50SWRcIixcbiAgICBcImxhc3RJbmRleFwiLFxuICAgIFwibGFzdEluZGV4T2ZcIixcbiAgICBcImxhc3RJbnB1dFRpbWVcIixcbiAgICBcImxhc3RNYXRjaFwiLFxuICAgIFwibGFzdE1lc3NhZ2VTdWJqZWN0XCIsXG4gICAgXCJsYXN0TWVzc2FnZVR5cGVcIixcbiAgICBcImxhc3RNb2RpZmllZFwiLFxuICAgIFwibGFzdE1vZGlmaWVkRGF0ZVwiLFxuICAgIFwibGFzdFBhZ2VcIixcbiAgICBcImxhc3RQYXJlblwiLFxuICAgIFwibGFzdFN0YXRlXCIsXG4gICAgXCJsYXN0U3R5bGVTaGVldFNldFwiLFxuICAgIFwibGF0ZW5jeVwiLFxuICAgIFwibGF0aXR1ZGVcIixcbiAgICBcImxhdW5jaFF1ZXVlXCIsXG4gICAgXCJsYXllck5hbWVcIixcbiAgICBcImxheWVyWFwiLFxuICAgIFwibGF5ZXJZXCIsXG4gICAgXCJsYXlvdXRcIixcbiAgICBcImxheW91dEZsb3dcIixcbiAgICBcImxheW91dEdyaWRcIixcbiAgICBcImxheW91dEdyaWRDaGFyXCIsXG4gICAgXCJsYXlvdXRHcmlkTGluZVwiLFxuICAgIFwibGF5b3V0R3JpZE1vZGVcIixcbiAgICBcImxheW91dEdyaWRUeXBlXCIsXG4gICAgXCJsYm91bmRcIixcbiAgICBcImxlYXZlQWRJbnRlcmVzdEdyb3VwXCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJsZWZ0Q29udGV4dFwiLFxuICAgIFwibGVmdERlZ3JlZXNcIixcbiAgICBcImxlZnRNYXJnaW5cIixcbiAgICBcImxlZnRQcm9qZWN0aW9uTWF0cml4XCIsXG4gICAgXCJsZWZ0Vmlld01hdHJpeFwiLFxuICAgIFwibGVuZ3RoXCIsXG4gICAgXCJsZW5ndGhBZGp1c3RcIixcbiAgICBcImxlbmd0aENvbXB1dGFibGVcIixcbiAgICBcImxldHRlci1zcGFjaW5nXCIsXG4gICAgXCJsZXR0ZXJTcGFjaW5nXCIsXG4gICAgXCJsZXZlbFwiLFxuICAgIFwibGhcIixcbiAgICBcImxpZ2h0aW5nLWNvbG9yXCIsXG4gICAgXCJsaWdodGluZ0NvbG9yXCIsXG4gICAgXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxuICAgIFwibGltaXRzXCIsXG4gICAgXCJsaW5lXCIsXG4gICAgXCJsaW5lLWJyZWFrXCIsXG4gICAgXCJsaW5lLWhlaWdodFwiLFxuICAgIFwibGluZUFsaWduXCIsXG4gICAgXCJsaW5lQnJlYWtcIixcbiAgICBcImxpbmVDYXBcIixcbiAgICBcImxpbmVEYXNoT2Zmc2V0XCIsXG4gICAgXCJsaW5lR2FwT3ZlcnJpZGVcIixcbiAgICBcImxpbmVIZWlnaHRcIixcbiAgICBcImxpbmVKb2luXCIsXG4gICAgXCJsaW5lTnVtXCIsXG4gICAgXCJsaW5lTnVtYmVyXCIsXG4gICAgXCJsaW5lUG9zXCIsXG4gICAgXCJsaW5lVG9cIixcbiAgICBcImxpbmVXaWR0aFwiLFxuICAgIFwibGluZWFyQWNjZWxlcmF0aW9uXCIsXG4gICAgXCJsaW5lYXJSYW1wVG9WYWx1ZUF0VGltZVwiLFxuICAgIFwibGluZWFyVmVsb2NpdHlcIixcbiAgICBcImxpbmVub1wiLFxuICAgIFwibGluZXNcIixcbiAgICBcImxpbmtcIixcbiAgICBcImxpbmtDb2xvclwiLFxuICAgIFwibGlua1Byb2dyYW1cIixcbiAgICBcImxpbmtzXCIsXG4gICAgXCJsaXN0XCIsXG4gICAgXCJsaXN0LXN0eWxlXCIsXG4gICAgXCJsaXN0LXN0eWxlLWltYWdlXCIsXG4gICAgXCJsaXN0LXN0eWxlLXBvc2l0aW9uXCIsXG4gICAgXCJsaXN0LXN0eWxlLXR5cGVcIixcbiAgICBcImxpc3RTdHlsZVwiLFxuICAgIFwibGlzdFN0eWxlSW1hZ2VcIixcbiAgICBcImxpc3RTdHlsZVBvc2l0aW9uXCIsXG4gICAgXCJsaXN0U3R5bGVUeXBlXCIsXG4gICAgXCJsaXN0ZW5lclwiLFxuICAgIFwibGlzdGVuZXJzXCIsXG4gICAgXCJsb2FkXCIsXG4gICAgXCJsb2FkRXZlbnRFbmRcIixcbiAgICBcImxvYWRFdmVudFN0YXJ0XCIsXG4gICAgXCJsb2FkT3BcIixcbiAgICBcImxvYWRUaW1lXCIsXG4gICAgXCJsb2FkVGltZXNcIixcbiAgICBcImxvYWRlZFwiLFxuICAgIFwibG9hZGluZ1wiLFxuICAgIFwibG9jYWxEZXNjcmlwdGlvblwiLFxuICAgIFwibG9jYWxOYW1lXCIsXG4gICAgXCJsb2NhbFNlcnZpY2VcIixcbiAgICBcImxvY2FsU3RvcmFnZVwiLFxuICAgIFwibG9jYWxlXCIsXG4gICAgXCJsb2NhbGVDb21wYXJlXCIsXG4gICAgXCJsb2NhdGlvblwiLFxuICAgIFwibG9jYXRpb25iYXJcIixcbiAgICBcImxvY2tcIixcbiAgICBcImxvY2tlZFwiLFxuICAgIFwibG9ja2VkRmlsZVwiLFxuICAgIFwibG9ja3NcIixcbiAgICBcImxvZE1heENsYW1wXCIsXG4gICAgXCJsb2RNaW5DbGFtcFwiLFxuICAgIFwibG9nXCIsXG4gICAgXCJsb2cxMFwiLFxuICAgIFwibG9nMXBcIixcbiAgICBcImxvZzJcIixcbiAgICBcImxvZ2ljYWxYRFBJXCIsXG4gICAgXCJsb2dpY2FsWURQSVwiLFxuICAgIFwibG9naW5cIixcbiAgICBcImxvZ2xldmVsXCIsXG4gICAgXCJsb25nRGVzY1wiLFxuICAgIFwibG9uZ2l0dWRlXCIsXG4gICAgXCJsb29rdXBOYW1lc3BhY2VVUklcIixcbiAgICBcImxvb2t1cFByZWZpeFwiLFxuICAgIFwibG9vcFwiLFxuICAgIFwibG9vcEVuZFwiLFxuICAgIFwibG9vcFN0YXJ0XCIsXG4gICAgXCJsb29waW5nXCIsXG4gICAgXCJsb3N0XCIsXG4gICAgXCJsb3dcIixcbiAgICBcImxvd2VyXCIsXG4gICAgXCJsb3dlckJvdW5kXCIsXG4gICAgXCJsb3dlck9wZW5cIixcbiAgICBcImxvd3NyY1wiLFxuICAgIFwibHZiXCIsXG4gICAgXCJsdmhcIixcbiAgICBcImx2aVwiLFxuICAgIFwibHZtYXhcIixcbiAgICBcImx2bWluXCIsXG4gICAgXCJsdndcIixcbiAgICBcIm0xMVwiLFxuICAgIFwibTEyXCIsXG4gICAgXCJtMTNcIixcbiAgICBcIm0xNFwiLFxuICAgIFwibTIxXCIsXG4gICAgXCJtMjJcIixcbiAgICBcIm0yM1wiLFxuICAgIFwibTI0XCIsXG4gICAgXCJtMzFcIixcbiAgICBcIm0zMlwiLFxuICAgIFwibTMzXCIsXG4gICAgXCJtMzRcIixcbiAgICBcIm00MVwiLFxuICAgIFwibTQyXCIsXG4gICAgXCJtNDNcIixcbiAgICBcIm00NFwiLFxuICAgIFwibWFnRmlsdGVyXCIsXG4gICAgXCJtYWtlWFJDb21wYXRpYmxlXCIsXG4gICAgXCJtYW5hZ2VkXCIsXG4gICAgXCJtYW5hZ2VtZW50XCIsXG4gICAgXCJtYW5pZmVzdFwiLFxuICAgIFwibWFudWZhY3R1cmVyXCIsXG4gICAgXCJtYW51ZmFjdHVyZXJOYW1lXCIsXG4gICAgXCJtYXBcIixcbiAgICBcIm1hcEFzeW5jXCIsXG4gICAgXCJtYXBTdGF0ZVwiLFxuICAgIFwibWFwcGVkQXRDcmVhdGlvblwiLFxuICAgIFwibWFwcGluZ1wiLFxuICAgIFwibWFyZ2luXCIsXG4gICAgXCJtYXJnaW4tYmxvY2tcIixcbiAgICBcIm1hcmdpbi1ibG9jay1lbmRcIixcbiAgICBcIm1hcmdpbi1ibG9jay1zdGFydFwiLFxuICAgIFwibWFyZ2luLWJvdHRvbVwiLFxuICAgIFwibWFyZ2luLWlubGluZVwiLFxuICAgIFwibWFyZ2luLWlubGluZS1lbmRcIixcbiAgICBcIm1hcmdpbi1pbmxpbmUtc3RhcnRcIixcbiAgICBcIm1hcmdpbi1sZWZ0XCIsXG4gICAgXCJtYXJnaW4tcmlnaHRcIixcbiAgICBcIm1hcmdpbi10b3BcIixcbiAgICBcIm1hcmdpbkJsb2NrXCIsXG4gICAgXCJtYXJnaW5CbG9ja0VuZFwiLFxuICAgIFwibWFyZ2luQmxvY2tTdGFydFwiLFxuICAgIFwibWFyZ2luQm90dG9tXCIsXG4gICAgXCJtYXJnaW5IZWlnaHRcIixcbiAgICBcIm1hcmdpbklubGluZVwiLFxuICAgIFwibWFyZ2luSW5saW5lRW5kXCIsXG4gICAgXCJtYXJnaW5JbmxpbmVTdGFydFwiLFxuICAgIFwibWFyZ2luTGVmdFwiLFxuICAgIFwibWFyZ2luUmlnaHRcIixcbiAgICBcIm1hcmdpblRvcFwiLFxuICAgIFwibWFyZ2luV2lkdGhcIixcbiAgICBcIm1hcmtcIixcbiAgICBcIm1hcmtlclwiLFxuICAgIFwibWFya2VyLWVuZFwiLFxuICAgIFwibWFya2VyLW1pZFwiLFxuICAgIFwibWFya2VyLW9mZnNldFwiLFxuICAgIFwibWFya2VyLXN0YXJ0XCIsXG4gICAgXCJtYXJrZXJFbmRcIixcbiAgICBcIm1hcmtlckhlaWdodFwiLFxuICAgIFwibWFya2VyTWlkXCIsXG4gICAgXCJtYXJrZXJPZmZzZXRcIixcbiAgICBcIm1hcmtlclN0YXJ0XCIsXG4gICAgXCJtYXJrZXJVbml0c1wiLFxuICAgIFwibWFya2VyV2lkdGhcIixcbiAgICBcIm1hcmtzXCIsXG4gICAgXCJtYXNrXCIsXG4gICAgXCJtYXNrLWNsaXBcIixcbiAgICBcIm1hc2stY29tcG9zaXRlXCIsXG4gICAgXCJtYXNrLWltYWdlXCIsXG4gICAgXCJtYXNrLW1vZGVcIixcbiAgICBcIm1hc2stb3JpZ2luXCIsXG4gICAgXCJtYXNrLXBvc2l0aW9uXCIsXG4gICAgXCJtYXNrLXBvc2l0aW9uLXhcIixcbiAgICBcIm1hc2stcG9zaXRpb24teVwiLFxuICAgIFwibWFzay1yZXBlYXRcIixcbiAgICBcIm1hc2stc2l6ZVwiLFxuICAgIFwibWFzay10eXBlXCIsXG4gICAgXCJtYXNrQ2xpcFwiLFxuICAgIFwibWFza0NvbXBvc2l0ZVwiLFxuICAgIFwibWFza0NvbnRlbnRVbml0c1wiLFxuICAgIFwibWFza0ltYWdlXCIsXG4gICAgXCJtYXNrTW9kZVwiLFxuICAgIFwibWFza09yaWdpblwiLFxuICAgIFwibWFza1Bvc2l0aW9uXCIsXG4gICAgXCJtYXNrUG9zaXRpb25YXCIsXG4gICAgXCJtYXNrUG9zaXRpb25ZXCIsXG4gICAgXCJtYXNrUmVwZWF0XCIsXG4gICAgXCJtYXNrU2l6ZVwiLFxuICAgIFwibWFza1R5cGVcIixcbiAgICBcIm1hc2tVbml0c1wiLFxuICAgIFwibWF0Y2hcIixcbiAgICBcIm1hdGNoQWxsXCIsXG4gICAgXCJtYXRjaE1lZGlhXCIsXG4gICAgXCJtYXRjaE1lZGl1bVwiLFxuICAgIFwibWF0Y2hQYXR0ZXJuc1wiLFxuICAgIFwibWF0Y2hlc1wiLFxuICAgIFwibWF0aC1kZXB0aFwiLFxuICAgIFwibWF0aC1zdHlsZVwiLFxuICAgIFwibWF0aERlcHRoXCIsXG4gICAgXCJtYXRoU3R5bGVcIixcbiAgICBcIm1hdHJpeFwiLFxuICAgIFwibWF0cml4VHJhbnNmb3JtXCIsXG4gICAgXCJtYXhcIixcbiAgICBcIm1heC1ibG9jay1zaXplXCIsXG4gICAgXCJtYXgtaGVpZ2h0XCIsXG4gICAgXCJtYXgtaW5saW5lLXNpemVcIixcbiAgICBcIm1heC13aWR0aFwiLFxuICAgIFwibWF4QWN0aW9uc1wiLFxuICAgIFwibWF4QWx0ZXJuYXRpdmVzXCIsXG4gICAgXCJtYXhBbmlzb3Ryb3B5XCIsXG4gICAgXCJtYXhCaW5kR3JvdXBzXCIsXG4gICAgXCJtYXhCaW5kR3JvdXBzUGx1c1ZlcnRleEJ1ZmZlcnNcIixcbiAgICBcIm1heEJpbmRpbmdzUGVyQmluZEdyb3VwXCIsXG4gICAgXCJtYXhCbG9ja1NpemVcIixcbiAgICBcIm1heEJ1ZmZlclNpemVcIixcbiAgICBcIm1heEJ5dGVMZW5ndGhcIixcbiAgICBcIm1heENoYW5uZWxDb3VudFwiLFxuICAgIFwibWF4Q2hhbm5lbHNcIixcbiAgICBcIm1heENvbG9yQXR0YWNobWVudEJ5dGVzUGVyU2FtcGxlXCIsXG4gICAgXCJtYXhDb2xvckF0dGFjaG1lbnRzXCIsXG4gICAgXCJtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXBcIixcbiAgICBcIm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWFwiLFxuICAgIFwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVZXCIsXG4gICAgXCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVpcIixcbiAgICBcIm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZVwiLFxuICAgIFwibWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb25cIixcbiAgICBcIm1heENvbm5lY3Rpb25zUGVyU2VydmVyXCIsXG4gICAgXCJtYXhEYXRhZ3JhbVNpemVcIixcbiAgICBcIm1heERlY2liZWxzXCIsXG4gICAgXCJtYXhEaXN0YW5jZVwiLFxuICAgIFwibWF4RHJhd0NvdW50XCIsXG4gICAgXCJtYXhEeW5hbWljU3RvcmFnZUJ1ZmZlcnNQZXJQaXBlbGluZUxheW91dFwiLFxuICAgIFwibWF4RHluYW1pY1VuaWZvcm1CdWZmZXJzUGVyUGlwZWxpbmVMYXlvdXRcIixcbiAgICBcIm1heEhlaWdodFwiLFxuICAgIFwibWF4SW5saW5lU2l6ZVwiLFxuICAgIFwibWF4SW50ZXJTdGFnZVNoYWRlckNvbXBvbmVudHNcIixcbiAgICBcIm1heEludGVyU3RhZ2VTaGFkZXJWYXJpYWJsZXNcIixcbiAgICBcIm1heExheWVyc1wiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtYXhNZXNzYWdlU2l6ZVwiLFxuICAgIFwibWF4UGFja2V0TGlmZVRpbWVcIixcbiAgICBcIm1heFJldHJhbnNtaXRzXCIsXG4gICAgXCJtYXhTYW1wbGVkVGV4dHVyZXNQZXJTaGFkZXJTdGFnZVwiLFxuICAgIFwibWF4U2FtcGxlcnNQZXJTaGFkZXJTdGFnZVwiLFxuICAgIFwibWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplXCIsXG4gICAgXCJtYXhTdG9yYWdlQnVmZmVyc1BlclNoYWRlclN0YWdlXCIsXG4gICAgXCJtYXhTdG9yYWdlVGV4dHVyZXNQZXJTaGFkZXJTdGFnZVwiLFxuICAgIFwibWF4VGV4dHVyZUFycmF5TGF5ZXJzXCIsXG4gICAgXCJtYXhUZXh0dXJlRGltZW5zaW9uMURcIixcbiAgICBcIm1heFRleHR1cmVEaW1lbnNpb24yRFwiLFxuICAgIFwibWF4VGV4dHVyZURpbWVuc2lvbjNEXCIsXG4gICAgXCJtYXhUb3VjaFBvaW50c1wiLFxuICAgIFwibWF4VW5pZm9ybUJ1ZmZlckJpbmRpbmdTaXplXCIsXG4gICAgXCJtYXhVbmlmb3JtQnVmZmVyc1BlclNoYWRlclN0YWdlXCIsXG4gICAgXCJtYXhWYWx1ZVwiLFxuICAgIFwibWF4VmVydGV4QXR0cmlidXRlc1wiLFxuICAgIFwibWF4VmVydGV4QnVmZmVyQXJyYXlTdHJpZGVcIixcbiAgICBcIm1heFZlcnRleEJ1ZmZlcnNcIixcbiAgICBcIm1heFdpZHRoXCIsXG4gICAgXCJtYXhpbXVtTGF0ZW5jeVwiLFxuICAgIFwibWVhc3VyZVwiLFxuICAgIFwibWVhc3VyZVRleHRcIixcbiAgICBcIm1lZGlhXCIsXG4gICAgXCJtZWRpYUNhcGFiaWxpdGllc1wiLFxuICAgIFwibWVkaWFEZXZpY2VzXCIsXG4gICAgXCJtZWRpYUVsZW1lbnRcIixcbiAgICBcIm1lZGlhR3JvdXBcIixcbiAgICBcIm1lZGlhS2V5c1wiLFxuICAgIFwibWVkaWFTZXNzaW9uXCIsXG4gICAgXCJtZWRpYVN0cmVhbVwiLFxuICAgIFwibWVkaWFUZXh0XCIsXG4gICAgXCJtZWV0T3JTbGljZVwiLFxuICAgIFwibWVtb3J5XCIsXG4gICAgXCJtZW51YmFyXCIsXG4gICAgXCJtZW51c1wiLFxuICAgIFwibWVudXNDaGlsZFwiLFxuICAgIFwibWVudXNJbnRlcm5hbFwiLFxuICAgIFwibWVyZ2VBdHRyaWJ1dGVzXCIsXG4gICAgXCJtZXNzYWdlXCIsXG4gICAgXCJtZXNzYWdlQ2xhc3NcIixcbiAgICBcIm1lc3NhZ2VIYW5kbGVyc1wiLFxuICAgIFwibWVzc2FnZVR5cGVcIixcbiAgICBcIm1lc3NhZ2VzXCIsXG4gICAgXCJtZXRhS2V5XCIsXG4gICAgXCJtZXRhZGF0YVwiLFxuICAgIFwibWV0aG9kXCIsXG4gICAgXCJtZXRob2REZXRhaWxzXCIsXG4gICAgXCJtZXRob2ROYW1lXCIsXG4gICAgXCJtaWRcIixcbiAgICBcIm1pbWVUeXBlXCIsXG4gICAgXCJtaW1lVHlwZXNcIixcbiAgICBcIm1pblwiLFxuICAgIFwibWluLWJsb2NrLXNpemVcIixcbiAgICBcIm1pbi1oZWlnaHRcIixcbiAgICBcIm1pbi1pbmxpbmUtc2l6ZVwiLFxuICAgIFwibWluLXdpZHRoXCIsXG4gICAgXCJtaW5CaW5kaW5nU2l6ZVwiLFxuICAgIFwibWluQmxvY2tTaXplXCIsXG4gICAgXCJtaW5EZWNpYmVsc1wiLFxuICAgIFwibWluRmlsdGVyXCIsXG4gICAgXCJtaW5IZWlnaHRcIixcbiAgICBcIm1pbklubGluZVNpemVcIixcbiAgICBcIm1pbkxlbmd0aFwiLFxuICAgIFwibWluU3RvcmFnZUJ1ZmZlck9mZnNldEFsaWdubWVudFwiLFxuICAgIFwibWluVW5pZm9ybUJ1ZmZlck9mZnNldEFsaWdubWVudFwiLFxuICAgIFwibWluVmFsdWVcIixcbiAgICBcIm1pbldpZHRoXCIsXG4gICAgXCJtaW5pbXVtTGF0ZW5jeVwiLFxuICAgIFwibWlwTGV2ZWxcIixcbiAgICBcIm1pcExldmVsQ291bnRcIixcbiAgICBcIm1pcG1hcEZpbHRlclwiLFxuICAgIFwibWl0ZXJMaW1pdFwiLFxuICAgIFwibWl4LWJsZW5kLW1vZGVcIixcbiAgICBcIm1peEJsZW5kTW9kZVwiLFxuICAgIFwibW1cIixcbiAgICBcIm1vYmlsZVwiLFxuICAgIFwibW9kZVwiLFxuICAgIFwibW9kZWxcIixcbiAgICBcIm1vZGlmeVwiLFxuICAgIFwibW9kdWxlXCIsXG4gICAgXCJtb3VudFwiLFxuICAgIFwibW92ZVwiLFxuICAgIFwibW92ZUJ5XCIsXG4gICAgXCJtb3ZlRW5kXCIsXG4gICAgXCJtb3ZlRmlyc3RcIixcbiAgICBcIm1vdmVGb2N1c0Rvd25cIixcbiAgICBcIm1vdmVGb2N1c0xlZnRcIixcbiAgICBcIm1vdmVGb2N1c1JpZ2h0XCIsXG4gICAgXCJtb3ZlRm9jdXNVcFwiLFxuICAgIFwibW92ZUluU3VjY2Vzc2lvblwiLFxuICAgIFwibW92ZU5leHRcIixcbiAgICBcIm1vdmVSb3dcIixcbiAgICBcIm1vdmVTdGFydFwiLFxuICAgIFwibW92ZVRvXCIsXG4gICAgXCJtb3ZlVG9Cb29rbWFya1wiLFxuICAgIFwibW92ZVRvRWxlbWVudFRleHRcIixcbiAgICBcIm1vdmVUb1BvaW50XCIsXG4gICAgXCJtb3ZlbWVudFhcIixcbiAgICBcIm1vdmVtZW50WVwiLFxuICAgIFwibW96QWRkXCIsXG4gICAgXCJtb3pBbmltYXRpb25TdGFydFRpbWVcIixcbiAgICBcIm1vekFub25cIixcbiAgICBcIm1vekFwcHNcIixcbiAgICBcIm1vekF1ZGlvQ2FwdHVyZWRcIixcbiAgICBcIm1vekF1ZGlvQ2hhbm5lbFR5cGVcIixcbiAgICBcIm1vekF1dG9wbGF5RW5hYmxlZFwiLFxuICAgIFwibW96Q2FuY2VsQW5pbWF0aW9uRnJhbWVcIixcbiAgICBcIm1vekNhbmNlbEZ1bGxTY3JlZW5cIixcbiAgICBcIm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgIFwibW96Q2FwdHVyZVN0cmVhbVwiLFxuICAgIFwibW96Q2FwdHVyZVN0cmVhbVVudGlsRW5kZWRcIixcbiAgICBcIm1vekNsZWFyRGF0YUF0XCIsXG4gICAgXCJtb3pDb250YWN0XCIsXG4gICAgXCJtb3pDb250YWN0c1wiLFxuICAgIFwibW96Q3JlYXRlRmlsZUhhbmRsZVwiLFxuICAgIFwibW96Q3VycmVudFRyYW5zZm9ybVwiLFxuICAgIFwibW96Q3VycmVudFRyYW5zZm9ybUludmVyc2VcIixcbiAgICBcIm1vekN1cnNvclwiLFxuICAgIFwibW96RGFzaFwiLFxuICAgIFwibW96RGFzaE9mZnNldFwiLFxuICAgIFwibW96RGVjb2RlZEZyYW1lc1wiLFxuICAgIFwibW96RXhpdFBvaW50ZXJMb2NrXCIsXG4gICAgXCJtb3pGaWxsUnVsZVwiLFxuICAgIFwibW96RnJhZ21lbnRFbmRcIixcbiAgICBcIm1vekZyYW1lRGVsYXlcIixcbiAgICBcIm1vekZ1bGxTY3JlZW5cIixcbiAgICBcIm1vekZ1bGxTY3JlZW5FbGVtZW50XCIsXG4gICAgXCJtb3pGdWxsU2NyZWVuRW5hYmxlZFwiLFxuICAgIFwibW96R2V0QWxsXCIsXG4gICAgXCJtb3pHZXRBbGxLZXlzXCIsXG4gICAgXCJtb3pHZXRBc0ZpbGVcIixcbiAgICBcIm1vekdldERhdGFBdFwiLFxuICAgIFwibW96R2V0TWV0YWRhdGFcIixcbiAgICBcIm1vekdldFVzZXJNZWRpYVwiLFxuICAgIFwibW96SGFzQXVkaW9cIixcbiAgICBcIm1vekhhc0l0ZW1cIixcbiAgICBcIm1vekhpZGRlblwiLFxuICAgIFwibW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIsXG4gICAgXCJtb3pJbmRleGVkREJcIixcbiAgICBcIm1veklubmVyU2NyZWVuWFwiLFxuICAgIFwibW96SW5uZXJTY3JlZW5ZXCIsXG4gICAgXCJtb3pJbnB1dFNvdXJjZVwiLFxuICAgIFwibW96SXNUZXh0RmllbGRcIixcbiAgICBcIm1vekl0ZW1cIixcbiAgICBcIm1vekl0ZW1Db3VudFwiLFxuICAgIFwibW96SXRlbXNcIixcbiAgICBcIm1vekxlbmd0aFwiLFxuICAgIFwibW96TG9ja09yaWVudGF0aW9uXCIsXG4gICAgXCJtb3pNYXRjaGVzU2VsZWN0b3JcIixcbiAgICBcIm1vek1vdmVtZW50WFwiLFxuICAgIFwibW96TW92ZW1lbnRZXCIsXG4gICAgXCJtb3pPcGFxdWVcIixcbiAgICBcIm1vek9yaWVudGF0aW9uXCIsXG4gICAgXCJtb3pQYWludENvdW50XCIsXG4gICAgXCJtb3pQYWludGVkRnJhbWVzXCIsXG4gICAgXCJtb3pQYXJzZWRGcmFtZXNcIixcbiAgICBcIm1velBheVwiLFxuICAgIFwibW96UG9pbnRlckxvY2tFbGVtZW50XCIsXG4gICAgXCJtb3pQcmVzZW50ZWRGcmFtZXNcIixcbiAgICBcIm1velByZXNlcnZlc1BpdGNoXCIsXG4gICAgXCJtb3pQcmVzc3VyZVwiLFxuICAgIFwibW96UHJpbnRDYWxsYmFja1wiLFxuICAgIFwibW96UlRDSWNlQ2FuZGlkYXRlXCIsXG4gICAgXCJtb3pSVENQZWVyQ29ubmVjdGlvblwiLFxuICAgIFwibW96UlRDU2Vzc2lvbkRlc2NyaXB0aW9uXCIsXG4gICAgXCJtb3pSZW1vdmVcIixcbiAgICBcIm1velJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgIFwibW96UmVxdWVzdEZ1bGxTY3JlZW5cIixcbiAgICBcIm1velJlcXVlc3RQb2ludGVyTG9ja1wiLFxuICAgIFwibW96U2V0RGF0YUF0XCIsXG4gICAgXCJtb3pTZXRJbWFnZUVsZW1lbnRcIixcbiAgICBcIm1velNvdXJjZU5vZGVcIixcbiAgICBcIm1velNyY09iamVjdFwiLFxuICAgIFwibW96U3lzdGVtXCIsXG4gICAgXCJtb3pUQ1BTb2NrZXRcIixcbiAgICBcIm1velRleHRTdHlsZVwiLFxuICAgIFwibW96VHlwZXNBdFwiLFxuICAgIFwibW96VW5sb2NrT3JpZW50YXRpb25cIixcbiAgICBcIm1velVzZXJDYW5jZWxsZWRcIixcbiAgICBcIm1velZpc2liaWxpdHlTdGF0ZVwiLFxuICAgIFwibXNcIixcbiAgICBcIm1zQW5pbWF0aW9uXCIsXG4gICAgXCJtc0FuaW1hdGlvbkRlbGF5XCIsXG4gICAgXCJtc0FuaW1hdGlvbkRpcmVjdGlvblwiLFxuICAgIFwibXNBbmltYXRpb25EdXJhdGlvblwiLFxuICAgIFwibXNBbmltYXRpb25GaWxsTW9kZVwiLFxuICAgIFwibXNBbmltYXRpb25JdGVyYXRpb25Db3VudFwiLFxuICAgIFwibXNBbmltYXRpb25OYW1lXCIsXG4gICAgXCJtc0FuaW1hdGlvblBsYXlTdGF0ZVwiLFxuICAgIFwibXNBbmltYXRpb25TdGFydFRpbWVcIixcbiAgICBcIm1zQW5pbWF0aW9uVGltaW5nRnVuY3Rpb25cIixcbiAgICBcIm1zQmFja2ZhY2VWaXNpYmlsaXR5XCIsXG4gICAgXCJtc0Jsb2NrUHJvZ3Jlc3Npb25cIixcbiAgICBcIm1zQ1NTT01FbGVtZW50RmxvYXRNZXRyaWNzXCIsXG4gICAgXCJtc0NhY2hpbmdcIixcbiAgICBcIm1zQ2FjaGluZ0VuYWJsZWRcIixcbiAgICBcIm1zQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIsXG4gICAgXCJtc0NhcHNMb2NrV2FybmluZ09mZlwiLFxuICAgIFwibXNDbGVhckltbWVkaWF0ZVwiLFxuICAgIFwibXNDbG9zZVwiLFxuICAgIFwibXNDb250ZW50Wm9vbUNoYWluaW5nXCIsXG4gICAgXCJtc0NvbnRlbnRab29tRmFjdG9yXCIsXG4gICAgXCJtc0NvbnRlbnRab29tTGltaXRcIixcbiAgICBcIm1zQ29udGVudFpvb21MaW1pdE1heFwiLFxuICAgIFwibXNDb250ZW50Wm9vbUxpbWl0TWluXCIsXG4gICAgXCJtc0NvbnRlbnRab29tU25hcFwiLFxuICAgIFwibXNDb250ZW50Wm9vbVNuYXBQb2ludHNcIixcbiAgICBcIm1zQ29udGVudFpvb21TbmFwVHlwZVwiLFxuICAgIFwibXNDb250ZW50Wm9vbWluZ1wiLFxuICAgIFwibXNDb252ZXJ0VVJMXCIsXG4gICAgXCJtc0NyeXB0b1wiLFxuICAgIFwibXNEb05vdFRyYWNrXCIsXG4gICAgXCJtc0VsZW1lbnRzRnJvbVBvaW50XCIsXG4gICAgXCJtc0VsZW1lbnRzRnJvbVJlY3RcIixcbiAgICBcIm1zRXhpdEZ1bGxzY3JlZW5cIixcbiAgICBcIm1zRXh0ZW5kZWRDb2RlXCIsXG4gICAgXCJtc0ZpbGxSdWxlXCIsXG4gICAgXCJtc0ZpcnN0UGFpbnRcIixcbiAgICBcIm1zRmxleFwiLFxuICAgIFwibXNGbGV4QWxpZ25cIixcbiAgICBcIm1zRmxleERpcmVjdGlvblwiLFxuICAgIFwibXNGbGV4Rmxvd1wiLFxuICAgIFwibXNGbGV4SXRlbUFsaWduXCIsXG4gICAgXCJtc0ZsZXhMaW5lUGFja1wiLFxuICAgIFwibXNGbGV4TmVnYXRpdmVcIixcbiAgICBcIm1zRmxleE9yZGVyXCIsXG4gICAgXCJtc0ZsZXhQYWNrXCIsXG4gICAgXCJtc0ZsZXhQb3NpdGl2ZVwiLFxuICAgIFwibXNGbGV4UHJlZmVycmVkU2l6ZVwiLFxuICAgIFwibXNGbGV4V3JhcFwiLFxuICAgIFwibXNGbG93RnJvbVwiLFxuICAgIFwibXNGbG93SW50b1wiLFxuICAgIFwibXNGb250RmVhdHVyZVNldHRpbmdzXCIsXG4gICAgXCJtc0Z1bGxzY3JlZW5FbGVtZW50XCIsXG4gICAgXCJtc0Z1bGxzY3JlZW5FbmFibGVkXCIsXG4gICAgXCJtc0dldElucHV0Q29udGV4dFwiLFxuICAgIFwibXNHZXRSZWdpb25Db250ZW50XCIsXG4gICAgXCJtc0dldFVudHJhbnNmb3JtZWRCb3VuZHNcIixcbiAgICBcIm1zR3JhcGhpY3NUcnVzdFN0YXR1c1wiLFxuICAgIFwibXNHcmlkQ29sdW1uXCIsXG4gICAgXCJtc0dyaWRDb2x1bW5BbGlnblwiLFxuICAgIFwibXNHcmlkQ29sdW1uU3BhblwiLFxuICAgIFwibXNHcmlkQ29sdW1uc1wiLFxuICAgIFwibXNHcmlkUm93XCIsXG4gICAgXCJtc0dyaWRSb3dBbGlnblwiLFxuICAgIFwibXNHcmlkUm93U3BhblwiLFxuICAgIFwibXNHcmlkUm93c1wiLFxuICAgIFwibXNIaWRkZW5cIixcbiAgICBcIm1zSGlnaENvbnRyYXN0QWRqdXN0XCIsXG4gICAgXCJtc0h5cGhlbmF0ZUxpbWl0Q2hhcnNcIixcbiAgICBcIm1zSHlwaGVuYXRlTGltaXRMaW5lc1wiLFxuICAgIFwibXNIeXBoZW5hdGVMaW1pdFpvbmVcIixcbiAgICBcIm1zSHlwaGVuc1wiLFxuICAgIFwibXNJbWFnZVNtb290aGluZ0VuYWJsZWRcIixcbiAgICBcIm1zSW1lQWxpZ25cIixcbiAgICBcIm1zSW5kZXhlZERCXCIsXG4gICAgXCJtc0ludGVycG9sYXRpb25Nb2RlXCIsXG4gICAgXCJtc0lzU3RhdGljSFRNTFwiLFxuICAgIFwibXNLZXlTeXN0ZW1cIixcbiAgICBcIm1zS2V5c1wiLFxuICAgIFwibXNMYXVuY2hVcmlcIixcbiAgICBcIm1zTG9ja09yaWVudGF0aW9uXCIsXG4gICAgXCJtc01hbmlwdWxhdGlvblZpZXdzRW5hYmxlZFwiLFxuICAgIFwibXNNYXRjaE1lZGlhXCIsXG4gICAgXCJtc01hdGNoZXNTZWxlY3RvclwiLFxuICAgIFwibXNNYXhUb3VjaFBvaW50c1wiLFxuICAgIFwibXNPcmllbnRhdGlvblwiLFxuICAgIFwibXNPdmVyZmxvd1N0eWxlXCIsXG4gICAgXCJtc1BlcnNwZWN0aXZlXCIsXG4gICAgXCJtc1BlcnNwZWN0aXZlT3JpZ2luXCIsXG4gICAgXCJtc1BsYXlUb0Rpc2FibGVkXCIsXG4gICAgXCJtc1BsYXlUb1ByZWZlcnJlZFNvdXJjZVVyaVwiLFxuICAgIFwibXNQbGF5VG9QcmltYXJ5XCIsXG4gICAgXCJtc1BvaW50ZXJFbmFibGVkXCIsXG4gICAgXCJtc1JlZ2lvbk92ZXJmbG93XCIsXG4gICAgXCJtc1JlbGVhc2VQb2ludGVyQ2FwdHVyZVwiLFxuICAgIFwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixcbiAgICBcIm1zUmVxdWVzdEZ1bGxzY3JlZW5cIixcbiAgICBcIm1zU2F2ZUJsb2JcIixcbiAgICBcIm1zU2F2ZU9yT3BlbkJsb2JcIixcbiAgICBcIm1zU2Nyb2xsQ2hhaW5pbmdcIixcbiAgICBcIm1zU2Nyb2xsTGltaXRcIixcbiAgICBcIm1zU2Nyb2xsTGltaXRYTWF4XCIsXG4gICAgXCJtc1Njcm9sbExpbWl0WE1pblwiLFxuICAgIFwibXNTY3JvbGxMaW1pdFlNYXhcIixcbiAgICBcIm1zU2Nyb2xsTGltaXRZTWluXCIsXG4gICAgXCJtc1Njcm9sbFJhaWxzXCIsXG4gICAgXCJtc1Njcm9sbFNuYXBQb2ludHNYXCIsXG4gICAgXCJtc1Njcm9sbFNuYXBQb2ludHNZXCIsXG4gICAgXCJtc1Njcm9sbFNuYXBUeXBlXCIsXG4gICAgXCJtc1Njcm9sbFNuYXBYXCIsXG4gICAgXCJtc1Njcm9sbFNuYXBZXCIsXG4gICAgXCJtc1Njcm9sbFRyYW5zbGF0aW9uXCIsXG4gICAgXCJtc1NldEltbWVkaWF0ZVwiLFxuICAgIFwibXNTZXRNZWRpYUtleXNcIixcbiAgICBcIm1zU2V0UG9pbnRlckNhcHR1cmVcIixcbiAgICBcIm1zVGV4dENvbWJpbmVIb3Jpem9udGFsXCIsXG4gICAgXCJtc1RleHRTaXplQWRqdXN0XCIsXG4gICAgXCJtc1RvQmxvYlwiLFxuICAgIFwibXNUb3VjaEFjdGlvblwiLFxuICAgIFwibXNUb3VjaFNlbGVjdFwiLFxuICAgIFwibXNUcmFjZUFzeW5jQ2FsbGJhY2tDb21wbGV0ZWRcIixcbiAgICBcIm1zVHJhY2VBc3luY0NhbGxiYWNrU3RhcnRpbmdcIixcbiAgICBcIm1zVHJhY2VBc3luY09wZXJhdGlvbkNvbXBsZXRlZFwiLFxuICAgIFwibXNUcmFjZUFzeW5jT3BlcmF0aW9uU3RhcnRpbmdcIixcbiAgICBcIm1zVHJhbnNmb3JtXCIsXG4gICAgXCJtc1RyYW5zZm9ybU9yaWdpblwiLFxuICAgIFwibXNUcmFuc2Zvcm1TdHlsZVwiLFxuICAgIFwibXNUcmFuc2l0aW9uXCIsXG4gICAgXCJtc1RyYW5zaXRpb25EZWxheVwiLFxuICAgIFwibXNUcmFuc2l0aW9uRHVyYXRpb25cIixcbiAgICBcIm1zVHJhbnNpdGlvblByb3BlcnR5XCIsXG4gICAgXCJtc1RyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICAgIFwibXNVbmxvY2tPcmllbnRhdGlvblwiLFxuICAgIFwibXNVcGRhdGVBc3luY0NhbGxiYWNrUmVsYXRpb25cIixcbiAgICBcIm1zVXNlclNlbGVjdFwiLFxuICAgIFwibXNWaXNpYmlsaXR5U3RhdGVcIixcbiAgICBcIm1zV3JhcEZsb3dcIixcbiAgICBcIm1zV3JhcE1hcmdpblwiLFxuICAgIFwibXNXcmFwVGhyb3VnaFwiLFxuICAgIFwibXNXcml0ZVByb2ZpbGVyTWFya1wiLFxuICAgIFwibXNab29tXCIsXG4gICAgXCJtc1pvb21Ub1wiLFxuICAgIFwibXRcIixcbiAgICBcIm11bFwiLFxuICAgIFwibXVsdGlFbnRyeVwiLFxuICAgIFwibXVsdGlTZWxlY3Rpb25PYmpcIixcbiAgICBcIm11bHRpbGluZVwiLFxuICAgIFwibXVsdGlwbGVcIixcbiAgICBcIm11bHRpcGx5XCIsXG4gICAgXCJtdWx0aXBseVNlbGZcIixcbiAgICBcIm11bHRpc2FtcGxlXCIsXG4gICAgXCJtdWx0aXNhbXBsZWRcIixcbiAgICBcIm11dGFibGVGaWxlXCIsXG4gICAgXCJtdXRlZFwiLFxuICAgIFwiblwiLFxuICAgIFwibmFjbF9hcmNoXCIsXG4gICAgXCJuYW1lXCIsXG4gICAgXCJuYW1lTGlzdFwiLFxuICAgIFwibmFtZVByb3BcIixcbiAgICBcIm5hbWVkSXRlbVwiLFxuICAgIFwibmFtZWRSZWNvcmRzZXRcIixcbiAgICBcIm5hbWVzXCIsXG4gICAgXCJuYW1lc3BhY2VVUklcIixcbiAgICBcIm5hbWVzcGFjZXNcIixcbiAgICBcIm5hdGl2ZUFwcGxpY2F0aW9uXCIsXG4gICAgXCJuYXRpdmVNYXBcIixcbiAgICBcIm5hdGl2ZU9iamVjdENyZWF0ZVwiLFxuICAgIFwibmF0aXZlU2V0XCIsXG4gICAgXCJuYXRpdmVXZWFrTWFwXCIsXG4gICAgXCJuYXR1cmFsSGVpZ2h0XCIsXG4gICAgXCJuYXR1cmFsV2lkdGhcIixcbiAgICBcIm5hdmlnYXRlXCIsXG4gICAgXCJuYXZpZ2F0aW9uXCIsXG4gICAgXCJuYXZpZ2F0aW9uTW9kZVwiLFxuICAgIFwibmF2aWdhdGlvblByZWxvYWRcIixcbiAgICBcIm5hdmlnYXRpb25TdGFydFwiLFxuICAgIFwibmF2aWdhdGlvblR5cGVcIixcbiAgICBcIm5hdmlnYXRvclwiLFxuICAgIFwibmVhclwiLFxuICAgIFwibmVhcmVzdFZpZXdwb3J0RWxlbWVudFwiLFxuICAgIFwibmVnYXRpdmVcIixcbiAgICBcIm5lZ290aWF0ZWRcIixcbiAgICBcIm5ldHNjYXBlXCIsXG4gICAgXCJuZXR3b3JrU3RhdGVcIixcbiAgICBcIm5ldHdvcmtTdGF0dXNcIixcbiAgICBcIm5ld1NjYWxlXCIsXG4gICAgXCJuZXdTdGF0ZVwiLFxuICAgIFwibmV3VHJhbnNsYXRlXCIsXG4gICAgXCJuZXdVUkxcIixcbiAgICBcIm5ld1ZhbHVlXCIsXG4gICAgXCJuZXdWYWx1ZVNwZWNpZmllZFVuaXRzXCIsXG4gICAgXCJuZXdWZXJzaW9uXCIsXG4gICAgXCJuZXdob21lXCIsXG4gICAgXCJuZXh0XCIsXG4gICAgXCJuZXh0RWxlbWVudFNpYmxpbmdcIixcbiAgICBcIm5leHRIb3BQcm90b2NvbFwiLFxuICAgIFwibmV4dE5vZGVcIixcbiAgICBcIm5leHRQYWdlXCIsXG4gICAgXCJuZXh0U2libGluZ1wiLFxuICAgIFwibmlja25hbWVcIixcbiAgICBcIm5vSHJlZlwiLFxuICAgIFwibm9Nb2R1bGVcIixcbiAgICBcIm5vUmVzaXplXCIsXG4gICAgXCJub1NoYWRlXCIsXG4gICAgXCJub1ZhbGlkYXRlXCIsXG4gICAgXCJub1dyYXBcIixcbiAgICBcIm5vZGVcIixcbiAgICBcIm5vZGVOYW1lXCIsXG4gICAgXCJub2RlVHlwZVwiLFxuICAgIFwibm9kZVZhbHVlXCIsXG4gICAgXCJub25jZVwiLFxuICAgIFwibm9ybURlcHRoQnVmZmVyRnJvbU5vcm1WaWV3XCIsXG4gICAgXCJub3JtYWxpemVcIixcbiAgICBcIm5vcm1hbGl6ZWRQYXRoU2VnTGlzdFwiLFxuICAgIFwibm9ybWFuZHlBZGRvblN0dWR5XCIsXG4gICAgXCJub3RSZXN0b3JlZFJlYXNvbnNcIixcbiAgICBcIm5vdGF0aW9uTmFtZVwiLFxuICAgIFwibm90YXRpb25zXCIsXG4gICAgXCJub3RlXCIsXG4gICAgXCJub3RlR3JhaW5PblwiLFxuICAgIFwibm90ZU9mZlwiLFxuICAgIFwibm90ZU9uXCIsXG4gICAgXCJub3RpZmljYXRpb25zXCIsXG4gICAgXCJub3RpZnlcIixcbiAgICBcIm5vd1wiLFxuICAgIFwibnBuTmVnb3RpYXRlZFByb3RvY29sXCIsXG4gICAgXCJudW1PY3RhdmVzXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcIm51bWJlck9mQ2hhbm5lbHNcIixcbiAgICBcIm51bWJlck9mRnJhbWVzXCIsXG4gICAgXCJudW1iZXJPZklucHV0c1wiLFxuICAgIFwibnVtYmVyT2ZJdGVtc1wiLFxuICAgIFwibnVtYmVyT2ZPdXRwdXRzXCIsXG4gICAgXCJudW1iZXJWYWx1ZVwiLFxuICAgIFwib01hdGNoZXNTZWxlY3RvclwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJvYmplY3QtZml0XCIsXG4gICAgXCJvYmplY3QtcG9zaXRpb25cIixcbiAgICBcIm9iamVjdEZpdFwiLFxuICAgIFwib2JqZWN0UG9zaXRpb25cIixcbiAgICBcIm9iamVjdFN0b3JlXCIsXG4gICAgXCJvYmplY3RTdG9yZU5hbWVzXCIsXG4gICAgXCJvYmplY3RUeXBlXCIsXG4gICAgXCJvYnNlcnZlXCIsXG4gICAgXCJvY2NsdXNpb25RdWVyeVNldFwiLFxuICAgIFwib2ZcIixcbiAgICBcIm9mZlwiLFxuICAgIFwib2Zmc2NyZWVuQnVmZmVyaW5nXCIsXG4gICAgXCJvZmZzZXRcIixcbiAgICBcIm9mZnNldC1hbmNob3JcIixcbiAgICBcIm9mZnNldC1kaXN0YW5jZVwiLFxuICAgIFwib2Zmc2V0LXBhdGhcIixcbiAgICBcIm9mZnNldC1wb3NpdGlvblwiLFxuICAgIFwib2Zmc2V0LXJvdGF0ZVwiLFxuICAgIFwib2Zmc2V0QW5jaG9yXCIsXG4gICAgXCJvZmZzZXREaXN0YW5jZVwiLFxuICAgIFwib2Zmc2V0SGVpZ2h0XCIsXG4gICAgXCJvZmZzZXRMZWZ0XCIsXG4gICAgXCJvZmZzZXROb2RlXCIsXG4gICAgXCJvZmZzZXRQYXJlbnRcIixcbiAgICBcIm9mZnNldFBhdGhcIixcbiAgICBcIm9mZnNldFBvc2l0aW9uXCIsXG4gICAgXCJvZmZzZXRSb3RhdGVcIixcbiAgICBcIm9mZnNldFRvcFwiLFxuICAgIFwib2Zmc2V0V2lkdGhcIixcbiAgICBcIm9mZnNldFhcIixcbiAgICBcIm9mZnNldFlcIixcbiAgICBcIm9rXCIsXG4gICAgXCJvbGRTdGF0ZVwiLFxuICAgIFwib2xkVVJMXCIsXG4gICAgXCJvbGRWYWx1ZVwiLFxuICAgIFwib2xkVmVyc2lvblwiLFxuICAgIFwib2xkZXJTaGFkb3dSb290XCIsXG4gICAgXCJvbW5pYm94XCIsXG4gICAgXCJvblwiLFxuICAgIFwib25BY3RpdmF0ZWRcIixcbiAgICBcIm9uQWRkZWRcIixcbiAgICBcIm9uQXR0YWNoZWRcIixcbiAgICBcIm9uQm91bmRzQ2hhbmdlZFwiLFxuICAgIFwib25Ccm93c2VyVXBkYXRlQXZhaWxhYmxlXCIsXG4gICAgXCJvbkNsaWNrZWRcIixcbiAgICBcIm9uQ29tbWl0RmliZXJSb290XCIsXG4gICAgXCJvbkNvbW1pdEZpYmVyVW5tb3VudFwiLFxuICAgIFwib25Db25uZWN0XCIsXG4gICAgXCJvbkNvbm5lY3RFeHRlcm5hbFwiLFxuICAgIFwib25Db25uZWN0TmF0aXZlXCIsXG4gICAgXCJvbkNyZWF0ZWRcIixcbiAgICBcIm9uRGV0YWNoZWRcIixcbiAgICBcIm9uRGlzYWJsZWRcIixcbiAgICBcIm9uRW5hYmxlZFwiLFxuICAgIFwib25Gb2N1c0NoYW5nZWRcIixcbiAgICBcIm9uSGlnaGxpZ2h0ZWRcIixcbiAgICBcIm9uSW5zdGFsbGVkXCIsXG4gICAgXCJvbkxpbmVcIixcbiAgICBcIm9uTWVzc2FnZVwiLFxuICAgIFwib25NZXNzYWdlRXh0ZXJuYWxcIixcbiAgICBcIm9uTW92ZWRcIixcbiAgICBcIm9uUGVyZm9ybWFuY2VXYXJuaW5nXCIsXG4gICAgXCJvblBvc3RDb21taXRGaWJlclJvb3RcIixcbiAgICBcIm9uUmVtb3ZlZFwiLFxuICAgIFwib25SZXBsYWNlZFwiLFxuICAgIFwib25SZXN0YXJ0UmVxdWlyZWRcIixcbiAgICBcIm9uU3RhcnR1cFwiLFxuICAgIFwib25TdWJtaXR0ZWRXb3JrRG9uZVwiLFxuICAgIFwib25TdXNwZW5kXCIsXG4gICAgXCJvblN1c3BlbmRDYW5jZWxlZFwiLFxuICAgIFwib25Vbmluc3RhbGxlZFwiLFxuICAgIFwib25VcGRhdGVBdmFpbGFibGVcIixcbiAgICBcIm9uVXBkYXRlZFwiLFxuICAgIFwib25Vc2VyU2NyaXB0Q29ubmVjdFwiLFxuICAgIFwib25Vc2VyU2NyaXB0TWVzc2FnZVwiLFxuICAgIFwib25Vc2VyU2V0dGluZ3NDaGFuZ2VkXCIsXG4gICAgXCJvblpvb21DaGFuZ2VcIixcbiAgICBcIm9uYWJvcnRcIixcbiAgICBcIm9uYWJzb2x1dGVkZXZpY2VvcmllbnRhdGlvblwiLFxuICAgIFwib25hY3RpdmF0ZVwiLFxuICAgIFwib25hY3RpdmVcIixcbiAgICBcIm9uYWRkc291cmNlYnVmZmVyXCIsXG4gICAgXCJvbmFkZHN0cmVhbVwiLFxuICAgIFwib25hZGR0cmFja1wiLFxuICAgIFwib25hZnRlcnByaW50XCIsXG4gICAgXCJvbmFmdGVyc2NyaXB0ZXhlY3V0ZVwiLFxuICAgIFwib25hZnRlcnVwZGF0ZVwiLFxuICAgIFwib25hbmltYXRpb25jYW5jZWxcIixcbiAgICBcIm9uYW5pbWF0aW9uZW5kXCIsXG4gICAgXCJvbmFuaW1hdGlvbml0ZXJhdGlvblwiLFxuICAgIFwib25hbmltYXRpb25zdGFydFwiLFxuICAgIFwib25hcHBpbnN0YWxsZWRcIixcbiAgICBcIm9uYXVkaW9lbmRcIixcbiAgICBcIm9uYXVkaW9wcm9jZXNzXCIsXG4gICAgXCJvbmF1ZGlvc3RhcnRcIixcbiAgICBcIm9uYXV0b2NvbXBsZXRlXCIsXG4gICAgXCJvbmF1dG9jb21wbGV0ZWVycm9yXCIsXG4gICAgXCJvbmF1eGNsaWNrXCIsXG4gICAgXCJvbmJlZm9yZWFjdGl2YXRlXCIsXG4gICAgXCJvbmJlZm9yZWNvcHlcIixcbiAgICBcIm9uYmVmb3JlY3V0XCIsXG4gICAgXCJvbmJlZm9yZWRlYWN0aXZhdGVcIixcbiAgICBcIm9uYmVmb3JlZWRpdGZvY3VzXCIsXG4gICAgXCJvbmJlZm9yZWlucHV0XCIsXG4gICAgXCJvbmJlZm9yZWluc3RhbGxwcm9tcHRcIixcbiAgICBcIm9uYmVmb3JlbWF0Y2hcIixcbiAgICBcIm9uYmVmb3JlcGFzdGVcIixcbiAgICBcIm9uYmVmb3JlcHJpbnRcIixcbiAgICBcIm9uYmVmb3Jlc2NyaXB0ZXhlY3V0ZVwiLFxuICAgIFwib25iZWZvcmV0b2dnbGVcIixcbiAgICBcIm9uYmVmb3JldW5sb2FkXCIsXG4gICAgXCJvbmJlZm9yZXVwZGF0ZVwiLFxuICAgIFwib25iZWZvcmV4cnNlbGVjdFwiLFxuICAgIFwib25iZWdpblwiLFxuICAgIFwib25ibG9ja2VkXCIsXG4gICAgXCJvbmJsdXJcIixcbiAgICBcIm9uYm91bmNlXCIsXG4gICAgXCJvbmJvdW5kYXJ5XCIsXG4gICAgXCJvbmJ1ZmZlcmVkYW1vdW50bG93XCIsXG4gICAgXCJvbmNhY2hlZFwiLFxuICAgIFwib25jYW5jZWxcIixcbiAgICBcIm9uY2FuZGlkYXRld2luZG93aGlkZVwiLFxuICAgIFwib25jYW5kaWRhdGV3aW5kb3dzaG93XCIsXG4gICAgXCJvbmNhbmRpZGF0ZXdpbmRvd3VwZGF0ZVwiLFxuICAgIFwib25jYW5wbGF5XCIsXG4gICAgXCJvbmNhbnBsYXl0aHJvdWdoXCIsXG4gICAgXCJvbmNhcHR1cmVoYW5kbGVjaGFuZ2VcIixcbiAgICBcIm9uY2VcIixcbiAgICBcIm9uY2VsbGNoYW5nZVwiLFxuICAgIFwib25jaGFuZ2VcIixcbiAgICBcIm9uY2hhcmFjdGVyYm91bmRzdXBkYXRlXCIsXG4gICAgXCJvbmNoYXJhY3RlcmlzdGljdmFsdWVjaGFuZ2VkXCIsXG4gICAgXCJvbmNoYXJnaW5nY2hhbmdlXCIsXG4gICAgXCJvbmNoYXJnaW5ndGltZWNoYW5nZVwiLFxuICAgIFwib25jaGVja2luZ1wiLFxuICAgIFwib25jbGlja1wiLFxuICAgIFwib25jbG9zZVwiLFxuICAgIFwib25jbG9zaW5nXCIsXG4gICAgXCJvbmNvbXBhc3NuZWVkc2NhbGlicmF0aW9uXCIsXG4gICAgXCJvbmNvbXBsZXRlXCIsXG4gICAgXCJvbmNvbXBvc2l0aW9uZW5kXCIsXG4gICAgXCJvbmNvbXBvc2l0aW9uc3RhcnRcIixcbiAgICBcIm9uY29ubmVjdFwiLFxuICAgIFwib25jb25uZWN0aW5nXCIsXG4gICAgXCJvbmNvbm5lY3Rpb25hdmFpbGFibGVcIixcbiAgICBcIm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsXG4gICAgXCJvbmNvbnRlbnR2aXNpYmlsaXR5YXV0b3N0YXRlY2hhbmdlXCIsXG4gICAgXCJvbmNvbnRleHRsb3N0XCIsXG4gICAgXCJvbmNvbnRleHRtZW51XCIsXG4gICAgXCJvbmNvbnRleHRyZXN0b3JlZFwiLFxuICAgIFwib25jb250cm9sbGVyY2hhbmdlXCIsXG4gICAgXCJvbmNvbnRyb2xzZWxlY3RcIixcbiAgICBcIm9uY29weVwiLFxuICAgIFwib25jdWVjaGFuZ2VcIixcbiAgICBcIm9uY3VycmVudGVudHJ5Y2hhbmdlXCIsXG4gICAgXCJvbmN1cnJlbnRzY3JlZW5jaGFuZ2VcIixcbiAgICBcIm9uY3V0XCIsXG4gICAgXCJvbmRhdGFhdmFpbGFibGVcIixcbiAgICBcIm9uZGF0YWNoYW5uZWxcIixcbiAgICBcIm9uZGF0YXNldGNoYW5nZWRcIixcbiAgICBcIm9uZGF0YXNldGNvbXBsZXRlXCIsXG4gICAgXCJvbmRibGNsaWNrXCIsXG4gICAgXCJvbmRlYWN0aXZhdGVcIixcbiAgICBcIm9uZGVxdWV1ZVwiLFxuICAgIFwib25kZXZpY2VjaGFuZ2VcIixcbiAgICBcIm9uZGV2aWNlbGlnaHRcIixcbiAgICBcIm9uZGV2aWNlbW90aW9uXCIsXG4gICAgXCJvbmRldmljZW9yaWVudGF0aW9uXCIsXG4gICAgXCJvbmRldmljZW9yaWVudGF0aW9uYWJzb2x1dGVcIixcbiAgICBcIm9uZGV2aWNlcHJveGltaXR5XCIsXG4gICAgXCJvbmRpc2NoYXJnaW5ndGltZWNoYW5nZVwiLFxuICAgIFwib25kaXNjb25uZWN0XCIsXG4gICAgXCJvbmRpc3BsYXlcIixcbiAgICBcIm9uZGlzcG9zZVwiLFxuICAgIFwib25kb3dubG9hZGluZ1wiLFxuICAgIFwib25kcmFnXCIsXG4gICAgXCJvbmRyYWdlbmRcIixcbiAgICBcIm9uZHJhZ2VudGVyXCIsXG4gICAgXCJvbmRyYWdleGl0XCIsXG4gICAgXCJvbmRyYWdsZWF2ZVwiLFxuICAgIFwib25kcmFnb3ZlclwiLFxuICAgIFwib25kcmFnc3RhcnRcIixcbiAgICBcIm9uZHJvcFwiLFxuICAgIFwib25kdXJhdGlvbmNoYW5nZVwiLFxuICAgIFwib25lbXB0aWVkXCIsXG4gICAgXCJvbmVuY3J5cHRlZFwiLFxuICAgIFwib25lbmRcIixcbiAgICBcIm9uZW5kZWRcIixcbiAgICBcIm9uZW50ZXJcIixcbiAgICBcIm9uZW50ZXJwaWN0dXJlaW5waWN0dXJlXCIsXG4gICAgXCJvbmVycm9yXCIsXG4gICAgXCJvbmVycm9ydXBkYXRlXCIsXG4gICAgXCJvbmV4aXRcIixcbiAgICBcIm9uZmVuY2VkdHJlZWNsaWNrXCIsXG4gICAgXCJvbmZpbHRlcmNoYW5nZVwiLFxuICAgIFwib25maW5pc2hcIixcbiAgICBcIm9uZm9jdXNcIixcbiAgICBcIm9uZm9jdXNpblwiLFxuICAgIFwib25mb2N1c291dFwiLFxuICAgIFwib25mb3JtZGF0YVwiLFxuICAgIFwib25mcmVlemVcIixcbiAgICBcIm9uZnVsbHNjcmVlbmNoYW5nZVwiLFxuICAgIFwib25mdWxsc2NyZWVuZXJyb3JcIixcbiAgICBcIm9uZ2FtZXBhZGNvbm5lY3RlZFwiLFxuICAgIFwib25nYW1lcGFkZGlzY29ubmVjdGVkXCIsXG4gICAgXCJvbmdhdGhlcmluZ3N0YXRlY2hhbmdlXCIsXG4gICAgXCJvbmdhdHRzZXJ2ZXJkaXNjb25uZWN0ZWRcIixcbiAgICBcIm9uZ2VvbWV0cnljaGFuZ2VcIixcbiAgICBcIm9uZ2VzdHVyZWNoYW5nZVwiLFxuICAgIFwib25nZXN0dXJlZW5kXCIsXG4gICAgXCJvbmdlc3R1cmVzdGFydFwiLFxuICAgIFwib25nb3Rwb2ludGVyY2FwdHVyZVwiLFxuICAgIFwib25oYXNoY2hhbmdlXCIsXG4gICAgXCJvbmhlbHBcIixcbiAgICBcIm9uaWNlY2FuZGlkYXRlXCIsXG4gICAgXCJvbmljZWNhbmRpZGF0ZWVycm9yXCIsXG4gICAgXCJvbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZVwiLFxuICAgIFwib25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZVwiLFxuICAgIFwib25pbmFjdGl2ZVwiLFxuICAgIFwib25pbnB1dFwiLFxuICAgIFwib25pbnB1dHJlcG9ydFwiLFxuICAgIFwib25pbnB1dHNvdXJjZXNjaGFuZ2VcIixcbiAgICBcIm9uaW52YWxpZFwiLFxuICAgIFwib25rZXlkb3duXCIsXG4gICAgXCJvbmtleXByZXNzXCIsXG4gICAgXCJvbmtleXN0YXR1c2VzY2hhbmdlXCIsXG4gICAgXCJvbmtleXVwXCIsXG4gICAgXCJvbmxhbmd1YWdlY2hhbmdlXCIsXG4gICAgXCJvbmxheW91dGNvbXBsZXRlXCIsXG4gICAgXCJvbmxlYXZlcGljdHVyZWlucGljdHVyZVwiLFxuICAgIFwib25sZXZlbGNoYW5nZVwiLFxuICAgIFwib25sb2FkXCIsXG4gICAgXCJvbmxvYWRUXCIsXG4gICAgXCJvbmxvYWRlZGRhdGFcIixcbiAgICBcIm9ubG9hZGVkbWV0YWRhdGFcIixcbiAgICBcIm9ubG9hZGVuZFwiLFxuICAgIFwib25sb2FkaW5nXCIsXG4gICAgXCJvbmxvYWRpbmdkb25lXCIsXG4gICAgXCJvbmxvYWRpbmdlcnJvclwiLFxuICAgIFwib25sb2Fkc3RhcnRcIixcbiAgICBcIm9ubG9zZWNhcHR1cmVcIixcbiAgICBcIm9ubG9zdHBvaW50ZXJjYXB0dXJlXCIsXG4gICAgXCJvbmx5XCIsXG4gICAgXCJvbm1hbmFnZWRjb25maWd1cmF0aW9uY2hhbmdlXCIsXG4gICAgXCJvbm1hcmtcIixcbiAgICBcIm9ubWVzc2FnZVwiLFxuICAgIFwib25tZXNzYWdlZXJyb3JcIixcbiAgICBcIm9ubWlkaW1lc3NhZ2VcIixcbiAgICBcIm9ubW91c2Vkb3duXCIsXG4gICAgXCJvbm1vdXNlZW50ZXJcIixcbiAgICBcIm9ubW91c2VsZWF2ZVwiLFxuICAgIFwib25tb3VzZW1vdmVcIixcbiAgICBcIm9ubW91c2VvdXRcIixcbiAgICBcIm9ubW91c2VvdmVyXCIsXG4gICAgXCJvbm1vdXNldXBcIixcbiAgICBcIm9ubW91c2V3aGVlbFwiLFxuICAgIFwib25tb3ZlXCIsXG4gICAgXCJvbm1vdmVlbmRcIixcbiAgICBcIm9ubW92ZXN0YXJ0XCIsXG4gICAgXCJvbm1vemZ1bGxzY3JlZW5jaGFuZ2VcIixcbiAgICBcIm9ubW96ZnVsbHNjcmVlbmVycm9yXCIsXG4gICAgXCJvbm1vem9yaWVudGF0aW9uY2hhbmdlXCIsXG4gICAgXCJvbm1venBvaW50ZXJsb2NrY2hhbmdlXCIsXG4gICAgXCJvbm1venBvaW50ZXJsb2NrZXJyb3JcIixcbiAgICBcIm9ubXNjb250ZW50em9vbVwiLFxuICAgIFwib25tc2Z1bGxzY3JlZW5jaGFuZ2VcIixcbiAgICBcIm9ubXNmdWxsc2NyZWVuZXJyb3JcIixcbiAgICBcIm9ubXNnZXN0dXJlY2hhbmdlXCIsXG4gICAgXCJvbm1zZ2VzdHVyZWRvdWJsZXRhcFwiLFxuICAgIFwib25tc2dlc3R1cmVlbmRcIixcbiAgICBcIm9ubXNnZXN0dXJlaG9sZFwiLFxuICAgIFwib25tc2dlc3R1cmVzdGFydFwiLFxuICAgIFwib25tc2dlc3R1cmV0YXBcIixcbiAgICBcIm9ubXNnb3Rwb2ludGVyY2FwdHVyZVwiLFxuICAgIFwib25tc2luZXJ0aWFzdGFydFwiLFxuICAgIFwib25tc2xvc3Rwb2ludGVyY2FwdHVyZVwiLFxuICAgIFwib25tc21hbmlwdWxhdGlvbnN0YXRlY2hhbmdlZFwiLFxuICAgIFwib25tc25lZWRrZXlcIixcbiAgICBcIm9ubXNvcmllbnRhdGlvbmNoYW5nZVwiLFxuICAgIFwib25tc3BvaW50ZXJjYW5jZWxcIixcbiAgICBcIm9ubXNwb2ludGVyZG93blwiLFxuICAgIFwib25tc3BvaW50ZXJlbnRlclwiLFxuICAgIFwib25tc3BvaW50ZXJob3ZlclwiLFxuICAgIFwib25tc3BvaW50ZXJsZWF2ZVwiLFxuICAgIFwib25tc3BvaW50ZXJtb3ZlXCIsXG4gICAgXCJvbm1zcG9pbnRlcm91dFwiLFxuICAgIFwib25tc3BvaW50ZXJvdmVyXCIsXG4gICAgXCJvbm1zcG9pbnRlcnVwXCIsXG4gICAgXCJvbm1zc2l0ZW1vZGVqdW1wbGlzdGl0ZW1yZW1vdmVkXCIsXG4gICAgXCJvbm1zdGh1bWJuYWlsY2xpY2tcIixcbiAgICBcIm9ubXV0ZVwiLFxuICAgIFwib25uYXZpZ2F0ZVwiLFxuICAgIFwib25uYXZpZ2F0ZWVycm9yXCIsXG4gICAgXCJvbm5hdmlnYXRlc3VjY2Vzc1wiLFxuICAgIFwib25uZWdvdGlhdGlvbm5lZWRlZFwiLFxuICAgIFwib25ub21hdGNoXCIsXG4gICAgXCJvbm5vdXBkYXRlXCIsXG4gICAgXCJvbm9ic29sZXRlXCIsXG4gICAgXCJvbm9mZmxpbmVcIixcbiAgICBcIm9ub25saW5lXCIsXG4gICAgXCJvbm9wZW5cIixcbiAgICBcIm9ub3JpZW50YXRpb25jaGFuZ2VcIixcbiAgICBcIm9ucGFnZWNoYW5nZVwiLFxuICAgIFwib25wYWdlaGlkZVwiLFxuICAgIFwib25wYWdlcmV2ZWFsXCIsXG4gICAgXCJvbnBhZ2VzaG93XCIsXG4gICAgXCJvbnBhZ2Vzd2FwXCIsXG4gICAgXCJvbnBhc3RlXCIsXG4gICAgXCJvbnBhdXNlXCIsXG4gICAgXCJvbnBheWVyZGV0YWlsY2hhbmdlXCIsXG4gICAgXCJvbnBheW1lbnRtZXRob2RjaGFuZ2VcIixcbiAgICBcIm9ucGxheVwiLFxuICAgIFwib25wbGF5aW5nXCIsXG4gICAgXCJvbnBsdWdpbnN0cmVhbXN0YXJ0XCIsXG4gICAgXCJvbnBvaW50ZXJjYW5jZWxcIixcbiAgICBcIm9ucG9pbnRlcmRvd25cIixcbiAgICBcIm9ucG9pbnRlcmVudGVyXCIsXG4gICAgXCJvbnBvaW50ZXJsZWF2ZVwiLFxuICAgIFwib25wb2ludGVybG9ja2NoYW5nZVwiLFxuICAgIFwib25wb2ludGVybG9ja2Vycm9yXCIsXG4gICAgXCJvbnBvaW50ZXJtb3ZlXCIsXG4gICAgXCJvbnBvaW50ZXJvdXRcIixcbiAgICBcIm9ucG9pbnRlcm92ZXJcIixcbiAgICBcIm9ucG9pbnRlcnJhd3VwZGF0ZVwiLFxuICAgIFwib25wb2ludGVydXBcIixcbiAgICBcIm9ucG9wc3RhdGVcIixcbiAgICBcIm9ucHJlcmVuZGVyaW5nY2hhbmdlXCIsXG4gICAgXCJvbnByaW9yaXR5Y2hhbmdlXCIsXG4gICAgXCJvbnByb2Nlc3NvcmVycm9yXCIsXG4gICAgXCJvbnByb2dyZXNzXCIsXG4gICAgXCJvbnByb3BlcnR5Y2hhbmdlXCIsXG4gICAgXCJvbnJhdGVjaGFuZ2VcIixcbiAgICBcIm9ucmVhZGluZ1wiLFxuICAgIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsXG4gICAgXCJvbnJlZmxlY3Rpb25jaGFuZ2VcIixcbiAgICBcIm9ucmVqZWN0aW9uaGFuZGxlZFwiLFxuICAgIFwib25yZWxlYXNlXCIsXG4gICAgXCJvbnJlbW92ZVwiLFxuICAgIFwib25yZW1vdmVzb3VyY2VidWZmZXJcIixcbiAgICBcIm9ucmVtb3Zlc3RyZWFtXCIsXG4gICAgXCJvbnJlbW92ZXRyYWNrXCIsXG4gICAgXCJvbnJlcGVhdFwiLFxuICAgIFwib25yZXNldFwiLFxuICAgIFwib25yZXNpemVcIixcbiAgICBcIm9ucmVzaXplZW5kXCIsXG4gICAgXCJvbnJlc2l6ZXN0YXJ0XCIsXG4gICAgXCJvbnJlc291cmNldGltaW5nYnVmZmVyZnVsbFwiLFxuICAgIFwib25yZXN1bHRcIixcbiAgICBcIm9ucmVzdW1lXCIsXG4gICAgXCJvbnJvd2VudGVyXCIsXG4gICAgXCJvbnJvd2V4aXRcIixcbiAgICBcIm9ucm93c2RlbGV0ZVwiLFxuICAgIFwib25yb3dzaW5zZXJ0ZWRcIixcbiAgICBcIm9uc2NyZWVuc2NoYW5nZVwiLFxuICAgIFwib25zY3JvbGxcIixcbiAgICBcIm9uc2Nyb2xsZW5kXCIsXG4gICAgXCJvbnNjcm9sbHNuYXBjaGFuZ2VcIixcbiAgICBcIm9uc2Nyb2xsc25hcGNoYW5naW5nXCIsXG4gICAgXCJvbnNlYXJjaFwiLFxuICAgIFwib25zZWN1cml0eXBvbGljeXZpb2xhdGlvblwiLFxuICAgIFwib25zZWVrZWRcIixcbiAgICBcIm9uc2Vla2luZ1wiLFxuICAgIFwib25zZWxlY3RcIixcbiAgICBcIm9uc2VsZWN0ZWRjYW5kaWRhdGVwYWlyY2hhbmdlXCIsXG4gICAgXCJvbnNlbGVjdGVuZFwiLFxuICAgIFwib25zZWxlY3Rpb25jaGFuZ2VcIixcbiAgICBcIm9uc2VsZWN0c3RhcnRcIixcbiAgICBcIm9uc2hpcHBpbmdhZGRyZXNzY2hhbmdlXCIsXG4gICAgXCJvbnNoaXBwaW5nb3B0aW9uY2hhbmdlXCIsXG4gICAgXCJvbnNob3dcIixcbiAgICBcIm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2VcIixcbiAgICBcIm9uc2lua2NoYW5nZVwiLFxuICAgIFwib25zbG90Y2hhbmdlXCIsXG4gICAgXCJvbnNvdW5kZW5kXCIsXG4gICAgXCJvbnNvdW5kc3RhcnRcIixcbiAgICBcIm9uc291cmNlY2xvc2VcIixcbiAgICBcIm9uc291cmNlY2xvc2VkXCIsXG4gICAgXCJvbnNvdXJjZWVuZGVkXCIsXG4gICAgXCJvbnNvdXJjZW9wZW5cIixcbiAgICBcIm9uc3BlZWNoZW5kXCIsXG4gICAgXCJvbnNwZWVjaHN0YXJ0XCIsXG4gICAgXCJvbnNxdWVlemVcIixcbiAgICBcIm9uc3F1ZWV6ZWVuZFwiLFxuICAgIFwib25zcXVlZXplc3RhcnRcIixcbiAgICBcIm9uc3RhbGxlZFwiLFxuICAgIFwib25zdGFydFwiLFxuICAgIFwib25zdGF0ZWNoYW5nZVwiLFxuICAgIFwib25zdG9wXCIsXG4gICAgXCJvbnN0b3JhZ2VcIixcbiAgICBcIm9uc3RvcmFnZWNvbW1pdFwiLFxuICAgIFwib25zdWJtaXRcIixcbiAgICBcIm9uc3VjY2Vzc1wiLFxuICAgIFwib25zdXNwZW5kXCIsXG4gICAgXCJvbnRlcm1pbmF0ZVwiLFxuICAgIFwib250ZXh0Zm9ybWF0dXBkYXRlXCIsXG4gICAgXCJvbnRleHRpbnB1dFwiLFxuICAgIFwib250ZXh0dXBkYXRlXCIsXG4gICAgXCJvbnRpbWVvdXRcIixcbiAgICBcIm9udGltZXVwZGF0ZVwiLFxuICAgIFwib250b2dnbGVcIixcbiAgICBcIm9udG9uZWNoYW5nZVwiLFxuICAgIFwib250b3VjaGNhbmNlbFwiLFxuICAgIFwib250b3VjaGVuZFwiLFxuICAgIFwib250b3VjaG1vdmVcIixcbiAgICBcIm9udG91Y2hzdGFydFwiLFxuICAgIFwib250cmFja1wiLFxuICAgIFwib250cmFuc2l0aW9uY2FuY2VsXCIsXG4gICAgXCJvbnRyYW5zaXRpb25lbmRcIixcbiAgICBcIm9udHJhbnNpdGlvbnJ1blwiLFxuICAgIFwib250cmFuc2l0aW9uc3RhcnRcIixcbiAgICBcIm9udW5jYXB0dXJlZGVycm9yXCIsXG4gICAgXCJvbnVuaGFuZGxlZHJlamVjdGlvblwiLFxuICAgIFwib251bmxvYWRcIixcbiAgICBcIm9udW5tdXRlXCIsXG4gICAgXCJvbnVwZGF0ZVwiLFxuICAgIFwib251cGRhdGVlbmRcIixcbiAgICBcIm9udXBkYXRlZm91bmRcIixcbiAgICBcIm9udXBkYXRlcmVhZHlcIixcbiAgICBcIm9udXBkYXRlc3RhcnRcIixcbiAgICBcIm9udXBncmFkZW5lZWRlZFwiLFxuICAgIFwib251c2VycHJveGltaXR5XCIsXG4gICAgXCJvbnZlcnNpb25jaGFuZ2VcIixcbiAgICBcIm9udmlzaWJpbGl0eWNoYW5nZVwiLFxuICAgIFwib252b2ljZXNjaGFuZ2VkXCIsXG4gICAgXCJvbnZvbHVtZWNoYW5nZVwiLFxuICAgIFwib252cmRpc3BsYXlhY3RpdmF0ZVwiLFxuICAgIFwib252cmRpc3BsYXljb25uZWN0XCIsXG4gICAgXCJvbnZyZGlzcGxheWRlYWN0aXZhdGVcIixcbiAgICBcIm9udnJkaXNwbGF5ZGlzY29ubmVjdFwiLFxuICAgIFwib252cmRpc3BsYXlwcmVzZW50Y2hhbmdlXCIsXG4gICAgXCJvbndhaXRpbmdcIixcbiAgICBcIm9ud2FpdGluZ2ZvcmtleVwiLFxuICAgIFwib253YXJuaW5nXCIsXG4gICAgXCJvbndlYmtpdGFuaW1hdGlvbmVuZFwiLFxuICAgIFwib253ZWJraXRhbmltYXRpb25pdGVyYXRpb25cIixcbiAgICBcIm9ud2Via2l0YW5pbWF0aW9uc3RhcnRcIixcbiAgICBcIm9ud2Via2l0Y3VycmVudHBsYXliYWNrdGFyZ2V0aXN3aXJlbGVzc2NoYW5nZWRcIixcbiAgICBcIm9ud2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLFxuICAgIFwib253ZWJraXRmdWxsc2NyZWVuZXJyb3JcIixcbiAgICBcIm9ud2Via2l0a2V5YWRkZWRcIixcbiAgICBcIm9ud2Via2l0a2V5ZXJyb3JcIixcbiAgICBcIm9ud2Via2l0a2V5bWVzc2FnZVwiLFxuICAgIFwib253ZWJraXRuZWVka2V5XCIsXG4gICAgXCJvbndlYmtpdG9yaWVudGF0aW9uY2hhbmdlXCIsXG4gICAgXCJvbndlYmtpdHBsYXliYWNrdGFyZ2V0YXZhaWxhYmlsaXR5Y2hhbmdlZFwiLFxuICAgIFwib253ZWJraXRwb2ludGVybG9ja2NoYW5nZVwiLFxuICAgIFwib253ZWJraXRwb2ludGVybG9ja2Vycm9yXCIsXG4gICAgXCJvbndlYmtpdHJlc291cmNldGltaW5nYnVmZmVyZnVsbFwiLFxuICAgIFwib253ZWJraXR0cmFuc2l0aW9uZW5kXCIsXG4gICAgXCJvbndoZWVsXCIsXG4gICAgXCJvbnpvb21cIixcbiAgICBcIm9wYWNpdHlcIixcbiAgICBcIm9wZW5cIixcbiAgICBcIm9wZW5DdXJzb3JcIixcbiAgICBcIm9wZW5EYXRhYmFzZVwiLFxuICAgIFwib3BlbktleUN1cnNvclwiLFxuICAgIFwib3Blbk9wdGlvbnNQYWdlXCIsXG4gICAgXCJvcGVuT3JDbG9zZWRTaGFkb3dSb290XCIsXG4gICAgXCJvcGVuUG9wdXBcIixcbiAgICBcIm9wZW5lZFwiLFxuICAgIFwib3BlbmVyXCIsXG4gICAgXCJvcGVyYVwiLFxuICAgIFwib3BlcmF0aW9uXCIsXG4gICAgXCJvcGVyYXRpb25UeXBlXCIsXG4gICAgXCJvcGVyYXRvclwiLFxuICAgIFwib3ByXCIsXG4gICAgXCJvcHRpbXVtXCIsXG4gICAgXCJvcHRpb25zXCIsXG4gICAgXCJvclwiLFxuICAgIFwib3JkZXJcIixcbiAgICBcIm9yZGVyWFwiLFxuICAgIFwib3JkZXJZXCIsXG4gICAgXCJvcmRlcmVkXCIsXG4gICAgXCJvcmdcIixcbiAgICBcIm9yZ2FuaXphdGlvblwiLFxuICAgIFwib3JpZW50XCIsXG4gICAgXCJvcmllbnRBbmdsZVwiLFxuICAgIFwib3JpZW50VHlwZVwiLFxuICAgIFwib3JpZW50YXRpb25cIixcbiAgICBcIm9yaWVudGF0aW9uWFwiLFxuICAgIFwib3JpZW50YXRpb25ZXCIsXG4gICAgXCJvcmllbnRhdGlvblpcIixcbiAgICBcIm9yaWdpblwiLFxuICAgIFwib3JpZ2luQWdlbnRDbHVzdGVyXCIsXG4gICAgXCJvcmlnaW5hbFBvbGljeVwiLFxuICAgIFwib3JpZ2luYWxUYXJnZXRcIixcbiAgICBcIm9ycGhhbnNcIixcbiAgICBcIm9zXCIsXG4gICAgXCJvc2NwdVwiLFxuICAgIFwib3V0ZXJIVE1MXCIsXG4gICAgXCJvdXRlckhlaWdodFwiLFxuICAgIFwib3V0ZXJUZXh0XCIsXG4gICAgXCJvdXRlcldpZHRoXCIsXG4gICAgXCJvdXRnb2luZ0hpZ2hXYXRlck1hcmtcIixcbiAgICBcIm91dGdvaW5nTWF4QWdlXCIsXG4gICAgXCJvdXRsaW5lXCIsXG4gICAgXCJvdXRsaW5lLWNvbG9yXCIsXG4gICAgXCJvdXRsaW5lLW9mZnNldFwiLFxuICAgIFwib3V0bGluZS1zdHlsZVwiLFxuICAgIFwib3V0bGluZS13aWR0aFwiLFxuICAgIFwib3V0bGluZUNvbG9yXCIsXG4gICAgXCJvdXRsaW5lT2Zmc2V0XCIsXG4gICAgXCJvdXRsaW5lU3R5bGVcIixcbiAgICBcIm91dGxpbmVXaWR0aFwiLFxuICAgIFwib3V0cHV0QnVmZmVyXCIsXG4gICAgXCJvdXRwdXRDaGFubmVsQ291bnRcIixcbiAgICBcIm91dHB1dExhdGVuY3lcIixcbiAgICBcIm91dHB1dHNcIixcbiAgICBcIm92ZXJmbG93XCIsXG4gICAgXCJvdmVyZmxvdy1hbmNob3JcIixcbiAgICBcIm92ZXJmbG93LWJsb2NrXCIsXG4gICAgXCJvdmVyZmxvdy1jbGlwLW1hcmdpblwiLFxuICAgIFwib3ZlcmZsb3ctaW5saW5lXCIsXG4gICAgXCJvdmVyZmxvdy13cmFwXCIsXG4gICAgXCJvdmVyZmxvdy14XCIsXG4gICAgXCJvdmVyZmxvdy15XCIsXG4gICAgXCJvdmVyZmxvd0FuY2hvclwiLFxuICAgIFwib3ZlcmZsb3dCbG9ja1wiLFxuICAgIFwib3ZlcmZsb3dDbGlwTWFyZ2luXCIsXG4gICAgXCJvdmVyZmxvd0lubGluZVwiLFxuICAgIFwib3ZlcmZsb3dXcmFwXCIsXG4gICAgXCJvdmVyZmxvd1hcIixcbiAgICBcIm92ZXJmbG93WVwiLFxuICAgIFwib3ZlcmxheXNDb250ZW50XCIsXG4gICAgXCJvdmVycmlkZUNvbG9yc1wiLFxuICAgIFwib3ZlcnJpZGVNaW1lVHlwZVwiLFxuICAgIFwib3ZlcnNhbXBsZVwiLFxuICAgIFwib3ZlcnNjcm9sbC1iZWhhdmlvclwiLFxuICAgIFwib3ZlcnNjcm9sbC1iZWhhdmlvci1ibG9ja1wiLFxuICAgIFwib3ZlcnNjcm9sbC1iZWhhdmlvci1pbmxpbmVcIixcbiAgICBcIm92ZXJzY3JvbGwtYmVoYXZpb3IteFwiLFxuICAgIFwib3ZlcnNjcm9sbC1iZWhhdmlvci15XCIsXG4gICAgXCJvdmVyc2Nyb2xsQmVoYXZpb3JcIixcbiAgICBcIm92ZXJzY3JvbGxCZWhhdmlvckJsb2NrXCIsXG4gICAgXCJvdmVyc2Nyb2xsQmVoYXZpb3JJbmxpbmVcIixcbiAgICBcIm92ZXJzY3JvbGxCZWhhdmlvclhcIixcbiAgICBcIm92ZXJzY3JvbGxCZWhhdmlvcllcIixcbiAgICBcIm93bktleXNcIixcbiAgICBcIm93bmVyRG9jdW1lbnRcIixcbiAgICBcIm93bmVyRWxlbWVudFwiLFxuICAgIFwib3duZXJOb2RlXCIsXG4gICAgXCJvd25lclJ1bGVcIixcbiAgICBcIm93bmVyU1ZHRWxlbWVudFwiLFxuICAgIFwib3duaW5nRWxlbWVudFwiLFxuICAgIFwicDFcIixcbiAgICBcInAyXCIsXG4gICAgXCJwM1wiLFxuICAgIFwicDRcIixcbiAgICBcInBhY2tldFNpemVcIixcbiAgICBcInBhY2tldHNcIixcbiAgICBcInBhZFwiLFxuICAgIFwicGFkRW5kXCIsXG4gICAgXCJwYWRTdGFydFwiLFxuICAgIFwicGFkZGluZ1wiLFxuICAgIFwicGFkZGluZy1ibG9ja1wiLFxuICAgIFwicGFkZGluZy1ibG9jay1lbmRcIixcbiAgICBcInBhZGRpbmctYmxvY2stc3RhcnRcIixcbiAgICBcInBhZGRpbmctYm90dG9tXCIsXG4gICAgXCJwYWRkaW5nLWlubGluZVwiLFxuICAgIFwicGFkZGluZy1pbmxpbmUtZW5kXCIsXG4gICAgXCJwYWRkaW5nLWlubGluZS1zdGFydFwiLFxuICAgIFwicGFkZGluZy1sZWZ0XCIsXG4gICAgXCJwYWRkaW5nLXJpZ2h0XCIsXG4gICAgXCJwYWRkaW5nLXRvcFwiLFxuICAgIFwicGFkZGluZ0Jsb2NrXCIsXG4gICAgXCJwYWRkaW5nQmxvY2tFbmRcIixcbiAgICBcInBhZGRpbmdCbG9ja1N0YXJ0XCIsXG4gICAgXCJwYWRkaW5nQm90dG9tXCIsXG4gICAgXCJwYWRkaW5nSW5saW5lXCIsXG4gICAgXCJwYWRkaW5nSW5saW5lRW5kXCIsXG4gICAgXCJwYWRkaW5nSW5saW5lU3RhcnRcIixcbiAgICBcInBhZGRpbmdMZWZ0XCIsXG4gICAgXCJwYWRkaW5nUmlnaHRcIixcbiAgICBcInBhZGRpbmdUb3BcIixcbiAgICBcInBhZ2VcIixcbiAgICBcInBhZ2UtYnJlYWstYWZ0ZXJcIixcbiAgICBcInBhZ2UtYnJlYWstYmVmb3JlXCIsXG4gICAgXCJwYWdlLWJyZWFrLWluc2lkZVwiLFxuICAgIFwicGFnZS1vcmllbnRhdGlvblwiLFxuICAgIFwicGFnZUFjdGlvblwiLFxuICAgIFwicGFnZUJyZWFrQWZ0ZXJcIixcbiAgICBcInBhZ2VCcmVha0JlZm9yZVwiLFxuICAgIFwicGFnZUJyZWFrSW5zaWRlXCIsXG4gICAgXCJwYWdlQ291bnRcIixcbiAgICBcInBhZ2VMZWZ0XCIsXG4gICAgXCJwYWdlT3JpZW50YXRpb25cIixcbiAgICBcInBhZ2VUXCIsXG4gICAgXCJwYWdlVG9wXCIsXG4gICAgXCJwYWdlWFwiLFxuICAgIFwicGFnZVhPZmZzZXRcIixcbiAgICBcInBhZ2VZXCIsXG4gICAgXCJwYWdlWU9mZnNldFwiLFxuICAgIFwicGFnZXNcIixcbiAgICBcInBhaW50LW9yZGVyXCIsXG4gICAgXCJwYWludE9yZGVyXCIsXG4gICAgXCJwYWludFJlcXVlc3RzXCIsXG4gICAgXCJwYWludFR5cGVcIixcbiAgICBcInBhaW50V29ya2xldFwiLFxuICAgIFwicGFsZXR0ZVwiLFxuICAgIFwicGFuXCIsXG4gICAgXCJwYW5uaW5nTW9kZWxcIixcbiAgICBcInBhcmFtZXRlckRhdGFcIixcbiAgICBcInBhcmFtZXRlcnNcIixcbiAgICBcInBhcmVudFwiLFxuICAgIFwicGFyZW50RWxlbWVudFwiLFxuICAgIFwicGFyZW50Tm9kZVwiLFxuICAgIFwicGFyZW50UnVsZVwiLFxuICAgIFwicGFyZW50U3R5bGVTaGVldFwiLFxuICAgIFwicGFyZW50VGV4dEVkaXRcIixcbiAgICBcInBhcmVudFdpbmRvd1wiLFxuICAgIFwicGFyc2VcIixcbiAgICBcInBhcnNlQWxsXCIsXG4gICAgXCJwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OXCIsXG4gICAgXCJwYXJzZUZsb2F0XCIsXG4gICAgXCJwYXJzZUZyb21TdHJpbmdcIixcbiAgICBcInBhcnNlSFRNTFVuc2FmZVwiLFxuICAgIFwicGFyc2VJbnRcIixcbiAgICBcInBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTlwiLFxuICAgIFwicGFydFwiLFxuICAgIFwicGFydGljaXBhbnRzXCIsXG4gICAgXCJwYXNzT3BcIixcbiAgICBcInBhc3NpdmVcIixcbiAgICBcInBhc3N3b3JkXCIsXG4gICAgXCJwYXN0ZUhUTUxcIixcbiAgICBcInBhdGhcIixcbiAgICBcInBhdGhMZW5ndGhcIixcbiAgICBcInBhdGhTZWdMaXN0XCIsXG4gICAgXCJwYXRoU2VnVHlwZVwiLFxuICAgIFwicGF0aFNlZ1R5cGVBc0xldHRlclwiLFxuICAgIFwicGF0aG5hbWVcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcInBhdHRlcm5Db250ZW50VW5pdHNcIixcbiAgICBcInBhdHRlcm5NaXNtYXRjaFwiLFxuICAgIFwicGF0dGVyblRyYW5zZm9ybVwiLFxuICAgIFwicGF0dGVyblVuaXRzXCIsXG4gICAgXCJwYXVzZVwiLFxuICAgIFwicGF1c2VBbmltYXRpb25zXCIsXG4gICAgXCJwYXVzZUR1cmF0aW9uXCIsXG4gICAgXCJwYXVzZU9uRXhpdFwiLFxuICAgIFwicGF1c2VQcm9maWxlcnNcIixcbiAgICBcInBhdXNlVHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICBcInBhdXNlZFwiLFxuICAgIFwicGF5ZXJFbWFpbFwiLFxuICAgIFwicGF5ZXJOYW1lXCIsXG4gICAgXCJwYXllclBob25lXCIsXG4gICAgXCJwYXltZW50TWFuYWdlclwiLFxuICAgIFwicGNcIixcbiAgICBcInBkZlZpZXdlckVuYWJsZWRcIixcbiAgICBcInBlZXJJZGVudGl0eVwiLFxuICAgIFwicGVuZGluZ1wiLFxuICAgIFwicGVuZGluZ0xvY2FsRGVzY3JpcHRpb25cIixcbiAgICBcInBlbmRpbmdSZW1vdGVEZXNjcmlwdGlvblwiLFxuICAgIFwicGVyY2VudFwiLFxuICAgIFwicGVyZm9ybWFuY2VcIixcbiAgICBcInBlcmlvZGljU3luY1wiLFxuICAgIFwicGVybWlzc2lvblwiLFxuICAgIFwicGVybWlzc2lvblN0YXRlXCIsXG4gICAgXCJwZXJtaXNzaW9uc1wiLFxuICAgIFwicGVyc2lzdFwiLFxuICAgIFwicGVyc2lzdGVkXCIsXG4gICAgXCJwZXJzaXN0ZW50RGV2aWNlSWRcIixcbiAgICBcInBlcnNvbmFsYmFyXCIsXG4gICAgXCJwZXJzcGVjdGl2ZVwiLFxuICAgIFwicGVyc3BlY3RpdmUtb3JpZ2luXCIsXG4gICAgXCJwZXJzcGVjdGl2ZU9yaWdpblwiLFxuICAgIFwicGhvbmVcIixcbiAgICBcInBob25ldGljRmFtaWx5TmFtZVwiLFxuICAgIFwicGhvbmV0aWNHaXZlbk5hbWVcIixcbiAgICBcInBob3RvXCIsXG4gICAgXCJwaWN0dXJlSW5QaWN0dXJlQ2hpbGRcIixcbiAgICBcInBpY3R1cmVJblBpY3R1cmVFbGVtZW50XCIsXG4gICAgXCJwaWN0dXJlSW5QaWN0dXJlRW5hYmxlZFwiLFxuICAgIFwicGljdHVyZUluUGljdHVyZVdpbmRvd1wiLFxuICAgIFwicGluZ1wiLFxuICAgIFwicGlwZVRocm91Z2hcIixcbiAgICBcInBpcGVUb1wiLFxuICAgIFwicGl0Y2hcIixcbiAgICBcInBpeGVsQm90dG9tXCIsXG4gICAgXCJwaXhlbERlcHRoXCIsXG4gICAgXCJwaXhlbEhlaWdodFwiLFxuICAgIFwicGl4ZWxMZWZ0XCIsXG4gICAgXCJwaXhlbFJpZ2h0XCIsXG4gICAgXCJwaXhlbFN0b3JlaVwiLFxuICAgIFwicGl4ZWxUb3BcIixcbiAgICBcInBpeGVsVW5pdFRvTWlsbGltZXRlclhcIixcbiAgICBcInBpeGVsVW5pdFRvTWlsbGltZXRlcllcIixcbiAgICBcInBpeGVsV2lkdGhcIixcbiAgICBcInBrY3MxMVwiLFxuICAgIFwicGxhY2UtY29udGVudFwiLFxuICAgIFwicGxhY2UtaXRlbXNcIixcbiAgICBcInBsYWNlLXNlbGZcIixcbiAgICBcInBsYWNlQ29udGVudFwiLFxuICAgIFwicGxhY2VJdGVtc1wiLFxuICAgIFwicGxhY2VTZWxmXCIsXG4gICAgXCJwbGFjZWhvbGRlclwiLFxuICAgIFwicGxhdGZvcm1cIixcbiAgICBcInBsYXRmb3JtVmVyc2lvblwiLFxuICAgIFwicGxhdGZvcm1zXCIsXG4gICAgXCJwbGF5XCIsXG4gICAgXCJwbGF5RWZmZWN0XCIsXG4gICAgXCJwbGF5U3RhdGVcIixcbiAgICBcInBsYXliYWNrUmF0ZVwiLFxuICAgIFwicGxheWJhY2tTdGF0ZVwiLFxuICAgIFwicGxheWJhY2tUaW1lXCIsXG4gICAgXCJwbGF5ZWRcIixcbiAgICBcInBsYXlvdXREZWxheUhpbnRcIixcbiAgICBcInBsYXlzSW5saW5lXCIsXG4gICAgXCJwbHVnaW5zXCIsXG4gICAgXCJwbHVnaW5zcGFnZVwiLFxuICAgIFwicG5hbWVcIixcbiAgICBcInBvaW50ZXItZXZlbnRzXCIsXG4gICAgXCJwb2ludGVyQmVmb3JlUmVmZXJlbmNlTm9kZVwiLFxuICAgIFwicG9pbnRlckVuYWJsZWRcIixcbiAgICBcInBvaW50ZXJFdmVudHNcIixcbiAgICBcInBvaW50ZXJJZFwiLFxuICAgIFwicG9pbnRlckxvY2tFbGVtZW50XCIsXG4gICAgXCJwb2ludGVyVHlwZVwiLFxuICAgIFwicG9pbnRzXCIsXG4gICAgXCJwb2ludHNBdFhcIixcbiAgICBcInBvaW50c0F0WVwiLFxuICAgIFwicG9pbnRzQXRaXCIsXG4gICAgXCJwb2x5Z29uT2Zmc2V0XCIsXG4gICAgXCJwb3BcIixcbiAgICBcInBvcERlYnVnR3JvdXBcIixcbiAgICBcInBvcEVycm9yU2NvcGVcIixcbiAgICBcInBvcG92ZXJcIixcbiAgICBcInBvcG92ZXJUYXJnZXRBY3Rpb25cIixcbiAgICBcInBvcG92ZXJUYXJnZXRFbGVtZW50XCIsXG4gICAgXCJwb3B1bGF0ZU1hdHJpeFwiLFxuICAgIFwicG9wdXBXaW5kb3dGZWF0dXJlc1wiLFxuICAgIFwicG9wdXBXaW5kb3dOYW1lXCIsXG4gICAgXCJwb3B1cFdpbmRvd1VSSVwiLFxuICAgIFwicG9ydFwiLFxuICAgIFwicG9ydDFcIixcbiAgICBcInBvcnQyXCIsXG4gICAgXCJwb3J0c1wiLFxuICAgIFwicG9zQm90dG9tXCIsXG4gICAgXCJwb3NIZWlnaHRcIixcbiAgICBcInBvc0xlZnRcIixcbiAgICBcInBvc1JpZ2h0XCIsXG4gICAgXCJwb3NUb3BcIixcbiAgICBcInBvc1dpZHRoXCIsXG4gICAgXCJwb3NlXCIsXG4gICAgXCJwb3NpdGlvblwiLFxuICAgIFwicG9zaXRpb24tYW5jaG9yXCIsXG4gICAgXCJwb3NpdGlvbi1hcmVhXCIsXG4gICAgXCJwb3NpdGlvbkFsaWduXCIsXG4gICAgXCJwb3NpdGlvbkFuY2hvclwiLFxuICAgIFwicG9zaXRpb25BcmVhXCIsXG4gICAgXCJwb3NpdGlvblhcIixcbiAgICBcInBvc2l0aW9uWVwiLFxuICAgIFwicG9zaXRpb25aXCIsXG4gICAgXCJwb3N0RXJyb3JcIixcbiAgICBcInBvc3RNZXNzYWdlXCIsXG4gICAgXCJwb3N0VGFza1wiLFxuICAgIFwicG9zdGFsQ29kZVwiLFxuICAgIFwicG9zdGVyXCIsXG4gICAgXCJwb3N0c2NyaXB0TmFtZVwiLFxuICAgIFwicG93XCIsXG4gICAgXCJwb3dlckVmZmljaWVudFwiLFxuICAgIFwicG93ZXJPZmZcIixcbiAgICBcInBvd2VyUHJlZmVyZW5jZVwiLFxuICAgIFwicHJlTXVsdGlwbHlTZWxmXCIsXG4gICAgXCJwcmVjaXNpb25cIixcbiAgICBcInByZWZlcnJlZFJlZmxlY3Rpb25Gb3JtYXRcIixcbiAgICBcInByZWZlcnJlZFN0eWxlU2hlZXRTZXRcIixcbiAgICBcInByZWZlcnJlZFN0eWxlc2hlZXRTZXRcIixcbiAgICBcInByZWZpeFwiLFxuICAgIFwicHJlbG9hZFwiLFxuICAgIFwicHJlbXVsdGlwbGllZEFscGhhXCIsXG4gICAgXCJwcmVwZW5kXCIsXG4gICAgXCJwcmVyZW5kZXJpbmdcIixcbiAgICBcInByZXNlbnRhdGlvblwiLFxuICAgIFwicHJlc2VudGF0aW9uQXJlYVwiLFxuICAgIFwicHJlc2VudGF0aW9uU3R5bGVcIixcbiAgICBcInByZXNlcnZlQWxwaGFcIixcbiAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9TdHJpbmdcIixcbiAgICBcInByZXNlcnZlc1BpdGNoXCIsXG4gICAgXCJwcmVzc2VkXCIsXG4gICAgXCJwcmVzc3VyZVwiLFxuICAgIFwicHJldlZhbHVlXCIsXG4gICAgXCJwcmV2ZW50RGVmYXVsdFwiLFxuICAgIFwicHJldmVudEV4dGVuc2lvbnNcIixcbiAgICBcInByZXZlbnRTaWxlbnRBY2Nlc3NcIixcbiAgICBcInByZXZpb3VzRWxlbWVudFNpYmxpbmdcIixcbiAgICBcInByZXZpb3VzTm9kZVwiLFxuICAgIFwicHJldmlvdXNQYWdlXCIsXG4gICAgXCJwcmV2aW91c1ByaW9yaXR5XCIsXG4gICAgXCJwcmV2aW91c1JlY3RcIixcbiAgICBcInByZXZpb3VzU2NhbGVcIixcbiAgICBcInByZXZpb3VzU2libGluZ1wiLFxuICAgIFwicHJldmlvdXNUcmFuc2xhdGVcIixcbiAgICBcInByaW1hcmllc1wiLFxuICAgIFwicHJpbWFyeUtleVwiLFxuICAgIFwicHJpbWFyeUxpZ2h0RGlyZWN0aW9uXCIsXG4gICAgXCJwcmltYXJ5TGlnaHRJbnRlbnNpdHlcIixcbiAgICBcInByaW1pdGl2ZVwiLFxuICAgIFwicHJpbWl0aXZlVHlwZVwiLFxuICAgIFwicHJpbWl0aXZlVW5pdHNcIixcbiAgICBcInByaW5jaXBhbHNcIixcbiAgICBcInByaW50XCIsXG4gICAgXCJwcmludC1jb2xvci1hZGp1c3RcIixcbiAgICBcInByaW50Q29sb3JBZGp1c3RcIixcbiAgICBcInByaW50UHJldmlld1wiLFxuICAgIFwicHJpb3JpdHlcIixcbiAgICBcInByaXZhY3lcIixcbiAgICBcInByaXZhdGVLZXlcIixcbiAgICBcInByaXZhdGVUb2tlblwiLFxuICAgIFwicHJvYmFibHlTdXBwb3J0c0NvbnRleHRcIixcbiAgICBcInByb2JlU3BhY2VcIixcbiAgICBcInByb2Nlc3NcIixcbiAgICBcInByb2Nlc3NJY2VNZXNzYWdlXCIsXG4gICAgXCJwcm9jZXNzaW5nRW5kXCIsXG4gICAgXCJwcm9jZXNzaW5nU3RhcnRcIixcbiAgICBcInByb2Nlc3Nvck9wdGlvbnNcIixcbiAgICBcInByb2R1Y3RcIixcbiAgICBcInByb2R1Y3RJZFwiLFxuICAgIFwicHJvZHVjdE5hbWVcIixcbiAgICBcInByb2R1Y3RTdWJcIixcbiAgICBcInByb2ZpbGVcIixcbiAgICBcInByb2ZpbGVFbmRcIixcbiAgICBcInByb2ZpbGVzXCIsXG4gICAgXCJwcm9qZWN0aW9uTWF0cml4XCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJwcm9tcHRcIixcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsXG4gICAgXCJwcm9wZXJ0eU5hbWVcIixcbiAgICBcInByb3RlY3RlZEF1ZGllbmNlXCIsXG4gICAgXCJwcm90b2NvbFwiLFxuICAgIFwicHJvdG9jb2xMb25nXCIsXG4gICAgXCJwcm90b3R5cGVcIixcbiAgICBcInByb3ZpZGVyXCIsXG4gICAgXCJwcm94eVwiLFxuICAgIFwicHNldWRvQ2xhc3NcIixcbiAgICBcInBzZXVkb0VsZW1lbnRcIixcbiAgICBcInB0XCIsXG4gICAgXCJwdWJsaWNJZFwiLFxuICAgIFwicHVibGljS2V5XCIsXG4gICAgXCJwdWJsaXNoZWRcIixcbiAgICBcInB1bHNlXCIsXG4gICAgXCJwdXNoXCIsXG4gICAgXCJwdXNoRGVidWdHcm91cFwiLFxuICAgIFwicHVzaEVycm9yU2NvcGVcIixcbiAgICBcInB1c2hNYW5hZ2VyXCIsXG4gICAgXCJwdXNoTm90aWZpY2F0aW9uXCIsXG4gICAgXCJwdXNoU3RhdGVcIixcbiAgICBcInB1dFwiLFxuICAgIFwicHV0SW1hZ2VEYXRhXCIsXG4gICAgXCJweFwiLFxuICAgIFwicXVhZHJhdGljQ3VydmVUb1wiLFxuICAgIFwicXVhbGlmaWVyXCIsXG4gICAgXCJxdWF0ZXJuaW9uXCIsXG4gICAgXCJxdWVyeVwiLFxuICAgIFwicXVlcnlDb21tYW5kRW5hYmxlZFwiLFxuICAgIFwicXVlcnlDb21tYW5kSW5kZXRlcm1cIixcbiAgICBcInF1ZXJ5Q29tbWFuZFN0YXRlXCIsXG4gICAgXCJxdWVyeUNvbW1hbmRTdXBwb3J0ZWRcIixcbiAgICBcInF1ZXJ5Q29tbWFuZFRleHRcIixcbiAgICBcInF1ZXJ5Q29tbWFuZFZhbHVlXCIsXG4gICAgXCJxdWVyeUZlYXR1cmVTdXBwb3J0XCIsXG4gICAgXCJxdWVyeUxvY2FsRm9udHNcIixcbiAgICBcInF1ZXJ5UGVybWlzc2lvblwiLFxuICAgIFwicXVlcnlTZWxlY3RvclwiLFxuICAgIFwicXVlcnlTZWxlY3RvckFsbFwiLFxuICAgIFwicXVlcnlTZXRcIixcbiAgICBcInF1ZXVlXCIsXG4gICAgXCJxdWV1ZU1pY3JvdGFza1wiLFxuICAgIFwicXVvdGVcIixcbiAgICBcInF1b3Rlc1wiLFxuICAgIFwiclwiLFxuICAgIFwicjFcIixcbiAgICBcInIyXCIsXG4gICAgXCJyYWNlXCIsXG4gICAgXCJyYWRcIixcbiAgICBcInJhZGlvZ3JvdXBcIixcbiAgICBcInJhZGl1c1wiLFxuICAgIFwicmFkaXVzWFwiLFxuICAgIFwicmFkaXVzWVwiLFxuICAgIFwicmFuZG9tXCIsXG4gICAgXCJyYW5kb21VVUlEXCIsXG4gICAgXCJyYW5nZVwiLFxuICAgIFwicmFuZ2VDb3VudFwiLFxuICAgIFwicmFuZ2VFbmRcIixcbiAgICBcInJhbmdlTWF4XCIsXG4gICAgXCJyYW5nZU1pblwiLFxuICAgIFwicmFuZ2VPZmZzZXRcIixcbiAgICBcInJhbmdlT3ZlcmZsb3dcIixcbiAgICBcInJhbmdlUGFyZW50XCIsXG4gICAgXCJyYW5nZVN0YXJ0XCIsXG4gICAgXCJyYW5nZVVuZGVyZmxvd1wiLFxuICAgIFwicmF0ZVwiLFxuICAgIFwicmF0aW9cIixcbiAgICBcInJhd1wiLFxuICAgIFwicmF3SWRcIixcbiAgICBcInJhd0pTT05cIixcbiAgICBcInJhd1ZhbHVlVG9NZXRlcnNcIixcbiAgICBcInJjYXBcIixcbiAgICBcInJjaFwiLFxuICAgIFwicmVhZFwiLFxuICAgIFwicmVhZEFzQXJyYXlCdWZmZXJcIixcbiAgICBcInJlYWRBc0JpbmFyeVN0cmluZ1wiLFxuICAgIFwicmVhZEFzQmxvYlwiLFxuICAgIFwicmVhZEFzRGF0YVVSTFwiLFxuICAgIFwicmVhZEFzVGV4dFwiLFxuICAgIFwicmVhZEJ1ZmZlclwiLFxuICAgIFwicmVhZEVudHJpZXNcIixcbiAgICBcInJlYWRPbmx5XCIsXG4gICAgXCJyZWFkUGl4ZWxzXCIsXG4gICAgXCJyZWFkUmVwb3J0UmVxdWVzdGVkXCIsXG4gICAgXCJyZWFkVGV4dFwiLFxuICAgIFwicmVhZFZhbHVlXCIsXG4gICAgXCJyZWFkYWJsZVwiLFxuICAgIFwicmVhZHlcIixcbiAgICBcInJlYWR5U3RhdGVcIixcbiAgICBcInJlYXNvblwiLFxuICAgIFwicmVhc29uc1wiLFxuICAgIFwicmVib290XCIsXG4gICAgXCJyZWNlaXZlRmVhdHVyZVJlcG9ydFwiLFxuICAgIFwicmVjZWl2ZWRBbGVydFwiLFxuICAgIFwicmVjZWl2ZXJcIixcbiAgICBcInJlY2VpdmVyc1wiLFxuICAgIFwicmVjaXBpZW50XCIsXG4gICAgXCJyZWNvbW1lbmRlZFZpZXdwb3J0U2NhbGVcIixcbiAgICBcInJlY29ubmVjdFwiLFxuICAgIFwicmVjb3JkTnVtYmVyXCIsXG4gICAgXCJyZWNvcmRzQXZhaWxhYmxlXCIsXG4gICAgXCJyZWNvcmRzZXRcIixcbiAgICBcInJlY3RcIixcbiAgICBcInJlZFwiLFxuICAgIFwicmVkRXllUmVkdWN0aW9uXCIsXG4gICAgXCJyZWRpcmVjdFwiLFxuICAgIFwicmVkaXJlY3RDb3VudFwiLFxuICAgIFwicmVkaXJlY3RFbmRcIixcbiAgICBcInJlZGlyZWN0U3RhcnRcIixcbiAgICBcInJlZGlyZWN0ZWRcIixcbiAgICBcInJlZHVjZVwiLFxuICAgIFwicmVkdWNlUmlnaHRcIixcbiAgICBcInJlZHVjdGlvblwiLFxuICAgIFwicmVmRGlzdGFuY2VcIixcbiAgICBcInJlZlhcIixcbiAgICBcInJlZllcIixcbiAgICBcInJlZmVyZW5jZU5vZGVcIixcbiAgICBcInJlZmVyZW5jZVNwYWNlXCIsXG4gICAgXCJyZWZlcnJlclwiLFxuICAgIFwicmVmZXJyZXJQb2xpY3lcIixcbiAgICBcInJlZnJlc2hcIixcbiAgICBcInJlZ2lvblwiLFxuICAgIFwicmVnaW9uQW5jaG9yWFwiLFxuICAgIFwicmVnaW9uQW5jaG9yWVwiLFxuICAgIFwicmVnaW9uSWRcIixcbiAgICBcInJlZ2lvbnNcIixcbiAgICBcInJlZ2lzdGVyXCIsXG4gICAgXCJyZWdpc3RlckNvbnRlbnRIYW5kbGVyXCIsXG4gICAgXCJyZWdpc3RlckVsZW1lbnRcIixcbiAgICBcInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydFwiLFxuICAgIFwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3BcIixcbiAgICBcInJlZ2lzdGVyUHJvcGVydHlcIixcbiAgICBcInJlZ2lzdGVyUHJvdG9jb2xIYW5kbGVyXCIsXG4gICAgXCJyZWplY3RcIixcbiAgICBcInJlbFwiLFxuICAgIFwicmVsTGlzdFwiLFxuICAgIFwicmVsYXRlZEFkZHJlc3NcIixcbiAgICBcInJlbGF0ZWROb2RlXCIsXG4gICAgXCJyZWxhdGVkUG9ydFwiLFxuICAgIFwicmVsYXRlZFRhcmdldFwiLFxuICAgIFwicmVsYXlQcm90b2NvbFwiLFxuICAgIFwicmVsZWFzZVwiLFxuICAgIFwicmVsZWFzZUNhcHR1cmVcIixcbiAgICBcInJlbGVhc2VFdmVudHNcIixcbiAgICBcInJlbGVhc2VJbnRlcmZhY2VcIixcbiAgICBcInJlbGVhc2VMb2NrXCIsXG4gICAgXCJyZWxlYXNlUG9pbnRlckNhcHR1cmVcIixcbiAgICBcInJlbGVhc2VTaGFkZXJDb21waWxlclwiLFxuICAgIFwicmVsZWFzZWRcIixcbiAgICBcInJlbGlhYmlsaXR5XCIsXG4gICAgXCJyZWxpYWJsZVwiLFxuICAgIFwicmVsaWFibGVXcml0ZVwiLFxuICAgIFwicmVsb2FkXCIsXG4gICAgXCJyZW1cIixcbiAgICBcInJlbWFpbmluZ1NwYWNlXCIsXG4gICAgXCJyZW1vdGVcIixcbiAgICBcInJlbW90ZURlc2NyaXB0aW9uXCIsXG4gICAgXCJyZW1vdmVcIixcbiAgICBcInJlbW92ZUFsbFJhbmdlc1wiLFxuICAgIFwicmVtb3ZlQXR0cmlidXRlXCIsXG4gICAgXCJyZW1vdmVBdHRyaWJ1dGVOU1wiLFxuICAgIFwicmVtb3ZlQXR0cmlidXRlTm9kZVwiLFxuICAgIFwicmVtb3ZlQmVoYXZpb3JcIixcbiAgICBcInJlbW92ZUNoaWxkXCIsXG4gICAgXCJyZW1vdmVDdWVcIixcbiAgICBcInJlbW92ZUVudHJ5XCIsXG4gICAgXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgXCJyZW1vdmVGaWx0ZXJcIixcbiAgICBcInJlbW92ZUltcG9ydFwiLFxuICAgIFwicmVtb3ZlSXRlbVwiLFxuICAgIFwicmVtb3ZlTGlzdGVuZXJcIixcbiAgICBcInJlbW92ZU5hbWVkSXRlbVwiLFxuICAgIFwicmVtb3ZlTmFtZWRJdGVtTlNcIixcbiAgICBcInJlbW92ZU5vZGVcIixcbiAgICBcInJlbW92ZVBhcmFtZXRlclwiLFxuICAgIFwicmVtb3ZlUHJvcGVydHlcIixcbiAgICBcInJlbW92ZVJhbmdlXCIsXG4gICAgXCJyZW1vdmVSZWdpb25cIixcbiAgICBcInJlbW92ZVJ1bGVcIixcbiAgICBcInJlbW92ZVNpdGVTcGVjaWZpY1RyYWNraW5nRXhjZXB0aW9uXCIsXG4gICAgXCJyZW1vdmVTb3VyY2VCdWZmZXJcIixcbiAgICBcInJlbW92ZVN0cmVhbVwiLFxuICAgIFwicmVtb3ZlVHJhY2tcIixcbiAgICBcInJlbW92ZVZhcmlhYmxlXCIsXG4gICAgXCJyZW1vdmVXYWtlTG9ja0xpc3RlbmVyXCIsXG4gICAgXCJyZW1vdmVXZWJXaWRlVHJhY2tpbmdFeGNlcHRpb25cIixcbiAgICBcInJlbW92ZWRcIixcbiAgICBcInJlbW92ZWROb2Rlc1wiLFxuICAgIFwicmVuZGVyQmxvY2tpbmdTdGF0dXNcIixcbiAgICBcInJlbmRlckhlaWdodFwiLFxuICAgIFwicmVuZGVyU3RhcnRcIixcbiAgICBcInJlbmRlclN0YXRlXCIsXG4gICAgXCJyZW5kZXJUaW1lXCIsXG4gICAgXCJyZW5kZXJXaWR0aFwiLFxuICAgIFwicmVuZGVyYnVmZmVyU3RvcmFnZVwiLFxuICAgIFwicmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlXCIsXG4gICAgXCJyZW5kZXJlZEJ1ZmZlclwiLFxuICAgIFwicmVuZGVyZXJJbnRlcmZhY2VzXCIsXG4gICAgXCJyZW5kZXJlcnNcIixcbiAgICBcInJlbmRlcmluZ01vZGVcIixcbiAgICBcInJlbm90aWZ5XCIsXG4gICAgXCJyZXBlYXRcIixcbiAgICBcInJlcGV0aXRpb25Db3VudFwiLFxuICAgIFwicmVwbGFjZVwiLFxuICAgIFwicmVwbGFjZUFkamFjZW50VGV4dFwiLFxuICAgIFwicmVwbGFjZUFsbFwiLFxuICAgIFwicmVwbGFjZUNoaWxkXCIsXG4gICAgXCJyZXBsYWNlQ2hpbGRyZW5cIixcbiAgICBcInJlcGxhY2VEYXRhXCIsXG4gICAgXCJyZXBsYWNlSWRcIixcbiAgICBcInJlcGxhY2VJdGVtXCIsXG4gICAgXCJyZXBsYWNlTm9kZVwiLFxuICAgIFwicmVwbGFjZVN0YXRlXCIsXG4gICAgXCJyZXBsYWNlU3luY1wiLFxuICAgIFwicmVwbGFjZVRyYWNrXCIsXG4gICAgXCJyZXBsYWNlV2hvbGVUZXh0XCIsXG4gICAgXCJyZXBsYWNlV2l0aFwiLFxuICAgIFwicmVwb3J0RXJyb3JcIixcbiAgICBcInJlcG9ydEV2ZW50XCIsXG4gICAgXCJyZXBvcnRJZFwiLFxuICAgIFwicmVwb3J0VmFsaWRpdHlcIixcbiAgICBcInJlcXVlc3RcIixcbiAgICBcInJlcXVlc3RBZGFwdGVyXCIsXG4gICAgXCJyZXF1ZXN0QWRhcHRlckluZm9cIixcbiAgICBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgIFwicmVxdWVzdEF1dG9jb21wbGV0ZVwiLFxuICAgIFwicmVxdWVzdENsb3NlXCIsXG4gICAgXCJyZXF1ZXN0RGF0YVwiLFxuICAgIFwicmVxdWVzdERldmljZVwiLFxuICAgIFwicmVxdWVzdEZyYW1lXCIsXG4gICAgXCJyZXF1ZXN0RnVsbHNjcmVlblwiLFxuICAgIFwicmVxdWVzdEhpdFRlc3RTb3VyY2VcIixcbiAgICBcInJlcXVlc3RIaXRUZXN0U291cmNlRm9yVHJhbnNpZW50SW5wdXRcIixcbiAgICBcInJlcXVlc3RJZFwiLFxuICAgIFwicmVxdWVzdElkbGVDYWxsYmFja1wiLFxuICAgIFwicmVxdWVzdExpZ2h0UHJvYmVcIixcbiAgICBcInJlcXVlc3RNSURJQWNjZXNzXCIsXG4gICAgXCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcIixcbiAgICBcInJlcXVlc3RQZXJtaXNzaW9uXCIsXG4gICAgXCJyZXF1ZXN0UGljdHVyZUluUGljdHVyZVwiLFxuICAgIFwicmVxdWVzdFBvaW50ZXJMb2NrXCIsXG4gICAgXCJyZXF1ZXN0UG9ydFwiLFxuICAgIFwicmVxdWVzdFByZXNlbnRcIixcbiAgICBcInJlcXVlc3RQcmVzZW50ZXJcIixcbiAgICBcInJlcXVlc3RSZWZlcmVuY2VTcGFjZVwiLFxuICAgIFwicmVxdWVzdFNlc3Npb25cIixcbiAgICBcInJlcXVlc3RTdGFydFwiLFxuICAgIFwicmVxdWVzdFN0b3JhZ2VBY2Nlc3NcIixcbiAgICBcInJlcXVlc3RTdG9yYWdlQWNjZXNzRm9yXCIsXG4gICAgXCJyZXF1ZXN0U3VibWl0XCIsXG4gICAgXCJyZXF1ZXN0VGltZVwiLFxuICAgIFwicmVxdWVzdFVwZGF0ZUNoZWNrXCIsXG4gICAgXCJyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrXCIsXG4gICAgXCJyZXF1ZXN0Vmlld3BvcnRTY2FsZVwiLFxuICAgIFwicmVxdWVzdFdpbmRvd1wiLFxuICAgIFwicmVxdWVzdGluZ1dpbmRvd1wiLFxuICAgIFwicmVxdWlyZUludGVyYWN0aW9uXCIsXG4gICAgXCJyZXF1aXJlZFwiLFxuICAgIFwicmVxdWlyZWRFeHRlbnNpb25zXCIsXG4gICAgXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gICAgXCJyZXF1aXJlZExpbWl0c1wiLFxuICAgIFwicmVzZXRcIixcbiAgICBcInJlc2V0TGF0ZW5jeVwiLFxuICAgIFwicmVzZXRQb3NlXCIsXG4gICAgXCJyZXNldFRyYW5zZm9ybVwiLFxuICAgIFwicmVzaXphYmxlXCIsXG4gICAgXCJyZXNpemVcIixcbiAgICBcInJlc2l6ZUJ5XCIsXG4gICAgXCJyZXNpemVUb1wiLFxuICAgIFwicmVzb2x2ZVwiLFxuICAgIFwicmVzb2x2ZVF1ZXJ5U2V0XCIsXG4gICAgXCJyZXNvbHZlVGFyZ2V0XCIsXG4gICAgXCJyZXNvdXJjZVwiLFxuICAgIFwicmVzcG9uZFwiLFxuICAgIFwicmVzcG9uZFdpdGhOZXdWaWV3XCIsXG4gICAgXCJyZXNwb25zZVwiLFxuICAgIFwicmVzcG9uc2VCb2R5XCIsXG4gICAgXCJyZXNwb25zZUVuZFwiLFxuICAgIFwicmVzcG9uc2VSZWFkeVwiLFxuICAgIFwicmVzcG9uc2VTdGFydFwiLFxuICAgIFwicmVzcG9uc2VTdGF0dXNcIixcbiAgICBcInJlc3BvbnNlVGV4dFwiLFxuICAgIFwicmVzcG9uc2VUeXBlXCIsXG4gICAgXCJyZXNwb25zZVVSTFwiLFxuICAgIFwicmVzcG9uc2VYTUxcIixcbiAgICBcInJlc3RhcnRcIixcbiAgICBcInJlc3RhcnRBZnRlckRlbGF5XCIsXG4gICAgXCJyZXN0YXJ0SWNlXCIsXG4gICAgXCJyZXN0b3JlXCIsXG4gICAgXCJyZXN1bHRcIixcbiAgICBcInJlc3VsdEluZGV4XCIsXG4gICAgXCJyZXN1bHRUeXBlXCIsXG4gICAgXCJyZXN1bHRzXCIsXG4gICAgXCJyZXN1bWVcIixcbiAgICBcInJlc3VtZVByb2ZpbGVyc1wiLFxuICAgIFwicmVzdW1lVHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICBcInJldHJ5XCIsXG4gICAgXCJyZXR1cm5WYWx1ZVwiLFxuICAgIFwicmV2XCIsXG4gICAgXCJyZXZlcnNlXCIsXG4gICAgXCJyZXZlcnNlZFwiLFxuICAgIFwicmV2b2NhYmxlXCIsXG4gICAgXCJyZXZva2VPYmplY3RVUkxcIixcbiAgICBcInJleFwiLFxuICAgIFwicmdiQ29sb3JcIixcbiAgICBcInJpY1wiLFxuICAgIFwicmlnaHRcIixcbiAgICBcInJpZ2h0Q29udGV4dFwiLFxuICAgIFwicmlnaHREZWdyZWVzXCIsXG4gICAgXCJyaWdodE1hcmdpblwiLFxuICAgIFwicmlnaHRQcm9qZWN0aW9uTWF0cml4XCIsXG4gICAgXCJyaWdodFZpZXdNYXRyaXhcIixcbiAgICBcInJsaFwiLFxuICAgIFwicm9sZVwiLFxuICAgIFwicm9sbG9mZkZhY3RvclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwicm9vdEJvdW5kc1wiLFxuICAgIFwicm9vdEVsZW1lbnRcIixcbiAgICBcInJvb3RNYXJnaW5cIixcbiAgICBcInJvdGF0ZVwiLFxuICAgIFwicm90YXRlQXhpc0FuZ2xlXCIsXG4gICAgXCJyb3RhdGVBeGlzQW5nbGVTZWxmXCIsXG4gICAgXCJyb3RhdGVGcm9tVmVjdG9yXCIsXG4gICAgXCJyb3RhdGVGcm9tVmVjdG9yU2VsZlwiLFxuICAgIFwicm90YXRlU2VsZlwiLFxuICAgIFwicm90YXRpb25cIixcbiAgICBcInJvdGF0aW9uQW5nbGVcIixcbiAgICBcInJvdGF0aW9uUmF0ZVwiLFxuICAgIFwicm91bmRcIixcbiAgICBcInJvdW5kUmVjdFwiLFxuICAgIFwicm93LWdhcFwiLFxuICAgIFwicm93R2FwXCIsXG4gICAgXCJyb3dJbmRleFwiLFxuICAgIFwicm93U3BhblwiLFxuICAgIFwicm93c1wiLFxuICAgIFwicm93c1BlckltYWdlXCIsXG4gICAgXCJydGNwVHJhbnNwb3J0XCIsXG4gICAgXCJydHRcIixcbiAgICBcInJ1YnktYWxpZ25cIixcbiAgICBcInJ1YnktcG9zaXRpb25cIixcbiAgICBcInJ1YnlBbGlnblwiLFxuICAgIFwicnVieU92ZXJoYW5nXCIsXG4gICAgXCJydWJ5UG9zaXRpb25cIixcbiAgICBcInJ1bGVzXCIsXG4gICAgXCJydW5cIixcbiAgICBcInJ1bkFkQXVjdGlvblwiLFxuICAgIFwicnVudGltZVwiLFxuICAgIFwicnVudGltZVN0eWxlXCIsXG4gICAgXCJyeFwiLFxuICAgIFwicnlcIixcbiAgICBcInNcIixcbiAgICBcInNhZmFyaVwiLFxuICAgIFwic2FtZURvY3VtZW50XCIsXG4gICAgXCJzYW1wbGVcIixcbiAgICBcInNhbXBsZUNvdW50XCIsXG4gICAgXCJzYW1wbGVDb3ZlcmFnZVwiLFxuICAgIFwic2FtcGxlSW50ZXJ2YWxcIixcbiAgICBcInNhbXBsZVJhdGVcIixcbiAgICBcInNhbXBsZVR5cGVcIixcbiAgICBcInNhbXBsZXJcIixcbiAgICBcInNhbXBsZXJQYXJhbWV0ZXJmXCIsXG4gICAgXCJzYW1wbGVyUGFyYW1ldGVyaVwiLFxuICAgIFwic2FuZGJveFwiLFxuICAgIFwic2F2ZVwiLFxuICAgIFwic2F2ZUFzUERGXCIsXG4gICAgXCJzYXZlRGF0YVwiLFxuICAgIFwic2NhbGVcIixcbiAgICBcInNjYWxlM2RcIixcbiAgICBcInNjYWxlM2RTZWxmXCIsXG4gICAgXCJzY2FsZU5vblVuaWZvcm1cIixcbiAgICBcInNjYWxlTm9uVW5pZm9ybVNlbGZcIixcbiAgICBcInNjYWxlU2VsZlwiLFxuICAgIFwic2NoZWR1bGVyXCIsXG4gICAgXCJzY2hlZHVsaW5nXCIsXG4gICAgXCJzY2hlbWVcIixcbiAgICBcInNjaXNzb3JcIixcbiAgICBcInNjb3BlXCIsXG4gICAgXCJzY29wZU5hbWVcIixcbiAgICBcInNjb3BlZFwiLFxuICAgIFwic2NyZWVuXCIsXG4gICAgXCJzY3JlZW5CcmlnaHRuZXNzXCIsXG4gICAgXCJzY3JlZW5FbmFibGVkXCIsXG4gICAgXCJzY3JlZW5MZWZ0XCIsXG4gICAgXCJzY3JlZW5QaXhlbFRvTWlsbGltZXRlclhcIixcbiAgICBcInNjcmVlblBpeGVsVG9NaWxsaW1ldGVyWVwiLFxuICAgIFwic2NyZWVuU3RhdGVcIixcbiAgICBcInNjcmVlblRvcFwiLFxuICAgIFwic2NyZWVuWFwiLFxuICAgIFwic2NyZWVuWVwiLFxuICAgIFwic2NyZWVuc1wiLFxuICAgIFwic2NyaXB0VVJMXCIsXG4gICAgXCJzY3JpcHRpbmdcIixcbiAgICBcInNjcmlwdHNcIixcbiAgICBcInNjcm9sbFwiLFxuICAgIFwic2Nyb2xsLWJlaGF2aW9yXCIsXG4gICAgXCJzY3JvbGwtbWFyZ2luXCIsXG4gICAgXCJzY3JvbGwtbWFyZ2luLWJsb2NrXCIsXG4gICAgXCJzY3JvbGwtbWFyZ2luLWJsb2NrLWVuZFwiLFxuICAgIFwic2Nyb2xsLW1hcmdpbi1ibG9jay1zdGFydFwiLFxuICAgIFwic2Nyb2xsLW1hcmdpbi1ib3R0b21cIixcbiAgICBcInNjcm9sbC1tYXJnaW4taW5saW5lXCIsXG4gICAgXCJzY3JvbGwtbWFyZ2luLWlubGluZS1lbmRcIixcbiAgICBcInNjcm9sbC1tYXJnaW4taW5saW5lLXN0YXJ0XCIsXG4gICAgXCJzY3JvbGwtbWFyZ2luLWxlZnRcIixcbiAgICBcInNjcm9sbC1tYXJnaW4tcmlnaHRcIixcbiAgICBcInNjcm9sbC1tYXJnaW4tdG9wXCIsXG4gICAgXCJzY3JvbGwtcGFkZGluZ1wiLFxuICAgIFwic2Nyb2xsLXBhZGRpbmctYmxvY2tcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLWJsb2NrLWVuZFwiLFxuICAgIFwic2Nyb2xsLXBhZGRpbmctYmxvY2stc3RhcnRcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLWJvdHRvbVwiLFxuICAgIFwic2Nyb2xsLXBhZGRpbmctaW5saW5lXCIsXG4gICAgXCJzY3JvbGwtcGFkZGluZy1pbmxpbmUtZW5kXCIsXG4gICAgXCJzY3JvbGwtcGFkZGluZy1pbmxpbmUtc3RhcnRcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLWxlZnRcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLXJpZ2h0XCIsXG4gICAgXCJzY3JvbGwtcGFkZGluZy10b3BcIixcbiAgICBcInNjcm9sbC1zbmFwLWFsaWduXCIsXG4gICAgXCJzY3JvbGwtc25hcC1zdG9wXCIsXG4gICAgXCJzY3JvbGwtc25hcC10eXBlXCIsXG4gICAgXCJzY3JvbGxBbW91bnRcIixcbiAgICBcInNjcm9sbEJlaGF2aW9yXCIsXG4gICAgXCJzY3JvbGxCeVwiLFxuICAgIFwic2Nyb2xsQnlMaW5lc1wiLFxuICAgIFwic2Nyb2xsQnlQYWdlc1wiLFxuICAgIFwic2Nyb2xsRGVsYXlcIixcbiAgICBcInNjcm9sbEhlaWdodFwiLFxuICAgIFwic2Nyb2xsSW50b1ZpZXdcIixcbiAgICBcInNjcm9sbEludG9WaWV3SWZOZWVkZWRcIixcbiAgICBcInNjcm9sbExlZnRcIixcbiAgICBcInNjcm9sbExlZnRNYXhcIixcbiAgICBcInNjcm9sbE1hcmdpblwiLFxuICAgIFwic2Nyb2xsTWFyZ2luQmxvY2tcIixcbiAgICBcInNjcm9sbE1hcmdpbkJsb2NrRW5kXCIsXG4gICAgXCJzY3JvbGxNYXJnaW5CbG9ja1N0YXJ0XCIsXG4gICAgXCJzY3JvbGxNYXJnaW5Cb3R0b21cIixcbiAgICBcInNjcm9sbE1hcmdpbklubGluZVwiLFxuICAgIFwic2Nyb2xsTWFyZ2luSW5saW5lRW5kXCIsXG4gICAgXCJzY3JvbGxNYXJnaW5JbmxpbmVTdGFydFwiLFxuICAgIFwic2Nyb2xsTWFyZ2luTGVmdFwiLFxuICAgIFwic2Nyb2xsTWFyZ2luUmlnaHRcIixcbiAgICBcInNjcm9sbE1hcmdpblRvcFwiLFxuICAgIFwic2Nyb2xsTWF4WFwiLFxuICAgIFwic2Nyb2xsTWF4WVwiLFxuICAgIFwic2Nyb2xsUGFkZGluZ1wiLFxuICAgIFwic2Nyb2xsUGFkZGluZ0Jsb2NrXCIsXG4gICAgXCJzY3JvbGxQYWRkaW5nQmxvY2tFbmRcIixcbiAgICBcInNjcm9sbFBhZGRpbmdCbG9ja1N0YXJ0XCIsXG4gICAgXCJzY3JvbGxQYWRkaW5nQm90dG9tXCIsXG4gICAgXCJzY3JvbGxQYWRkaW5nSW5saW5lXCIsXG4gICAgXCJzY3JvbGxQYWRkaW5nSW5saW5lRW5kXCIsXG4gICAgXCJzY3JvbGxQYWRkaW5nSW5saW5lU3RhcnRcIixcbiAgICBcInNjcm9sbFBhZGRpbmdMZWZ0XCIsXG4gICAgXCJzY3JvbGxQYWRkaW5nUmlnaHRcIixcbiAgICBcInNjcm9sbFBhZGRpbmdUb3BcIixcbiAgICBcInNjcm9sbFJlc3RvcmF0aW9uXCIsXG4gICAgXCJzY3JvbGxTbmFwQWxpZ25cIixcbiAgICBcInNjcm9sbFNuYXBTdG9wXCIsXG4gICAgXCJzY3JvbGxTbmFwVHlwZVwiLFxuICAgIFwic2Nyb2xsVG9cIixcbiAgICBcInNjcm9sbFRvcFwiLFxuICAgIFwic2Nyb2xsVG9wTWF4XCIsXG4gICAgXCJzY3JvbGxXaWR0aFwiLFxuICAgIFwic2Nyb2xsWFwiLFxuICAgIFwic2Nyb2xsWVwiLFxuICAgIFwic2Nyb2xsYmFyLWNvbG9yXCIsXG4gICAgXCJzY3JvbGxiYXItZ3V0dGVyXCIsXG4gICAgXCJzY3JvbGxiYXItd2lkdGhcIixcbiAgICBcInNjcm9sbGJhcjNkTGlnaHRDb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyQXJyb3dDb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyQmFzZUNvbG9yXCIsXG4gICAgXCJzY3JvbGxiYXJDb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyRGFya1NoYWRvd0NvbG9yXCIsXG4gICAgXCJzY3JvbGxiYXJGYWNlQ29sb3JcIixcbiAgICBcInNjcm9sbGJhckd1dHRlclwiLFxuICAgIFwic2Nyb2xsYmFySGlnaGxpZ2h0Q29sb3JcIixcbiAgICBcInNjcm9sbGJhclNoYWRvd0NvbG9yXCIsXG4gICAgXCJzY3JvbGxiYXJUcmFja0NvbG9yXCIsXG4gICAgXCJzY3JvbGxiYXJXaWR0aFwiLFxuICAgIFwic2Nyb2xsYmFyc1wiLFxuICAgIFwic2Nyb2xsaW5nXCIsXG4gICAgXCJzY3JvbGxpbmdFbGVtZW50XCIsXG4gICAgXCJzY3RwXCIsXG4gICAgXCJzY3RwQ2F1c2VDb2RlXCIsXG4gICAgXCJzZHBcIixcbiAgICBcInNkcExpbmVOdW1iZXJcIixcbiAgICBcInNkcE1MaW5lSW5kZXhcIixcbiAgICBcInNkcE1pZFwiLFxuICAgIFwic2VhbFwiLFxuICAgIFwic2VhcmNoXCIsXG4gICAgXCJzZWFyY2hCb3hcIixcbiAgICBcInNlYXJjaEJveEphdmFCcmlkZ2VfXCIsXG4gICAgXCJzZWFyY2hQYXJhbXNcIixcbiAgICBcInNlY3Rpb25Sb3dJbmRleFwiLFxuICAgIFwic2VjdXJlQ29ubmVjdGlvblN0YXJ0XCIsXG4gICAgXCJzZWN1cml0eVwiLFxuICAgIFwic2VlZFwiLFxuICAgIFwic2Vla1wiLFxuICAgIFwic2Vla1RvTmV4dEZyYW1lXCIsXG4gICAgXCJzZWVrYWJsZVwiLFxuICAgIFwic2Vla2luZ1wiLFxuICAgIFwic2VsZWN0XCIsXG4gICAgXCJzZWxlY3RBbGxDaGlsZHJlblwiLFxuICAgIFwic2VsZWN0QWx0ZXJuYXRlSW50ZXJmYWNlXCIsXG4gICAgXCJzZWxlY3RBdWRpb091dHB1dFwiLFxuICAgIFwic2VsZWN0Q29uZmlndXJhdGlvblwiLFxuICAgIFwic2VsZWN0Tm9kZVwiLFxuICAgIFwic2VsZWN0Tm9kZUNvbnRlbnRzXCIsXG4gICAgXCJzZWxlY3ROb2Rlc1wiLFxuICAgIFwic2VsZWN0U2luZ2xlTm9kZVwiLFxuICAgIFwic2VsZWN0U3ViU3RyaW5nXCIsXG4gICAgXCJzZWxlY3RVUkxcIixcbiAgICBcInNlbGVjdGVkXCIsXG4gICAgXCJzZWxlY3RlZEluZGV4XCIsXG4gICAgXCJzZWxlY3RlZE9wdGlvbnNcIixcbiAgICBcInNlbGVjdGVkU3R5bGVTaGVldFNldFwiLFxuICAgIFwic2VsZWN0ZWRTdHlsZXNoZWV0U2V0XCIsXG4gICAgXCJzZWxlY3RlZFRyYWNrXCIsXG4gICAgXCJzZWxlY3Rpb25cIixcbiAgICBcInNlbGVjdGlvbkRpcmVjdGlvblwiLFxuICAgIFwic2VsZWN0aW9uRW5kXCIsXG4gICAgXCJzZWxlY3Rpb25TdGFydFwiLFxuICAgIFwic2VsZWN0b3JcIixcbiAgICBcInNlbGVjdG9yVGV4dFwiLFxuICAgIFwic2VsZlwiLFxuICAgIFwic2VuZFwiLFxuICAgIFwic2VuZEFzQmluYXJ5XCIsXG4gICAgXCJzZW5kQmVhY29uXCIsXG4gICAgXCJzZW5kRmVhdHVyZVJlcG9ydFwiLFxuICAgIFwic2VuZE1lc3NhZ2VcIixcbiAgICBcInNlbmROYXRpdmVNZXNzYWdlXCIsXG4gICAgXCJzZW5kT3JkZXJcIixcbiAgICBcInNlbmRSZXBvcnRcIixcbiAgICBcInNlbmRlclwiLFxuICAgIFwic2VudEFsZXJ0XCIsXG4gICAgXCJzZW50VGltZXN0YW1wXCIsXG4gICAgXCJzZXBhcmF0b3JcIixcbiAgICBcInNlcmlhbFwiLFxuICAgIFwic2VyaWFsTnVtYmVyXCIsXG4gICAgXCJzZXJpYWxpemFibGVcIixcbiAgICBcInNlcmlhbGl6ZVRvU3RyaW5nXCIsXG4gICAgXCJzZXJ2ZXJUaW1pbmdcIixcbiAgICBcInNlcnZpY2VcIixcbiAgICBcInNlcnZpY2VXb3JrZXJcIixcbiAgICBcInNlc3Npb25cIixcbiAgICBcInNlc3Npb25JZFwiLFxuICAgIFwic2Vzc2lvblN0b3JhZ2VcIixcbiAgICBcInNlc3Npb25zXCIsXG4gICAgXCJzZXRcIixcbiAgICBcInNldEFjdGlvbkhhbmRsZXJcIixcbiAgICBcInNldEFjdGl2ZVwiLFxuICAgIFwic2V0QWxwaGFcIixcbiAgICBcInNldEFwcEJhZGdlXCIsXG4gICAgXCJzZXRBdHRyaWJ1dGVcIixcbiAgICBcInNldEF0dHJpYnV0ZU5TXCIsXG4gICAgXCJzZXRBdHRyaWJ1dGVOb2RlXCIsXG4gICAgXCJzZXRBdHRyaWJ1dGVOb2RlTlNcIixcbiAgICBcInNldEF0dHJpYnV0aW9uUmVwb3J0aW5nXCIsXG4gICAgXCJzZXRCYWRnZUJhY2tncm91bmRDb2xvclwiLFxuICAgIFwic2V0QmFkZ2VUZXh0XCIsXG4gICAgXCJzZXRCYWRnZVRleHRDb2xvclwiLFxuICAgIFwic2V0QmFzZUFuZEV4dGVudFwiLFxuICAgIFwic2V0QmlnSW50NjRcIixcbiAgICBcInNldEJpZ1VpbnQ2NFwiLFxuICAgIFwic2V0QmluZEdyb3VwXCIsXG4gICAgXCJzZXRCaW5nQ3VycmVudFNlYXJjaERlZmF1bHRcIixcbiAgICBcInNldEJsZW5kQ29uc3RhbnRcIixcbiAgICBcInNldENhbWVyYUFjdGl2ZVwiLFxuICAgIFwic2V0Q2FwdHVyZVwiLFxuICAgIFwic2V0Q2FwdHVyZUhhbmRsZUNvbmZpZ1wiLFxuICAgIFwic2V0Q29kZWNQcmVmZXJlbmNlc1wiLFxuICAgIFwic2V0Q29sb3JcIixcbiAgICBcInNldENvbXBvc2l0ZU9wZXJhdGlvblwiLFxuICAgIFwic2V0Q29uZmlndXJhdGlvblwiLFxuICAgIFwic2V0Q29uc3VtZXJcIixcbiAgICBcInNldEN1cnJlbnRUaW1lXCIsXG4gICAgXCJzZXRDdXN0b21WYWxpZGl0eVwiLFxuICAgIFwic2V0RGF0YVwiLFxuICAgIFwic2V0RGF0ZVwiLFxuICAgIFwic2V0RHJhZ0ltYWdlXCIsXG4gICAgXCJzZXRFbmFibGVkXCIsXG4gICAgXCJzZXRFbmRcIixcbiAgICBcInNldEVuZEFmdGVyXCIsXG4gICAgXCJzZXRFbmRCZWZvcmVcIixcbiAgICBcInNldEVuZFBvaW50XCIsXG4gICAgXCJzZXRFeHBpcmVzXCIsXG4gICAgXCJzZXRGaWxsQ29sb3JcIixcbiAgICBcInNldEZpbHRlclJlc1wiLFxuICAgIFwic2V0RmxvYXQxNlwiLFxuICAgIFwic2V0RmxvYXQzMlwiLFxuICAgIFwic2V0RmxvYXQ2NFwiLFxuICAgIFwic2V0RmxvYXRWYWx1ZVwiLFxuICAgIFwic2V0Rm9jdXNCZWhhdmlvclwiLFxuICAgIFwic2V0Rm9ybVZhbHVlXCIsXG4gICAgXCJzZXRGcm9tQmFzZTY0XCIsXG4gICAgXCJzZXRGcm9tSGV4XCIsXG4gICAgXCJzZXRGdWxsWWVhclwiLFxuICAgIFwic2V0SFRNTFVuc2FmZVwiLFxuICAgIFwic2V0SGVhZGVyRXh0ZW5zaW9uc1RvTmVnb3RpYXRlXCIsXG4gICAgXCJzZXRIZWFkZXJWYWx1ZVwiLFxuICAgIFwic2V0SG91cnNcIixcbiAgICBcInNldEljb25cIixcbiAgICBcInNldElkZW50aXR5UHJvdmlkZXJcIixcbiAgICBcInNldEltbWVkaWF0ZVwiLFxuICAgIFwic2V0SW5kZXhCdWZmZXJcIixcbiAgICBcInNldEludDE2XCIsXG4gICAgXCJzZXRJbnQzMlwiLFxuICAgIFwic2V0SW50OFwiLFxuICAgIFwic2V0SW50ZXJ2YWxcIixcbiAgICBcInNldEl0ZW1cIixcbiAgICBcInNldEtleWZyYW1lc1wiLFxuICAgIFwic2V0TGluZUNhcFwiLFxuICAgIFwic2V0TGluZURhc2hcIixcbiAgICBcInNldExpbmVKb2luXCIsXG4gICAgXCJzZXRMaW5lV2lkdGhcIixcbiAgICBcInNldExpdmVTZWVrYWJsZVJhbmdlXCIsXG4gICAgXCJzZXRMb2NhbERlc2NyaXB0aW9uXCIsXG4gICAgXCJzZXRNYXRyaXhcIixcbiAgICBcInNldE1hdHJpeFZhbHVlXCIsXG4gICAgXCJzZXRNZWRpYUtleXNcIixcbiAgICBcInNldE1pY3JvcGhvbmVBY3RpdmVcIixcbiAgICBcInNldE1pbGxpc2Vjb25kc1wiLFxuICAgIFwic2V0TWludXRlc1wiLFxuICAgIFwic2V0TWl0ZXJMaW1pdFwiLFxuICAgIFwic2V0TW9udGhcIixcbiAgICBcInNldE5hbWVkSXRlbVwiLFxuICAgIFwic2V0TmFtZWRJdGVtTlNcIixcbiAgICBcInNldE5vblVzZXJDb2RlRXhjZXB0aW9uc1wiLFxuICAgIFwic2V0T3JpZW50VG9BbmdsZVwiLFxuICAgIFwic2V0T3JpZW50VG9BdXRvXCIsXG4gICAgXCJzZXRPcmllbnRhdGlvblwiLFxuICAgIFwic2V0T3ZlcnJpZGVIaXN0b3J5TmF2aWdhdGlvbk1vZGVcIixcbiAgICBcInNldFBhaW50XCIsXG4gICAgXCJzZXRQYXJhbWV0ZXJcIixcbiAgICBcInNldFBhcmFtZXRlcnNcIixcbiAgICBcInNldFBlcmlvZGljV2F2ZVwiLFxuICAgIFwic2V0UGlwZWxpbmVcIixcbiAgICBcInNldFBvaW50ZXJDYXB0dXJlXCIsXG4gICAgXCJzZXRQb3B1cFwiLFxuICAgIFwic2V0UG9zaXRpb25cIixcbiAgICBcInNldFBvc2l0aW9uU3RhdGVcIixcbiAgICBcInNldFByZWZlcmVuY2VcIixcbiAgICBcInNldFByaW9yaXR5XCIsXG4gICAgXCJzZXRQcml2YXRlVG9rZW5cIixcbiAgICBcInNldFByb3BlcnR5XCIsXG4gICAgXCJzZXRQcm90b3R5cGVPZlwiLFxuICAgIFwic2V0UkdCQ29sb3JcIixcbiAgICBcInNldFJHQkNvbG9ySUNDQ29sb3JcIixcbiAgICBcInNldFJhZGl1c1wiLFxuICAgIFwic2V0UmFuZ2VUZXh0XCIsXG4gICAgXCJzZXRSZW1vdGVEZXNjcmlwdGlvblwiLFxuICAgIFwic2V0UmVwb3J0RXZlbnREYXRhRm9yQXV0b21hdGljQmVhY29uc1wiLFxuICAgIFwic2V0UmVxdWVzdEhlYWRlclwiLFxuICAgIFwic2V0UmVzaXphYmxlXCIsXG4gICAgXCJzZXRSZXNvdXJjZVRpbWluZ0J1ZmZlclNpemVcIixcbiAgICBcInNldFJvdGF0ZVwiLFxuICAgIFwic2V0U2NhbGVcIixcbiAgICBcInNldFNjaXNzb3JSZWN0XCIsXG4gICAgXCJzZXRTZWNvbmRzXCIsXG4gICAgXCJzZXRTZWxlY3Rpb25SYW5nZVwiLFxuICAgIFwic2V0U2VydmVyQ2VydGlmaWNhdGVcIixcbiAgICBcInNldFNoYWRvd1wiLFxuICAgIFwic2V0U2hhcmVkU3RvcmFnZUNvbnRleHRcIixcbiAgICBcInNldFNpZ25hbHNcIixcbiAgICBcInNldFNpbmtJZFwiLFxuICAgIFwic2V0U2tld1hcIixcbiAgICBcInNldFNrZXdZXCIsXG4gICAgXCJzZXRTdGFydFwiLFxuICAgIFwic2V0U3RhcnRBZnRlclwiLFxuICAgIFwic2V0U3RhcnRCZWZvcmVcIixcbiAgICBcInNldFN0YXR1c1wiLFxuICAgIFwic2V0U3RkRGV2aWF0aW9uXCIsXG4gICAgXCJzZXRTdGVuY2lsUmVmZXJlbmNlXCIsXG4gICAgXCJzZXRTdHJlYW1zXCIsXG4gICAgXCJzZXRTdHJpY3RNb2RlXCIsXG4gICAgXCJzZXRTdHJpbmdWYWx1ZVwiLFxuICAgIFwic2V0U3Ryb2tlQ29sb3JcIixcbiAgICBcInNldFN1Z2dlc3RSZXN1bHRcIixcbiAgICBcInNldFRhcmdldEF0VGltZVwiLFxuICAgIFwic2V0VGFyZ2V0VmFsdWVBdFRpbWVcIixcbiAgICBcInNldFRpbWVcIixcbiAgICBcInNldFRpbWVvdXRcIixcbiAgICBcInNldFRpdGxlXCIsXG4gICAgXCJzZXRUcmFuc2Zvcm1cIixcbiAgICBcInNldFRyYW5zbGF0ZVwiLFxuICAgIFwic2V0VVRDRGF0ZVwiLFxuICAgIFwic2V0VVRDRnVsbFllYXJcIixcbiAgICBcInNldFVUQ0hvdXJzXCIsXG4gICAgXCJzZXRVVENNaWxsaXNlY29uZHNcIixcbiAgICBcInNldFVUQ01pbnV0ZXNcIixcbiAgICBcInNldFVUQ01vbnRoXCIsXG4gICAgXCJzZXRVVENTZWNvbmRzXCIsXG4gICAgXCJzZXRVaW50MTZcIixcbiAgICBcInNldFVpbnQzMlwiLFxuICAgIFwic2V0VWludDhcIixcbiAgICBcInNldFVuaW5zdGFsbFVSTFwiLFxuICAgIFwic2V0VXBkYXRlVXJsRGF0YVwiLFxuICAgIFwic2V0VXJpXCIsXG4gICAgXCJzZXRWYWxpZGl0eVwiLFxuICAgIFwic2V0VmFsdWVBdFRpbWVcIixcbiAgICBcInNldFZhbHVlQ3VydmVBdFRpbWVcIixcbiAgICBcInNldFZhcmlhYmxlXCIsXG4gICAgXCJzZXRWZWxvY2l0eVwiLFxuICAgIFwic2V0VmVyc2lvblwiLFxuICAgIFwic2V0VmVydGV4QnVmZmVyXCIsXG4gICAgXCJzZXRWaWV3cG9ydFwiLFxuICAgIFwic2V0WWVhclwiLFxuICAgIFwic2V0Wm9vbVwiLFxuICAgIFwic2V0Wm9vbVNldHRpbmdzXCIsXG4gICAgXCJzZXR0aW5nTmFtZVwiLFxuICAgIFwic2V0dGluZ1ZhbHVlXCIsXG4gICAgXCJzZXhcIixcbiAgICBcInNoYWRlckxvY2F0aW9uXCIsXG4gICAgXCJzaGFkZXJTb3VyY2VcIixcbiAgICBcInNoYWRvd0JsdXJcIixcbiAgICBcInNoYWRvd0NvbG9yXCIsXG4gICAgXCJzaGFkb3dPZmZzZXRYXCIsXG4gICAgXCJzaGFkb3dPZmZzZXRZXCIsXG4gICAgXCJzaGFkb3dSb290XCIsXG4gICAgXCJzaGFkb3dSb290Q2xvbmFibGVcIixcbiAgICBcInNoYWRvd1Jvb3REZWxlZ2F0ZXNGb2N1c1wiLFxuICAgIFwic2hhZG93Um9vdE1vZGVcIixcbiAgICBcInNoYWRvd1Jvb3RTZXJpYWxpemFibGVcIixcbiAgICBcInNoYXBlXCIsXG4gICAgXCJzaGFwZS1pbWFnZS10aHJlc2hvbGRcIixcbiAgICBcInNoYXBlLW1hcmdpblwiLFxuICAgIFwic2hhcGUtb3V0c2lkZVwiLFxuICAgIFwic2hhcGUtcmVuZGVyaW5nXCIsXG4gICAgXCJzaGFwZUltYWdlVGhyZXNob2xkXCIsXG4gICAgXCJzaGFwZU1hcmdpblwiLFxuICAgIFwic2hhcGVPdXRzaWRlXCIsXG4gICAgXCJzaGFwZVJlbmRlcmluZ1wiLFxuICAgIFwic2hhcmVcIixcbiAgICBcInNoYXJlZFN0b3JhZ2VcIixcbiAgICBcInNoYXJlZFN0b3JhZ2VXcml0YWJsZVwiLFxuICAgIFwic2hlZXRcIixcbiAgICBcInNoaWZ0XCIsXG4gICAgXCJzaGlmdEtleVwiLFxuICAgIFwic2hpZnRMZWZ0XCIsXG4gICAgXCJzaGlwcGluZ0FkZHJlc3NcIixcbiAgICBcInNoaXBwaW5nT3B0aW9uXCIsXG4gICAgXCJzaGlwcGluZ1R5cGVcIixcbiAgICBcInNob3dcIixcbiAgICBcInNob3dEaXJlY3RvcnlQaWNrZXJcIixcbiAgICBcInNob3dIZWxwXCIsXG4gICAgXCJzaG93TW9kYWxcIixcbiAgICBcInNob3dNb2RhbERpYWxvZ1wiLFxuICAgIFwic2hvd01vZGVsZXNzRGlhbG9nXCIsXG4gICAgXCJzaG93Tm90aWZpY2F0aW9uXCIsXG4gICAgXCJzaG93T3BlbkZpbGVQaWNrZXJcIixcbiAgICBcInNob3dQaWNrZXJcIixcbiAgICBcInNob3dQb3BvdmVyXCIsXG4gICAgXCJzaG93U2F2ZUZpbGVQaWNrZXJcIixcbiAgICBcInNpZGViYXJcIixcbiAgICBcInNpZGViYXJBY3Rpb25cIixcbiAgICBcInNpZ25cIixcbiAgICBcInNpZ25hbFwiLFxuICAgIFwic2lnbmFsaW5nU3RhdGVcIixcbiAgICBcInNpZ25hdHVyZVwiLFxuICAgIFwic2lsZW50XCIsXG4gICAgXCJzaW5cIixcbiAgICBcInNpbmdsZU5vZGVWYWx1ZVwiLFxuICAgIFwic2luaFwiLFxuICAgIFwic2lua0lkXCIsXG4gICAgXCJzaXR0aW5nVG9TdGFuZGluZ1RyYW5zZm9ybVwiLFxuICAgIFwic2l6ZVwiLFxuICAgIFwic2l6ZUFkanVzdFwiLFxuICAgIFwic2l6ZVRvQ29udGVudFwiLFxuICAgIFwic2l6ZVhcIixcbiAgICBcInNpemVaXCIsXG4gICAgXCJzaXplc1wiLFxuICAgIFwic2tld1hcIixcbiAgICBcInNrZXdYU2VsZlwiLFxuICAgIFwic2tld1lcIixcbiAgICBcInNrZXdZU2VsZlwiLFxuICAgIFwic2tpcFRyYW5zaXRpb25cIixcbiAgICBcInNraXBwZWRcIixcbiAgICBcInNsaWNlXCIsXG4gICAgXCJzbG9wZVwiLFxuICAgIFwic2xvdFwiLFxuICAgIFwic2xvdEFzc2lnbm1lbnRcIixcbiAgICBcInNtYWxsXCIsXG4gICAgXCJzbWlsXCIsXG4gICAgXCJzbW9vdGhcIixcbiAgICBcInNtb290aGluZ1RpbWVDb25zdGFudFwiLFxuICAgIFwic25hcFRhcmdldEJsb2NrXCIsXG4gICAgXCJzbmFwVGFyZ2V0SW5saW5lXCIsXG4gICAgXCJzbmFwVG9MaW5lc1wiLFxuICAgIFwic25hcHNob3RJdGVtXCIsXG4gICAgXCJzbmFwc2hvdExlbmd0aFwiLFxuICAgIFwic29tZVwiLFxuICAgIFwic29ydFwiLFxuICAgIFwic29ydGluZ0NvZGVcIixcbiAgICBcInNvdXJjZVwiLFxuICAgIFwic291cmNlQnVmZmVyXCIsXG4gICAgXCJzb3VyY2VCdWZmZXJzXCIsXG4gICAgXCJzb3VyY2VDYXBhYmlsaXRpZXNcIixcbiAgICBcInNvdXJjZUNoYXJQb3NpdGlvblwiLFxuICAgIFwic291cmNlRmlsZVwiLFxuICAgIFwic291cmNlRnVuY3Rpb25OYW1lXCIsXG4gICAgXCJzb3VyY2VJbmRleFwiLFxuICAgIFwic291cmNlTWFwXCIsXG4gICAgXCJzb3VyY2VVUkxcIixcbiAgICBcInNvdXJjZXNcIixcbiAgICBcInNwYWNpbmdcIixcbiAgICBcInNwYW5cIixcbiAgICBcInNwZWFrXCIsXG4gICAgXCJzcGVha0FzXCIsXG4gICAgXCJzcGVha2luZ1wiLFxuICAgIFwic3BlY2llc1wiLFxuICAgIFwic3BlY2lmaWVkXCIsXG4gICAgXCJzcGVjdWxhckNvbnN0YW50XCIsXG4gICAgXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgXCJzcGVlY2hTeW50aGVzaXNcIixcbiAgICBcInNwZWVkXCIsXG4gICAgXCJzcGVlZE9mU291bmRcIixcbiAgICBcInNwZWxsY2hlY2tcIixcbiAgICBcInNwaGVyaWNhbEhhcm1vbmljc0NvZWZmaWNpZW50c1wiLFxuICAgIFwic3BsaWNlXCIsXG4gICAgXCJzcGxpdFwiLFxuICAgIFwic3BsaXRUZXh0XCIsXG4gICAgXCJzcHJlYWRNZXRob2RcIixcbiAgICBcInNxcnRcIixcbiAgICBcInNyY1wiLFxuICAgIFwic3JjRWxlbWVudFwiLFxuICAgIFwic3JjRmFjdG9yXCIsXG4gICAgXCJzcmNGaWx0ZXJcIixcbiAgICBcInNyY09iamVjdFwiLFxuICAgIFwic3JjVXJuXCIsXG4gICAgXCJzcmNkb2NcIixcbiAgICBcInNyY2xhbmdcIixcbiAgICBcInNyY3NldFwiLFxuICAgIFwic3RhY2tcIixcbiAgICBcInN0YWNrVHJhY2VMaW1pdFwiLFxuICAgIFwic3RhY2t0cmFjZVwiLFxuICAgIFwic3RhZ2VQYXJhbWV0ZXJzXCIsXG4gICAgXCJzdGFuZGFsb25lXCIsXG4gICAgXCJzdGFuZGJ5XCIsXG4gICAgXCJzdGFydFwiLFxuICAgIFwic3RhcnRDb250YWluZXJcIixcbiAgICBcInN0YXJ0RVwiLFxuICAgIFwic3RhcnRJY2VcIixcbiAgICBcInN0YXJ0TG9hZFRpbWVcIixcbiAgICBcInN0YXJ0TWVzc2FnZXNcIixcbiAgICBcInN0YXJ0Tm90aWZpY2F0aW9uc1wiLFxuICAgIFwic3RhcnRPZmZzZXRcIixcbiAgICBcInN0YXJ0UHJvZmlsaW5nXCIsXG4gICAgXCJzdGFydFJlbmRlcmluZ1wiLFxuICAgIFwic3RhcnRTaGFya1wiLFxuICAgIFwic3RhcnRUaW1lXCIsXG4gICAgXCJzdGFydFZpZXdUcmFuc2l0aW9uXCIsXG4gICAgXCJzdGFydHNXaXRoXCIsXG4gICAgXCJzdGF0ZVwiLFxuICAgIFwic3RhdGVzXCIsXG4gICAgXCJzdGF0c1wiLFxuICAgIFwic3RhdHVzXCIsXG4gICAgXCJzdGF0dXNDb2RlXCIsXG4gICAgXCJzdGF0dXNNZXNzYWdlXCIsXG4gICAgXCJzdGF0dXNUZXh0XCIsXG4gICAgXCJzdGF0dXNiYXJcIixcbiAgICBcInN0ZERldmlhdGlvblhcIixcbiAgICBcInN0ZERldmlhdGlvbllcIixcbiAgICBcInN0ZW5jaWxCYWNrXCIsXG4gICAgXCJzdGVuY2lsQ2xlYXJWYWx1ZVwiLFxuICAgIFwic3RlbmNpbEZyb250XCIsXG4gICAgXCJzdGVuY2lsRnVuY1wiLFxuICAgIFwic3RlbmNpbEZ1bmNTZXBhcmF0ZVwiLFxuICAgIFwic3RlbmNpbExvYWRPcFwiLFxuICAgIFwic3RlbmNpbE1hc2tcIixcbiAgICBcInN0ZW5jaWxNYXNrU2VwYXJhdGVcIixcbiAgICBcInN0ZW5jaWxPcFwiLFxuICAgIFwic3RlbmNpbE9wU2VwYXJhdGVcIixcbiAgICBcInN0ZW5jaWxSZWFkTWFza1wiLFxuICAgIFwic3RlbmNpbFJlYWRPbmx5XCIsXG4gICAgXCJzdGVuY2lsU3RvcmVPcFwiLFxuICAgIFwic3RlbmNpbFdyaXRlTWFza1wiLFxuICAgIFwic3RlcFwiLFxuICAgIFwic3RlcERvd25cIixcbiAgICBcInN0ZXBNaXNtYXRjaFwiLFxuICAgIFwic3RlcE1vZGVcIixcbiAgICBcInN0ZXBVcFwiLFxuICAgIFwic3RpY2t5XCIsXG4gICAgXCJzdGl0Y2hUaWxlc1wiLFxuICAgIFwic3RvcFwiLFxuICAgIFwic3RvcC1jb2xvclwiLFxuICAgIFwic3RvcC1vcGFjaXR5XCIsXG4gICAgXCJzdG9wQ29sb3JcIixcbiAgICBcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLFxuICAgIFwic3RvcE5vdGlmaWNhdGlvbnNcIixcbiAgICBcInN0b3BPcGFjaXR5XCIsXG4gICAgXCJzdG9wUHJvZmlsaW5nXCIsXG4gICAgXCJzdG9wUHJvcGFnYXRpb25cIixcbiAgICBcInN0b3BTaGFya1wiLFxuICAgIFwic3RvcHBlZFwiLFxuICAgIFwic3RvcmFnZVwiLFxuICAgIFwic3RvcmFnZUFyZWFcIixcbiAgICBcInN0b3JhZ2VCdWNrZXRzXCIsXG4gICAgXCJzdG9yYWdlTmFtZVwiLFxuICAgIFwic3RvcmFnZVN0YXR1c1wiLFxuICAgIFwic3RvcmFnZVRleHR1cmVcIixcbiAgICBcInN0b3JlXCIsXG4gICAgXCJzdG9yZU9wXCIsXG4gICAgXCJzdG9yZVNpdGVTcGVjaWZpY1RyYWNraW5nRXhjZXB0aW9uXCIsXG4gICAgXCJzdG9yZVdlYldpZGVUcmFja2luZ0V4Y2VwdGlvblwiLFxuICAgIFwic3RwVmVyc2lvblwiLFxuICAgIFwic3RyZWFtXCIsXG4gICAgXCJzdHJlYW1FcnJvckNvZGVcIixcbiAgICBcInN0cmVhbXNcIixcbiAgICBcInN0cmV0Y2hcIixcbiAgICBcInN0cmlrZVwiLFxuICAgIFwic3RyaW5nXCIsXG4gICAgXCJzdHJpbmdWYWx1ZVwiLFxuICAgIFwic3RyaW5naWZ5XCIsXG4gICAgXCJzdHJpcEluZGV4Rm9ybWF0XCIsXG4gICAgXCJzdHJva2VcIixcbiAgICBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgICBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gICAgXCJzdHJva2UtbGluZWNhcFwiLFxuICAgIFwic3Ryb2tlLWxpbmVqb2luXCIsXG4gICAgXCJzdHJva2UtbWl0ZXJsaW1pdFwiLFxuICAgIFwic3Ryb2tlLW9wYWNpdHlcIixcbiAgICBcInN0cm9rZS13aWR0aFwiLFxuICAgIFwic3Ryb2tlRGFzaGFycmF5XCIsXG4gICAgXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgXCJzdHJva2VMaW5lY2FwXCIsXG4gICAgXCJzdHJva2VMaW5lam9pblwiLFxuICAgIFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgIFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgIFwic3Ryb2tlUmVjdFwiLFxuICAgIFwic3Ryb2tlU3R5bGVcIixcbiAgICBcInN0cm9rZVRleHRcIixcbiAgICBcInN0cm9rZVdpZHRoXCIsXG4gICAgXCJzdHJ1Y3R1cmVkQ2xvbmVcIixcbiAgICBcInN0eWxlXCIsXG4gICAgXCJzdHlsZUFuZExheW91dFN0YXJ0XCIsXG4gICAgXCJzdHlsZUZsb2F0XCIsXG4gICAgXCJzdHlsZU1hcFwiLFxuICAgIFwic3R5bGVNZWRpYVwiLFxuICAgIFwic3R5bGVTaGVldFwiLFxuICAgIFwic3R5bGVTaGVldFNldHNcIixcbiAgICBcInN0eWxlU2hlZXRzXCIsXG4gICAgXCJzdWJcIixcbiAgICBcInN1YmFycmF5XCIsXG4gICAgXCJzdWJqZWN0XCIsXG4gICAgXCJzdWJtaXRcIixcbiAgICBcInN1Ym1pdEZyYW1lXCIsXG4gICAgXCJzdWJtaXR0ZXJcIixcbiAgICBcInN1YnNjcmliZVwiLFxuICAgIFwic3Vic3RyXCIsXG4gICAgXCJzdWJzdHJpbmdcIixcbiAgICBcInN1YnN0cmluZ0RhdGFcIixcbiAgICBcInN1YnRsZVwiLFxuICAgIFwic3VidHJlZVwiLFxuICAgIFwic3VmZml4XCIsXG4gICAgXCJzdWZmaXhlc1wiLFxuICAgIFwic3VtbWFyeVwiLFxuICAgIFwic3VwXCIsXG4gICAgXCJzdXBwb3J0ZWRcIixcbiAgICBcInN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3NcIixcbiAgICBcInN1cHBvcnRlZEVudHJ5VHlwZXNcIixcbiAgICBcInN1cHBvcnRlZFZhbHVlc09mXCIsXG4gICAgXCJzdXBwb3J0c1wiLFxuICAgIFwic3VwcG9ydHNGaWJlclwiLFxuICAgIFwic3VwcG9ydHNTZXNzaW9uXCIsXG4gICAgXCJzdXBwb3J0c1RleHRcIixcbiAgICBcInN1cmZhY2VTY2FsZVwiLFxuICAgIFwic3Vycm91bmRDb250ZW50c1wiLFxuICAgIFwic3VzcGVuZFwiLFxuICAgIFwic3VzcGVuZFJlZHJhd1wiLFxuICAgIFwic3ZiXCIsXG4gICAgXCJzdmhcIixcbiAgICBcInN2aVwiLFxuICAgIFwic3ZtYXhcIixcbiAgICBcInN2bWluXCIsXG4gICAgXCJzdndcIixcbiAgICBcInN3YXBDYWNoZVwiLFxuICAgIFwic3dhcE5vZGVcIixcbiAgICBcInN3ZWVwRmxhZ1wiLFxuICAgIFwic3ltYm9sc1wiLFxuICAgIFwic3ltbWV0cmljRGlmZmVyZW5jZVwiLFxuICAgIFwic3luY1wiLFxuICAgIFwic3ludGF4XCIsXG4gICAgXCJzeXNleEVuYWJsZWRcIixcbiAgICBcInN5c3RlbVwiLFxuICAgIFwic3lzdGVtQ29kZVwiLFxuICAgIFwic3lzdGVtSWRcIixcbiAgICBcInN5c3RlbUxhbmd1YWdlXCIsXG4gICAgXCJzeXN0ZW1YRFBJXCIsXG4gICAgXCJzeXN0ZW1ZRFBJXCIsXG4gICAgXCJ0Qm9kaWVzXCIsXG4gICAgXCJ0Rm9vdFwiLFxuICAgIFwidEhlYWRcIixcbiAgICBcInRhYlwiLFxuICAgIFwidGFiLXNpemVcIixcbiAgICBcInRhYklkXCIsXG4gICAgXCJ0YWJJZHNcIixcbiAgICBcInRhYkluZGV4XCIsXG4gICAgXCJ0YWJTaXplXCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwidGFibGUtbGF5b3V0XCIsXG4gICAgXCJ0YWJsZUxheW91dFwiLFxuICAgIFwidGFibGVWYWx1ZXNcIixcbiAgICBcInRhYnNcIixcbiAgICBcInRhZ1wiLFxuICAgIFwidGFnTmFtZVwiLFxuICAgIFwidGFnVXJuXCIsXG4gICAgXCJ0YWdzXCIsXG4gICAgXCJ0YWludEVuYWJsZWRcIixcbiAgICBcInRha2VcIixcbiAgICBcInRha2VQaG90b1wiLFxuICAgIFwidGFrZVJlY29yZHNcIixcbiAgICBcInRhblwiLFxuICAgIFwidGFuZ2VudGlhbFByZXNzdXJlXCIsXG4gICAgXCJ0YW5oXCIsXG4gICAgXCJ0YXJnZXRcIixcbiAgICBcInRhcmdldEFkZHJlc3NTcGFjZVwiLFxuICAgIFwidGFyZ2V0RWxlbWVudFwiLFxuICAgIFwidGFyZ2V0UmF5TW9kZVwiLFxuICAgIFwidGFyZ2V0UmF5U3BhY2VcIixcbiAgICBcInRhcmdldFRvdWNoZXNcIixcbiAgICBcInRhcmdldFVSTFwiLFxuICAgIFwidGFyZ2V0WFwiLFxuICAgIFwidGFyZ2V0WVwiLFxuICAgIFwidGFyZ2V0c1wiLFxuICAgIFwidGNwVHlwZVwiLFxuICAgIFwidGVlXCIsXG4gICAgXCJ0ZWxcIixcbiAgICBcInRlbGVtZXRyeVwiLFxuICAgIFwidGVybWluYXRlXCIsXG4gICAgXCJ0ZXN0XCIsXG4gICAgXCJ0ZXhJbWFnZTJEXCIsXG4gICAgXCJ0ZXhJbWFnZTNEXCIsXG4gICAgXCJ0ZXhQYXJhbWV0ZXJmXCIsXG4gICAgXCJ0ZXhQYXJhbWV0ZXJpXCIsXG4gICAgXCJ0ZXhTdG9yYWdlMkRcIixcbiAgICBcInRleFN0b3JhZ2UzRFwiLFxuICAgIFwidGV4U3ViSW1hZ2UyRFwiLFxuICAgIFwidGV4U3ViSW1hZ2UzRFwiLFxuICAgIFwidGV4dFwiLFxuICAgIFwidGV4dC1hbGlnblwiLFxuICAgIFwidGV4dC1hbGlnbi1sYXN0XCIsXG4gICAgXCJ0ZXh0LWFuY2hvclwiLFxuICAgIFwidGV4dC1jb21iaW5lLXVwcmlnaHRcIixcbiAgICBcInRleHQtZGVjb3JhdGlvblwiLFxuICAgIFwidGV4dC1kZWNvcmF0aW9uLWNvbG9yXCIsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb24tbGluZVwiLFxuICAgIFwidGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rXCIsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb24tc3R5bGVcIixcbiAgICBcInRleHQtZGVjb3JhdGlvbi10aGlja25lc3NcIixcbiAgICBcInRleHQtZW1waGFzaXNcIixcbiAgICBcInRleHQtZW1waGFzaXMtY29sb3JcIixcbiAgICBcInRleHQtZW1waGFzaXMtcG9zaXRpb25cIixcbiAgICBcInRleHQtZW1waGFzaXMtc3R5bGVcIixcbiAgICBcInRleHQtaW5kZW50XCIsXG4gICAgXCJ0ZXh0LWp1c3RpZnlcIixcbiAgICBcInRleHQtb3JpZW50YXRpb25cIixcbiAgICBcInRleHQtb3ZlcmZsb3dcIixcbiAgICBcInRleHQtcmVuZGVyaW5nXCIsXG4gICAgXCJ0ZXh0LXNoYWRvd1wiLFxuICAgIFwidGV4dC10cmFuc2Zvcm1cIixcbiAgICBcInRleHQtdW5kZXJsaW5lLW9mZnNldFwiLFxuICAgIFwidGV4dC11bmRlcmxpbmUtcG9zaXRpb25cIixcbiAgICBcInRleHQtd3JhcFwiLFxuICAgIFwidGV4dC13cmFwLW1vZGVcIixcbiAgICBcInRleHQtd3JhcC1zdHlsZVwiLFxuICAgIFwidGV4dEFsaWduXCIsXG4gICAgXCJ0ZXh0QWxpZ25MYXN0XCIsXG4gICAgXCJ0ZXh0QW5jaG9yXCIsXG4gICAgXCJ0ZXh0QXV0b3NwYWNlXCIsXG4gICAgXCJ0ZXh0QmFzZWxpbmVcIixcbiAgICBcInRleHRDb21iaW5lVXByaWdodFwiLFxuICAgIFwidGV4dENvbnRlbnRcIixcbiAgICBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgXCJ0ZXh0RGVjb3JhdGlvbkJsaW5rXCIsXG4gICAgXCJ0ZXh0RGVjb3JhdGlvbkNvbG9yXCIsXG4gICAgXCJ0ZXh0RGVjb3JhdGlvbkxpbmVcIixcbiAgICBcInRleHREZWNvcmF0aW9uTGluZVRocm91Z2hcIixcbiAgICBcInRleHREZWNvcmF0aW9uTm9uZVwiLFxuICAgIFwidGV4dERlY29yYXRpb25PdmVybGluZVwiLFxuICAgIFwidGV4dERlY29yYXRpb25Ta2lwSW5rXCIsXG4gICAgXCJ0ZXh0RGVjb3JhdGlvblN0eWxlXCIsXG4gICAgXCJ0ZXh0RGVjb3JhdGlvblRoaWNrbmVzc1wiLFxuICAgIFwidGV4dERlY29yYXRpb25VbmRlcmxpbmVcIixcbiAgICBcInRleHRFbXBoYXNpc1wiLFxuICAgIFwidGV4dEVtcGhhc2lzQ29sb3JcIixcbiAgICBcInRleHRFbXBoYXNpc1Bvc2l0aW9uXCIsXG4gICAgXCJ0ZXh0RW1waGFzaXNTdHlsZVwiLFxuICAgIFwidGV4dEluZGVudFwiLFxuICAgIFwidGV4dEp1c3RpZnlcIixcbiAgICBcInRleHRKdXN0aWZ5VHJpbVwiLFxuICAgIFwidGV4dEthc2hpZGFcIixcbiAgICBcInRleHRLYXNoaWRhU3BhY2VcIixcbiAgICBcInRleHRMZW5ndGhcIixcbiAgICBcInRleHRPcmllbnRhdGlvblwiLFxuICAgIFwidGV4dE92ZXJmbG93XCIsXG4gICAgXCJ0ZXh0UmVuZGVyaW5nXCIsXG4gICAgXCJ0ZXh0U2hhZG93XCIsXG4gICAgXCJ0ZXh0VHJhY2tzXCIsXG4gICAgXCJ0ZXh0VHJhbnNmb3JtXCIsXG4gICAgXCJ0ZXh0VW5kZXJsaW5lT2Zmc2V0XCIsXG4gICAgXCJ0ZXh0VW5kZXJsaW5lUG9zaXRpb25cIixcbiAgICBcInRleHRXcmFwXCIsXG4gICAgXCJ0ZXh0V3JhcE1vZGVcIixcbiAgICBcInRleHRXcmFwU3R5bGVcIixcbiAgICBcInRleHR1cmVcIixcbiAgICBcInRoZW1lXCIsXG4gICAgXCJ0aGVuXCIsXG4gICAgXCJ0aHJlYWRJZFwiLFxuICAgIFwidGhyZXNob2xkXCIsXG4gICAgXCJ0aHJlc2hvbGRzXCIsXG4gICAgXCJ0aHJvd0lmQWJvcnRlZFwiLFxuICAgIFwidGlsdFhcIixcbiAgICBcInRpbHRZXCIsXG4gICAgXCJ0aW1lXCIsXG4gICAgXCJ0aW1lRW5kXCIsXG4gICAgXCJ0aW1lTG9nXCIsXG4gICAgXCJ0aW1lT3JpZ2luXCIsXG4gICAgXCJ0aW1lUmVtYWluaW5nXCIsXG4gICAgXCJ0aW1lU3RhbXBcIixcbiAgICBcInRpbWVjb2RlXCIsXG4gICAgXCJ0aW1lbGluZVwiLFxuICAgIFwidGltZWxpbmVUaW1lXCIsXG4gICAgXCJ0aW1lb3V0XCIsXG4gICAgXCJ0aW1lc3RhbXBcIixcbiAgICBcInRpbWVzdGFtcE9mZnNldFwiLFxuICAgIFwidGltZXN0YW1wV3JpdGVzXCIsXG4gICAgXCJ0aW1pbmdcIixcbiAgICBcInRpdGxlXCIsXG4gICAgXCJ0aXRsZWJhckFyZWFSZWN0XCIsXG4gICAgXCJ0bHNDaGFubmVsSWRcIixcbiAgICBcInRvXCIsXG4gICAgXCJ0b0FycmF5XCIsXG4gICAgXCJ0b0Jhc2U2NFwiLFxuICAgIFwidG9CbG9iXCIsXG4gICAgXCJ0b0RhdGFVUkxcIixcbiAgICBcInRvRGF0ZVN0cmluZ1wiLFxuICAgIFwidG9FbGVtZW50XCIsXG4gICAgXCJ0b0V4cG9uZW50aWFsXCIsXG4gICAgXCJ0b0ZpeGVkXCIsXG4gICAgXCJ0b0Zsb2F0MzJBcnJheVwiLFxuICAgIFwidG9GbG9hdDY0QXJyYXlcIixcbiAgICBcInRvR01UU3RyaW5nXCIsXG4gICAgXCJ0b0hleFwiLFxuICAgIFwidG9JU09TdHJpbmdcIixcbiAgICBcInRvSlNPTlwiLFxuICAgIFwidG9Mb2NhbGVEYXRlU3RyaW5nXCIsXG4gICAgXCJ0b0xvY2FsZUZvcm1hdFwiLFxuICAgIFwidG9Mb2NhbGVMb3dlckNhc2VcIixcbiAgICBcInRvTG9jYWxlU3RyaW5nXCIsXG4gICAgXCJ0b0xvY2FsZVRpbWVTdHJpbmdcIixcbiAgICBcInRvTG9jYWxlVXBwZXJDYXNlXCIsXG4gICAgXCJ0b0xvd2VyQ2FzZVwiLFxuICAgIFwidG9NYXRyaXhcIixcbiAgICBcInRvTWV0aG9kXCIsXG4gICAgXCJ0b1ByZWNpc2lvblwiLFxuICAgIFwidG9QcmltaXRpdmVcIixcbiAgICBcInRvUmV2ZXJzZWRcIixcbiAgICBcInRvU2RwXCIsXG4gICAgXCJ0b1NvcnRlZFwiLFxuICAgIFwidG9Tb3VyY2VcIixcbiAgICBcInRvU3BsaWNlZFwiLFxuICAgIFwidG9TdGF0aWNIVE1MXCIsXG4gICAgXCJ0b1N0cmluZ1wiLFxuICAgIFwidG9TdHJpbmdUYWdcIixcbiAgICBcInRvU3VtXCIsXG4gICAgXCJ0b1RpbWVTdHJpbmdcIixcbiAgICBcInRvVVRDU3RyaW5nXCIsXG4gICAgXCJ0b1VwcGVyQ2FzZVwiLFxuICAgIFwidG9XZWxsRm9ybWVkXCIsXG4gICAgXCJ0b2dnbGVcIixcbiAgICBcInRvZ2dsZUF0dHJpYnV0ZVwiLFxuICAgIFwidG9nZ2xlTG9uZ1ByZXNzRW5hYmxlZFwiLFxuICAgIFwidG9nZ2xlUG9wb3ZlclwiLFxuICAgIFwidG9nZ2xlUmVhZGVyTW9kZVwiLFxuICAgIFwidG9rZW5cIixcbiAgICBcInRvbmVcIixcbiAgICBcInRvbmVCdWZmZXJcIixcbiAgICBcInRvb0xvbmdcIixcbiAgICBcInRvb1Nob3J0XCIsXG4gICAgXCJ0b29sYmFyXCIsXG4gICAgXCJ0b3BcIixcbiAgICBcInRvcE1hcmdpblwiLFxuICAgIFwidG9wU2l0ZXNcIixcbiAgICBcInRvcG9sb2d5XCIsXG4gICAgXCJ0b3RhbFwiLFxuICAgIFwidG90YWxGcmFtZURlbGF5XCIsXG4gICAgXCJ0b3RhbEZyYW1lc1wiLFxuICAgIFwidG90YWxGcmFtZXNEdXJhdGlvblwiLFxuICAgIFwidG90YWxWaWRlb0ZyYW1lc1wiLFxuICAgIFwidG91Y2gtYWN0aW9uXCIsXG4gICAgXCJ0b3VjaEFjdGlvblwiLFxuICAgIFwidG91Y2hlZFwiLFxuICAgIFwidG91Y2hlc1wiLFxuICAgIFwidHJhY2VcIixcbiAgICBcInRyYWNrXCIsXG4gICAgXCJ0cmFja1Zpc2liaWxpdHlcIixcbiAgICBcInRyYWNrZWRBbmNob3JzXCIsXG4gICAgXCJ0cmFja3NcIixcbiAgICBcInRyYW5cIixcbiAgICBcInRyYW5zYWN0aW9uXCIsXG4gICAgXCJ0cmFuc2FjdGlvbnNcIixcbiAgICBcInRyYW5zY2VpdmVyXCIsXG4gICAgXCJ0cmFuc2ZlclwiLFxuICAgIFwidHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW5cIixcbiAgICBcInRyYW5zZmVyRnJvbUltYWdlQml0bWFwXCIsXG4gICAgXCJ0cmFuc2ZlckltYWdlQml0bWFwXCIsXG4gICAgXCJ0cmFuc2ZlckluXCIsXG4gICAgXCJ0cmFuc2Zlck91dFwiLFxuICAgIFwidHJhbnNmZXJTaXplXCIsXG4gICAgXCJ0cmFuc2ZlclRvRml4ZWRMZW5ndGhcIixcbiAgICBcInRyYW5zZmVyVG9JbWFnZUJpdG1hcFwiLFxuICAgIFwidHJhbnNmb3JtXCIsXG4gICAgXCJ0cmFuc2Zvcm0tYm94XCIsXG4gICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCIsXG4gICAgXCJ0cmFuc2Zvcm0tc3R5bGVcIixcbiAgICBcInRyYW5zZm9ybUJveFwiLFxuICAgIFwidHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nc1wiLFxuICAgIFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgXCJ0cmFuc2Zvcm1Qb2ludFwiLFxuICAgIFwidHJhbnNmb3JtU3RyaW5nXCIsXG4gICAgXCJ0cmFuc2Zvcm1TdHlsZVwiLFxuICAgIFwidHJhbnNmb3JtVG9Eb2N1bWVudFwiLFxuICAgIFwidHJhbnNmb3JtVG9GcmFnbWVudFwiLFxuICAgIFwidHJhbnNpdGlvblwiLFxuICAgIFwidHJhbnNpdGlvbi1iZWhhdmlvclwiLFxuICAgIFwidHJhbnNpdGlvbi1kZWxheVwiLFxuICAgIFwidHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwidHJhbnNpdGlvbi1wcm9wZXJ0eVwiLFxuICAgIFwidHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cIixcbiAgICBcInRyYW5zaXRpb25CZWhhdmlvclwiLFxuICAgIFwidHJhbnNpdGlvbkRlbGF5XCIsXG4gICAgXCJ0cmFuc2l0aW9uRHVyYXRpb25cIixcbiAgICBcInRyYW5zaXRpb25Qcm9wZXJ0eVwiLFxuICAgIFwidHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gICAgXCJ0cmFuc2xhdGVcIixcbiAgICBcInRyYW5zbGF0ZVNlbGZcIixcbiAgICBcInRyYW5zbGF0aW9uWFwiLFxuICAgIFwidHJhbnNsYXRpb25ZXCIsXG4gICAgXCJ0cmFuc3BvcnRcIixcbiAgICBcInRyYXZlcnNlVG9cIixcbiAgICBcInRyaW1cIixcbiAgICBcInRyaW1FbmRcIixcbiAgICBcInRyaW1MZWZ0XCIsXG4gICAgXCJ0cmltUmlnaHRcIixcbiAgICBcInRyaW1TdGFydFwiLFxuICAgIFwidHJ1ZVNwZWVkXCIsXG4gICAgXCJ0cnVuY1wiLFxuICAgIFwidHJ1bmNhdGVcIixcbiAgICBcInRydXN0ZWRUeXBlc1wiLFxuICAgIFwidHJ5XCIsXG4gICAgXCJ0dXJuXCIsXG4gICAgXCJ0d2lzdFwiLFxuICAgIFwidHlwZVwiLFxuICAgIFwidHlwZURldGFpbFwiLFxuICAgIFwidHlwZU1pc21hdGNoXCIsXG4gICAgXCJ0eXBlTXVzdE1hdGNoXCIsXG4gICAgXCJ0eXBlc1wiLFxuICAgIFwidTJmXCIsXG4gICAgXCJ1Ym91bmRcIixcbiAgICBcInVpbnQxNlwiLFxuICAgIFwidWludDMyXCIsXG4gICAgXCJ1aW50OFwiLFxuICAgIFwidWludDhDbGFtcGVkXCIsXG4gICAgXCJ1bmFkanVzdGVkTW92ZW1lbnRcIixcbiAgICBcInVuY2xpcHBlZERlcHRoXCIsXG4gICAgXCJ1bmNvbmZpZ3VyZVwiLFxuICAgIFwidW5kZWZpbmVkXCIsXG4gICAgXCJ1bmRlcmxpbmVTdHlsZVwiLFxuICAgIFwidW5kZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgXCJ1bmVzY2FwZVwiLFxuICAgIFwidW5ldmFsXCIsXG4gICAgXCJ1bmdyb3VwXCIsXG4gICAgXCJ1bmljb2RlXCIsXG4gICAgXCJ1bmljb2RlLWJpZGlcIixcbiAgICBcInVuaWNvZGVCaWRpXCIsXG4gICAgXCJ1bmljb2RlUmFuZ2VcIixcbiAgICBcInVuaWNvZGVTZXRzXCIsXG4gICAgXCJ1bmlmb3JtMWZcIixcbiAgICBcInVuaWZvcm0xZnZcIixcbiAgICBcInVuaWZvcm0xaVwiLFxuICAgIFwidW5pZm9ybTFpdlwiLFxuICAgIFwidW5pZm9ybTF1aVwiLFxuICAgIFwidW5pZm9ybTF1aXZcIixcbiAgICBcInVuaWZvcm0yZlwiLFxuICAgIFwidW5pZm9ybTJmdlwiLFxuICAgIFwidW5pZm9ybTJpXCIsXG4gICAgXCJ1bmlmb3JtMml2XCIsXG4gICAgXCJ1bmlmb3JtMnVpXCIsXG4gICAgXCJ1bmlmb3JtMnVpdlwiLFxuICAgIFwidW5pZm9ybTNmXCIsXG4gICAgXCJ1bmlmb3JtM2Z2XCIsXG4gICAgXCJ1bmlmb3JtM2lcIixcbiAgICBcInVuaWZvcm0zaXZcIixcbiAgICBcInVuaWZvcm0zdWlcIixcbiAgICBcInVuaWZvcm0zdWl2XCIsXG4gICAgXCJ1bmlmb3JtNGZcIixcbiAgICBcInVuaWZvcm00ZnZcIixcbiAgICBcInVuaWZvcm00aVwiLFxuICAgIFwidW5pZm9ybTRpdlwiLFxuICAgIFwidW5pZm9ybTR1aVwiLFxuICAgIFwidW5pZm9ybTR1aXZcIixcbiAgICBcInVuaWZvcm1CbG9ja0JpbmRpbmdcIixcbiAgICBcInVuaWZvcm1NYXRyaXgyZnZcIixcbiAgICBcInVuaWZvcm1NYXRyaXgyeDNmdlwiLFxuICAgIFwidW5pZm9ybU1hdHJpeDJ4NGZ2XCIsXG4gICAgXCJ1bmlmb3JtTWF0cml4M2Z2XCIsXG4gICAgXCJ1bmlmb3JtTWF0cml4M3gyZnZcIixcbiAgICBcInVuaWZvcm1NYXRyaXgzeDRmdlwiLFxuICAgIFwidW5pZm9ybU1hdHJpeDRmdlwiLFxuICAgIFwidW5pZm9ybU1hdHJpeDR4MmZ2XCIsXG4gICAgXCJ1bmlmb3JtTWF0cml4NHgzZnZcIixcbiAgICBcInVuaW5zdGFsbFNlbGZcIixcbiAgICBcInVuaW9uXCIsXG4gICAgXCJ1bmlxdWVcIixcbiAgICBcInVuaXF1ZUlEXCIsXG4gICAgXCJ1bmlxdWVOdW1iZXJcIixcbiAgICBcInVuaXRcIixcbiAgICBcInVuaXRUeXBlXCIsXG4gICAgXCJ1bml0c1wiLFxuICAgIFwidW5sb2FkRXZlbnRFbmRcIixcbiAgICBcInVubG9hZEV2ZW50U3RhcnRcIixcbiAgICBcInVubG9ja1wiLFxuICAgIFwidW5tYXBcIixcbiAgICBcInVubW91bnRcIixcbiAgICBcInVub2JzZXJ2ZVwiLFxuICAgIFwidW5wYWNrQ29sb3JTcGFjZVwiLFxuICAgIFwidW5wYXVzZVwiLFxuICAgIFwidW5wYXVzZUFuaW1hdGlvbnNcIixcbiAgICBcInVucmVhZENvdW50XCIsXG4gICAgXCJ1bnJlZ2lzdGVyXCIsXG4gICAgXCJ1bnJlZ2lzdGVyQ29udGVudEhhbmRsZXJcIixcbiAgICBcInVucmVnaXN0ZXJQcm90b2NvbEhhbmRsZXJcIixcbiAgICBcInVuc2NvcGFibGVzXCIsXG4gICAgXCJ1bnNlbGVjdGFibGVcIixcbiAgICBcInVuc2hpZnRcIixcbiAgICBcInVuc3Vic2NyaWJlXCIsXG4gICAgXCJ1bnN1c3BlbmRSZWRyYXdcIixcbiAgICBcInVuc3VzcGVuZFJlZHJhd0FsbFwiLFxuICAgIFwidW53YXRjaFwiLFxuICAgIFwidW53cmFwS2V5XCIsXG4gICAgXCJ1cERlZ3JlZXNcIixcbiAgICBcInVwWFwiLFxuICAgIFwidXBZXCIsXG4gICAgXCJ1cFpcIixcbiAgICBcInVwZGF0ZVwiLFxuICAgIFwidXBkYXRlQWRJbnRlcmVzdEdyb3Vwc1wiLFxuICAgIFwidXBkYXRlQ2FsbGJhY2tEb25lXCIsXG4gICAgXCJ1cGRhdGVDaGFyYWN0ZXJCb3VuZHNcIixcbiAgICBcInVwZGF0ZUNvbW1hbmRzXCIsXG4gICAgXCJ1cGRhdGVDb250cm9sQm91bmRzXCIsXG4gICAgXCJ1cGRhdGVDdXJyZW50RW50cnlcIixcbiAgICBcInVwZGF0ZUljZVwiLFxuICAgIFwidXBkYXRlSW5rVHJhaWxTdGFydFBvaW50XCIsXG4gICAgXCJ1cGRhdGVJbnRlcnZhbFwiLFxuICAgIFwidXBkYXRlUGxheWJhY2tSYXRlXCIsXG4gICAgXCJ1cGRhdGVSYW5nZUVuZFwiLFxuICAgIFwidXBkYXRlUmFuZ2VTdGFydFwiLFxuICAgIFwidXBkYXRlUmVuZGVyU3RhdGVcIixcbiAgICBcInVwZGF0ZVNlbGVjdGlvblwiLFxuICAgIFwidXBkYXRlU2VsZWN0aW9uQm91bmRzXCIsXG4gICAgXCJ1cGRhdGVTZXR0aW5nc1wiLFxuICAgIFwidXBkYXRlVGV4dFwiLFxuICAgIFwidXBkYXRlVGltaW5nXCIsXG4gICAgXCJ1cGRhdGVWaWFDYWNoZVwiLFxuICAgIFwidXBkYXRlV2l0aFwiLFxuICAgIFwidXBkYXRlZFwiLFxuICAgIFwidXBkYXRpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInVwbG9hZFwiLFxuICAgIFwidXBsb2FkVG90YWxcIixcbiAgICBcInVwbG9hZGVkXCIsXG4gICAgXCJ1cHBlclwiLFxuICAgIFwidXBwZXJCb3VuZFwiLFxuICAgIFwidXBwZXJPcGVuXCIsXG4gICAgXCJ1cmlcIixcbiAgICBcInVybFwiLFxuICAgIFwidXJuXCIsXG4gICAgXCJ1cm5zXCIsXG4gICAgXCJ1c2FnZVwiLFxuICAgIFwidXNhZ2VzXCIsXG4gICAgXCJ1c2JcIixcbiAgICBcInVzYlZlcnNpb25NYWpvclwiLFxuICAgIFwidXNiVmVyc2lvbk1pbm9yXCIsXG4gICAgXCJ1c2JWZXJzaW9uU3VibWlub3JcIixcbiAgICBcInVzZUN1cnJlbnRWaWV3XCIsXG4gICAgXCJ1c2VNYXBcIixcbiAgICBcInVzZVByb2dyYW1cIixcbiAgICBcInVzZWRTcGFjZVwiLFxuICAgIFwidXNlci1zZWxlY3RcIixcbiAgICBcInVzZXJBY3RpdmF0aW9uXCIsXG4gICAgXCJ1c2VyQWdlbnRcIixcbiAgICBcInVzZXJBZ2VudERhdGFcIixcbiAgICBcInVzZXJDaG9pY2VcIixcbiAgICBcInVzZXJIYW5kbGVcIixcbiAgICBcInVzZXJIaW50XCIsXG4gICAgXCJ1c2VySW5pdGlhdGVkXCIsXG4gICAgXCJ1c2VyTGFuZ3VhZ2VcIixcbiAgICBcInVzZXJTZWxlY3RcIixcbiAgICBcInVzZXJTdGF0ZVwiLFxuICAgIFwidXNlclZpc2libGVPbmx5XCIsXG4gICAgXCJ1c2VybmFtZVwiLFxuICAgIFwidXNlcm5hbWVGcmFnbWVudFwiLFxuICAgIFwidXR0ZXJhbmNlXCIsXG4gICAgXCJ1dWlkXCIsXG4gICAgXCJ2OEJyZWFrSXRlcmF0b3JcIixcbiAgICBcInZBbGlnblwiLFxuICAgIFwidkxpbmtcIixcbiAgICBcInZhbGlkXCIsXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwidmFsaWRhdGVQcm9ncmFtXCIsXG4gICAgXCJ2YWxpZGF0aW9uTWVzc2FnZVwiLFxuICAgIFwidmFsaWRpdHlcIixcbiAgICBcInZhbHVlXCIsXG4gICAgXCJ2YWx1ZUFzRGF0ZVwiLFxuICAgIFwidmFsdWVBc051bWJlclwiLFxuICAgIFwidmFsdWVBc1N0cmluZ1wiLFxuICAgIFwidmFsdWVJblNwZWNpZmllZFVuaXRzXCIsXG4gICAgXCJ2YWx1ZU1pc3NpbmdcIixcbiAgICBcInZhbHVlT2ZcIixcbiAgICBcInZhbHVlVGV4dFwiLFxuICAgIFwidmFsdWVUeXBlXCIsXG4gICAgXCJ2YWx1ZXNcIixcbiAgICBcInZhcmlhYmxlXCIsXG4gICAgXCJ2YXJpYW50XCIsXG4gICAgXCJ2YXJpYXRpb25TZXR0aW5nc1wiLFxuICAgIFwidmJcIixcbiAgICBcInZlY3Rvci1lZmZlY3RcIixcbiAgICBcInZlY3RvckVmZmVjdFwiLFxuICAgIFwidmVsb2NpdHlBbmd1bGFyXCIsXG4gICAgXCJ2ZWxvY2l0eUV4cGFuc2lvblwiLFxuICAgIFwidmVsb2NpdHlYXCIsXG4gICAgXCJ2ZWxvY2l0eVlcIixcbiAgICBcInZlbmRvclwiLFxuICAgIFwidmVuZG9ySWRcIixcbiAgICBcInZlbmRvclN1YlwiLFxuICAgIFwidmVyaWZ5XCIsXG4gICAgXCJ2ZXJzaW9uXCIsXG4gICAgXCJ2ZXJ0ZXhcIixcbiAgICBcInZlcnRleEF0dHJpYjFmXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWIxZnZcIixcbiAgICBcInZlcnRleEF0dHJpYjJmXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWIyZnZcIixcbiAgICBcInZlcnRleEF0dHJpYjNmXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWIzZnZcIixcbiAgICBcInZlcnRleEF0dHJpYjRmXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWI0ZnZcIixcbiAgICBcInZlcnRleEF0dHJpYkRpdmlzb3JcIixcbiAgICBcInZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRVwiLFxuICAgIFwidmVydGV4QXR0cmliSTRpXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWJJNGl2XCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWJJNHVpXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWJJNHVpdlwiLFxuICAgIFwidmVydGV4QXR0cmliSVBvaW50ZXJcIixcbiAgICBcInZlcnRleEF0dHJpYlBvaW50ZXJcIixcbiAgICBcInZlcnRpY2FsXCIsXG4gICAgXCJ2ZXJ0aWNhbC1hbGlnblwiLFxuICAgIFwidmVydGljYWxBbGlnblwiLFxuICAgIFwidmVydGljYWxPdmVyZmxvd1wiLFxuICAgIFwidmhcIixcbiAgICBcInZpXCIsXG4gICAgXCJ2aWJyYXRlXCIsXG4gICAgXCJ2aWJyYXRpb25BY3R1YXRvclwiLFxuICAgIFwidmlkZW9CaXRzUGVyU2Vjb25kXCIsXG4gICAgXCJ2aWRlb0hlaWdodFwiLFxuICAgIFwidmlkZW9UcmFja3NcIixcbiAgICBcInZpZGVvV2lkdGhcIixcbiAgICBcInZpZXdcIixcbiAgICBcInZpZXdCb3hcIixcbiAgICBcInZpZXdCb3hTdHJpbmdcIixcbiAgICBcInZpZXdEaW1lbnNpb25cIixcbiAgICBcInZpZXdGb3JtYXRzXCIsXG4gICAgXCJ2aWV3VGFyZ2V0XCIsXG4gICAgXCJ2aWV3VGFyZ2V0U3RyaW5nXCIsXG4gICAgXCJ2aWV3VHJhbnNpdGlvblwiLFxuICAgIFwidmlld3BvcnRcIixcbiAgICBcInZpZXdwb3J0QW5jaG9yWFwiLFxuICAgIFwidmlld3BvcnRBbmNob3JZXCIsXG4gICAgXCJ2aWV3cG9ydEVsZW1lbnRcIixcbiAgICBcInZpZXdzXCIsXG4gICAgXCJ2aW9sYXRlZERpcmVjdGl2ZVwiLFxuICAgIFwidmlydHVhbEtleWJvYXJkXCIsXG4gICAgXCJ2aXJ0dWFsS2V5Ym9hcmRQb2xpY3lcIixcbiAgICBcInZpc2liaWxpdHlcIixcbiAgICBcInZpc2liaWxpdHlTdGF0ZVwiLFxuICAgIFwidmlzaWJsZVwiLFxuICAgIFwidmlzaWJsZVJlY3RcIixcbiAgICBcInZpc3VhbFZpZXdwb3J0XCIsXG4gICAgXCJ2bGlua0NvbG9yXCIsXG4gICAgXCJ2bWF4XCIsXG4gICAgXCJ2bWluXCIsXG4gICAgXCJ2b2ljZVwiLFxuICAgIFwidm9pY2VVUklcIixcbiAgICBcInZvbHVtZVwiLFxuICAgIFwidnJtbFwiLFxuICAgIFwidnNwYWNlXCIsXG4gICAgXCJ2d1wiLFxuICAgIFwid1wiLFxuICAgIFwid2FpdFwiLFxuICAgIFwid2FpdEFzeW5jXCIsXG4gICAgXCJ3YWl0U3luY1wiLFxuICAgIFwid2FpdGluZ1wiLFxuICAgIFwid2FrZVwiLFxuICAgIFwid2FrZUxvY2tcIixcbiAgICBcIndhbmRcIixcbiAgICBcIndhcm11cFwiLFxuICAgIFwid2FyblwiLFxuICAgIFwid2FzQWx0ZXJuYXRlUHJvdG9jb2xBdmFpbGFibGVcIixcbiAgICBcIndhc0NsZWFuXCIsXG4gICAgXCJ3YXNEaXNjYXJkZWRcIixcbiAgICBcIndhc0ZldGNoZWRWaWFTcGR5XCIsXG4gICAgXCJ3YXNOcG5OZWdvdGlhdGVkXCIsXG4gICAgXCJ3YXRjaFwiLFxuICAgIFwid2F0Y2hBdmFpbGFiaWxpdHlcIixcbiAgICBcIndhdGNoUG9zaXRpb25cIixcbiAgICBcIndlYk5hdmlnYXRpb25cIixcbiAgICBcIndlYlJlcXVlc3RcIixcbiAgICBcIndlYmRyaXZlclwiLFxuICAgIFwid2Via2l0QWRkS2V5XCIsXG4gICAgXCJ3ZWJraXRBbGlnbkNvbnRlbnRcIixcbiAgICBcIndlYmtpdEFsaWduSXRlbXNcIixcbiAgICBcIndlYmtpdEFsaWduU2VsZlwiLFxuICAgIFwid2Via2l0QW5pbWF0aW9uXCIsXG4gICAgXCJ3ZWJraXRBbmltYXRpb25EZWxheVwiLFxuICAgIFwid2Via2l0QW5pbWF0aW9uRGlyZWN0aW9uXCIsXG4gICAgXCJ3ZWJraXRBbmltYXRpb25EdXJhdGlvblwiLFxuICAgIFwid2Via2l0QW5pbWF0aW9uRmlsbE1vZGVcIixcbiAgICBcIndlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCIsXG4gICAgXCJ3ZWJraXRBbmltYXRpb25OYW1lXCIsXG4gICAgXCJ3ZWJraXRBbmltYXRpb25QbGF5U3RhdGVcIixcbiAgICBcIndlYmtpdEFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gICAgXCJ3ZWJraXRBcHBlYXJhbmNlXCIsXG4gICAgXCJ3ZWJraXRBdWRpb0NvbnRleHRcIixcbiAgICBcIndlYmtpdEF1ZGlvRGVjb2RlZEJ5dGVDb3VudFwiLFxuICAgIFwid2Via2l0QXVkaW9QYW5uZXJOb2RlXCIsXG4gICAgXCJ3ZWJraXRCYWNrZmFjZVZpc2liaWxpdHlcIixcbiAgICBcIndlYmtpdEJhY2tncm91bmRcIixcbiAgICBcIndlYmtpdEJhY2tncm91bmRBdHRhY2htZW50XCIsXG4gICAgXCJ3ZWJraXRCYWNrZ3JvdW5kQ2xpcFwiLFxuICAgIFwid2Via2l0QmFja2dyb3VuZENvbG9yXCIsXG4gICAgXCJ3ZWJraXRCYWNrZ3JvdW5kSW1hZ2VcIixcbiAgICBcIndlYmtpdEJhY2tncm91bmRPcmlnaW5cIixcbiAgICBcIndlYmtpdEJhY2tncm91bmRQb3NpdGlvblwiLFxuICAgIFwid2Via2l0QmFja2dyb3VuZFBvc2l0aW9uWFwiLFxuICAgIFwid2Via2l0QmFja2dyb3VuZFBvc2l0aW9uWVwiLFxuICAgIFwid2Via2l0QmFja2dyb3VuZFJlcGVhdFwiLFxuICAgIFwid2Via2l0QmFja2dyb3VuZFNpemVcIixcbiAgICBcIndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW9cIixcbiAgICBcIndlYmtpdEJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgICBcIndlYmtpdEJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG4gICAgXCJ3ZWJraXRCb3JkZXJJbWFnZVwiLFxuICAgIFwid2Via2l0Qm9yZGVySW1hZ2VPdXRzZXRcIixcbiAgICBcIndlYmtpdEJvcmRlckltYWdlUmVwZWF0XCIsXG4gICAgXCJ3ZWJraXRCb3JkZXJJbWFnZVNsaWNlXCIsXG4gICAgXCJ3ZWJraXRCb3JkZXJJbWFnZVNvdXJjZVwiLFxuICAgIFwid2Via2l0Qm9yZGVySW1hZ2VXaWR0aFwiLFxuICAgIFwid2Via2l0Qm9yZGVyUmFkaXVzXCIsXG4gICAgXCJ3ZWJraXRCb3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gICAgXCJ3ZWJraXRCb3JkZXJUb3BSaWdodFJhZGl1c1wiLFxuICAgIFwid2Via2l0Qm94QWxpZ25cIixcbiAgICBcIndlYmtpdEJveERpcmVjdGlvblwiLFxuICAgIFwid2Via2l0Qm94RmxleFwiLFxuICAgIFwid2Via2l0Qm94T3JkaW5hbEdyb3VwXCIsXG4gICAgXCJ3ZWJraXRCb3hPcmllbnRcIixcbiAgICBcIndlYmtpdEJveFBhY2tcIixcbiAgICBcIndlYmtpdEJveFNoYWRvd1wiLFxuICAgIFwid2Via2l0Qm94U2l6aW5nXCIsXG4gICAgXCJ3ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZVwiLFxuICAgIFwid2Via2l0Q2FuY2VsRnVsbFNjcmVlblwiLFxuICAgIFwid2Via2l0Q2FuY2VsS2V5UmVxdWVzdFwiLFxuICAgIFwid2Via2l0Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIsXG4gICAgXCJ3ZWJraXRDbGVhclJlc291cmNlVGltaW5nc1wiLFxuICAgIFwid2Via2l0Q2xpcFBhdGhcIixcbiAgICBcIndlYmtpdENsb3NlZENhcHRpb25zVmlzaWJsZVwiLFxuICAgIFwid2Via2l0Q29udmVydFBvaW50RnJvbU5vZGVUb1BhZ2VcIixcbiAgICBcIndlYmtpdENvbnZlcnRQb2ludEZyb21QYWdlVG9Ob2RlXCIsXG4gICAgXCJ3ZWJraXRDcmVhdGVTaGFkb3dSb290XCIsXG4gICAgXCJ3ZWJraXRDdXJyZW50RnVsbFNjcmVlbkVsZW1lbnRcIixcbiAgICBcIndlYmtpdEN1cnJlbnRQbGF5YmFja1RhcmdldElzV2lyZWxlc3NcIixcbiAgICBcIndlYmtpdERlY29kZWRGcmFtZUNvdW50XCIsXG4gICAgXCJ3ZWJraXREaXJlY3Rpb25JbnZlcnRlZEZyb21EZXZpY2VcIixcbiAgICBcIndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuXCIsXG4gICAgXCJ3ZWJraXREcm9wcGVkRnJhbWVDb3VudFwiLFxuICAgIFwid2Via2l0RW50ZXJGdWxsU2NyZWVuXCIsXG4gICAgXCJ3ZWJraXRFbnRlckZ1bGxzY3JlZW5cIixcbiAgICBcIndlYmtpdEVudHJpZXNcIixcbiAgICBcIndlYmtpdEV4aXRGdWxsU2NyZWVuXCIsXG4gICAgXCJ3ZWJraXRFeGl0RnVsbHNjcmVlblwiLFxuICAgIFwid2Via2l0RXhpdFBvaW50ZXJMb2NrXCIsXG4gICAgXCJ3ZWJraXRGaWx0ZXJcIixcbiAgICBcIndlYmtpdEZsZXhcIixcbiAgICBcIndlYmtpdEZsZXhCYXNpc1wiLFxuICAgIFwid2Via2l0RmxleERpcmVjdGlvblwiLFxuICAgIFwid2Via2l0RmxleEZsb3dcIixcbiAgICBcIndlYmtpdEZsZXhHcm93XCIsXG4gICAgXCJ3ZWJraXRGbGV4U2hyaW5rXCIsXG4gICAgXCJ3ZWJraXRGbGV4V3JhcFwiLFxuICAgIFwid2Via2l0Rm9udEZlYXR1cmVTZXR0aW5nc1wiLFxuICAgIFwid2Via2l0RnVsbFNjcmVlbktleWJvYXJkSW5wdXRBbGxvd2VkXCIsXG4gICAgXCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudFwiLFxuICAgIFwid2Via2l0RnVsbHNjcmVlbkVuYWJsZWRcIixcbiAgICBcIndlYmtpdEdlbmVyYXRlS2V5UmVxdWVzdFwiLFxuICAgIFwid2Via2l0R2V0QXNFbnRyeVwiLFxuICAgIFwid2Via2l0R2V0RGF0YWJhc2VOYW1lc1wiLFxuICAgIFwid2Via2l0R2V0RW50cmllc1wiLFxuICAgIFwid2Via2l0R2V0RW50cmllc0J5TmFtZVwiLFxuICAgIFwid2Via2l0R2V0RW50cmllc0J5VHlwZVwiLFxuICAgIFwid2Via2l0R2V0Rmxvd0J5TmFtZVwiLFxuICAgIFwid2Via2l0R2V0R2FtZXBhZHNcIixcbiAgICBcIndlYmtpdEdldEltYWdlRGF0YUhEXCIsXG4gICAgXCJ3ZWJraXRHZXROYW1lZEZsb3dzXCIsXG4gICAgXCJ3ZWJraXRHZXRSZWdpb25GbG93UmFuZ2VzXCIsXG4gICAgXCJ3ZWJraXRHZXRVc2VyTWVkaWFcIixcbiAgICBcIndlYmtpdEhhc0Nsb3NlZENhcHRpb25zXCIsXG4gICAgXCJ3ZWJraXRIaWRkZW5cIixcbiAgICBcIndlYmtpdElEQkN1cnNvclwiLFxuICAgIFwid2Via2l0SURCRGF0YWJhc2VcIixcbiAgICBcIndlYmtpdElEQkRhdGFiYXNlRXJyb3JcIixcbiAgICBcIndlYmtpdElEQkRhdGFiYXNlRXhjZXB0aW9uXCIsXG4gICAgXCJ3ZWJraXRJREJGYWN0b3J5XCIsXG4gICAgXCJ3ZWJraXRJREJJbmRleFwiLFxuICAgIFwid2Via2l0SURCS2V5UmFuZ2VcIixcbiAgICBcIndlYmtpdElEQk9iamVjdFN0b3JlXCIsXG4gICAgXCJ3ZWJraXRJREJSZXF1ZXN0XCIsXG4gICAgXCJ3ZWJraXRJREJUcmFuc2FjdGlvblwiLFxuICAgIFwid2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIsXG4gICAgXCJ3ZWJraXRJbmRleGVkREJcIixcbiAgICBcIndlYmtpdEluaXRNZXNzYWdlRXZlbnRcIixcbiAgICBcIndlYmtpdElzRnVsbFNjcmVlblwiLFxuICAgIFwid2Via2l0SnVzdGlmeUNvbnRlbnRcIixcbiAgICBcIndlYmtpdEtleXNcIixcbiAgICBcIndlYmtpdExpbmVDbGFtcFwiLFxuICAgIFwid2Via2l0TGluZURhc2hPZmZzZXRcIixcbiAgICBcIndlYmtpdExvY2tPcmllbnRhdGlvblwiLFxuICAgIFwid2Via2l0TWFza1wiLFxuICAgIFwid2Via2l0TWFza0NsaXBcIixcbiAgICBcIndlYmtpdE1hc2tDb21wb3NpdGVcIixcbiAgICBcIndlYmtpdE1hc2tJbWFnZVwiLFxuICAgIFwid2Via2l0TWFza09yaWdpblwiLFxuICAgIFwid2Via2l0TWFza1Bvc2l0aW9uXCIsXG4gICAgXCJ3ZWJraXRNYXNrUG9zaXRpb25YXCIsXG4gICAgXCJ3ZWJraXRNYXNrUG9zaXRpb25ZXCIsXG4gICAgXCJ3ZWJraXRNYXNrUmVwZWF0XCIsXG4gICAgXCJ3ZWJraXRNYXNrU2l6ZVwiLFxuICAgIFwid2Via2l0TWF0Y2hlc1NlbGVjdG9yXCIsXG4gICAgXCJ3ZWJraXRNZWRpYVN0cmVhbVwiLFxuICAgIFwid2Via2l0Tm90aWZpY2F0aW9uc1wiLFxuICAgIFwid2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dFwiLFxuICAgIFwid2Via2l0T3JkZXJcIixcbiAgICBcIndlYmtpdE9yaWVudGF0aW9uXCIsXG4gICAgXCJ3ZWJraXRQZWVyQ29ubmVjdGlvbjAwXCIsXG4gICAgXCJ3ZWJraXRQZXJzaXN0ZW50U3RvcmFnZVwiLFxuICAgIFwid2Via2l0UGVyc3BlY3RpdmVcIixcbiAgICBcIndlYmtpdFBlcnNwZWN0aXZlT3JpZ2luXCIsXG4gICAgXCJ3ZWJraXRQb2ludGVyTG9ja0VsZW1lbnRcIixcbiAgICBcIndlYmtpdFBvc3RNZXNzYWdlXCIsXG4gICAgXCJ3ZWJraXRQcmVzZXJ2ZXNQaXRjaFwiLFxuICAgIFwid2Via2l0UHV0SW1hZ2VEYXRhSERcIixcbiAgICBcIndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uXCIsXG4gICAgXCJ3ZWJraXRSZWdpb25PdmVyc2V0XCIsXG4gICAgXCJ3ZWJraXRSZWxhdGl2ZVBhdGhcIixcbiAgICBcIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgIFwid2Via2l0UmVxdWVzdEZpbGVTeXN0ZW1cIixcbiAgICBcIndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuXCIsXG4gICAgXCJ3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlblwiLFxuICAgIFwid2Via2l0UmVxdWVzdFBvaW50ZXJMb2NrXCIsXG4gICAgXCJ3ZWJraXRSZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMXCIsXG4gICAgXCJ3ZWJraXRTZXRNZWRpYUtleXNcIixcbiAgICBcIndlYmtpdFNldFJlc291cmNlVGltaW5nQnVmZmVyU2l6ZVwiLFxuICAgIFwid2Via2l0U2hhZG93Um9vdFwiLFxuICAgIFwid2Via2l0U2hvd1BsYXliYWNrVGFyZ2V0UGlja2VyXCIsXG4gICAgXCJ3ZWJraXRTbGljZVwiLFxuICAgIFwid2Via2l0U3BlZWNoR3JhbW1hclwiLFxuICAgIFwid2Via2l0U3BlZWNoR3JhbW1hckxpc3RcIixcbiAgICBcIndlYmtpdFNwZWVjaFJlY29nbml0aW9uXCIsXG4gICAgXCJ3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbkVycm9yXCIsXG4gICAgXCJ3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbkV2ZW50XCIsXG4gICAgXCJ3ZWJraXRTdG9yYWdlSW5mb1wiLFxuICAgIFwid2Via2l0U3VwcG9ydHNGdWxsc2NyZWVuXCIsXG4gICAgXCJ3ZWJraXRUZW1wb3JhcnlTdG9yYWdlXCIsXG4gICAgXCJ3ZWJraXRUZXh0RmlsbENvbG9yXCIsXG4gICAgXCJ3ZWJraXRUZXh0U2VjdXJpdHlcIixcbiAgICBcIndlYmtpdFRleHRTaXplQWRqdXN0XCIsXG4gICAgXCJ3ZWJraXRUZXh0U3Ryb2tlXCIsXG4gICAgXCJ3ZWJraXRUZXh0U3Ryb2tlQ29sb3JcIixcbiAgICBcIndlYmtpdFRleHRTdHJva2VXaWR0aFwiLFxuICAgIFwid2Via2l0VHJhbnNmb3JtXCIsXG4gICAgXCJ3ZWJraXRUcmFuc2Zvcm1PcmlnaW5cIixcbiAgICBcIndlYmtpdFRyYW5zZm9ybVN0eWxlXCIsXG4gICAgXCJ3ZWJraXRUcmFuc2l0aW9uXCIsXG4gICAgXCJ3ZWJraXRUcmFuc2l0aW9uRGVsYXlcIixcbiAgICBcIndlYmtpdFRyYW5zaXRpb25EdXJhdGlvblwiLFxuICAgIFwid2Via2l0VHJhbnNpdGlvblByb3BlcnR5XCIsXG4gICAgXCJ3ZWJraXRUcmFuc2l0aW9uVGltaW5nRnVuY3Rpb25cIixcbiAgICBcIndlYmtpdFVSTFwiLFxuICAgIFwid2Via2l0VW5sb2NrT3JpZW50YXRpb25cIixcbiAgICBcIndlYmtpdFVzZXJTZWxlY3RcIixcbiAgICBcIndlYmtpdFZpZGVvRGVjb2RlZEJ5dGVDb3VudFwiLFxuICAgIFwid2Via2l0VmlzaWJpbGl0eVN0YXRlXCIsXG4gICAgXCJ3ZWJraXRXaXJlbGVzc1ZpZGVvUGxheWJhY2tEaXNhYmxlZFwiLFxuICAgIFwid2Via2l0ZGlyZWN0b3J5XCIsXG4gICAgXCJ3ZWJraXRkcm9wem9uZVwiLFxuICAgIFwid2Vic3RvcmVcIixcbiAgICBcIndlaWdodFwiLFxuICAgIFwid2dzbExhbmd1YWdlRmVhdHVyZXNcIixcbiAgICBcIndoYXRUb1Nob3dcIixcbiAgICBcIndoZWVsRGVsdGFcIixcbiAgICBcIndoZWVsRGVsdGFYXCIsXG4gICAgXCJ3aGVlbERlbHRhWVwiLFxuICAgIFwid2hlbkRlZmluZWRcIixcbiAgICBcIndoaWNoXCIsXG4gICAgXCJ3aGl0ZS1zcGFjZVwiLFxuICAgIFwid2hpdGUtc3BhY2UtY29sbGFwc2VcIixcbiAgICBcIndoaXRlU3BhY2VcIixcbiAgICBcIndoaXRlU3BhY2VDb2xsYXBzZVwiLFxuICAgIFwid2hvbGVUZXh0XCIsXG4gICAgXCJ3aWRvd3NcIixcbiAgICBcIndpZHRoXCIsXG4gICAgXCJ3aWxsLWNoYW5nZVwiLFxuICAgIFwid2lsbENoYW5nZVwiLFxuICAgIFwid2lsbFZhbGlkYXRlXCIsXG4gICAgXCJ3aW5kb3dcIixcbiAgICBcIndpbmRvd0F0dHJpYnV0aW9uXCIsXG4gICAgXCJ3aW5kb3dDb250cm9sc092ZXJsYXlcIixcbiAgICBcIndpbmRvd0lkXCIsXG4gICAgXCJ3aW5kb3dJZHNcIixcbiAgICBcIndpbmRvd3NcIixcbiAgICBcIndpdGhcIixcbiAgICBcIndpdGhDcmVkZW50aWFsc1wiLFxuICAgIFwid2l0aFJlc29sdmVyc1wiLFxuICAgIFwid29yZC1icmVha1wiLFxuICAgIFwid29yZC1zcGFjaW5nXCIsXG4gICAgXCJ3b3JkLXdyYXBcIixcbiAgICBcIndvcmRCcmVha1wiLFxuICAgIFwid29yZFNwYWNpbmdcIixcbiAgICBcIndvcmRXcmFwXCIsXG4gICAgXCJ3b3JrZXJTdGFydFwiLFxuICAgIFwid29ya2xldFwiLFxuICAgIFwid293NjRcIixcbiAgICBcIndyYXBcIixcbiAgICBcIndyYXBLZXlcIixcbiAgICBcIndyaXRhYmxlXCIsXG4gICAgXCJ3cml0YWJsZUF1eGlsaWFyaWVzXCIsXG4gICAgXCJ3cml0ZVwiLFxuICAgIFwid3JpdGVCdWZmZXJcIixcbiAgICBcIndyaXRlTWFza1wiLFxuICAgIFwid3JpdGVUZXh0XCIsXG4gICAgXCJ3cml0ZVRleHR1cmVcIixcbiAgICBcIndyaXRlVGltZXN0YW1wXCIsXG4gICAgXCJ3cml0ZVZhbHVlXCIsXG4gICAgXCJ3cml0ZVZhbHVlV2l0aFJlc3BvbnNlXCIsXG4gICAgXCJ3cml0ZVZhbHVlV2l0aG91dFJlc3BvbnNlXCIsXG4gICAgXCJ3cml0ZVdpdGhvdXRSZXNwb25zZVwiLFxuICAgIFwid3JpdGVsblwiLFxuICAgIFwid3JpdGluZy1tb2RlXCIsXG4gICAgXCJ3cml0aW5nTW9kZVwiLFxuICAgIFwid3JpdGluZ1N1Z2dlc3Rpb25zXCIsXG4gICAgXCJ4XCIsXG4gICAgXCJ4MVwiLFxuICAgIFwieDJcIixcbiAgICBcInhDaGFubmVsU2VsZWN0b3JcIixcbiAgICBcInhtbEVuY29kaW5nXCIsXG4gICAgXCJ4bWxTdGFuZGFsb25lXCIsXG4gICAgXCJ4bWxWZXJzaW9uXCIsXG4gICAgXCJ4bWxiYXNlXCIsXG4gICAgXCJ4bWxsYW5nXCIsXG4gICAgXCJ4bWxzcGFjZVwiLFxuICAgIFwieG9yXCIsXG4gICAgXCJ4clwiLFxuICAgIFwieVwiLFxuICAgIFwieTFcIixcbiAgICBcInkyXCIsXG4gICAgXCJ5Q2hhbm5lbFNlbGVjdG9yXCIsXG4gICAgXCJ5YW5kZXhcIixcbiAgICBcInlpZWxkXCIsXG4gICAgXCJ6XCIsXG4gICAgXCJ6LWluZGV4XCIsXG4gICAgXCJ6SW5kZXhcIixcbiAgICBcInpvb21cIixcbiAgICBcInpvb21BbmRQYW5cIixcbiAgICBcInpvb21SZWN0U2NyZWVuXCIsXG5dO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIGZpbmRfYnVpbHRpbnMocmVzZXJ2ZWQpIHtcbiAgICBkb21wcm9wcy5mb3JFYWNoKGFkZCk7XG5cbiAgICAvLyBDb21wYXRpYmlsaXR5IGZpeCBmb3Igc29tZSBzdGFuZGFyZCBkZWZpbmVkIGdsb2JhbHMgbm90IGRlZmluZWQgb24gZXZlcnkganMgZW52aXJvbm1lbnRcbiAgICB2YXIgbmV3X2dsb2JhbHMgPSBbXCJTeW1ib2xcIiwgXCJNYXBcIiwgXCJQcm9taXNlXCIsIFwiUHJveHlcIiwgXCJSZWZsZWN0XCIsIFwiU2V0XCIsIFwiV2Vha01hcFwiLCBcIldlYWtTZXRcIl07XG4gICAgdmFyIG9iamVjdHMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsX3JlZiA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiBzZWxmO1xuXG4gICAgbmV3X2dsb2JhbHMuZm9yRWFjaChmdW5jdGlvbiAobmV3X2dsb2JhbCkge1xuICAgICAgICBvYmplY3RzW25ld19nbG9iYWxdID0gZ2xvYmFsX3JlZltuZXdfZ2xvYmFsXSB8fCBmdW5jdGlvbigpIHt9O1xuICAgIH0pO1xuXG4gICAgW1xuICAgICAgICBcIm51bGxcIixcbiAgICAgICAgXCJ0cnVlXCIsXG4gICAgICAgIFwiZmFsc2VcIixcbiAgICAgICAgXCJOYU5cIixcbiAgICAgICAgXCJJbmZpbml0eVwiLFxuICAgICAgICBcIi1JbmZpbml0eVwiLFxuICAgICAgICBcInVuZGVmaW5lZFwiLFxuICAgIF0uZm9yRWFjaChhZGQpO1xuICAgIFsgT2JqZWN0LCBBcnJheSwgRnVuY3Rpb24sIE51bWJlcixcbiAgICAgIFN0cmluZywgQm9vbGVhbiwgRXJyb3IsIE1hdGgsXG4gICAgICBEYXRlLCBSZWdFeHAsIG9iamVjdHMuU3ltYm9sLCBBcnJheUJ1ZmZlcixcbiAgICAgIERhdGFWaWV3LCBkZWNvZGVVUkksIGRlY29kZVVSSUNvbXBvbmVudCxcbiAgICAgIGVuY29kZVVSSSwgZW5jb2RlVVJJQ29tcG9uZW50LCBldmFsLCBFdmFsRXJyb3IsXG4gICAgICBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheSwgSW50OEFycmF5LCBJbnQxNkFycmF5LFxuICAgICAgSW50MzJBcnJheSwgaXNGaW5pdGUsIGlzTmFOLCBKU09OLCBvYmplY3RzLk1hcCwgcGFyc2VGbG9hdCxcbiAgICAgIHBhcnNlSW50LCBvYmplY3RzLlByb21pc2UsIG9iamVjdHMuUHJveHksIFJhbmdlRXJyb3IsIFJlZmVyZW5jZUVycm9yLFxuICAgICAgb2JqZWN0cy5SZWZsZWN0LCBvYmplY3RzLlNldCwgU3ludGF4RXJyb3IsIFR5cGVFcnJvciwgVWludDhBcnJheSxcbiAgICAgIFVpbnQ4Q2xhbXBlZEFycmF5LCBVaW50MTZBcnJheSwgVWludDMyQXJyYXksIFVSSUVycm9yLFxuICAgICAgb2JqZWN0cy5XZWFrTWFwLCBvYmplY3RzLldlYWtTZXRcbiAgICBdLmZvckVhY2goZnVuY3Rpb24oY3Rvcikge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdG9yKS5tYXAoYWRkKTtcbiAgICAgICAgaWYgKGN0b3IucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdG9yLnByb3RvdHlwZSkubWFwKGFkZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBhZGQobmFtZSkge1xuICAgICAgICByZXNlcnZlZC5hZGQobmFtZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNlcnZlX3F1b3RlZF9rZXlzKGFzdCwgcmVzZXJ2ZWQpIHtcbiAgICBmdW5jdGlvbiBhZGQobmFtZSkge1xuICAgICAgICBwdXNoX3VuaXEocmVzZXJ2ZWQsIG5hbWUpO1xuICAgIH1cblxuICAgIGFzdC53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsICYmIG5vZGUucXVvdGUpIHtcbiAgICAgICAgICAgIGFkZChub2RlLmtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RQcm9wZXJ0eSAmJiBub2RlLnF1b3RlKSB7XG4gICAgICAgICAgICBhZGQobm9kZS5rZXkubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TdWIpIHtcbiAgICAgICAgICAgIGFkZFN0cmluZ3Mobm9kZS5wcm9wZXJ0eSwgYWRkKTtcbiAgICAgICAgfVxuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gYWRkU3RyaW5ncyhub2RlLCBhZGQpIHtcbiAgICBub2RlLndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICAgICAgYWRkU3RyaW5ncyhub2RlLnRhaWxfbm9kZSgpLCBhZGQpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3RyaW5nKSB7XG4gICAgICAgICAgICBhZGQobm9kZS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCkge1xuICAgICAgICAgICAgYWRkU3RyaW5ncyhub2RlLmNvbnNlcXVlbnQsIGFkZCk7XG4gICAgICAgICAgICBhZGRTdHJpbmdzKG5vZGUuYWx0ZXJuYXRpdmUsIGFkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBtYW5nbGVfcHJpdmF0ZV9wcm9wZXJ0aWVzKGFzdCwgb3B0aW9ucykge1xuICAgIHZhciBjcHJpdmF0ZSA9IC0xO1xuICAgIHZhciBwcml2YXRlX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgIHZhciBudGhfaWRlbnRpZmllciA9IG9wdGlvbnMubnRoX2lkZW50aWZpZXIgfHwgYmFzZTU0O1xuXG4gICAgYXN0ID0gIGFzdC50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3NQcml2YXRlUHJvcGVydHlcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfUHJpdmF0ZU1ldGhvZFxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Qcml2YXRlR2V0dGVyXG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1ByaXZhdGVTZXR0ZXJcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfUHJpdmF0ZUluXG4gICAgICAgICkge1xuICAgICAgICAgICAgbm9kZS5rZXkubmFtZSA9IG1hbmdsZV9wcml2YXRlKG5vZGUua2V5Lm5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRG90SGFzaCkge1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IG1hbmdsZV9wcml2YXRlKG5vZGUucHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIHJldHVybiBhc3Q7XG5cbiAgICBmdW5jdGlvbiBtYW5nbGVfcHJpdmF0ZShuYW1lKSB7XG4gICAgICAgIGxldCBtYW5nbGVkID0gcHJpdmF0ZV9jYWNoZS5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbWFuZ2xlZCkge1xuICAgICAgICAgICAgbWFuZ2xlZCA9IG50aF9pZGVudGlmaWVyLmdldCgrK2Nwcml2YXRlKTtcbiAgICAgICAgICAgIHByaXZhdGVfY2FjaGUuc2V0KG5hbWUsIG1hbmdsZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hbmdsZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaW5kX2Fubm90YXRlZF9wcm9wcyhhc3QpIHtcbiAgICB2YXIgYW5ub3RhdGVkX3Byb3BzID0gbmV3IFNldCgpO1xuICAgIHdhbGsoYXN0LCBub2RlID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9DbGFzc1ByaXZhdGVQcm9wZXJ0eVxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Qcml2YXRlTWV0aG9kXG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1ByaXZhdGVHZXR0ZXJcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfUHJpdmF0ZVNldHRlclxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Eb3RIYXNoXG4gICAgICAgICkgOyBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmtleSA9PSBcInN0cmluZ1wiICYmIGhhc19hbm5vdGF0aW9uKG5vZGUsIF9NQU5HTEVQUk9QKSkge1xuICAgICAgICAgICAgICAgIGFubm90YXRlZF9wcm9wcy5hZGQobm9kZS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0UHJvcGVydHkpIHtcbiAgICAgICAgICAgIC8vIHNldHRlciBvciBnZXR0ZXIsIHNpbmNlIEtleVZhbCBpcyBoYW5kbGVkIGFib3ZlXG4gICAgICAgICAgICBpZiAoaGFzX2Fubm90YXRpb24obm9kZSwgX01BTkdMRVBST1ApKSB7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGVkX3Byb3BzLmFkZChub2RlLmtleS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RvdCkge1xuICAgICAgICAgICAgaWYgKGhhc19hbm5vdGF0aW9uKG5vZGUsIF9NQU5HTEVQUk9QKSkge1xuICAgICAgICAgICAgICAgIGFubm90YXRlZF9wcm9wcy5hZGQobm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TdWIpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnByb3BlcnR5IGluc3RhbmNlb2YgQVNUX1N0cmluZyAmJiBoYXNfYW5ub3RhdGlvbihub2RlLCBfTUFOR0xFUFJPUCkpIHtcbiAgICAgICAgICAgICAgICBhbm5vdGF0ZWRfcHJvcHMuYWRkKG5vZGUucHJvcGVydHkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFubm90YXRlZF9wcm9wcztcbn1cblxuZnVuY3Rpb24gbWFuZ2xlX3Byb3BlcnRpZXMoYXN0LCBvcHRpb25zLCBhbm5vdGF0ZWRfcHJvcHMgPSBmaW5kX2Fubm90YXRlZF9wcm9wcyhhc3QpKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgYnVpbHRpbnM6IGZhbHNlLFxuICAgICAgICBjYWNoZTogbnVsbCxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBrZWVwX3F1b3RlZDogZmFsc2UsXG4gICAgICAgIG50aF9pZGVudGlmaWVyOiBiYXNlNTQsXG4gICAgICAgIG9ubHlfY2FjaGU6IGZhbHNlLFxuICAgICAgICByZWdleDogbnVsbCxcbiAgICAgICAgcmVzZXJ2ZWQ6IG51bGwsXG4gICAgICAgIHVuZGVjbGFyZWQ6IGZhbHNlLFxuICAgICAgICBvbmx5X2Fubm90YXRlZDogZmFsc2UsXG4gICAgfSwgdHJ1ZSk7XG5cbiAgICB2YXIgbnRoX2lkZW50aWZpZXIgPSBvcHRpb25zLm50aF9pZGVudGlmaWVyO1xuXG4gICAgdmFyIHJlc2VydmVkX29wdGlvbiA9IG9wdGlvbnMucmVzZXJ2ZWQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc2VydmVkX29wdGlvbikpIHJlc2VydmVkX29wdGlvbiA9IFtyZXNlcnZlZF9vcHRpb25dO1xuICAgIHZhciByZXNlcnZlZCA9IG5ldyBTZXQocmVzZXJ2ZWRfb3B0aW9uKTtcbiAgICBpZiAoIW9wdGlvbnMuYnVpbHRpbnMpIGZpbmRfYnVpbHRpbnMocmVzZXJ2ZWQpO1xuXG4gICAgdmFyIGNuYW1lID0gLTE7XG5cbiAgICB2YXIgY2FjaGU7XG4gICAgaWYgKG9wdGlvbnMuY2FjaGUpIHtcbiAgICAgICAgY2FjaGUgPSBvcHRpb25zLmNhY2hlLnByb3BzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIHZhciBvbmx5X2Fubm90YXRlZCA9IG9wdGlvbnMub25seV9hbm5vdGF0ZWQ7XG4gICAgdmFyIHJlZ2V4ID0gb3B0aW9ucy5yZWdleCAmJiBuZXcgUmVnRXhwKG9wdGlvbnMucmVnZXgpO1xuXG4gICAgLy8gbm90ZSBkZWJ1ZyBpcyBlaXRoZXIgZmFsc2UgKGRpc2FibGVkKSwgb3IgYSBzdHJpbmcgb2YgdGhlIGRlYnVnIHN1ZmZpeCB0byB1c2UgKGVuYWJsZWQpLlxuICAgIC8vIG5vdGUgZGVidWcgbWF5IGJlIGVuYWJsZWQgYXMgYW4gZW1wdHkgc3RyaW5nLCB3aGljaCBpcyBmYWxzZXkuIEFsc28gdHJlYXQgcGFzc2luZyAndHJ1ZSdcbiAgICAvLyB0aGUgc2FtZSBhcyBwYXNzaW5nIGFuIGVtcHR5IHN0cmluZy5cbiAgICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnICE9PSBmYWxzZTtcbiAgICB2YXIgZGVidWdfbmFtZV9zdWZmaXg7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGRlYnVnX25hbWVfc3VmZml4ID0gKG9wdGlvbnMuZGVidWcgPT09IHRydWUgPyBcIlwiIDogb3B0aW9ucy5kZWJ1Zyk7XG4gICAgfVxuXG4gICAgdmFyIG5hbWVzX3RvX21hbmdsZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdW5tYW5nbGVhYmxlID0gbmV3IFNldCgpO1xuICAgIC8vIFRyYWNrIGVhY2ggYWxyZWFkeS1tYW5nbGVkIG5hbWUgdG8gcHJldmVudCBudGhfaWRlbnRpZmllciBmcm9tIGdlbmVyYXRpbmdcbiAgICAvLyB0aGUgc2FtZSBuYW1lLlxuICAgIGNhY2hlLmZvckVhY2goKG1hbmdsZWRfbmFtZSkgPT4gdW5tYW5nbGVhYmxlLmFkZChtYW5nbGVkX25hbWUpKTtcblxuICAgIHZhciBrZWVwX3F1b3RlZCA9ICEhb3B0aW9ucy5rZWVwX3F1b3RlZDtcblxuICAgIC8vIHN0ZXAgMTogZmluZCBjYW5kaWRhdGVzIHRvIG1hbmdsZVxuICAgIGFzdC53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9DbGFzc1ByaXZhdGVQcm9wZXJ0eVxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Qcml2YXRlTWV0aG9kXG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1ByaXZhdGVHZXR0ZXJcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfUHJpdmF0ZVNldHRlclxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Eb3RIYXNoXG4gICAgICAgICkgOyBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmtleSA9PSBcInN0cmluZ1wiICYmICgha2VlcF9xdW90ZWQgfHwgIW5vZGUucXVvdGUpKSB7XG4gICAgICAgICAgICAgICAgYWRkKG5vZGUua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdFByb3BlcnR5KSB7XG4gICAgICAgICAgICAvLyBzZXR0ZXIgb3IgZ2V0dGVyLCBzaW5jZSBLZXlWYWwgaXMgaGFuZGxlZCBhYm92ZVxuICAgICAgICAgICAgaWYgKCFrZWVwX3F1b3RlZCB8fCAhbm9kZS5xdW90ZSkge1xuICAgICAgICAgICAgICAgIGFkZChub2RlLmtleS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RvdCkge1xuICAgICAgICAgICAgdmFyIGRlY2xhcmVkID0gISFvcHRpb25zLnVuZGVjbGFyZWQ7XG4gICAgICAgICAgICBpZiAoIWRlY2xhcmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBub2RlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyb290LmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbGFyZWQgPSAhKHJvb3QudGhlZGVmICYmIHJvb3QudGhlZGVmLnVuZGVjbGFyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY2xhcmVkICYmXG4gICAgICAgICAgICAgICAgKCFrZWVwX3F1b3RlZCB8fCAhbm9kZS5xdW90ZSkpIHtcbiAgICAgICAgICAgICAgICBhZGQobm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TdWIpIHtcbiAgICAgICAgICAgIGlmICgha2VlcF9xdW90ZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRTdHJpbmdzKG5vZGUucHJvcGVydHksIGFkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAmJiBub2RlLmV4cHJlc3Npb24ucHJpbnRfdG9fc3RyaW5nKCkgPT0gXCJPYmplY3QuZGVmaW5lUHJvcGVydHlcIikge1xuICAgICAgICAgICAgYWRkU3RyaW5ncyhub2RlLmFyZ3NbMV0sIGFkZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJpblwiKSB7XG4gICAgICAgICAgICBhZGRTdHJpbmdzKG5vZGUubGVmdCwgYWRkKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N0cmluZyAmJiBoYXNfYW5ub3RhdGlvbihub2RlLCBfS0VZKSkge1xuICAgICAgICAgICAgYWRkKG5vZGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gc3RlcCAyOiB0cmFuc2Zvcm0gdGhlIHRyZWUsIHJlbmFtaW5nIHByb3BlcnRpZXNcbiAgICByZXR1cm4gYXN0LnRyYW5zZm9ybShuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9DbGFzc1ByaXZhdGVQcm9wZXJ0eVxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Qcml2YXRlTWV0aG9kXG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1ByaXZhdGVHZXR0ZXJcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfUHJpdmF0ZVNldHRlclxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Eb3RIYXNoXG4gICAgICAgICkgOyBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmtleSA9PSBcInN0cmluZ1wiICYmICgha2VlcF9xdW90ZWQgfHwgIW5vZGUucXVvdGUpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5rZXkgPSBtYW5nbGUobm9kZS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0UHJvcGVydHkpIHtcbiAgICAgICAgICAgIC8vIHNldHRlciwgZ2V0dGVyLCBtZXRob2Qgb3IgY2xhc3MgZmllbGRcbiAgICAgICAgICAgIGlmICgha2VlcF9xdW90ZWQgfHwgIW5vZGUucXVvdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuY29tcHV0ZWRfa2V5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5rZXkubmFtZSA9IG1hbmdsZShub2RlLmtleS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Eb3QpIHtcbiAgICAgICAgICAgIGlmICgha2VlcF9xdW90ZWQgfHwgIW5vZGUucXVvdGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnR5ID0gbWFuZ2xlKG5vZGUucHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFrZWVwX3F1b3RlZCAmJiBub2RlIGluc3RhbmNlb2YgQVNUX1N1Yikge1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IG1hbmdsZVN0cmluZ3Mobm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAmJiBub2RlLmV4cHJlc3Npb24ucHJpbnRfdG9fc3RyaW5nKCkgPT0gXCJPYmplY3QuZGVmaW5lUHJvcGVydHlcIikge1xuICAgICAgICAgICAgbm9kZS5hcmdzWzFdID0gbWFuZ2xlU3RyaW5ncyhub2RlLmFyZ3NbMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiaW5cIikge1xuICAgICAgICAgICAgbm9kZS5sZWZ0ID0gbWFuZ2xlU3RyaW5ncyhub2RlLmxlZnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3RyaW5nICYmIGhhc19hbm5vdGF0aW9uKG5vZGUsIF9LRVkpKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBfS0VZIGFubm90YXRpb24gdG8gcHJldmVudCBkb3VibGUgbWFuZ2xpbmdcbiAgICAgICAgICAgIGNsZWFyX2Fubm90YXRpb24obm9kZSwgX0tFWSk7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbWFuZ2xlKG5vZGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gb25seSBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgYWZ0ZXIgdGhpcyBsaW5lXG5cbiAgICBmdW5jdGlvbiBjYW5fbWFuZ2xlKG5hbWUpIHtcbiAgICAgICAgaWYgKHVubWFuZ2xlYWJsZS5oYXMobmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHJlc2VydmVkLmhhcyhuYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5vbmx5X2NhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuaGFzKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXi0/WzAtOV0rKFxcLlswLTldKyk/KGVbKy1dWzAtOV0rKT8kLy50ZXN0KG5hbWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZF9tYW5nbGUobmFtZSkge1xuICAgICAgICBpZiAob25seV9hbm5vdGF0ZWQgJiYgIWFubm90YXRlZF9wcm9wcy5oYXMobmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHJlZ2V4ICYmICFyZWdleC50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYW5ub3RhdGVkX3Byb3BzLmhhcyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZXJ2ZWQuaGFzKG5hbWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBjYWNoZS5oYXMobmFtZSlcbiAgICAgICAgICAgIHx8IG5hbWVzX3RvX21hbmdsZS5oYXMobmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKG5hbWUpIHtcbiAgICAgICAgaWYgKGNhbl9tYW5nbGUobmFtZSkpIHtcbiAgICAgICAgICAgIG5hbWVzX3RvX21hbmdsZS5hZGQobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZF9tYW5nbGUobmFtZSkpIHtcbiAgICAgICAgICAgIHVubWFuZ2xlYWJsZS5hZGQobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYW5nbGUobmFtZSkge1xuICAgICAgICBpZiAoIXNob3VsZF9tYW5nbGUobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hbmdsZWQgPSBjYWNoZS5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbWFuZ2xlZCkge1xuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVidWcgbW9kZTogdXNlIGEgcHJlZml4IGFuZCBzdWZmaXggdG8gcHJlc2VydmUgcmVhZGFiaWxpdHksIGUuZy4gby5mb28gLT4gby5fJGZvbyROTk5fLlxuICAgICAgICAgICAgICAgIHZhciBkZWJ1Z19tYW5nbGVkID0gXCJfJFwiICsgbmFtZSArIFwiJFwiICsgZGVidWdfbmFtZV9zdWZmaXggKyBcIl9cIjtcblxuICAgICAgICAgICAgICAgIGlmIChjYW5fbWFuZ2xlKGRlYnVnX21hbmdsZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hbmdsZWQgPSBkZWJ1Z19tYW5nbGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZWl0aGVyIGRlYnVnIG1vZGUgaXMgb2ZmLCBvciBpdCBpcyBvbiBhbmQgd2UgY291bGQgbm90IHVzZSB0aGUgbWFuZ2xlZCBuYW1lXG4gICAgICAgICAgICBpZiAoIW1hbmdsZWQpIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG1hbmdsZWQgPSBudGhfaWRlbnRpZmllci5nZXQoKytjbmFtZSk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoIWNhbl9tYW5nbGUobWFuZ2xlZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZS5zZXQobmFtZSwgbWFuZ2xlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmdsZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFuZ2xlU3RyaW5ncyhub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnRyYW5zZm9ybShuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBub2RlLmV4cHJlc3Npb25zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uc1tsYXN0XSA9IG1hbmdsZVN0cmluZ3Mobm9kZS5leHByZXNzaW9uc1tsYXN0XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgX0tFWSBhbm5vdGF0aW9uIHRvIHByZXZlbnQgZG91YmxlIG1hbmdsaW5nXG4gICAgICAgICAgICAgICAgY2xlYXJfYW5ub3RhdGlvbihub2RlLCBfS0VZKTtcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbWFuZ2xlKG5vZGUudmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jb25zZXF1ZW50ID0gbWFuZ2xlU3RyaW5ncyhub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICAgICAgICAgIG5vZGUuYWx0ZXJuYXRpdmUgPSBtYW5nbGVTdHJpbmdzKG5vZGUuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5cbi8vIHRvL2Zyb20gYmFzZTY0IGZ1bmN0aW9uc1xuLy8gUHJlZmVyIGJ1aWx0LWluIEJ1ZmZlciwgaWYgYXZhaWxhYmxlLCB0aGVuIHVzZSBoYWNrXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L0Jhc2U2NCNUaGVfVW5pY29kZV9Qcm9ibGVtXG52YXIgdG9fYXNjaWkgPSB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyAoYjY0KSA9PiBCdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKClcbiAgICA6IChiNjQpID0+IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoYXRvYihiNjQpKSk7XG52YXIgdG9fYmFzZTY0ID0gdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gKHN0cikgPT4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZyhcImJhc2U2NFwiKVxuICAgIDogKHN0cikgPT4gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuXG5mdW5jdGlvbiByZWFkX3NvdXJjZV9tYXAoY29kZSkge1xuICAgIHZhciBtYXRjaCA9IC8oPzpefFteLl0pXFwvXFwvIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb25cXC9qc29uKDtbXFx3PS1dKik/O2Jhc2U2NCwoWysvMC05QS1aYS16XSo9KilcXHMqJC8uZXhlYyhjb2RlKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImlubGluZSBzb3VyY2UgbWFwIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0b19hc2NpaShtYXRjaFsyXSk7XG59XG5cbmZ1bmN0aW9uIHNldF9zaG9ydGhhbmQobmFtZSwgb3B0aW9ucywga2V5cykge1xuICAgIGlmIChvcHRpb25zW25hbWVdKSB7XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW2tleV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSAhPSBcIm9iamVjdFwiKSBvcHRpb25zW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIShuYW1lIGluIG9wdGlvbnNba2V5XSkpIG9wdGlvbnNba2V5XVtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdF9jYWNoZShjYWNoZSkge1xuICAgIGlmICghY2FjaGUpIHJldHVybjtcbiAgICBpZiAoIShcInByb3BzXCIgaW4gY2FjaGUpKSB7XG4gICAgICAgIGNhY2hlLnByb3BzID0gbmV3IE1hcCgpO1xuICAgIH0gZWxzZSBpZiAoIShjYWNoZS5wcm9wcyBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgICAgY2FjaGUucHJvcHMgPSBtYXBfZnJvbV9vYmplY3QoY2FjaGUucHJvcHMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FjaGVfdG9fanNvbihjYWNoZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiBtYXBfdG9fb2JqZWN0KGNhY2hlLnByb3BzKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGxvZ19pbnB1dChmaWxlcywgb3B0aW9ucywgZnMsIGRlYnVnX2ZvbGRlcikge1xuICAgIGlmICghKGZzICYmIGZzLndyaXRlRmlsZVN5bmMgJiYgZnMubWtkaXJTeW5jKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgZnMubWtkaXJTeW5jKGRlYnVnX2ZvbGRlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5jb2RlICE9PSBcIkVFWElTVFwiKSB0aHJvdyBlO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ19wYXRoID0gYCR7ZGVidWdfZm9sZGVyfS90ZXJzZXItZGVidWctJHsoTWF0aC5yYW5kb20oKSAqIDk5OTk5OTkpIHwgMH0ubG9nYDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3Qgb3B0aW9uc19zdHIgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLCAoX2tleSwgdGhpbmcpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGluZyA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gXCJbRnVuY3Rpb24gXCIgKyB0aGluZy50b1N0cmluZygpICsgXCJdXCI7XG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIFwiW1JlZ0V4cCBcIiArIHRoaW5nLnRvU3RyaW5nKCkgKyBcIl1cIjtcbiAgICAgICAgcmV0dXJuIHRoaW5nO1xuICAgIH0sIDQpO1xuXG4gICAgY29uc3QgZmlsZXNfc3RyID0gKGZpbGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMucGFyc2UgJiYgb3B0aW9ucy5wYXJzZS5zcGlkZXJtb25rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShmaWxlLCBudWxsLCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpbGUpXG4gICAgICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiBrZXkgKyBcIjogXCIgKyBmaWxlc19zdHIoZmlsZVtrZXldKSlcbiAgICAgICAgICAgICAgICAuam9pbihcIlxcblxcblwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiYGBgXFxuXCIgKyBmaWxlICsgXCJcXG5gYGBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlOyAvLyBXaGF0IGRvP1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZzLndyaXRlRmlsZVN5bmMobG9nX3BhdGgsIFwiT3B0aW9uczogXFxuXCIgKyBvcHRpb25zX3N0ciArIFwiXFxuXFxuSW5wdXQgZmlsZXM6XFxuXFxuXCIgKyBmaWxlc19zdHIoZmlsZXMpICsgXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uKiBtaW5pZnlfc3luY19vcl9hc3luYyhmaWxlcywgb3B0aW9ucywgX2ZzX21vZHVsZSkge1xuICAgIGlmIChcbiAgICAgICAgX2ZzX21vZHVsZVxuICAgICAgICAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIlxuICAgICAgICAmJiBwcm9jZXNzLmVudlxuICAgICAgICAmJiB0eXBlb2YgcHJvY2Vzcy5lbnYuVEVSU0VSX0RFQlVHX0RJUiA9PT0gXCJzdHJpbmdcIlxuICAgICkge1xuICAgICAgICBsb2dfaW5wdXQoZmlsZXMsIG9wdGlvbnMsIF9mc19tb2R1bGUsIHByb2Nlc3MuZW52LlRFUlNFUl9ERUJVR19ESVIpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGNvbXByZXNzOiB7fSxcbiAgICAgICAgZWNtYTogdW5kZWZpbmVkLFxuICAgICAgICBlbmNsb3NlOiBmYWxzZSxcbiAgICAgICAgaWU4OiBmYWxzZSxcbiAgICAgICAga2VlcF9jbGFzc25hbWVzOiB1bmRlZmluZWQsXG4gICAgICAgIGtlZXBfZm5hbWVzOiBmYWxzZSxcbiAgICAgICAgbWFuZ2xlOiB7fSxcbiAgICAgICAgbW9kdWxlOiBmYWxzZSxcbiAgICAgICAgbmFtZUNhY2hlOiBudWxsLFxuICAgICAgICBvdXRwdXQ6IG51bGwsXG4gICAgICAgIGZvcm1hdDogbnVsbCxcbiAgICAgICAgcGFyc2U6IHt9LFxuICAgICAgICByZW5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgc2FmYXJpMTA6IGZhbHNlLFxuICAgICAgICBzb3VyY2VNYXA6IGZhbHNlLFxuICAgICAgICBzcGlkZXJtb25rZXk6IGZhbHNlLFxuICAgICAgICB0aW1pbmdzOiBmYWxzZSxcbiAgICAgICAgdG9wbGV2ZWw6IGZhbHNlLFxuICAgICAgICB3YXJuaW5nczogZmFsc2UsXG4gICAgICAgIHdyYXA6IGZhbHNlLFxuICAgIH0sIHRydWUpO1xuXG4gICAgdmFyIHRpbWluZ3MgPSBvcHRpb25zLnRpbWluZ3MgJiYge1xuICAgICAgICBzdGFydDogRGF0ZS5ub3coKVxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMua2VlcF9jbGFzc25hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5rZWVwX2NsYXNzbmFtZXMgPSBvcHRpb25zLmtlZXBfZm5hbWVzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZW5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLnJlbmFtZSA9IG9wdGlvbnMuY29tcHJlc3MgJiYgb3B0aW9ucy5tYW5nbGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm91dHB1dCAmJiBvcHRpb25zLmZvcm1hdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugb25seSBzcGVjaWZ5IGVpdGhlciBvdXRwdXQgb3IgZm9ybWF0IG9wdGlvbiwgcHJlZmVycmFibHkgZm9ybWF0LlwiKTtcbiAgICB9XG4gICAgb3B0aW9ucy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBvcHRpb25zLm91dHB1dCB8fCB7fTtcbiAgICBzZXRfc2hvcnRoYW5kKFwiZWNtYVwiLCBvcHRpb25zLCBbIFwicGFyc2VcIiwgXCJjb21wcmVzc1wiLCBcImZvcm1hdFwiIF0pO1xuICAgIHNldF9zaG9ydGhhbmQoXCJpZThcIiwgb3B0aW9ucywgWyBcImNvbXByZXNzXCIsIFwibWFuZ2xlXCIsIFwiZm9ybWF0XCIgXSk7XG4gICAgc2V0X3Nob3J0aGFuZChcImtlZXBfY2xhc3NuYW1lc1wiLCBvcHRpb25zLCBbIFwiY29tcHJlc3NcIiwgXCJtYW5nbGVcIiBdKTtcbiAgICBzZXRfc2hvcnRoYW5kKFwia2VlcF9mbmFtZXNcIiwgb3B0aW9ucywgWyBcImNvbXByZXNzXCIsIFwibWFuZ2xlXCIgXSk7XG4gICAgc2V0X3Nob3J0aGFuZChcIm1vZHVsZVwiLCBvcHRpb25zLCBbIFwicGFyc2VcIiwgXCJjb21wcmVzc1wiLCBcIm1hbmdsZVwiIF0pO1xuICAgIHNldF9zaG9ydGhhbmQoXCJzYWZhcmkxMFwiLCBvcHRpb25zLCBbIFwibWFuZ2xlXCIsIFwiZm9ybWF0XCIgXSk7XG4gICAgc2V0X3Nob3J0aGFuZChcInRvcGxldmVsXCIsIG9wdGlvbnMsIFsgXCJjb21wcmVzc1wiLCBcIm1hbmdsZVwiIF0pO1xuICAgIHNldF9zaG9ydGhhbmQoXCJ3YXJuaW5nc1wiLCBvcHRpb25zLCBbIFwiY29tcHJlc3NcIiBdKTsgLy8gbGVnYWN5XG4gICAgdmFyIHF1b3RlZF9wcm9wcztcbiAgICBpZiAob3B0aW9ucy5tYW5nbGUpIHtcbiAgICAgICAgb3B0aW9ucy5tYW5nbGUgPSBkZWZhdWx0cyhvcHRpb25zLm1hbmdsZSwge1xuICAgICAgICAgICAgY2FjaGU6IG9wdGlvbnMubmFtZUNhY2hlICYmIChvcHRpb25zLm5hbWVDYWNoZS52YXJzIHx8IHt9KSxcbiAgICAgICAgICAgIGV2YWw6IGZhbHNlLFxuICAgICAgICAgICAgaWU4OiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBfY2xhc3NuYW1lczogZmFsc2UsXG4gICAgICAgICAgICBrZWVwX2ZuYW1lczogZmFsc2UsXG4gICAgICAgICAgICBtb2R1bGU6IGZhbHNlLFxuICAgICAgICAgICAgbnRoX2lkZW50aWZpZXI6IGJhc2U1NCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgICAgICAgcmVzZXJ2ZWQ6IFtdLFxuICAgICAgICAgICAgc2FmYXJpMTA6IGZhbHNlLFxuICAgICAgICAgICAgdG9wbGV2ZWw6IGZhbHNlLFxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubWFuZ2xlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYW5nbGUucHJvcGVydGllcyAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tYW5nbGUucHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFuZ2xlLnByb3BlcnRpZXMua2VlcF9xdW90ZWQpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWRfcHJvcHMgPSBvcHRpb25zLm1hbmdsZS5wcm9wZXJ0aWVzLnJlc2VydmVkO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShxdW90ZWRfcHJvcHMpKSBxdW90ZWRfcHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1hbmdsZS5wcm9wZXJ0aWVzLnJlc2VydmVkID0gcXVvdGVkX3Byb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubmFtZUNhY2hlICYmICEoXCJjYWNoZVwiIGluIG9wdGlvbnMubWFuZ2xlLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tYW5nbGUucHJvcGVydGllcy5jYWNoZSA9IG9wdGlvbnMubmFtZUNhY2hlLnByb3BzIHx8IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluaXRfY2FjaGUob3B0aW9ucy5tYW5nbGUuY2FjaGUpO1xuICAgICAgICBpbml0X2NhY2hlKG9wdGlvbnMubWFuZ2xlLnByb3BlcnRpZXMuY2FjaGUpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXApIHtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VNYXAgPSBkZWZhdWx0cyhvcHRpb25zLnNvdXJjZU1hcCwge1xuICAgICAgICAgICAgYXNPYmplY3Q6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogbnVsbCxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBudWxsLFxuICAgICAgICAgICAgaW5jbHVkZVNvdXJjZXM6IGZhbHNlLFxuICAgICAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gLS0gUGFyc2UgcGhhc2UgLS1cbiAgICBpZiAodGltaW5ncykgdGltaW5ncy5wYXJzZSA9IERhdGUubm93KCk7XG4gICAgdmFyIHRvcGxldmVsO1xuICAgIGlmIChmaWxlcyBpbnN0YW5jZW9mIEFTVF9Ub3BsZXZlbCkge1xuICAgICAgICB0b3BsZXZlbCA9IGZpbGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZXMgPT0gXCJzdHJpbmdcIiB8fCAob3B0aW9ucy5wYXJzZS5zcGlkZXJtb25rZXkgJiYgIUFycmF5LmlzQXJyYXkoZmlsZXMpKSkge1xuICAgICAgICAgICAgZmlsZXMgPSBbIGZpbGVzIF07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5wYXJzZSA9IG9wdGlvbnMucGFyc2UgfHwge307XG4gICAgICAgIG9wdGlvbnMucGFyc2UudG9wbGV2ZWwgPSBudWxsO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnBhcnNlLnNwaWRlcm1vbmtleSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJzZS50b3BsZXZlbCA9IEFTVF9Ob2RlLmZyb21fbW96aWxsYV9hc3QoT2JqZWN0LmtleXMoZmlsZXMpLnJlZHVjZShmdW5jdGlvbih0b3BsZXZlbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghdG9wbGV2ZWwpIHJldHVybiBmaWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB0b3BsZXZlbC5ib2R5ID0gdG9wbGV2ZWwuYm9keS5jb25jYXQoZmlsZXNbbmFtZV0uYm9keSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvcGxldmVsO1xuICAgICAgICAgICAgfSwgbnVsbCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMucGFyc2Uuc3BpZGVybW9ua2V5O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGZpbGVzKSBpZiAoSE9QKGZpbGVzLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyc2UuZmlsZW5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyc2UudG9wbGV2ZWwgPSBwYXJzZShmaWxlc1tuYW1lXSwgb3B0aW9ucy5wYXJzZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwICYmIG9wdGlvbnMuc291cmNlTWFwLmNvbnRlbnQgPT0gXCJpbmxpbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZmlsZXMpLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmxpbmUgc291cmNlIG1hcCBvbmx5IHdvcmtzIHdpdGggc2luZ3VsYXIgaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc291cmNlTWFwLmNvbnRlbnQgPSByZWFkX3NvdXJjZV9tYXAoZmlsZXNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wYXJzZS50b3BsZXZlbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc291cmNlIGZpbGUgZ2l2ZW5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB0b3BsZXZlbCA9IG9wdGlvbnMucGFyc2UudG9wbGV2ZWw7XG4gICAgfVxuICAgIGlmIChxdW90ZWRfcHJvcHMgJiYgb3B0aW9ucy5tYW5nbGUucHJvcGVydGllcy5rZWVwX3F1b3RlZCAhPT0gXCJzdHJpY3RcIikge1xuICAgICAgICByZXNlcnZlX3F1b3RlZF9rZXlzKHRvcGxldmVsLCBxdW90ZWRfcHJvcHMpO1xuICAgIH1cbiAgICB2YXIgYW5ub3RhdGVkX3Byb3BzO1xuICAgIGlmIChvcHRpb25zLm1hbmdsZSAmJiBvcHRpb25zLm1hbmdsZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGFubm90YXRlZF9wcm9wcyA9IGZpbmRfYW5ub3RhdGVkX3Byb3BzKHRvcGxldmVsKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud3JhcCkge1xuICAgICAgICB0b3BsZXZlbCA9IHRvcGxldmVsLndyYXBfY29tbW9uanMob3B0aW9ucy53cmFwKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZW5jbG9zZSkge1xuICAgICAgICB0b3BsZXZlbCA9IHRvcGxldmVsLndyYXBfZW5jbG9zZShvcHRpb25zLmVuY2xvc2UpO1xuICAgIH1cbiAgICBpZiAodGltaW5ncykgdGltaW5ncy5yZW5hbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gLS0gQ29tcHJlc3MgcGhhc2UgLS1cbiAgICBpZiAodGltaW5ncykgdGltaW5ncy5jb21wcmVzcyA9IERhdGUubm93KCk7XG4gICAgaWYgKG9wdGlvbnMuY29tcHJlc3MpIHtcbiAgICAgICAgdG9wbGV2ZWwgPSBuZXcgQ29tcHJlc3NvcihvcHRpb25zLmNvbXByZXNzLCB7XG4gICAgICAgICAgICBtYW5nbGVfb3B0aW9uczogb3B0aW9ucy5tYW5nbGVcbiAgICAgICAgfSkuY29tcHJlc3ModG9wbGV2ZWwpO1xuICAgIH1cblxuICAgIC8vIC0tIE1hbmdsZSBwaGFzZSAtLVxuICAgIGlmICh0aW1pbmdzKSB0aW1pbmdzLnNjb3BlID0gRGF0ZS5ub3coKTtcbiAgICBpZiAob3B0aW9ucy5tYW5nbGUpIHRvcGxldmVsLmZpZ3VyZV9vdXRfc2NvcGUob3B0aW9ucy5tYW5nbGUpO1xuICAgIGlmICh0aW1pbmdzKSB0aW1pbmdzLm1hbmdsZSA9IERhdGUubm93KCk7XG4gICAgaWYgKG9wdGlvbnMubWFuZ2xlKSB7XG4gICAgICAgIHRvcGxldmVsLmNvbXB1dGVfY2hhcl9mcmVxdWVuY3kob3B0aW9ucy5tYW5nbGUpO1xuICAgICAgICB0b3BsZXZlbC5tYW5nbGVfbmFtZXMob3B0aW9ucy5tYW5nbGUpO1xuICAgICAgICB0b3BsZXZlbCA9IG1hbmdsZV9wcml2YXRlX3Byb3BlcnRpZXModG9wbGV2ZWwsIG9wdGlvbnMubWFuZ2xlKTtcbiAgICB9XG4gICAgaWYgKHRpbWluZ3MpIHRpbWluZ3MucHJvcGVydGllcyA9IERhdGUubm93KCk7XG4gICAgaWYgKG9wdGlvbnMubWFuZ2xlICYmIG9wdGlvbnMubWFuZ2xlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgdG9wbGV2ZWwgPSBtYW5nbGVfcHJvcGVydGllcyh0b3BsZXZlbCwgb3B0aW9ucy5tYW5nbGUucHJvcGVydGllcywgYW5ub3RhdGVkX3Byb3BzKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgcGhhc2VcbiAgICBpZiAodGltaW5ncykgdGltaW5ncy5mb3JtYXQgPSBEYXRlLm5vdygpO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5mb3JtYXQuYXN0KSB7XG4gICAgICAgIHJlc3VsdC5hc3QgPSB0b3BsZXZlbDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZm9ybWF0LnNwaWRlcm1vbmtleSkge1xuICAgICAgICByZXN1bHQuYXN0ID0gdG9wbGV2ZWwudG9fbW96aWxsYV9hc3QoKTtcbiAgICB9XG4gICAgbGV0IGZvcm1hdF9vcHRpb25zO1xuICAgIGlmICghSE9QKG9wdGlvbnMuZm9ybWF0LCBcImNvZGVcIikgfHwgb3B0aW9ucy5mb3JtYXQuY29kZSkge1xuICAgICAgICAvLyBNYWtlIGEgc2hhbGxvdyBjb3B5IHNvIHRoYXQgd2UgY2FuIG1vZGlmeSB3aXRob3V0IG11dGF0aW5nIHRoZSB1c2VyJ3MgaW5wdXQuXG4gICAgICAgIGZvcm1hdF9vcHRpb25zID0gey4uLm9wdGlvbnMuZm9ybWF0fTtcbiAgICAgICAgaWYgKCFmb3JtYXRfb3B0aW9ucy5hc3QpIHtcbiAgICAgICAgICAgIC8vIERlc3Ryb3kgc3R1ZmYgdG8gc2F2ZSBSQU0uICh1bmxlc3MgdGhlIGRlcHJlY2F0ZWQgYGFzdGAgb3B0aW9uIGlzIG9uKVxuICAgICAgICAgICAgZm9ybWF0X29wdGlvbnMuX2Rlc3Ryb3lfYXN0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgd2Fsayh0b3BsZXZlbCwgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52YXJpYWJsZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZW5jbG9zZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50X3Njb3BlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ibG9ja19zY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmJsb2NrX3Njb3BlLnZhcmlhYmxlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5ibG9ja19zY29wZS5lbmNsb3NlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5ibG9ja19zY29wZS5wYXJlbnRfc2NvcGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcC5pbmNsdWRlU291cmNlcyAmJiBmaWxlcyBpbnN0YW5jZW9mIEFTVF9Ub3BsZXZlbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9yaWdpbmFsIHNvdXJjZSBjb250ZW50IHVuYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9ybWF0X29wdGlvbnMuc291cmNlX21hcCA9IHlpZWxkKiBTb3VyY2VNYXAoe1xuICAgICAgICAgICAgICAgIGZpbGU6IG9wdGlvbnMuc291cmNlTWFwLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG9yaWc6IG9wdGlvbnMuc291cmNlTWFwLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgcm9vdDogb3B0aW9ucy5zb3VyY2VNYXAucm9vdCxcbiAgICAgICAgICAgICAgICBmaWxlczogb3B0aW9ucy5zb3VyY2VNYXAuaW5jbHVkZVNvdXJjZXMgPyBmaWxlcyA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZm9ybWF0X29wdGlvbnMuYXN0O1xuICAgICAgICBkZWxldGUgZm9ybWF0X29wdGlvbnMuY29kZTtcbiAgICAgICAgZGVsZXRlIGZvcm1hdF9vcHRpb25zLnNwaWRlcm1vbmtleTtcbiAgICAgICAgdmFyIHN0cmVhbSA9IE91dHB1dFN0cmVhbShmb3JtYXRfb3B0aW9ucyk7XG4gICAgICAgIHRvcGxldmVsLnByaW50KHN0cmVhbSk7XG4gICAgICAgIHJlc3VsdC5jb2RlID0gc3RyZWFtLmdldCgpO1xuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIFwibWFwXCIsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcCA9IGZvcm1hdF9vcHRpb25zLnNvdXJjZV9tYXAuZ2V0RW5jb2RlZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdC5tYXAgPSBvcHRpb25zLnNvdXJjZU1hcC5hc09iamVjdCA/IG1hcCA6IEpTT04uc3RyaW5naWZ5KG1hcCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIFwibWFwXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LmRlY29kZWRfbWFwID0gZm9ybWF0X29wdGlvbnMuc291cmNlX21hcC5nZXREZWNvZGVkKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXAudXJsID09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlTWFwID0gdHlwZW9mIHJlc3VsdC5tYXAgPT09IFwib2JqZWN0XCIgPyBKU09OLnN0cmluZ2lmeShyZXN1bHQubWFwKSA6IHJlc3VsdC5tYXA7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvZGUgKz0gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIgKyB0b19iYXNlNjQoc291cmNlTWFwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zb3VyY2VNYXAudXJsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvZGUgKz0gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1cIiArIG9wdGlvbnMuc291cmNlTWFwLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uYW1lQ2FjaGUgJiYgb3B0aW9ucy5tYW5nbGUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubWFuZ2xlLmNhY2hlKSBvcHRpb25zLm5hbWVDYWNoZS52YXJzID0gY2FjaGVfdG9fanNvbihvcHRpb25zLm1hbmdsZS5jYWNoZSk7XG4gICAgICAgIGlmIChvcHRpb25zLm1hbmdsZS5wcm9wZXJ0aWVzICYmIG9wdGlvbnMubWFuZ2xlLnByb3BlcnRpZXMuY2FjaGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubmFtZUNhY2hlLnByb3BzID0gY2FjaGVfdG9fanNvbihvcHRpb25zLm1hbmdsZS5wcm9wZXJ0aWVzLmNhY2hlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9ybWF0X29wdGlvbnMgJiYgZm9ybWF0X29wdGlvbnMuc291cmNlX21hcCkge1xuICAgICAgICBmb3JtYXRfb3B0aW9ucy5zb3VyY2VfbWFwLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRpbWluZ3MpIHtcbiAgICAgICAgdGltaW5ncy5lbmQgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXN1bHQudGltaW5ncyA9IHtcbiAgICAgICAgICAgIHBhcnNlOiAxZS0zICogKHRpbWluZ3MucmVuYW1lIC0gdGltaW5ncy5wYXJzZSksXG4gICAgICAgICAgICByZW5hbWU6IDFlLTMgKiAodGltaW5ncy5jb21wcmVzcyAtIHRpbWluZ3MucmVuYW1lKSxcbiAgICAgICAgICAgIGNvbXByZXNzOiAxZS0zICogKHRpbWluZ3Muc2NvcGUgLSB0aW1pbmdzLmNvbXByZXNzKSxcbiAgICAgICAgICAgIHNjb3BlOiAxZS0zICogKHRpbWluZ3MubWFuZ2xlIC0gdGltaW5ncy5zY29wZSksXG4gICAgICAgICAgICBtYW5nbGU6IDFlLTMgKiAodGltaW5ncy5wcm9wZXJ0aWVzIC0gdGltaW5ncy5tYW5nbGUpLFxuICAgICAgICAgICAgcHJvcGVydGllczogMWUtMyAqICh0aW1pbmdzLmZvcm1hdCAtIHRpbWluZ3MucHJvcGVydGllcyksXG4gICAgICAgICAgICBmb3JtYXQ6IDFlLTMgKiAodGltaW5ncy5lbmQgLSB0aW1pbmdzLmZvcm1hdCksXG4gICAgICAgICAgICB0b3RhbDogMWUtMyAqICh0aW1pbmdzLmVuZCAtIHRpbWluZ3Muc3RhcnQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1pbmlmeShmaWxlcywgb3B0aW9ucywgX2ZzX21vZHVsZSkge1xuICAgIGNvbnN0IGdlbiA9IG1pbmlmeV9zeW5jX29yX2FzeW5jKGZpbGVzLCBvcHRpb25zLCBfZnNfbW9kdWxlKTtcblxuICAgIGxldCB5aWVsZGVkO1xuICAgIGxldCB2YWw7XG4gICAgZG8ge1xuICAgICAgICB2YWwgPSBnZW4ubmV4dChhd2FpdCB5aWVsZGVkKTtcbiAgICAgICAgeWllbGRlZCA9IHZhbC52YWx1ZTtcbiAgICB9IHdoaWxlICghdmFsLmRvbmUpO1xuXG4gICAgcmV0dXJuIHZhbC52YWx1ZTtcbn1cblxuZnVuY3Rpb24gbWluaWZ5X3N5bmMoZmlsZXMsIG9wdGlvbnMsIF9mc19tb2R1bGUpIHtcbiAgICBjb25zdCBnZW4gPSBtaW5pZnlfc3luY19vcl9hc3luYyhmaWxlcywgb3B0aW9ucywgX2ZzX21vZHVsZSk7XG5cbiAgICBsZXQgeWllbGRlZDtcbiAgICBsZXQgdmFsO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHlpZWxkZWQgJiYgdHlwZW9mIHlpZWxkZWQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaW5pZnlfc3luYyBjYW5ub3QgYmUgdXNlZCB3aXRoIHRoZSBsZWdhY3kgc291cmNlLW1hcCBtb2R1bGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gZ2VuLm5leHQoeWllbGRlZCk7XG4gICAgICAgIHlpZWxkZWQgPSB2YWwudmFsdWU7XG4gICAgfSB3aGlsZSAoIXZhbC5kb25lKTtcblxuICAgIHJldHVybiB2YWwudmFsdWU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bl9jbGkoeyBwcm9ncmFtLCBwYWNrYWdlSnNvbiwgZnMsIHBhdGggfSkge1xuICAgIGNvbnN0IHNraXBfa2V5cyA9IG5ldyBTZXQoWyBcImNuYW1lXCIsIFwicGFyZW50X3Njb3BlXCIsIFwic2NvcGVcIiwgXCJ1c2VzX2V2YWxcIiwgXCJ1c2VzX3dpdGhcIiBdKTtcbiAgICB2YXIgZmlsZXMgPSB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgY29tcHJlc3M6IGZhbHNlLFxuICAgICAgICBtYW5nbGU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBkZWZhdWx0X29wdGlvbnMgPSBhd2FpdCBfZGVmYXVsdF9vcHRpb25zKCk7XG4gICAgcHJvZ3JhbS52ZXJzaW9uKHBhY2thZ2VKc29uLm5hbWUgKyBcIiBcIiArIHBhY2thZ2VKc29uLnZlcnNpb24pO1xuICAgIHByb2dyYW0ucGFyc2VBcmd2ID0gcHJvZ3JhbS5wYXJzZTtcbiAgICBwcm9ncmFtLnBhcnNlID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHByb2Nlc3MuYXJndi5pbmNsdWRlcyhcImFzdFwiKSkgcHJvZ3JhbS5oZWxwSW5mb3JtYXRpb24gPSBkZXNjcmliZV9hc3Q7XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5hcmd2LmluY2x1ZGVzKFwib3B0aW9uc1wiKSkgcHJvZ3JhbS5oZWxwSW5mb3JtYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRleHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIGRlZmF1bHRfb3B0aW9ucykge1xuICAgICAgICAgICAgdGV4dC5wdXNoKFwiLS1cIiArIChvcHRpb24gPT09IFwic291cmNlTWFwXCIgPyBcInNvdXJjZS1tYXBcIiA6IG9wdGlvbikgKyBcIiBvcHRpb25zOlwiKTtcbiAgICAgICAgICAgIHRleHQucHVzaChmb3JtYXRfb2JqZWN0KGRlZmF1bHRfb3B0aW9uc1tvcHRpb25dKSk7XG4gICAgICAgICAgICB0ZXh0LnB1c2goXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuam9pbihcIlxcblwiKTtcbiAgICB9O1xuXG4gICAgcHJvZ3JhbS5vcHRpb24oXCItcCwgLS1wYXJzZSA8b3B0aW9ucz5cIiwgXCJTcGVjaWZ5IHBhcnNlciBvcHRpb25zLlwiLCBwYXJzZV9qcygpKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi1jLCAtLWNvbXByZXNzIFtvcHRpb25zXVwiLCBcIkVuYWJsZSBjb21wcmVzc29yL3NwZWNpZnkgY29tcHJlc3NvciBvcHRpb25zLlwiLCBwYXJzZV9qcygpKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi1tLCAtLW1hbmdsZSBbb3B0aW9uc11cIiwgXCJNYW5nbGUgbmFtZXMvc3BlY2lmeSBtYW5nbGVyIG9wdGlvbnMuXCIsIHBhcnNlX2pzKCkpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS1tYW5nbGUtcHJvcHMgW29wdGlvbnNdXCIsIFwiTWFuZ2xlIHByb3BlcnRpZXMvc3BlY2lmeSBtYW5nbGVyIG9wdGlvbnMuXCIsIHBhcnNlX2pzKCkpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLWYsIC0tZm9ybWF0IFtvcHRpb25zXVwiLCBcIkZvcm1hdCBvcHRpb25zLlwiLCBwYXJzZV9qcygpKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi1iLCAtLWJlYXV0aWZ5IFtvcHRpb25zXVwiLCBcIkFsaWFzIGZvciAtLWZvcm1hdC5cIiwgcGFyc2VfanMoKSk7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItbywgLS1vdXRwdXQgPGZpbGU+XCIsIFwiT3V0cHV0IGZpbGUgKGRlZmF1bHQgU1RET1VUKS5cIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLWNvbW1lbnRzIFtmaWx0ZXJdXCIsIFwiUHJlc2VydmUgY29weXJpZ2h0IGNvbW1lbnRzIGluIHRoZSBvdXRwdXQuXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS1jb25maWctZmlsZSA8ZmlsZT5cIiwgXCJSZWFkIG1pbmlmeSgpIG9wdGlvbnMgZnJvbSBKU09OIGZpbGUuXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLWQsIC0tZGVmaW5lIDxleHByPls9dmFsdWVdXCIsIFwiR2xvYmFsIGRlZmluaXRpb25zLlwiLCBwYXJzZV9qcyhcImRlZmluZVwiKSk7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLWVjbWEgPHZlcnNpb24+XCIsIFwiU3BlY2lmeSBFQ01BU2NyaXB0IHJlbGVhc2U6IDUsIDIwMTUsIDIwMTYgb3IgMjAxNy4uLlwiKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi1lLCAtLWVuY2xvc2UgW2FyZ1ssLi4uXVs6dmFsdWVbLC4uLl1dXVwiLCBcIkVtYmVkIG91dHB1dCBpbiBhIGJpZyBmdW5jdGlvbiB3aXRoIGNvbmZpZ3VyYWJsZSBhcmd1bWVudHMgYW5kIHZhbHVlcy5cIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLWllOFwiLCBcIlN1cHBvcnQgbm9uLXN0YW5kYXJkIEludGVybmV0IEV4cGxvcmVyIDguXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS1rZWVwLWNsYXNzbmFtZXNcIiwgXCJEbyBub3QgbWFuZ2xlL2Ryb3AgY2xhc3MgbmFtZXMuXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS1rZWVwLWZuYW1lc1wiLCBcIkRvIG5vdCBtYW5nbGUvZHJvcCBmdW5jdGlvbiBuYW1lcy4gVXNlZnVsIGZvciBjb2RlIHJlbHlpbmcgb24gRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUuXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS1tb2R1bGVcIiwgXCJJbnB1dCBpcyBhbiBFUzYgbW9kdWxlXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS1uYW1lLWNhY2hlIDxmaWxlPlwiLCBcIkZpbGUgdG8gaG9sZCBtYW5nbGVkIG5hbWUgbWFwcGluZ3MuXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS1yZW5hbWVcIiwgXCJGb3JjZSBzeW1ib2wgZXhwYW5zaW9uLlwiKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi0tbm8tcmVuYW1lXCIsIFwiRGlzYWJsZSBzeW1ib2wgZXhwYW5zaW9uLlwiKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi0tc2FmYXJpMTBcIiwgXCJTdXBwb3J0IG5vbi1zdGFuZGFyZCBTYWZhcmkgMTAuXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS1zb3VyY2UtbWFwIFtvcHRpb25zXVwiLCBcIkVuYWJsZSBzb3VyY2UgbWFwL3NwZWNpZnkgc291cmNlIG1hcCBvcHRpb25zLlwiLCBwYXJzZV9qcygpKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi0tdGltaW5nc1wiLCBcIkRpc3BsYXkgb3BlcmF0aW9ucyBydW4gdGltZSBvbiBTVERFUlIuXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS10b3BsZXZlbFwiLCBcIkNvbXByZXNzIGFuZC9vciBtYW5nbGUgdmFyaWFibGVzIGluIHRvcGxldmVsIHNjb3BlLlwiKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi0td3JhcCA8bmFtZT5cIiwgXCJFbWJlZCBldmVyeXRoaW5nIGFzIGEgZnVuY3Rpb24gd2l0aCDigJxleHBvcnRz4oCdIGNvcnJlc3BvbmRpbmcgdG8g4oCcbmFtZeKAnSBnbG9iYWxseS5cIik7XG4gICAgcHJvZ3JhbS5hcmd1bWVudHMoXCJbZmlsZXMuLi5dXCIpLnBhcnNlQXJndihwcm9jZXNzLmFyZ3YpO1xuICAgIGlmIChwcm9ncmFtLmNvbmZpZ0ZpbGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IEpTT04ucGFyc2UocmVhZF9maWxlKHByb2dyYW0uY29uZmlnRmlsZSkpO1xuICAgIH1cbiAgICBpZiAoIXByb2dyYW0ub3V0cHV0ICYmIHByb2dyYW0uc291cmNlTWFwICYmIHByb2dyYW0uc291cmNlTWFwLnVybCAhPSBcImlubGluZVwiKSB7XG4gICAgICAgIGZhdGFsKFwiRVJST1I6IGNhbm5vdCB3cml0ZSBzb3VyY2UgbWFwIHRvIFNURE9VVFwiKTtcbiAgICB9XG5cbiAgICBbXG4gICAgICAgIFwiY29tcHJlc3NcIixcbiAgICAgICAgXCJlbmNsb3NlXCIsXG4gICAgICAgIFwiaWU4XCIsXG4gICAgICAgIFwibWFuZ2xlXCIsXG4gICAgICAgIFwibW9kdWxlXCIsXG4gICAgICAgIFwic2FmYXJpMTBcIixcbiAgICAgICAgXCJzb3VyY2VNYXBcIixcbiAgICAgICAgXCJ0b3BsZXZlbFwiLFxuICAgICAgICBcIndyYXBcIlxuICAgIF0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHByb2dyYW0pIHtcbiAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSBwcm9ncmFtW25hbWVdO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoXCJlY21hXCIgaW4gcHJvZ3JhbSkge1xuICAgICAgICBpZiAocHJvZ3JhbS5lY21hICE9IChwcm9ncmFtLmVjbWEgfCAwKSkgZmF0YWwoXCJFUlJPUjogZWNtYSBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gICAgICAgIGNvbnN0IGVjbWEgPSBwcm9ncmFtLmVjbWEgfCAwO1xuICAgICAgICBpZiAoZWNtYSA+IDUgJiYgZWNtYSA8IDIwMTUpXG4gICAgICAgICAgICBvcHRpb25zLmVjbWEgPSBlY21hICsgMjAwOTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3B0aW9ucy5lY21hID0gZWNtYTtcbiAgICB9XG4gICAgaWYgKHByb2dyYW0uZm9ybWF0IHx8IHByb2dyYW0uYmVhdXRpZnkpIHtcbiAgICAgICAgY29uc3QgY2hvc2VuT3B0aW9uID0gcHJvZ3JhbS5mb3JtYXQgfHwgcHJvZ3JhbS5iZWF1dGlmeTtcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSB0eXBlb2YgY2hvc2VuT3B0aW9uID09PSBcIm9iamVjdFwiID8gY2hvc2VuT3B0aW9uIDoge307XG4gICAgfVxuICAgIGlmIChwcm9ncmFtLmNvbW1lbnRzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb3JtYXQgIT0gXCJvYmplY3RcIikgb3B0aW9ucy5mb3JtYXQgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQuY29tbWVudHMgPSB0eXBlb2YgcHJvZ3JhbS5jb21tZW50cyA9PSBcInN0cmluZ1wiID8gKHByb2dyYW0uY29tbWVudHMgPT0gXCJmYWxzZVwiID8gZmFsc2UgOiBwcm9ncmFtLmNvbW1lbnRzKSA6IFwic29tZVwiO1xuICAgIH1cbiAgICBpZiAocHJvZ3JhbS5kZWZpbmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbXByZXNzICE9IFwib2JqZWN0XCIpIG9wdGlvbnMuY29tcHJlc3MgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbXByZXNzLmdsb2JhbF9kZWZzICE9IFwib2JqZWN0XCIpIG9wdGlvbnMuY29tcHJlc3MuZ2xvYmFsX2RlZnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZXhwciBpbiBwcm9ncmFtLmRlZmluZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5jb21wcmVzcy5nbG9iYWxfZGVmc1tleHByXSA9IHByb2dyYW0uZGVmaW5lW2V4cHJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9ncmFtLmtlZXBDbGFzc25hbWVzKSB7XG4gICAgICAgIG9wdGlvbnMua2VlcF9jbGFzc25hbWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb2dyYW0ua2VlcEZuYW1lcykge1xuICAgICAgICBvcHRpb25zLmtlZXBfZm5hbWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb2dyYW0ubWFuZ2xlUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb2dyYW0ubWFuZ2xlUHJvcHMuZG9tcHJvcHMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9ncmFtLm1hbmdsZVByb3BzLmRvbXByb3BzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9ncmFtLm1hbmdsZVByb3BzICE9IFwib2JqZWN0XCIpIHByb2dyYW0ubWFuZ2xlUHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9ncmFtLm1hbmdsZVByb3BzLnJlc2VydmVkKSkgcHJvZ3JhbS5tYW5nbGVQcm9wcy5yZXNlcnZlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYW5nbGUgIT0gXCJvYmplY3RcIikgb3B0aW9ucy5tYW5nbGUgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5tYW5nbGUucHJvcGVydGllcyA9IHByb2dyYW0ubWFuZ2xlUHJvcHM7XG4gICAgfVxuICAgIGlmIChwcm9ncmFtLm5hbWVDYWNoZSkge1xuICAgICAgICBvcHRpb25zLm5hbWVDYWNoZSA9IEpTT04ucGFyc2UocmVhZF9maWxlKHByb2dyYW0ubmFtZUNhY2hlLCBcInt9XCIpKTtcbiAgICB9XG4gICAgaWYgKHByb2dyYW0ub3V0cHV0ID09IFwiYXN0XCIpIHtcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSB7XG4gICAgICAgICAgICBhc3Q6IHRydWUsXG4gICAgICAgICAgICBjb2RlOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAocHJvZ3JhbS5wYXJzZSkge1xuICAgICAgICBpZiAoIXByb2dyYW0ucGFyc2UuYWNvcm4gJiYgIXByb2dyYW0ucGFyc2Uuc3BpZGVybW9ua2V5KSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhcnNlID0gcHJvZ3JhbS5wYXJzZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9ncmFtLnNvdXJjZU1hcCAmJiBwcm9ncmFtLnNvdXJjZU1hcC5jb250ZW50ID09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgICAgIGZhdGFsKFwiRVJST1I6IGlubGluZSBzb3VyY2UgbWFwIG9ubHkgd29ya3Mgd2l0aCBidWlsdC1pbiBwYXJzZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKH5wcm9ncmFtLnJhd0FyZ3MuaW5kZXhPZihcIi0tcmVuYW1lXCIpKSB7XG4gICAgICAgIG9wdGlvbnMucmVuYW1lID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFwcm9ncmFtLnJlbmFtZSkge1xuICAgICAgICBvcHRpb25zLnJlbmFtZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBjb252ZXJ0X3BhdGggPSBuYW1lID0+IG5hbWU7XG4gICAgaWYgKHR5cGVvZiBwcm9ncmFtLnNvdXJjZU1hcCA9PSBcIm9iamVjdFwiICYmIFwiYmFzZVwiIGluIHByb2dyYW0uc291cmNlTWFwKSB7XG4gICAgICAgIGNvbnZlcnRfcGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBwcm9ncmFtLnNvdXJjZU1hcC5iYXNlO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuc291cmNlTWFwLmJhc2U7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLnJlbGF0aXZlKGJhc2UsIG5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgIH1cblxuICAgIGxldCBmaWxlc0xpc3Q7XG4gICAgaWYgKG9wdGlvbnMuZmlsZXMgJiYgb3B0aW9ucy5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgZmlsZXNMaXN0ID0gb3B0aW9ucy5maWxlcztcblxuICAgICAgICBkZWxldGUgb3B0aW9ucy5maWxlcztcbiAgICB9IGVsc2UgaWYgKHByb2dyYW0uYXJncy5sZW5ndGgpIHtcbiAgICAgICAgZmlsZXNMaXN0ID0gcHJvZ3JhbS5hcmdzO1xuICAgIH1cblxuICAgIGlmIChmaWxlc0xpc3QpIHtcbiAgICAgICAgc2ltcGxlX2dsb2IoZmlsZXNMaXN0KS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGZpbGVzW2NvbnZlcnRfcGF0aChuYW1lKV0gPSByZWFkX2ZpbGUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB2YXIgY2h1bmtzID0gW107XG4gICAgICAgICAgICBwcm9jZXNzLnN0ZGluLnNldEVuY29kaW5nKFwidXRmOFwiKTtcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkaW4ub24oXCJkYXRhXCIsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfSkub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZmlsZXMgPSBbIGNodW5rcy5qb2luKFwiXCIpIF07XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9jZXNzLnN0ZGluLnJlc3VtZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhd2FpdCBydW5fY2xpKCk7XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0X2FzdChmbikge1xuICAgICAgICByZXR1cm4gQVNUX05vZGUuZnJvbV9tb3ppbGxhX2FzdChPYmplY3Qua2V5cyhmaWxlcykucmVkdWNlKGZuLCBudWxsKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcnVuX2NsaSgpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBwcm9ncmFtLnNvdXJjZU1hcCAmJiBwcm9ncmFtLnNvdXJjZU1hcC5jb250ZW50O1xuICAgICAgICBpZiAoY29udGVudCAmJiBjb250ZW50ICE9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNvdXJjZU1hcC5jb250ZW50ID0gcmVhZF9maWxlKGNvbnRlbnQsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtLnRpbWluZ3MpIG9wdGlvbnMudGltaW5ncyA9IHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChwcm9ncmFtLnBhcnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2dyYW0ucGFyc2UuYWNvcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXMgPSBjb252ZXJ0X2FzdChmdW5jdGlvbih0b3BsZXZlbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCJhY29yblwiKS5wYXJzZShmaWxlc1tuYW1lXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjbWFWZXJzaW9uOiAyMDI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmFtOiB0b3BsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWxlOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6IG9wdGlvbnMubW9kdWxlIHx8IHByb2dyYW0ucGFyc2UubW9kdWxlID8gXCJtb2R1bGVcIiA6IFwic2NyaXB0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb2dyYW0ucGFyc2Uuc3BpZGVybW9ua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVzID0gY29udmVydF9hc3QoZnVuY3Rpb24odG9wbGV2ZWwsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBKU09OLnBhcnNlKGZpbGVzW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdG9wbGV2ZWwpIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BsZXZlbC5ib2R5ID0gdG9wbGV2ZWwuYm9keS5jb25jYXQob2JqLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvcGxldmVsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBmYXRhbChleCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgbWluaWZ5KGZpbGVzLCBvcHRpb25zLCBmcyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpZiAoZXgubmFtZSA9PSBcIlN5bnRheEVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICBwcmludF9lcnJvcihcIlBhcnNlIGVycm9yIGF0IFwiICsgZXguZmlsZW5hbWUgKyBcIjpcIiArIGV4LmxpbmUgKyBcIixcIiArIGV4LmNvbCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IGV4LmNvbDtcbiAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBmaWxlc1tleC5maWxlbmFtZV0uc3BsaXQoL1xccj9cXG4vKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2V4LmxpbmUgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmUgJiYgIWNvbCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZXNbZXgubGluZSAtIDJdO1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gNzA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2wgPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoY29sIC0gbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gbGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfZXJyb3IobGluZS5zbGljZSgwLCA4MCkpO1xuICAgICAgICAgICAgICAgICAgICBwcmludF9lcnJvcihsaW5lLnNsaWNlKDAsIGNvbCkucmVwbGFjZSgvXFxTL2csIFwiIFwiKSArIFwiXlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXguZGVmcykge1xuICAgICAgICAgICAgICAgIHByaW50X2Vycm9yKFwiU3VwcG9ydGVkIG9wdGlvbnM6XCIpO1xuICAgICAgICAgICAgICAgIHByaW50X2Vycm9yKGZvcm1hdF9vYmplY3QoZXguZGVmcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmF0YWwoZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2dyYW0ub3V0cHV0ID09IFwiYXN0XCIpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jb21wcmVzcyAmJiAhb3B0aW9ucy5tYW5nbGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXN0LmZpZ3VyZV9vdXRfc2NvcGUoe30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkocmVzdWx0LmFzdCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0aGVkZWZcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWRlZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5jbG9zZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IHZhbHVlLm1hcChzeW1kZWYpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInZhcmlhYmxlc1wiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImdsb2JhbHNcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNpemUgPyBjb2xsZWN0X2Zyb21fbWFwKHZhbHVlLCBzeW1kZWYpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2tpcF9rZXlzLmhhcyhrZXkpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQVNUX1Rva2VuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQVNUX05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzczogXCJBU1RfXCIgKyB2YWx1ZS5UWVBFXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5ibG9ja19zY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhcmlhYmxlcyA9IHZhbHVlLmJsb2NrX3Njb3BlLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbmNsb3NlZCA9IHZhbHVlLmJsb2NrX3Njb3BlLmVuY2xvc2VkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLkNUT1IuUFJPUFMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gXCJibG9ja19zY29wZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsdWVbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LCAyKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvZ3JhbS5vdXRwdXQgPT0gXCJzcGlkZXJtb25rZXlcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5pZmllZCA9IGF3YWl0IG1pbmlmeShcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmdsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG1pbmlmaWVkLmFzdC50b19tb3ppbGxhX2FzdCgpLCBudWxsLCAyKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGZhdGFsKGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvZ3JhbS5vdXRwdXQpIHtcbiAgICAgICAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmRpcm5hbWUocHJvZ3JhbS5vdXRwdXQpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMocHJvZ3JhbS5vdXRwdXQsIHJlc3VsdC5jb2RlKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcCAmJiBvcHRpb25zLnNvdXJjZU1hcC51cmwgIT09IFwiaW5saW5lXCIgJiYgcmVzdWx0Lm1hcCkge1xuICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMocHJvZ3JhbS5vdXRwdXQgKyBcIi5tYXBcIiwgcmVzdWx0Lm1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQuY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW0ubmFtZUNhY2hlKSB7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHByb2dyYW0ubmFtZUNhY2hlLCBKU09OLnN0cmluZ2lmeShvcHRpb25zLm5hbWVDYWNoZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQudGltaW5ncykgZm9yICh2YXIgcGhhc2UgaW4gcmVzdWx0LnRpbWluZ3MpIHtcbiAgICAgICAgICAgIHByaW50X2Vycm9yKFwiLSBcIiArIHBoYXNlICsgXCI6IFwiICsgcmVzdWx0LnRpbWluZ3NbcGhhc2VdLnRvRml4ZWQoMykgKyBcInNcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYXRhbChtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIG1lc3NhZ2UgPSBtZXNzYWdlLnN0YWNrLnJlcGxhY2UoL15cXFMqP0Vycm9yOi8sIFwiRVJST1I6XCIpO1xuICAgICAgICBwcmludF9lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cblxuICAgIC8vIEEgZmlsZSBnbG9iIGZ1bmN0aW9uIHRoYXQgb25seSBzdXBwb3J0cyBcIipcIiBhbmQgXCI/XCIgd2lsZGNhcmRzIGluIHRoZSBiYXNlbmFtZS5cbiAgICAvLyBFeGFtcGxlOiBcImZvby9iYXIvKmJhej8/LiouanNcIlxuICAgIC8vIEFyZ3VtZW50IGBnbG9iYCBtYXkgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MuIEdhcmJhZ2UgaW4sIGdhcmJhZ2Ugb3V0LlxuICAgIGZ1bmN0aW9uIHNpbXBsZV9nbG9iKGdsb2IpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZ2xvYikpIHtcbiAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGdsb2IubWFwKHNpbXBsZV9nbG9iKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsb2IgJiYgZ2xvYi5tYXRjaCgvWyo/XS8pKSB7XG4gICAgICAgICAgICB2YXIgZGlyID0gcGF0aC5kaXJuYW1lKGdsb2IpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IGZzLnJlYWRkaXJTeW5jKGRpcik7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge31cbiAgICAgICAgICAgIGlmIChlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBcIl5cIiArIHBhdGguYmFzZW5hbWUoZ2xvYilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1suK14kW1xcXVxcXFwoKXt9XS9nLCBcIlxcXFwkJlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwqL2csIFwiW14vXFxcXFxcXFxdKlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFw/L2csIFwiW14vXFxcXFxcXFxdXCIpICsgXCIkXCI7XG4gICAgICAgICAgICAgICAgdmFyIG1vZCA9IHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIiA/IFwiaVwiIDogXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgcnggPSBuZXcgUmVnRXhwKHBhdHRlcm4sIG1vZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByeC50ZXN0KG5hbWUpO1xuICAgICAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmpvaW4oZGlyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGgpIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbIGdsb2IgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkX2ZpbGUocGF0aCwgZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhwYXRoLCBcInV0ZjhcIik7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpZiAoKGV4LmNvZGUgPT0gXCJFTk9FTlRcIiB8fCBleC5jb2RlID09IFwiRU5BTUVUT09MT05HXCIpICYmIGRlZmF1bHRfdmFsdWUgIT0gbnVsbCkgcmV0dXJuIGRlZmF1bHRfdmFsdWU7XG4gICAgICAgICAgICBmYXRhbChleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZV9qcyhmbGFnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdhbGsocGFyc2UodmFsdWUsIHsgZXhwcmVzc2lvbjogdHJ1ZSB9KSwgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBub2RlLmxlZnQucHJpbnRfdG9fc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQVNUX0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlLmVsZW1lbnRzLm1hcCh0b19zdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9SZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSBuZXcgUmVnRXhwKHZhbHVlLnNvdXJjZSwgdmFsdWUuZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gdG9fc3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbCB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5wcmludF90b19zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkpIHRocm93IG5vZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdG9fc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQgPyB2YWx1ZS5nZXRWYWx1ZSgpIDogdmFsdWUucHJpbnRfdG9fc3RyaW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZV9rZXlzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhdGFsKFwiRXJyb3IgcGFyc2luZyBhcmd1bWVudHMgZm9yICdcIiArIGZsYWcgKyBcIic6IFwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbdmFsdWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzeW1kZWYoZGVmKSB7XG4gICAgICAgIHZhciByZXQgPSAoMWU2ICsgZGVmLmlkKSArIFwiIFwiICsgZGVmLm5hbWU7XG4gICAgICAgIGlmIChkZWYubWFuZ2xlZF9uYW1lKSByZXQgKz0gXCIgXCIgKyBkZWYubWFuZ2xlZF9uYW1lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RfZnJvbV9tYXAobWFwLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKGRlZikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRfb2JqZWN0KG9iaikge1xuICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBcIlwiO1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBpZiAocGFkZGluZy5sZW5ndGggPCBuYW1lLmxlbmd0aCkgcGFkZGluZyA9IEFycmF5KG5hbWUubGVuZ3RoICsgMSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICByZXR1cm4gWyBuYW1lLCBKU09OLnN0cmluZ2lmeShvYmpbbmFtZV0pIF07XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24odG9rZW5zKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKFwiICBcIiArIHRva2Vuc1swXSArIHBhZGRpbmcuc2xpY2UodG9rZW5zWzBdLmxlbmd0aCAtIDIpICsgdG9rZW5zWzFdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByaW50X2Vycm9yKG1zZykge1xuICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShtc2cpO1xuICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcIlxcblwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXNjcmliZV9hc3QoKSB7XG4gICAgICAgIHZhciBvdXQgPSBPdXRwdXRTdHJlYW0oeyBiZWF1dGlmeTogdHJ1ZSB9KTtcbiAgICAgICAgZnVuY3Rpb24gZG9pdGVtKGN0b3IpIHtcbiAgICAgICAgICAgIG91dC5wcmludChcIkFTVF9cIiArIGN0b3IuVFlQRSk7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IGN0b3IuU0VMRl9QUk9QUy5maWx0ZXIocHJvcCA9PiAhL15cXCQvLnRlc3QocHJvcCkpO1xuXG4gICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG91dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgIG91dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSkgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHJpbnQocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3Rvci5kb2N1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgb3V0LnByaW50X3N0cmluZyhjdG9yLmRvY3VtZW50YXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3Rvci5TVUJDTEFTU0VTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Rvci5TVUJDTEFTU0VTLmZvckVhY2goZnVuY3Rpb24oY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9pdGVtKGN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG9pdGVtKEFTVF9Ob2RlKTtcbiAgICAgICAgcmV0dXJuIG91dCArIFwiXFxuXCI7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfZGVmYXVsdF9vcHRpb25zKCkge1xuICAgIGNvbnN0IGRlZnMgPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKGluZmVyX29wdGlvbnMoeyAwOiAwIH0pKS5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGluZmVyX29wdGlvbnMoe1xuICAgICAgICAgICAgW2NvbXBvbmVudF06IHswOiAwfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucykgZGVmc1tjb21wb25lbnRdID0gb3B0aW9ucztcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5mZXJfb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbWluaWZ5KFwiXCIsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5kZWZzO1xuICAgIH1cbn1cblxuZXhwb3J0cy5fZGVmYXVsdF9vcHRpb25zID0gX2RlZmF1bHRfb3B0aW9ucztcbmV4cG9ydHMuX3J1bl9jbGkgPSBydW5fY2xpO1xuZXhwb3J0cy5taW5pZnkgPSBtaW5pZnk7XG5leHBvcnRzLm1pbmlmeV9zeW5jID0gbWluaWZ5X3N5bmM7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terser/dist/bundle.min.js\n\n}");

/***/ },

/***/ "./src/TinyShade.ts"
/*!**************************!*\
  !*** ./src/TinyShade.ts ***!
  \**************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TinyShade = void 0;\nconst UniformLayout_1 = __webpack_require__(/*! ./UniformLayout */ \"./src/UniformLayout.ts\");\n/**\n * Utility for writing data to GPU Buffers.\n */\nconst Buffer = {\n    /**\n     * Writes an ArrayBufferView to a GPUBuffer.\n     * @param device The active GPUDevice.\n     * @param buffer The target GPUBuffer.\n     * @param data The data to write.\n     * @param offset Byte offset in the buffer.\n     */\n    write(device, buffer, data, offset = 0) {\n        device.queue.writeBuffer(buffer, offset, data.buffer, data.byteOffset, data.byteLength);\n        return buffer;\n    }\n};\n/**\n * Calculates the largest power of two less than or equal to n.\n * Useful for optimizing workgroup sizes.\n */\nconst largestPowerOf2LessThan = (n) => {\n    let power = 1;\n    while (power * 2 <= n)\n        power *= 2;\n    return power;\n};\n/**\n * Determines optimal workgroup sizes based on hardware limits.\n */\nconst getWorkgroupSize = (limits) => {\n    const x = Math.min(16, largestPowerOf2LessThan(limits.maxComputeWorkgroupSizeX));\n    const y = Math.min(16, largestPowerOf2LessThan(limits.maxComputeWorkgroupSizeY));\n    return { x, y, z: 1, str: `@workgroup_size(${x}, ${y}, 1)` };\n};\n/**\n * TinyShade: A minimal, high-performance WebGPU framework for\n * multi-pass fragment and compute shaders.\n */\nclass TinyShade {\n    device;\n    context;\n    canvas;\n    uniforms;\n    uniformBuffer;\n    audioPlugin;\n    startTime = 0;\n    frameCounter = 0;\n    globalTextures = new Map();\n    commonWGSL = \"\";\n    passes = [];\n    passLayouts = [];\n    bgCache = [];\n    mainPassShader = \"\";\n    mainPipeline;\n    isCompiled = false;\n    startedAudio = false;\n    _mainDeps = undefined;\n    workgroupSize = { x: 8, y: 8, z: 1, str: \"@workgroup_size(8, 8, 1)\" };\n    globalSampler;\n    constructor(canvas) {\n        this.canvas = canvas;\n        const dpr = window.devicePixelRatio || 1;\n        this.uniforms = new UniformLayout_1.UniformLayout([this.canvas.width * dpr, this.canvas.height * dpr, dpr]);\n    }\n    /**\n     * Initializes the WebGPU context and creates a TinyShade instance.\n     * @param canvasId The ID of the HTML canvas element.\n     */\n    static async create(canvasId) {\n        const canvas = document.getElementById(canvasId);\n        const ts = new TinyShade(canvas);\n        await ts.initWebGPU();\n        return ts;\n    }\n    async initWebGPU() {\n        const adapter = await navigator.gpu?.requestAdapter();\n        if (!adapter)\n            throw \"WebGPU not supported\";\n        const features = [];\n        if (adapter.features.has('bgra8unorm-storage'))\n            features.push('bgra8unorm-storage');\n        if (adapter.features.has('timestamp-query'))\n            features.push('timestamp-query');\n        this.device = await adapter.requestDevice({ requiredFeatures: features });\n        this.globalSampler = this.device.createSampler({ magFilter: 'linear', minFilter: 'linear' });\n        this.workgroupSize = getWorkgroupSize(adapter.limits);\n        this.context = this.canvas.getContext(\"webgpu\");\n        this.context.configure({\n            device: this.device,\n            format: navigator.gpu.getPreferredCanvasFormat(),\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.startTime = performance.now();\n    }\n    getRelevantPasses(currentPass) {\n        const base = currentPass.dependencies\n            ? this.passes.filter(p => currentPass.dependencies.includes(p.name))\n            : this.passes;\n        const resultSet = new Set(base);\n        if (!currentPass.isMain)\n            resultSet.add(currentPass);\n        return Array.from(resultSet);\n    }\n    /**\n     * Connects an audio plugin to synchronize uniforms with audio data.\n     */\n    addAudio(plugin) { this.audioPlugin = plugin; return this; }\n    /**\n     * Adds WGSL code that will be prepended to all subsequent pass shaders.\n     * Useful for shared structs and constants.\n     */\n    addCommon(wgsl) { this.commonWGSL += `\\n${wgsl}\\n`; return this; }\n    /**\n     * Loads an image into a global texture accessible by all passes.\n     * @param name Name of the variable in WGSL (e.g., 'var tex: texture_2d<f32>').\n     * @param src URL or image element source.\n     */\n    async addTexture(name, src) {\n        let source;\n        if (typeof src === 'string') {\n            const img = new Image();\n            img.src = src;\n            await img.decode();\n            source = await createImageBitmap(img);\n        }\n        else {\n            source = src;\n        }\n        const texture = this.device.createTexture({\n            size: [source.width, source.height],\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.device.queue.copyExternalImageToTexture({ source }, { texture }, [source.width, source.height]);\n        this.globalTextures.set(name, texture);\n        return this;\n    }\n    /**\n     * configures the global uniform layout.\n     * @param callback Use this to add custom uniforms via layout.add().\n     */\n    setUniforms(callback) {\n        if (callback)\n            callback(this.uniforms);\n        this.uniformBuffer = this.device.createBuffer({\n            size: this.uniforms.byteSize,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n        return this;\n    }\n    /**\n     * Adds a GPGPU compute pass.\n     * @param name Used to reference this pass result in others.\n     * @param wgsl Compute shader code. Use '##WORKGROUP_SIZE' for auto-optimization.\n     * @param size Optional size for a storage buffer (array<f32>).\n     * @param deps List of pass names to read from.\n     */\n    addCompute(name, wgsl, size = 0, deps) {\n        const tex = this.device.createTexture({\n            size: [this.canvas.width, this.canvas.height],\n            format: \"rgba8unorm\",\n            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING\n        });\n        let buf;\n        if (size > 0)\n            buf = this.device.createBuffer({ size: size * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n        this.passes.push({ name, type: 'compute', shader: wgsl, textures: [tex], storageBuffer: buf, pipelines: [], dependencies: deps });\n        return this;\n    }\n    /**\n     * Adds a compute pass optimized for atomic operations (e.g., histograms, particle counters).\n     */\n    addAtomicCompute(name, wgsl, bufferSize, deps) {\n        const buf = this.device.createBuffer({\n            size: bufferSize * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n        });\n        this.passes.push({ name, type: 'compute', shader: wgsl, storageBuffer: buf, isAtomic: true, pipelines: [], textures: [], dependencies: deps });\n        return this;\n    }\n    /**\n     * Adds a full-screen fragment pass.\n     * This automatically manages two textures for feedback loops (ping-ponging).\n     * @param name Name of the texture variable in WGSL.\n     * @param wgsl Fragment shader code.\n     * @param deps List of pass names to read from.\n     */\n    addPass(name, wgsl, deps) {\n        const createTex = () => this.device.createTexture({\n            size: [this.canvas.width, this.canvas.height],\n            format: \"bgra8unorm\",\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.passes.push({ name, type: 'fragment', shader: wgsl, textures: [createTex(), createTex()], pipelines: [], dependencies: deps });\n        return this;\n    }\n    /**\n     * The final output pass that renders to the canvas.\n     * Calling this triggers the shader compilation process.\n     * @param wgsl Final fragment shader code.\n     * @param deps Pass names to be sampled in the final output.\n     */\n    async main(wgsl, deps) {\n        this.mainPassShader = wgsl;\n        this._mainDeps = deps;\n        this.compile(deps);\n        return this;\n    }\n    compile(mainDeps) {\n        if (!this.uniformBuffer)\n            this.setUniforms();\n        const vertCode = `\r\n            struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\r\n            @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\r\n                var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\r\n                return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\r\n            }\r\n        `;\n        const allStages = [...this.passes, {\n                name: \"main\", type: 'fragment', shader: this.mainPassShader,\n                isMain: true, textures: [], pipelines: [], dependencies: mainDeps\n            }];\n        allStages.forEach((currentPass, stageIdx) => {\n            let b = 0;\n            const layoutEntries = [];\n            let header = `${this.uniforms.wgslStruct}\\n@group(0) @binding(${b}) var<uniform> u: Uniforms;\\n`;\n            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } });\n            this.globalTextures.forEach((_, name) => {\n                header += `@group(0) @binding(${b}) var ${name}: texture_2d<f32>;\\n`;\n                layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n            });\n            header += `@group(0) @binding(${b}) var samp: sampler;\\n`;\n            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, sampler: {} });\n            this.getRelevantPasses(currentPass).forEach((p) => {\n                const isSelf = (currentPass === p);\n                if (p.type === 'compute') {\n                    if (p.textures.length > 0) {\n                        if (isSelf) {\n                            header += `@group(0) @binding(${b}) var outTex: texture_storage_2d<rgba8unorm, write>;\\n`;\n                            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.COMPUTE, storageTexture: { format: 'rgba8unorm', access: 'write-only' } });\n                        }\n                        else {\n                            header += `@group(0) @binding(${b}) var ${p.name}: texture_2d<f32>;\\n`;\n                            layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n                        }\n                    }\n                    if (p.storageBuffer) {\n                        const bufName = isSelf ? \"data\" : `${p.name}_data`;\n                        header += `@group(0) @binding(${b}) var<storage, read_write> ${bufName}: ${p.isAtomic ? \"array<atomic<u32>>\" : \"array<f32>\"};\\n`;\n                        layoutEntries.push({ binding: b++, visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT, buffer: { type: 'storage' } });\n                    }\n                }\n                else {\n                    header += `@group(0) @binding(${b}) var ${p.name}: texture_2d<f32>;\\n`;\n                    layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n                    header += `@group(0) @binding(${b}) var prev_${p.name}: texture_2d<f32>;\\n`;\n                    layoutEntries.push({ binding: b++, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, texture: {} });\n                }\n            });\n            const layout = this.device.createBindGroupLayout({ entries: layoutEntries });\n            this.passLayouts[stageIdx] = layout;\n            const code = (currentPass.type === 'fragment' ? vertCode : \"\") + header + this.commonWGSL +\n                (currentPass.type === 'compute' ? currentPass.shader.replace(\"##WORKGROUP_SIZE\", `@compute ${this.workgroupSize.str}`) : currentPass.shader);\n            const mod = this.device.createShaderModule({ code });\n            const pipeLayout = this.device.createPipelineLayout({ bindGroupLayouts: [layout] });\n            if (currentPass.type === 'compute') {\n                currentPass.pipelines[0] = this.device.createComputePipeline({ layout: pipeLayout, compute: { module: mod, entryPoint: 'main' } });\n            }\n            else {\n                currentPass.pipelines[0] = this.device.createRenderPipeline({\n                    layout: pipeLayout, vertex: { module: mod, entryPoint: 'vs' },\n                    fragment: { module: mod, entryPoint: 'main', targets: [{ format: currentPass.isMain ? navigator.gpu.getPreferredCanvasFormat() : \"bgra8unorm\" }] }\n                });\n                if (currentPass.isMain)\n                    this.mainPipeline = currentPass.pipelines[0];\n            }\n        });\n        this.isCompiled = true;\n    }\n    createBindGroup(stageIdx, writeIdx) {\n        const readIdx = 1 - writeIdx;\n        const isMainPass = stageIdx === this.passes.length;\n        const currentPass = isMainPass\n            ? { name: 'main', isMain: true, dependencies: this._mainDeps }\n            : this.passes[stageIdx];\n        const entries = [];\n        let b = 0;\n        entries.push({ binding: b++, resource: { buffer: this.uniformBuffer } });\n        this.globalTextures.forEach(tex => entries.push({ binding: b++, resource: tex.createView() }));\n        entries.push({ binding: b++, resource: this.globalSampler });\n        this.getRelevantPasses(currentPass).forEach((p) => {\n            const isSelf = (currentPass === p);\n            if (p.type === 'compute') {\n                if (p.textures.length > 0)\n                    entries.push({ binding: b++, resource: p.textures[0].createView() });\n                if (p.storageBuffer)\n                    entries.push({ binding: b++, resource: { buffer: p.storageBuffer } });\n            }\n            else {\n                if (isSelf) {\n                    entries.push({ binding: b++, resource: p.textures[readIdx].createView() });\n                    entries.push({ binding: b++, resource: p.textures[readIdx].createView() });\n                }\n                else {\n                    entries.push({ binding: b++, resource: p.textures[writeIdx].createView() });\n                    entries.push({ binding: b++, resource: p.textures[readIdx].createView() });\n                }\n            }\n        });\n        return this.device.createBindGroup({ layout: this.passLayouts[stageIdx], entries });\n    }\n    /**\n     * Starts the render loop.\n     * @param timer Optional WebGPUTiming plugin for profiling.\n     */\n    run(timer) {\n        const frame = (now) => {\n            if (!this.isCompiled)\n                return;\n            if (this.audioPlugin && !this.startedAudio) {\n                this.audioPlugin.play();\n                this.startedAudio = true;\n            }\n            const time = (this.audioPlugin?.isPlaying) ? this.audioPlugin.getTime() : (now - this.startTime) / 1000;\n            const writeIdx = (this.frameCounter % 2);\n            this.uniforms.update(time);\n            Buffer.write(this.device, this.uniformBuffer, this.uniforms.float32Array);\n            const enc = this.device.createCommandEncoder();\n            this.passes.forEach((p, i) => {\n                if (p.isAtomic && p.storageBuffer)\n                    enc.clearBuffer(p.storageBuffer);\n                const bg = this.createBindGroup(i, writeIdx);\n                if (p.type === 'compute') {\n                    const cp = enc.beginComputePass();\n                    cp.setPipeline(p.pipelines[0]);\n                    cp.setBindGroup(0, bg);\n                    cp.dispatchWorkgroups(Math.ceil(this.canvas.width / this.workgroupSize.x), Math.ceil(this.canvas.height / this.workgroupSize.y), 1);\n                    cp.end();\n                }\n                else {\n                    const rp = enc.beginRenderPass({\n                        colorAttachments: [{ view: p.textures[writeIdx].createView(), loadOp: \"clear\", storeOp: \"store\", clearValue: [0, 0, 0, 1] }]\n                    });\n                    rp.setPipeline(p.pipelines[0]);\n                    rp.setBindGroup(0, bg);\n                    rp.draw(3);\n                    rp.end();\n                }\n            });\n            const mainBG = this.createBindGroup(this.passes.length, writeIdx);\n            const mp = enc.beginRenderPass({\n                colorAttachments: [{ view: this.context.getCurrentTexture().createView(), loadOp: \"clear\", storeOp: \"store\", clearValue: [0, 0, 0, 1] }]\n            });\n            mp.setPipeline(this.mainPipeline);\n            mp.setBindGroup(0, mainBG);\n            mp.draw(3);\n            mp.end();\n            this.device.queue.submit([enc.finish()]);\n            this.frameCounter++;\n            requestAnimationFrame(frame);\n        };\n        requestAnimationFrame(frame);\n        return this;\n    }\n}\nexports.TinyShade = TinyShade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVGlueVNoYWRlLnRzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQix3QkFBd0IsbUJBQU8sQ0FBQywrQ0FBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0NBQW9DLEVBQUUsSUFBSSxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw0QkFBNEI7QUFDaEYseURBQXlELDBDQUEwQztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCLEtBQUssS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVEQUF1RCxRQUFRLElBQUksU0FBUztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2Q0FBNkMseUVBQXlFO0FBQ3RILDJCQUEyQiw2R0FBNkc7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJCQUEyQiwwSEFBMEg7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyQkFBMkIsK0dBQStHO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUIsdUJBQXVCLEVBQUUsMkJBQTJCO0FBQ3pHLGlDQUFpQyw4R0FBOEcsbUJBQW1CO0FBQ2xLO0FBQ0EsZ0RBQWdELEVBQUUsUUFBUSxLQUFLLGtCQUFrQjtBQUNqRixxQ0FBcUMseUZBQXlGO0FBQzlILGFBQWE7QUFDYiw0Q0FBNEMsRUFBRSxvQkFBb0I7QUFDbEUsaUNBQWlDLHlGQUF5RjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEVBQUUsb0RBQW9EO0FBQ2xILGlEQUFpRCxvRUFBb0UsOENBQThDO0FBQ25LO0FBQ0E7QUFDQSw0REFBNEQsRUFBRSxRQUFRLE9BQU8sa0JBQWtCO0FBQy9GLGlEQUFpRCx5RkFBeUY7QUFDMUk7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELE9BQU87QUFDcEUsd0RBQXdELEVBQUUsNkJBQTZCLFFBQVEsSUFBSSxrREFBa0Q7QUFDckosNkNBQTZDLHNGQUFzRixtQkFBbUI7QUFDdEo7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUUsUUFBUSxPQUFPLGtCQUFrQjtBQUN2Rix5Q0FBeUMseUZBQXlGO0FBQ2xJLG9EQUFvRCxFQUFFLGFBQWEsT0FBTyxrQkFBa0I7QUFDNUYseUNBQXlDLHlGQUF5RjtBQUNsSTtBQUNBLGFBQWE7QUFDYiwrREFBK0Qsd0JBQXdCO0FBQ3ZGO0FBQ0E7QUFDQSw2R0FBNkcsdUJBQXVCO0FBQ3BJLHlEQUF5RCxNQUFNO0FBQy9ELGtFQUFrRSw0QkFBNEI7QUFDOUY7QUFDQSwrRUFBK0UsK0JBQStCLG1DQUFtQztBQUNqSjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsK0JBQStCO0FBQ2pGLGdDQUFnQyw2Q0FBNkMsc0ZBQXNGO0FBQ25LLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEIsOEJBQThCO0FBQy9FLDBEQUEwRCwwQ0FBMEM7QUFDcEcsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvREFBb0Q7QUFDdkY7QUFDQSxtQ0FBbUMsMEJBQTBCLDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMERBQTBEO0FBQzdGLG1DQUFtQywwREFBMEQ7QUFDN0Y7QUFDQTtBQUNBLG1DQUFtQywyREFBMkQ7QUFDOUYsbUNBQW1DLDBEQUEwRDtBQUM3RjtBQUNBO0FBQ0EsU0FBUztBQUNULDZDQUE2Qyw2Q0FBNkM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0dBQXNHO0FBQ25KLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxQ0FBcUMsa0hBQWtIO0FBQ3ZKLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW55c2hhZGUvLi9zcmMvVGlueVNoYWRlLnRzPzI5OWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRpbnlTaGFkZSA9IHZvaWQgMDtcbmNvbnN0IFVuaWZvcm1MYXlvdXRfMSA9IHJlcXVpcmUoXCIuL1VuaWZvcm1MYXlvdXRcIik7XG4vKipcbiAqIFV0aWxpdHkgZm9yIHdyaXRpbmcgZGF0YSB0byBHUFUgQnVmZmVycy5cbiAqL1xuY29uc3QgQnVmZmVyID0ge1xuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBBcnJheUJ1ZmZlclZpZXcgdG8gYSBHUFVCdWZmZXIuXG4gICAgICogQHBhcmFtIGRldmljZSBUaGUgYWN0aXZlIEdQVURldmljZS5cbiAgICAgKiBAcGFyYW0gYnVmZmVyIFRoZSB0YXJnZXQgR1BVQnVmZmVyLlxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgQnl0ZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICB3cml0ZShkZXZpY2UsIGJ1ZmZlciwgZGF0YSwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBkZXZpY2UucXVldWUud3JpdGVCdWZmZXIoYnVmZmVyLCBvZmZzZXQsIGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGFyZ2VzdCBwb3dlciBvZiB0d28gbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG4uXG4gKiBVc2VmdWwgZm9yIG9wdGltaXppbmcgd29ya2dyb3VwIHNpemVzLlxuICovXG5jb25zdCBsYXJnZXN0UG93ZXJPZjJMZXNzVGhhbiA9IChuKSA9PiB7XG4gICAgbGV0IHBvd2VyID0gMTtcbiAgICB3aGlsZSAocG93ZXIgKiAyIDw9IG4pXG4gICAgICAgIHBvd2VyICo9IDI7XG4gICAgcmV0dXJuIHBvd2VyO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBvcHRpbWFsIHdvcmtncm91cCBzaXplcyBiYXNlZCBvbiBoYXJkd2FyZSBsaW1pdHMuXG4gKi9cbmNvbnN0IGdldFdvcmtncm91cFNpemUgPSAobGltaXRzKSA9PiB7XG4gICAgY29uc3QgeCA9IE1hdGgubWluKDE2LCBsYXJnZXN0UG93ZXJPZjJMZXNzVGhhbihsaW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYKSk7XG4gICAgY29uc3QgeSA9IE1hdGgubWluKDE2LCBsYXJnZXN0UG93ZXJPZjJMZXNzVGhhbihsaW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZKSk7XG4gICAgcmV0dXJuIHsgeCwgeSwgejogMSwgc3RyOiBgQHdvcmtncm91cF9zaXplKCR7eH0sICR7eX0sIDEpYCB9O1xufTtcbi8qKlxuICogVGlueVNoYWRlOiBBIG1pbmltYWwsIGhpZ2gtcGVyZm9ybWFuY2UgV2ViR1BVIGZyYW1ld29yayBmb3JcbiAqIG11bHRpLXBhc3MgZnJhZ21lbnQgYW5kIGNvbXB1dGUgc2hhZGVycy5cbiAqL1xuY2xhc3MgVGlueVNoYWRlIHtcbiAgICBkZXZpY2U7XG4gICAgY29udGV4dDtcbiAgICBjYW52YXM7XG4gICAgdW5pZm9ybXM7XG4gICAgdW5pZm9ybUJ1ZmZlcjtcbiAgICBhdWRpb1BsdWdpbjtcbiAgICBzdGFydFRpbWUgPSAwO1xuICAgIGZyYW1lQ291bnRlciA9IDA7XG4gICAgZ2xvYmFsVGV4dHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgY29tbW9uV0dTTCA9IFwiXCI7XG4gICAgcGFzc2VzID0gW107XG4gICAgcGFzc0xheW91dHMgPSBbXTtcbiAgICBiZ0NhY2hlID0gW107XG4gICAgbWFpblBhc3NTaGFkZXIgPSBcIlwiO1xuICAgIG1haW5QaXBlbGluZTtcbiAgICBpc0NvbXBpbGVkID0gZmFsc2U7XG4gICAgc3RhcnRlZEF1ZGlvID0gZmFsc2U7XG4gICAgX21haW5EZXBzID0gdW5kZWZpbmVkO1xuICAgIHdvcmtncm91cFNpemUgPSB7IHg6IDgsIHk6IDgsIHo6IDEsIHN0cjogXCJAd29ya2dyb3VwX3NpemUoOCwgOCwgMSlcIiB9O1xuICAgIGdsb2JhbFNhbXBsZXI7XG4gICAgY29uc3RydWN0b3IoY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0gbmV3IFVuaWZvcm1MYXlvdXRfMS5Vbmlmb3JtTGF5b3V0KFt0aGlzLmNhbnZhcy53aWR0aCAqIGRwciwgdGhpcy5jYW52YXMuaGVpZ2h0ICogZHByLCBkcHJdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFdlYkdQVSBjb250ZXh0IGFuZCBjcmVhdGVzIGEgVGlueVNoYWRlIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBjYW52YXNJZCBUaGUgSUQgb2YgdGhlIEhUTUwgY2FudmFzIGVsZW1lbnQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShjYW52YXNJZCkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNJZCk7XG4gICAgICAgIGNvbnN0IHRzID0gbmV3IFRpbnlTaGFkZShjYW52YXMpO1xuICAgICAgICBhd2FpdCB0cy5pbml0V2ViR1BVKCk7XG4gICAgICAgIHJldHVybiB0cztcbiAgICB9XG4gICAgYXN5bmMgaW5pdFdlYkdQVSgpIHtcbiAgICAgICAgY29uc3QgYWRhcHRlciA9IGF3YWl0IG5hdmlnYXRvci5ncHU/LnJlcXVlc3RBZGFwdGVyKCk7XG4gICAgICAgIGlmICghYWRhcHRlcilcbiAgICAgICAgICAgIHRocm93IFwiV2ViR1BVIG5vdCBzdXBwb3J0ZWRcIjtcbiAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgaWYgKGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCdiZ3JhOHVub3JtLXN0b3JhZ2UnKSlcbiAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goJ2JncmE4dW5vcm0tc3RvcmFnZScpO1xuICAgICAgICBpZiAoYWRhcHRlci5mZWF0dXJlcy5oYXMoJ3RpbWVzdGFtcC1xdWVyeScpKVxuICAgICAgICAgICAgZmVhdHVyZXMucHVzaCgndGltZXN0YW1wLXF1ZXJ5Jyk7XG4gICAgICAgIHRoaXMuZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKHsgcmVxdWlyZWRGZWF0dXJlczogZmVhdHVyZXMgfSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU2FtcGxlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZVNhbXBsZXIoeyBtYWdGaWx0ZXI6ICdsaW5lYXInLCBtaW5GaWx0ZXI6ICdsaW5lYXInIH0pO1xuICAgICAgICB0aGlzLndvcmtncm91cFNpemUgPSBnZXRXb3JrZ3JvdXBTaXplKGFkYXB0ZXIubGltaXRzKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIndlYmdwdVwiKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBkZXZpY2U6IHRoaXMuZGV2aWNlLFxuICAgICAgICAgICAgZm9ybWF0OiBuYXZpZ2F0b3IuZ3B1LmdldFByZWZlcnJlZENhbnZhc0Zvcm1hdCgpLFxuICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbiAgICBnZXRSZWxldmFudFBhc3NlcyhjdXJyZW50UGFzcykge1xuICAgICAgICBjb25zdCBiYXNlID0gY3VycmVudFBhc3MuZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICA/IHRoaXMucGFzc2VzLmZpbHRlcihwID0+IGN1cnJlbnRQYXNzLmRlcGVuZGVuY2llcy5pbmNsdWRlcyhwLm5hbWUpKVxuICAgICAgICAgICAgOiB0aGlzLnBhc3NlcztcbiAgICAgICAgY29uc3QgcmVzdWx0U2V0ID0gbmV3IFNldChiYXNlKTtcbiAgICAgICAgaWYgKCFjdXJyZW50UGFzcy5pc01haW4pXG4gICAgICAgICAgICByZXN1bHRTZXQuYWRkKGN1cnJlbnRQYXNzKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0U2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgYW4gYXVkaW8gcGx1Z2luIHRvIHN5bmNocm9uaXplIHVuaWZvcm1zIHdpdGggYXVkaW8gZGF0YS5cbiAgICAgKi9cbiAgICBhZGRBdWRpbyhwbHVnaW4pIHsgdGhpcy5hdWRpb1BsdWdpbiA9IHBsdWdpbjsgcmV0dXJuIHRoaXM7IH1cbiAgICAvKipcbiAgICAgKiBBZGRzIFdHU0wgY29kZSB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGFsbCBzdWJzZXF1ZW50IHBhc3Mgc2hhZGVycy5cbiAgICAgKiBVc2VmdWwgZm9yIHNoYXJlZCBzdHJ1Y3RzIGFuZCBjb25zdGFudHMuXG4gICAgICovXG4gICAgYWRkQ29tbW9uKHdnc2wpIHsgdGhpcy5jb21tb25XR1NMICs9IGBcXG4ke3dnc2x9XFxuYDsgcmV0dXJuIHRoaXM7IH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBpbWFnZSBpbnRvIGEgZ2xvYmFsIHRleHR1cmUgYWNjZXNzaWJsZSBieSBhbGwgcGFzc2VzLlxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIHZhcmlhYmxlIGluIFdHU0wgKGUuZy4sICd2YXIgdGV4OiB0ZXh0dXJlXzJkPGYzMj4nKS5cbiAgICAgKiBAcGFyYW0gc3JjIFVSTCBvciBpbWFnZSBlbGVtZW50IHNvdXJjZS5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRUZXh0dXJlKG5hbWUsIHNyYykge1xuICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgICAgICAgIGF3YWl0IGltZy5kZWNvZGUoKTtcbiAgICAgICAgICAgIHNvdXJjZSA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzcmM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgICAgICAgc2l6ZTogW3NvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodF0sXG4gICAgICAgICAgICBmb3JtYXQ6ICdyZ2JhOHVub3JtJyxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUIHwgR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRldmljZS5xdWV1ZS5jb3B5RXh0ZXJuYWxJbWFnZVRvVGV4dHVyZSh7IHNvdXJjZSB9LCB7IHRleHR1cmUgfSwgW3NvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodF0pO1xuICAgICAgICB0aGlzLmdsb2JhbFRleHR1cmVzLnNldChuYW1lLCB0ZXh0dXJlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbmZpZ3VyZXMgdGhlIGdsb2JhbCB1bmlmb3JtIGxheW91dC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVXNlIHRoaXMgdG8gYWRkIGN1c3RvbSB1bmlmb3JtcyB2aWEgbGF5b3V0LmFkZCgpLlxuICAgICAqL1xuICAgIHNldFVuaWZvcm1zKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMudW5pZm9ybXMpO1xuICAgICAgICB0aGlzLnVuaWZvcm1CdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICAgICAgc2l6ZTogdGhpcy51bmlmb3Jtcy5ieXRlU2l6ZSxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1RcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgR1BHUFUgY29tcHV0ZSBwYXNzLlxuICAgICAqIEBwYXJhbSBuYW1lIFVzZWQgdG8gcmVmZXJlbmNlIHRoaXMgcGFzcyByZXN1bHQgaW4gb3RoZXJzLlxuICAgICAqIEBwYXJhbSB3Z3NsIENvbXB1dGUgc2hhZGVyIGNvZGUuIFVzZSAnIyNXT1JLR1JPVVBfU0laRScgZm9yIGF1dG8tb3B0aW1pemF0aW9uLlxuICAgICAqIEBwYXJhbSBzaXplIE9wdGlvbmFsIHNpemUgZm9yIGEgc3RvcmFnZSBidWZmZXIgKGFycmF5PGYzMj4pLlxuICAgICAqIEBwYXJhbSBkZXBzIExpc3Qgb2YgcGFzcyBuYW1lcyB0byByZWFkIGZyb20uXG4gICAgICovXG4gICAgYWRkQ29tcHV0ZShuYW1lLCB3Z3NsLCBzaXplID0gMCwgZGVwcykge1xuICAgICAgICBjb25zdCB0ZXggPSB0aGlzLmRldmljZS5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgICAgIHNpemU6IFt0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0XSxcbiAgICAgICAgICAgIGZvcm1hdDogXCJyZ2JhOHVub3JtXCIsXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkdcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBidWY7XG4gICAgICAgIGlmIChzaXplID4gMClcbiAgICAgICAgICAgIGJ1ZiA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7IHNpemU6IHNpemUgKiA0LCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIH0pO1xuICAgICAgICB0aGlzLnBhc3Nlcy5wdXNoKHsgbmFtZSwgdHlwZTogJ2NvbXB1dGUnLCBzaGFkZXI6IHdnc2wsIHRleHR1cmVzOiBbdGV4XSwgc3RvcmFnZUJ1ZmZlcjogYnVmLCBwaXBlbGluZXM6IFtdLCBkZXBlbmRlbmNpZXM6IGRlcHMgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29tcHV0ZSBwYXNzIG9wdGltaXplZCBmb3IgYXRvbWljIG9wZXJhdGlvbnMgKGUuZy4sIGhpc3RvZ3JhbXMsIHBhcnRpY2xlIGNvdW50ZXJzKS5cbiAgICAgKi9cbiAgICBhZGRBdG9taWNDb21wdXRlKG5hbWUsIHdnc2wsIGJ1ZmZlclNpemUsIGRlcHMpIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIHNpemU6IGJ1ZmZlclNpemUgKiA0LFxuICAgICAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhc3Nlcy5wdXNoKHsgbmFtZSwgdHlwZTogJ2NvbXB1dGUnLCBzaGFkZXI6IHdnc2wsIHN0b3JhZ2VCdWZmZXI6IGJ1ZiwgaXNBdG9taWM6IHRydWUsIHBpcGVsaW5lczogW10sIHRleHR1cmVzOiBbXSwgZGVwZW5kZW5jaWVzOiBkZXBzIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZ1bGwtc2NyZWVuIGZyYWdtZW50IHBhc3MuXG4gICAgICogVGhpcyBhdXRvbWF0aWNhbGx5IG1hbmFnZXMgdHdvIHRleHR1cmVzIGZvciBmZWVkYmFjayBsb29wcyAocGluZy1wb25naW5nKS5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB0ZXh0dXJlIHZhcmlhYmxlIGluIFdHU0wuXG4gICAgICogQHBhcmFtIHdnc2wgRnJhZ21lbnQgc2hhZGVyIGNvZGUuXG4gICAgICogQHBhcmFtIGRlcHMgTGlzdCBvZiBwYXNzIG5hbWVzIHRvIHJlYWQgZnJvbS5cbiAgICAgKi9cbiAgICBhZGRQYXNzKG5hbWUsIHdnc2wsIGRlcHMpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlVGV4ID0gKCkgPT4gdGhpcy5kZXZpY2UuY3JlYXRlVGV4dHVyZSh7XG4gICAgICAgICAgICBzaXplOiBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF0sXG4gICAgICAgICAgICBmb3JtYXQ6IFwiYmdyYTh1bm9ybVwiLFxuICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFzc2VzLnB1c2goeyBuYW1lLCB0eXBlOiAnZnJhZ21lbnQnLCBzaGFkZXI6IHdnc2wsIHRleHR1cmVzOiBbY3JlYXRlVGV4KCksIGNyZWF0ZVRleCgpXSwgcGlwZWxpbmVzOiBbXSwgZGVwZW5kZW5jaWVzOiBkZXBzIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmFsIG91dHB1dCBwYXNzIHRoYXQgcmVuZGVycyB0byB0aGUgY2FudmFzLlxuICAgICAqIENhbGxpbmcgdGhpcyB0cmlnZ2VycyB0aGUgc2hhZGVyIGNvbXBpbGF0aW9uIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHdnc2wgRmluYWwgZnJhZ21lbnQgc2hhZGVyIGNvZGUuXG4gICAgICogQHBhcmFtIGRlcHMgUGFzcyBuYW1lcyB0byBiZSBzYW1wbGVkIGluIHRoZSBmaW5hbCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgbWFpbih3Z3NsLCBkZXBzKSB7XG4gICAgICAgIHRoaXMubWFpblBhc3NTaGFkZXIgPSB3Z3NsO1xuICAgICAgICB0aGlzLl9tYWluRGVwcyA9IGRlcHM7XG4gICAgICAgIHRoaXMuY29tcGlsZShkZXBzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbXBpbGUobWFpbkRlcHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVuaWZvcm1CdWZmZXIpXG4gICAgICAgICAgICB0aGlzLnNldFVuaWZvcm1zKCk7XG4gICAgICAgIGNvbnN0IHZlcnRDb2RlID0gYFxyXG4gICAgICAgICAgICBzdHJ1Y3QgVlNPdXQgeyBAYnVpbHRpbihwb3NpdGlvbikgcG9zOiB2ZWM0ZiwgQGxvY2F0aW9uKDApIHV2OiB2ZWMyZiB9O1xyXG4gICAgICAgICAgICBAdmVydGV4IGZuIHZzKEBidWlsdGluKHZlcnRleF9pbmRleCkgaTogdTMyKSAtPiBWU091dCB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGFycmF5PHZlYzJmLCAzPih2ZWMyZigtMS4wLCAtMS4wKSwgdmVjMmYoMy4wLCAtMS4wKSwgdmVjMmYoLTEuMCwgMy4wKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVlNPdXQodmVjNGYocFtpXSwgMC4wLCAxLjApLCB2ZWMyZihwW2ldLnggKiAwLjUgKyAwLjUsIDAuNSAtIHBbaV0ueSAqIDAuNSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgYDtcbiAgICAgICAgY29uc3QgYWxsU3RhZ2VzID0gWy4uLnRoaXMucGFzc2VzLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtYWluXCIsIHR5cGU6ICdmcmFnbWVudCcsIHNoYWRlcjogdGhpcy5tYWluUGFzc1NoYWRlcixcbiAgICAgICAgICAgICAgICBpc01haW46IHRydWUsIHRleHR1cmVzOiBbXSwgcGlwZWxpbmVzOiBbXSwgZGVwZW5kZW5jaWVzOiBtYWluRGVwc1xuICAgICAgICAgICAgfV07XG4gICAgICAgIGFsbFN0YWdlcy5mb3JFYWNoKChjdXJyZW50UGFzcywgc3RhZ2VJZHgpID0+IHtcbiAgICAgICAgICAgIGxldCBiID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dEVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBoZWFkZXIgPSBgJHt0aGlzLnVuaWZvcm1zLndnc2xTdHJ1Y3R9XFxuQGdyb3VwKDApIEBiaW5kaW5nKCR7Yn0pIHZhcjx1bmlmb3JtPiB1OiBVbmlmb3JtcztcXG5gO1xuICAgICAgICAgICAgbGF5b3V0RW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5WRVJURVggfCBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCB8IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUsIGJ1ZmZlcjogeyB0eXBlOiAndW5pZm9ybScgfSB9KTtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsVGV4dHVyZXMuZm9yRWFjaCgoXywgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGhlYWRlciArPSBgQGdyb3VwKDApIEBiaW5kaW5nKCR7Yn0pIHZhciAke25hbWV9OiB0ZXh0dXJlXzJkPGYzMj47XFxuYDtcbiAgICAgICAgICAgICAgICBsYXlvdXRFbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5UIHwgR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSwgdGV4dHVyZToge30gfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhlYWRlciArPSBgQGdyb3VwKDApIEBiaW5kaW5nKCR7Yn0pIHZhciBzYW1wOiBzYW1wbGVyO1xcbmA7XG4gICAgICAgICAgICBsYXlvdXRFbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5UIHwgR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSwgc2FtcGxlcjoge30gfSk7XG4gICAgICAgICAgICB0aGlzLmdldFJlbGV2YW50UGFzc2VzKGN1cnJlbnRQYXNzKS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTZWxmID0gKGN1cnJlbnRQYXNzID09PSBwKTtcbiAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSAnY29tcHV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAudGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciArPSBgQGdyb3VwKDApIEBiaW5kaW5nKCR7Yn0pIHZhciBvdXRUZXg6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhOHVub3JtLCB3cml0ZT47XFxuYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRFbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUsIHN0b3JhZ2VUZXh0dXJlOiB7IGZvcm1hdDogJ3JnYmE4dW5vcm0nLCBhY2Nlc3M6ICd3cml0ZS1vbmx5JyB9IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyICs9IGBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtifSkgdmFyICR7cC5uYW1lfTogdGV4dHVyZV8yZDxmMzI+O1xcbmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCB8IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUsIHRleHR1cmU6IHt9IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnN0b3JhZ2VCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1Zk5hbWUgPSBpc1NlbGYgPyBcImRhdGFcIiA6IGAke3AubmFtZX1fZGF0YWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgKz0gYEBncm91cCgwKSBAYmluZGluZygke2J9KSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gJHtidWZOYW1lfTogJHtwLmlzQXRvbWljID8gXCJhcnJheTxhdG9taWM8dTMyPj5cIiA6IFwiYXJyYXk8ZjMyPlwifTtcXG5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5DT01QVVRFIHwgR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsIGJ1ZmZlcjogeyB0eXBlOiAnc3RvcmFnZScgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyICs9IGBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtifSkgdmFyICR7cC5uYW1lfTogdGV4dHVyZV8yZDxmMzI+O1xcbmA7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dEVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQgfCBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLCB0ZXh0dXJlOiB7fSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyICs9IGBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtifSkgdmFyIHByZXZfJHtwLm5hbWV9OiB0ZXh0dXJlXzJkPGYzMj47XFxuYDtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0RW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCB8IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUsIHRleHR1cmU6IHt9IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHsgZW50cmllczogbGF5b3V0RW50cmllcyB9KTtcbiAgICAgICAgICAgIHRoaXMucGFzc0xheW91dHNbc3RhZ2VJZHhdID0gbGF5b3V0O1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IChjdXJyZW50UGFzcy50eXBlID09PSAnZnJhZ21lbnQnID8gdmVydENvZGUgOiBcIlwiKSArIGhlYWRlciArIHRoaXMuY29tbW9uV0dTTCArXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRQYXNzLnR5cGUgPT09ICdjb21wdXRlJyA/IGN1cnJlbnRQYXNzLnNoYWRlci5yZXBsYWNlKFwiIyNXT1JLR1JPVVBfU0laRVwiLCBgQGNvbXB1dGUgJHt0aGlzLndvcmtncm91cFNpemUuc3RyfWApIDogY3VycmVudFBhc3Muc2hhZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZCA9IHRoaXMuZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7IGNvZGUgfSk7XG4gICAgICAgICAgICBjb25zdCBwaXBlTGF5b3V0ID0gdGhpcy5kZXZpY2UuY3JlYXRlUGlwZWxpbmVMYXlvdXQoeyBiaW5kR3JvdXBMYXlvdXRzOiBbbGF5b3V0XSB9KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFzcy50eXBlID09PSAnY29tcHV0ZScpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFzcy5waXBlbGluZXNbMF0gPSB0aGlzLmRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoeyBsYXlvdXQ6IHBpcGVMYXlvdXQsIGNvbXB1dGU6IHsgbW9kdWxlOiBtb2QsIGVudHJ5UG9pbnQ6ICdtYWluJyB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBhc3MucGlwZWxpbmVzWzBdID0gdGhpcy5kZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoe1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IHBpcGVMYXlvdXQsIHZlcnRleDogeyBtb2R1bGU6IG1vZCwgZW50cnlQb2ludDogJ3ZzJyB9LFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogeyBtb2R1bGU6IG1vZCwgZW50cnlQb2ludDogJ21haW4nLCB0YXJnZXRzOiBbeyBmb3JtYXQ6IGN1cnJlbnRQYXNzLmlzTWFpbiA/IG5hdmlnYXRvci5ncHUuZ2V0UHJlZmVycmVkQ2FudmFzRm9ybWF0KCkgOiBcImJncmE4dW5vcm1cIiB9XSB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXNzLmlzTWFpbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluUGlwZWxpbmUgPSBjdXJyZW50UGFzcy5waXBlbGluZXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjcmVhdGVCaW5kR3JvdXAoc3RhZ2VJZHgsIHdyaXRlSWR4KSB7XG4gICAgICAgIGNvbnN0IHJlYWRJZHggPSAxIC0gd3JpdGVJZHg7XG4gICAgICAgIGNvbnN0IGlzTWFpblBhc3MgPSBzdGFnZUlkeCA9PT0gdGhpcy5wYXNzZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjdXJyZW50UGFzcyA9IGlzTWFpblBhc3NcbiAgICAgICAgICAgID8geyBuYW1lOiAnbWFpbicsIGlzTWFpbjogdHJ1ZSwgZGVwZW5kZW5jaWVzOiB0aGlzLl9tYWluRGVwcyB9XG4gICAgICAgICAgICA6IHRoaXMucGFzc2VzW3N0YWdlSWR4XTtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBsZXQgYiA9IDA7XG4gICAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgcmVzb3VyY2U6IHsgYnVmZmVyOiB0aGlzLnVuaWZvcm1CdWZmZXIgfSB9KTtcbiAgICAgICAgdGhpcy5nbG9iYWxUZXh0dXJlcy5mb3JFYWNoKHRleCA9PiBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHJlc291cmNlOiB0ZXguY3JlYXRlVmlldygpIH0pKTtcbiAgICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCByZXNvdXJjZTogdGhpcy5nbG9iYWxTYW1wbGVyIH0pO1xuICAgICAgICB0aGlzLmdldFJlbGV2YW50UGFzc2VzKGN1cnJlbnRQYXNzKS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1NlbGYgPSAoY3VycmVudFBhc3MgPT09IHApO1xuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gJ2NvbXB1dGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAudGV4dHVyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCByZXNvdXJjZTogcC50ZXh0dXJlc1swXS5jcmVhdGVWaWV3KCkgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHAuc3RvcmFnZUJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCByZXNvdXJjZTogeyBidWZmZXI6IHAuc3RvcmFnZUJ1ZmZlciB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2VsZikge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHJlc291cmNlOiBwLnRleHR1cmVzW3JlYWRJZHhdLmNyZWF0ZVZpZXcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogYisrLCByZXNvdXJjZTogcC50ZXh0dXJlc1tyZWFkSWR4XS5jcmVhdGVWaWV3KCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBiKyssIHJlc291cmNlOiBwLnRleHR1cmVzW3dyaXRlSWR4XS5jcmVhdGVWaWV3KCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGIrKywgcmVzb3VyY2U6IHAudGV4dHVyZXNbcmVhZElkeF0uY3JlYXRlVmlldygpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoeyBsYXlvdXQ6IHRoaXMucGFzc0xheW91dHNbc3RhZ2VJZHhdLCBlbnRyaWVzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIEBwYXJhbSB0aW1lciBPcHRpb25hbCBXZWJHUFVUaW1pbmcgcGx1Z2luIGZvciBwcm9maWxpbmcuXG4gICAgICovXG4gICAgcnVuKHRpbWVyKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gKG5vdykgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ29tcGlsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXVkaW9QbHVnaW4gJiYgIXRoaXMuc3RhcnRlZEF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb1BsdWdpbi5wbGF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydGVkQXVkaW8gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZSA9ICh0aGlzLmF1ZGlvUGx1Z2luPy5pc1BsYXlpbmcpID8gdGhpcy5hdWRpb1BsdWdpbi5nZXRUaW1lKCkgOiAobm93IC0gdGhpcy5zdGFydFRpbWUpIC8gMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlSWR4ID0gKHRoaXMuZnJhbWVDb3VudGVyICUgMik7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVwZGF0ZSh0aW1lKTtcbiAgICAgICAgICAgIEJ1ZmZlci53cml0ZSh0aGlzLmRldmljZSwgdGhpcy51bmlmb3JtQnVmZmVyLCB0aGlzLnVuaWZvcm1zLmZsb2F0MzJBcnJheSk7XG4gICAgICAgICAgICBjb25zdCBlbmMgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgICAgICAgICAgdGhpcy5wYXNzZXMuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwLmlzQXRvbWljICYmIHAuc3RvcmFnZUJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgZW5jLmNsZWFyQnVmZmVyKHAuc3RvcmFnZUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgYmcgPSB0aGlzLmNyZWF0ZUJpbmRHcm91cChpLCB3cml0ZUlkeCk7XG4gICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gJ2NvbXB1dGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNwID0gZW5jLmJlZ2luQ29tcHV0ZVBhc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgY3Auc2V0UGlwZWxpbmUocC5waXBlbGluZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBjcC5zZXRCaW5kR3JvdXAoMCwgYmcpO1xuICAgICAgICAgICAgICAgICAgICBjcC5kaXNwYXRjaFdvcmtncm91cHMoTWF0aC5jZWlsKHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy53b3JrZ3JvdXBTaXplLngpLCBNYXRoLmNlaWwodGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy53b3JrZ3JvdXBTaXplLnkpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY3AuZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBycCA9IGVuYy5iZWdpblJlbmRlclBhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW3sgdmlldzogcC50ZXh0dXJlc1t3cml0ZUlkeF0uY3JlYXRlVmlldygpLCBsb2FkT3A6IFwiY2xlYXJcIiwgc3RvcmVPcDogXCJzdG9yZVwiLCBjbGVhclZhbHVlOiBbMCwgMCwgMCwgMV0gfV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJwLnNldFBpcGVsaW5lKHAucGlwZWxpbmVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcnAuc2V0QmluZEdyb3VwKDAsIGJnKTtcbiAgICAgICAgICAgICAgICAgICAgcnAuZHJhdygzKTtcbiAgICAgICAgICAgICAgICAgICAgcnAuZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBtYWluQkcgPSB0aGlzLmNyZWF0ZUJpbmRHcm91cCh0aGlzLnBhc3Nlcy5sZW5ndGgsIHdyaXRlSWR4KTtcbiAgICAgICAgICAgIGNvbnN0IG1wID0gZW5jLmJlZ2luUmVuZGVyUGFzcyh7XG4gICAgICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW3sgdmlldzogdGhpcy5jb250ZXh0LmdldEN1cnJlbnRUZXh0dXJlKCkuY3JlYXRlVmlldygpLCBsb2FkT3A6IFwiY2xlYXJcIiwgc3RvcmVPcDogXCJzdG9yZVwiLCBjbGVhclZhbHVlOiBbMCwgMCwgMCwgMV0gfV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbXAuc2V0UGlwZWxpbmUodGhpcy5tYWluUGlwZWxpbmUpO1xuICAgICAgICAgICAgbXAuc2V0QmluZEdyb3VwKDAsIG1haW5CRyk7XG4gICAgICAgICAgICBtcC5kcmF3KDMpO1xuICAgICAgICAgICAgbXAuZW5kKCk7XG4gICAgICAgICAgICB0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW2VuYy5maW5pc2goKV0pO1xuICAgICAgICAgICAgdGhpcy5mcmFtZUNvdW50ZXIrKztcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuVGlueVNoYWRlID0gVGlueVNoYWRlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/TinyShade.ts\n\n}");

/***/ },

/***/ "./src/TinyShadeBake.ts"
/*!******************************!*\
  !*** ./src/TinyShadeBake.ts ***!
  \******************************/
(__unused_webpack_module, exports) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TinyShadeBake = void 0;\n/**\n * TinyShadeBake handles the serialization and distribution of a TinyShade application.\n * It provides methods to export the live shader graph as a minified JSON file or\n * as a self-contained, pixel-packed HTML application. */\nclass TinyShadeBake {\n    /**\n     * Captures the current TinyShade state and triggers a download of a self-executing HTML file.\n     * The application logic is packed into a PNG image and decoded at runtime via an <img> onload handler.\n     * * @param app - The active TinyShade instance.\n     * @param filename - The name of the output HTML file (e.g., \"scene.html\").\n     * @param runnerSource - The stringified source of the TinyShadeRunner class.\n     * If null, it attempts to fetch the source from 'assets/runnerCode.js'.\n     */\n    static async downloadSelfContained(app, filename = \"demo.html\", runnerSource, audio) {\n        const baker = new TinyShadeBake();\n        const graph = await baker.collectGraphData(app);\n        if (audio) {\n            graph.audio = audio;\n        }\n        if (!runnerSource) {\n            runnerSource = await fetch(\"assets/runnerCode.js\").then(r => r.text());\n            console.log(\"Using default runner code\");\n        }\n        else {\n            runnerSource = runnerSource.trim();\n            console.log(\"Using custom runner code\");\n        }\n        let cleanRunner = runnerSource;\n        if (cleanRunner.startsWith(\"class\")) {\n            cleanRunner = \"const TinyShadeRunner = \" + cleanRunner;\n        }\n        cleanRunner = cleanRunner.replace(/^export\\s+/, \"\");\n        const g = JSON.parse(JSON.stringify(graph));\n        g.passes.forEach((p) => p.shader = baker.minify(p.shader));\n        const hasAudio = !!g.audio;\n        const js = `(async()=>{\r\nconst g=${JSON.stringify(g)};\r\n${cleanRunner};\r\n\r\nconst c=document.createElement('canvas');\r\nc.width=${g.canvasSize.width};\r\nc.height=${g.canvasSize.height};\r\nc.style='width:100vw;height:100vh;display:block;';\r\ndocument.body.appendChild(c);\r\n\r\nconst r=new TinyShadeRunner(c,g);\r\nawait r.init();\r\n\r\n        ${hasAudio ? `\r\n        const b=document.createElement('button');\r\n        b.textContent='RUN';\r\n        b.style='position:fixed;inset:0;margin:auto;font-size:4vmin;border:0';\r\n        document.body.appendChild(b);\r\n        b.onclick=()=>{b.remove();r.run()};\r\n        ` : `r.run()`}\r\n        })()`;\n        const payload = new TextEncoder().encode(js);\n        const pngBase64 = await baker.generatePNG(payload);\n        const html = `<html><body style=\"margin:0;background:#000;overflow:hidden;display:flex;align-items:center;justify-content:center;\">\r\n            <img src=\"${pngBase64}\" style=\"display:none\" onload=\"\r\n                (function(i){\r\n                    var c=document.createElement('canvas'),\r\n                    w=c.width=i.width,h=c.height=i.height,\r\n                    x=c.getContext('2d');\r\n                    x.drawImage(i,0,0);\r\n                    var d=x.getImageData(0,0,w,h).data,b='',j=0;\r\n                    for(;j<d.length;j++)if(j%4!=3&&d[j])b+=String.fromCharCode(d[j]);\r\n                    (0,eval)(b);\r\n                })(this);\r\n            \"></body></html>`;\n        baker.triggerDownload(new Blob([html], { type: \"text/html\" }), filename);\n    }\n    /**\n     * Exports the current shader graph, including all passes, uniforms, and textures,\n     * as a minified JSON file. Useful for debugging or for use with a custom loader.\n     * * @param app - The active TinyShade instance.\n     * @param filename - The name of the JSON file (e.g., \"graph.json\").\n     */\n    static async downloadGraph(app, filename = \"graph.json\") {\n        const baker = new TinyShadeBake();\n        const graph = await baker.collectGraphData(app);\n        graph.passes.forEach((p) => p.shader = baker.minify(p.shader));\n        if (graph.common)\n            graph.common = baker.minify(graph.common);\n        const json = JSON.stringify(graph);\n        baker.triggerDownload(new Blob([json], { type: \"application/json\" }), filename);\n    }\n    triggerDownload(blob, filename) {\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        a.click();\n        setTimeout(() => URL.revokeObjectURL(url), 100);\n    }\n    static async getGraphData(app) {\n        return new TinyShadeBake().collectGraphData(app);\n    }\n    async collectGraphData(app) {\n        const internalApp = app;\n        const bakedTextures = [];\n        const sources = internalApp.textureSources;\n        if (sources) {\n            for (const [name, source] of sources) {\n                bakedTextures.push({ name, data: this.toBase64(source) });\n            }\n        }\n        const allPasses = [...internalApp.passes];\n        allPasses.push({\n            name: \"main\", type: 'fragment', isMain: true,\n            shader: internalApp.mainPassShader, textures: []\n        });\n        const bakedPasses = await Promise.all(allPasses.map(async (p) => ({\n            name: p.name,\n            type: p.type,\n            shader: await this.assembleShader(app, p),\n            storageBufferSize: p.storageBuffer?.size,\n            isAtomic: p.isAtomic,\n            isMain: p.isMain\n        })));\n        return {\n            canvasSize: { width: app.canvas.width, height: app.canvas.height },\n            uniforms: { byteSize: internalApp.uniforms.byteSize, struct: internalApp.uniforms.wgslStruct },\n            textures: bakedTextures,\n            passes: bakedPasses,\n            workgroupSize: internalApp.workgroupSize.str,\n            common: internalApp.commonWGSL\n        };\n    }\n    /**\n     * Encodes an arbitrary byte payload into a PNG image and returns it as a\n     * Base64 data URL (`data:image/png;base64,...`).\n     *\n     * The PNG is constructed manually (no Canvas usage) to ensure:\n     *  - deterministic output\n     *  - predictable scanline layout\n     *  - real DEFLATE compression of IDAT data\n     *  - browser-only operation without external libraries (e.g. pako)\n     *\n     * Payload bytes are packed sequentially into RGB pixels (8-bit, truecolor).\n     * If the payload length is not divisible by 3, zero padding is appended.\n     *\n     * The image dimensions are chosen as the smallest square capable of holding\n     * the full payload. Unused pixels remain zeroed.\n     *\n     * PNG details:\n     *  - Color type: 2 (RGB)\n     *  - Bit depth: 8\n     *  - Filter: 0 (None) per scanline\n     *  - Compression: zlib/DEFLATE via CompressionStream\n     *\n     * This function is intended for demoscene-style asset baking where the PNG\n     * acts as a compressed container, not a visual image.\n     *\n     * @param payload Arbitrary binary data to embed in the PNG.\n     * @returns A Base64-encoded PNG data URL suitable for use in <img src>.\n     */\n    async generatePNG(payload) {\n        while (payload.length % 3) {\n            payload = this.concat(payload, new Uint8Array([0]));\n        }\n        const side = Math.ceil(Math.sqrt(payload.length / 3));\n        const rgb = new Uint8Array(side * side * 3);\n        rgb.set(payload);\n        const scan = new Uint8Array(side * (side * 3 + 1));\n        for (let y = 0; y < side; y++) {\n            scan[y * (side * 3 + 1)] = 0;\n            scan.set(rgb.subarray(y * side * 3, (y + 1) * side * 3), y * (side * 3 + 1) + 1);\n        }\n        const compressed = await this.deflate(scan);\n        const png = this.concat(this.pngSig(), this.chunk(\"IHDR\", this.IHDR(side)), this.chunk(\"IDAT\", compressed), this.chunk(\"IEND\", new Uint8Array()));\n        return \"data:image/png;base64,\" + this.toBase64PNG(png);\n    }\n    toBase64PNG(data) {\n        let s = \"\";\n        for (let i = 0; i < data.length; i++) {\n            s += String.fromCharCode(data[i]);\n        }\n        return btoa(s);\n    }\n    async assembleShader(app, currentPass) {\n        const internalApp = app;\n        const body = currentPass.shader;\n        const passList = internalApp.passes;\n        let b = 0;\n        // 1. Uniforms\n        let header = `${internalApp.uniforms.wgslStruct}\\n@group(0) @binding(${b++}) var<uniform> u: Uniforms;\\n`;\n        // 2. Global Textures & Sampler\n        internalApp.globalTextures.forEach((_, name) => {\n            header += `@group(0) @binding(${b++}) var ${name}: texture_2d<f32>;\\n`;\n        });\n        header += `@group(0) @binding(${b++}) var samp: sampler;\\n`;\n        // 3. Dependency Logic (The Fix)\n        // If deps is null/undefined, use all. If [], use only self.\n        const getRelevant = (pass) => {\n            let list = [];\n            if (pass.dependencies) {\n                list = passList.filter(p => pass.dependencies.includes(p.name));\n            }\n            else {\n                list = passList;\n            }\n            const resultSet = new Set(list);\n            if (!pass.isMain)\n                resultSet.add(pass); // Ensure self is ALWAYS present\n            return Array.from(resultSet).sort((a, b) => passList.indexOf(a) - passList.indexOf(b));\n        };\n        const relevant = getRelevant(currentPass);\n        relevant.forEach((p) => {\n            const isSelf = (currentPass.name === p.name);\n            if (p.type === 'compute') {\n                if (isSelf) {\n                    header += `@group(0) @binding(${b++}) var outTex: texture_storage_2d<rgba8unorm, write>;\\n`;\n                }\n                else {\n                    header += `@group(0) @binding(${b++}) var ${p.name}: texture_2d<f32>;\\n`;\n                }\n                if (p.storageBuffer) {\n                    const name = isSelf ? \"data\" : `${p.name}_data`;\n                    header += `@group(0) @binding(${b++}) var<storage, read_write> ${name}: ${p.isAtomic ? 'array<atomic<u32>>' : 'array<f32>'};\\n`;\n                }\n            }\n            else {\n                // Fragment pairs (Current + Prev)\n                header += `@group(0) @binding(${b++}) var ${p.name}: texture_2d<f32>;\\n`;\n                header += `@group(0) @binding(${b++}) var prev_${p.name}: texture_2d<f32>;\\n`;\n            }\n        });\n        const vert = `struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\r\n@vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\r\n    var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\r\n    return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\r\n}\\n`;\n        let final = (currentPass.type === 'fragment' ? vert : \"\") + header + internalApp.commonWGSL + body;\n        return final.replace(\"##WORKGROUP_SIZE\", `@compute @workgroup_size(16, 16, 1)`);\n    }\n    minify(code) {\n        return code.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*/g, '').replace(/\\s+/g, ' ').trim();\n    }\n    toBase64(src) {\n        const c = document.createElement('canvas');\n        c.width = src.width;\n        c.height = src.height;\n        const ctx = c.getContext('2d');\n        ctx.drawImage(src, 0, 0);\n        return c.toDataURL('image/png');\n    }\n    pngSig() {\n        return new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);\n    }\n    IHDR(s) {\n        return this.concat(this.u32(s), this.u32(s), new Uint8Array([8, 2, 0, 0, 0]));\n    }\n    async deflate(data) {\n        const cs = new CompressionStream(\"deflate\");\n        const writer = cs.writable.getWriter();\n        writer.write(data);\n        writer.close();\n        return new Uint8Array(await new Response(cs.readable).arrayBuffer());\n    }\n    u32(n) {\n        return new Uint8Array([\n            (n >>> 24) & 255,\n            (n >>> 16) & 255,\n            (n >>> 8) & 255,\n            n & 255\n        ]);\n    }\n    concat(...arrs) {\n        const len = arrs.reduce((s, a) => s + a.length, 0);\n        const out = new Uint8Array(len);\n        let o = 0;\n        for (const a of arrs) {\n            out.set(a, o);\n            o += a.length;\n        }\n        return out;\n    }\n    crc32(buf) {\n        let c = ~0;\n        for (let i = 0; i < buf.length; i++) {\n            c ^= buf[i];\n            for (let k = 0; k < 8; k++) {\n                c = (c & 1)\n                    ? (0xEDB88320 ^ (c >>> 1))\n                    : (c >>> 1);\n            }\n        }\n        return ~c >>> 0;\n    }\n    chunk(type, data) {\n        const t = new TextEncoder().encode(type);\n        return this.concat(this.u32(data.length), t, data, this.u32(this.crc32(this.concat(t, data))));\n    }\n}\nexports.TinyShadeBake = TinyShadeBake;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVGlueVNoYWRlQmFrZS50cyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLEVBQUU7QUFDRjtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVc7QUFDWCxxQkFBcUIsYUFBYSxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLFlBQVksZ0JBQWdCO0FBQ3BFO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0IsZ0JBQWdCLGFBQWEsbUJBQW1CLHVCQUF1QjtBQUN6SSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlEQUFpRCxtQkFBbUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQkFBMEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1DQUFtQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQkFBMEIsb0RBQW9EO0FBQzlFLHdCQUF3QixrRkFBa0Y7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDLHVCQUF1QixJQUFJLDJCQUEyQjtBQUM5RztBQUNBO0FBQ0EsNENBQTRDLElBQUksUUFBUSxLQUFLLGtCQUFrQjtBQUMvRSxTQUFTO0FBQ1Qsd0NBQXdDLElBQUksb0JBQW9CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJLG9EQUFvRDtBQUM1RztBQUNBO0FBQ0Esb0RBQW9ELElBQUksUUFBUSxPQUFPLGtCQUFrQjtBQUN6RjtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Qsb0RBQW9ELElBQUksNkJBQTZCLEtBQUssSUFBSSxrREFBa0Q7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSSxRQUFRLE9BQU8sa0JBQWtCO0FBQ3JGLGdEQUFnRCxJQUFJLGFBQWEsT0FBTyxrQkFBa0I7QUFDMUY7QUFDQSxTQUFTO0FBQ1QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RpbnlzaGFkZS8uL3NyYy9UaW55U2hhZGVCYWtlLnRzPzFhMjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRpbnlTaGFkZUJha2UgPSB2b2lkIDA7XG4vKipcbiAqIFRpbnlTaGFkZUJha2UgaGFuZGxlcyB0aGUgc2VyaWFsaXphdGlvbiBhbmQgZGlzdHJpYnV0aW9uIG9mIGEgVGlueVNoYWRlIGFwcGxpY2F0aW9uLlxuICogSXQgcHJvdmlkZXMgbWV0aG9kcyB0byBleHBvcnQgdGhlIGxpdmUgc2hhZGVyIGdyYXBoIGFzIGEgbWluaWZpZWQgSlNPTiBmaWxlIG9yXG4gKiBhcyBhIHNlbGYtY29udGFpbmVkLCBwaXhlbC1wYWNrZWQgSFRNTCBhcHBsaWNhdGlvbi4gKi9cbmNsYXNzIFRpbnlTaGFkZUJha2Uge1xuICAgIC8qKlxuICAgICAqIENhcHR1cmVzIHRoZSBjdXJyZW50IFRpbnlTaGFkZSBzdGF0ZSBhbmQgdHJpZ2dlcnMgYSBkb3dubG9hZCBvZiBhIHNlbGYtZXhlY3V0aW5nIEhUTUwgZmlsZS5cbiAgICAgKiBUaGUgYXBwbGljYXRpb24gbG9naWMgaXMgcGFja2VkIGludG8gYSBQTkcgaW1hZ2UgYW5kIGRlY29kZWQgYXQgcnVudGltZSB2aWEgYW4gPGltZz4gb25sb2FkIGhhbmRsZXIuXG4gICAgICogKiBAcGFyYW0gYXBwIC0gVGhlIGFjdGl2ZSBUaW55U2hhZGUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG91dHB1dCBIVE1MIGZpbGUgKGUuZy4sIFwic2NlbmUuaHRtbFwiKS5cbiAgICAgKiBAcGFyYW0gcnVubmVyU291cmNlIC0gVGhlIHN0cmluZ2lmaWVkIHNvdXJjZSBvZiB0aGUgVGlueVNoYWRlUnVubmVyIGNsYXNzLlxuICAgICAqIElmIG51bGwsIGl0IGF0dGVtcHRzIHRvIGZldGNoIHRoZSBzb3VyY2UgZnJvbSAnYXNzZXRzL3J1bm5lckNvZGUuanMnLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBkb3dubG9hZFNlbGZDb250YWluZWQoYXBwLCBmaWxlbmFtZSA9IFwiZGVtby5odG1sXCIsIHJ1bm5lclNvdXJjZSwgYXVkaW8pIHtcbiAgICAgICAgY29uc3QgYmFrZXIgPSBuZXcgVGlueVNoYWRlQmFrZSgpO1xuICAgICAgICBjb25zdCBncmFwaCA9IGF3YWl0IGJha2VyLmNvbGxlY3RHcmFwaERhdGEoYXBwKTtcbiAgICAgICAgaWYgKGF1ZGlvKSB7XG4gICAgICAgICAgICBncmFwaC5hdWRpbyA9IGF1ZGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmVyU291cmNlKSB7XG4gICAgICAgICAgICBydW5uZXJTb3VyY2UgPSBhd2FpdCBmZXRjaChcImFzc2V0cy9ydW5uZXJDb2RlLmpzXCIpLnRoZW4ociA9PiByLnRleHQoKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGRlZmF1bHQgcnVubmVyIGNvZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBydW5uZXJTb3VyY2UgPSBydW5uZXJTb3VyY2UudHJpbSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVc2luZyBjdXN0b20gcnVubmVyIGNvZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsZWFuUnVubmVyID0gcnVubmVyU291cmNlO1xuICAgICAgICBpZiAoY2xlYW5SdW5uZXIuc3RhcnRzV2l0aChcImNsYXNzXCIpKSB7XG4gICAgICAgICAgICBjbGVhblJ1bm5lciA9IFwiY29uc3QgVGlueVNoYWRlUnVubmVyID0gXCIgKyBjbGVhblJ1bm5lcjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhblJ1bm5lciA9IGNsZWFuUnVubmVyLnJlcGxhY2UoL15leHBvcnRcXHMrLywgXCJcIik7XG4gICAgICAgIGNvbnN0IGcgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdyYXBoKSk7XG4gICAgICAgIGcucGFzc2VzLmZvckVhY2goKHApID0+IHAuc2hhZGVyID0gYmFrZXIubWluaWZ5KHAuc2hhZGVyKSk7XG4gICAgICAgIGNvbnN0IGhhc0F1ZGlvID0gISFnLmF1ZGlvO1xuICAgICAgICBjb25zdCBqcyA9IGAoYXN5bmMoKT0+e1xyXG5jb25zdCBnPSR7SlNPTi5zdHJpbmdpZnkoZyl9O1xyXG4ke2NsZWFuUnVubmVyfTtcclxuXHJcbmNvbnN0IGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbmMud2lkdGg9JHtnLmNhbnZhc1NpemUud2lkdGh9O1xyXG5jLmhlaWdodD0ke2cuY2FudmFzU2l6ZS5oZWlnaHR9O1xyXG5jLnN0eWxlPSd3aWR0aDoxMDB2dztoZWlnaHQ6MTAwdmg7ZGlzcGxheTpibG9jazsnO1xyXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGMpO1xyXG5cclxuY29uc3Qgcj1uZXcgVGlueVNoYWRlUnVubmVyKGMsZyk7XHJcbmF3YWl0IHIuaW5pdCgpO1xyXG5cclxuICAgICAgICAke2hhc0F1ZGlvID8gYFxyXG4gICAgICAgIGNvbnN0IGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICAgICAgYi50ZXh0Q29udGVudD0nUlVOJztcclxuICAgICAgICBiLnN0eWxlPSdwb3NpdGlvbjpmaXhlZDtpbnNldDowO21hcmdpbjphdXRvO2ZvbnQtc2l6ZTo0dm1pbjtib3JkZXI6MCc7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChiKTtcclxuICAgICAgICBiLm9uY2xpY2s9KCk9PntiLnJlbW92ZSgpO3IucnVuKCl9O1xyXG4gICAgICAgIGAgOiBgci5ydW4oKWB9XHJcbiAgICAgICAgfSkoKWA7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoanMpO1xuICAgICAgICBjb25zdCBwbmdCYXNlNjQgPSBhd2FpdCBiYWtlci5nZW5lcmF0ZVBORyhwYXlsb2FkKTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGA8aHRtbD48Ym9keSBzdHlsZT1cIm1hcmdpbjowO2JhY2tncm91bmQ6IzAwMDtvdmVyZmxvdzpoaWRkZW47ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO1wiPlxyXG4gICAgICAgICAgICA8aW1nIHNyYz1cIiR7cG5nQmFzZTY0fVwiIHN0eWxlPVwiZGlzcGxheTpub25lXCIgb25sb2FkPVwiXHJcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24oaSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgdz1jLndpZHRoPWkud2lkdGgsaD1jLmhlaWdodD1pLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICB4PWMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgICAgICB4LmRyYXdJbWFnZShpLDAsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQ9eC5nZXRJbWFnZURhdGEoMCwwLHcsaCkuZGF0YSxiPScnLGo9MDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IoO2o8ZC5sZW5ndGg7aisrKWlmKGolNCE9MyYmZFtqXSliKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGRbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICgwLGV2YWwpKGIpO1xyXG4gICAgICAgICAgICAgICAgfSkodGhpcyk7XHJcbiAgICAgICAgICAgIFwiPjwvYm9keT48L2h0bWw+YDtcbiAgICAgICAgYmFrZXIudHJpZ2dlckRvd25sb2FkKG5ldyBCbG9iKFtodG1sXSwgeyB0eXBlOiBcInRleHQvaHRtbFwiIH0pLCBmaWxlbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIGN1cnJlbnQgc2hhZGVyIGdyYXBoLCBpbmNsdWRpbmcgYWxsIHBhc3NlcywgdW5pZm9ybXMsIGFuZCB0ZXh0dXJlcyxcbiAgICAgKiBhcyBhIG1pbmlmaWVkIEpTT04gZmlsZS4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcgb3IgZm9yIHVzZSB3aXRoIGEgY3VzdG9tIGxvYWRlci5cbiAgICAgKiAqIEBwYXJhbSBhcHAgLSBUaGUgYWN0aXZlIFRpbnlTaGFkZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgSlNPTiBmaWxlIChlLmcuLCBcImdyYXBoLmpzb25cIikuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGRvd25sb2FkR3JhcGgoYXBwLCBmaWxlbmFtZSA9IFwiZ3JhcGguanNvblwiKSB7XG4gICAgICAgIGNvbnN0IGJha2VyID0gbmV3IFRpbnlTaGFkZUJha2UoKTtcbiAgICAgICAgY29uc3QgZ3JhcGggPSBhd2FpdCBiYWtlci5jb2xsZWN0R3JhcGhEYXRhKGFwcCk7XG4gICAgICAgIGdyYXBoLnBhc3Nlcy5mb3JFYWNoKChwKSA9PiBwLnNoYWRlciA9IGJha2VyLm1pbmlmeShwLnNoYWRlcikpO1xuICAgICAgICBpZiAoZ3JhcGguY29tbW9uKVxuICAgICAgICAgICAgZ3JhcGguY29tbW9uID0gYmFrZXIubWluaWZ5KGdyYXBoLmNvbW1vbik7XG4gICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShncmFwaCk7XG4gICAgICAgIGJha2VyLnRyaWdnZXJEb3dubG9hZChuZXcgQmxvYihbanNvbl0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSksIGZpbGVuYW1lKTtcbiAgICB9XG4gICAgdHJpZ2dlckRvd25sb2FkKGJsb2IsIGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgICAgYS5kb3dubG9hZCA9IGZpbGVuYW1lO1xuICAgICAgICBhLmNsaWNrKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpLCAxMDApO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZ2V0R3JhcGhEYXRhKGFwcCkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbnlTaGFkZUJha2UoKS5jb2xsZWN0R3JhcGhEYXRhKGFwcCk7XG4gICAgfVxuICAgIGFzeW5jIGNvbGxlY3RHcmFwaERhdGEoYXBwKSB7XG4gICAgICAgIGNvbnN0IGludGVybmFsQXBwID0gYXBwO1xuICAgICAgICBjb25zdCBiYWtlZFRleHR1cmVzID0gW107XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSBpbnRlcm5hbEFwcC50ZXh0dXJlU291cmNlcztcbiAgICAgICAgaWYgKHNvdXJjZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIHNvdXJjZV0gb2Ygc291cmNlcykge1xuICAgICAgICAgICAgICAgIGJha2VkVGV4dHVyZXMucHVzaCh7IG5hbWUsIGRhdGE6IHRoaXMudG9CYXNlNjQoc291cmNlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxQYXNzZXMgPSBbLi4uaW50ZXJuYWxBcHAucGFzc2VzXTtcbiAgICAgICAgYWxsUGFzc2VzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJtYWluXCIsIHR5cGU6ICdmcmFnbWVudCcsIGlzTWFpbjogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWRlcjogaW50ZXJuYWxBcHAubWFpblBhc3NTaGFkZXIsIHRleHR1cmVzOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmFrZWRQYXNzZXMgPSBhd2FpdCBQcm9taXNlLmFsbChhbGxQYXNzZXMubWFwKGFzeW5jIChwKSA9PiAoe1xuICAgICAgICAgICAgbmFtZTogcC5uYW1lLFxuICAgICAgICAgICAgdHlwZTogcC50eXBlLFxuICAgICAgICAgICAgc2hhZGVyOiBhd2FpdCB0aGlzLmFzc2VtYmxlU2hhZGVyKGFwcCwgcCksXG4gICAgICAgICAgICBzdG9yYWdlQnVmZmVyU2l6ZTogcC5zdG9yYWdlQnVmZmVyPy5zaXplLFxuICAgICAgICAgICAgaXNBdG9taWM6IHAuaXNBdG9taWMsXG4gICAgICAgICAgICBpc01haW46IHAuaXNNYWluXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYW52YXNTaXplOiB7IHdpZHRoOiBhcHAuY2FudmFzLndpZHRoLCBoZWlnaHQ6IGFwcC5jYW52YXMuaGVpZ2h0IH0sXG4gICAgICAgICAgICB1bmlmb3JtczogeyBieXRlU2l6ZTogaW50ZXJuYWxBcHAudW5pZm9ybXMuYnl0ZVNpemUsIHN0cnVjdDogaW50ZXJuYWxBcHAudW5pZm9ybXMud2dzbFN0cnVjdCB9LFxuICAgICAgICAgICAgdGV4dHVyZXM6IGJha2VkVGV4dHVyZXMsXG4gICAgICAgICAgICBwYXNzZXM6IGJha2VkUGFzc2VzLFxuICAgICAgICAgICAgd29ya2dyb3VwU2l6ZTogaW50ZXJuYWxBcHAud29ya2dyb3VwU2l6ZS5zdHIsXG4gICAgICAgICAgICBjb21tb246IGludGVybmFsQXBwLmNvbW1vbldHU0xcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhbiBhcmJpdHJhcnkgYnl0ZSBwYXlsb2FkIGludG8gYSBQTkcgaW1hZ2UgYW5kIHJldHVybnMgaXQgYXMgYVxuICAgICAqIEJhc2U2NCBkYXRhIFVSTCAoYGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwuLi5gKS5cbiAgICAgKlxuICAgICAqIFRoZSBQTkcgaXMgY29uc3RydWN0ZWQgbWFudWFsbHkgKG5vIENhbnZhcyB1c2FnZSkgdG8gZW5zdXJlOlxuICAgICAqICAtIGRldGVybWluaXN0aWMgb3V0cHV0XG4gICAgICogIC0gcHJlZGljdGFibGUgc2NhbmxpbmUgbGF5b3V0XG4gICAgICogIC0gcmVhbCBERUZMQVRFIGNvbXByZXNzaW9uIG9mIElEQVQgZGF0YVxuICAgICAqICAtIGJyb3dzZXItb25seSBvcGVyYXRpb24gd2l0aG91dCBleHRlcm5hbCBsaWJyYXJpZXMgKGUuZy4gcGFrbylcbiAgICAgKlxuICAgICAqIFBheWxvYWQgYnl0ZXMgYXJlIHBhY2tlZCBzZXF1ZW50aWFsbHkgaW50byBSR0IgcGl4ZWxzICg4LWJpdCwgdHJ1ZWNvbG9yKS5cbiAgICAgKiBJZiB0aGUgcGF5bG9hZCBsZW5ndGggaXMgbm90IGRpdmlzaWJsZSBieSAzLCB6ZXJvIHBhZGRpbmcgaXMgYXBwZW5kZWQuXG4gICAgICpcbiAgICAgKiBUaGUgaW1hZ2UgZGltZW5zaW9ucyBhcmUgY2hvc2VuIGFzIHRoZSBzbWFsbGVzdCBzcXVhcmUgY2FwYWJsZSBvZiBob2xkaW5nXG4gICAgICogdGhlIGZ1bGwgcGF5bG9hZC4gVW51c2VkIHBpeGVscyByZW1haW4gemVyb2VkLlxuICAgICAqXG4gICAgICogUE5HIGRldGFpbHM6XG4gICAgICogIC0gQ29sb3IgdHlwZTogMiAoUkdCKVxuICAgICAqICAtIEJpdCBkZXB0aDogOFxuICAgICAqICAtIEZpbHRlcjogMCAoTm9uZSkgcGVyIHNjYW5saW5lXG4gICAgICogIC0gQ29tcHJlc3Npb246IHpsaWIvREVGTEFURSB2aWEgQ29tcHJlc3Npb25TdHJlYW1cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgZm9yIGRlbW9zY2VuZS1zdHlsZSBhc3NldCBiYWtpbmcgd2hlcmUgdGhlIFBOR1xuICAgICAqIGFjdHMgYXMgYSBjb21wcmVzc2VkIGNvbnRhaW5lciwgbm90IGEgdmlzdWFsIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBheWxvYWQgQXJiaXRyYXJ5IGJpbmFyeSBkYXRhIHRvIGVtYmVkIGluIHRoZSBQTkcuXG4gICAgICogQHJldHVybnMgQSBCYXNlNjQtZW5jb2RlZCBQTkcgZGF0YSBVUkwgc3VpdGFibGUgZm9yIHVzZSBpbiA8aW1nIHNyYz4uXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVQTkcocGF5bG9hZCkge1xuICAgICAgICB3aGlsZSAocGF5bG9hZC5sZW5ndGggJSAzKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gdGhpcy5jb25jYXQocGF5bG9hZCwgbmV3IFVpbnQ4QXJyYXkoWzBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lkZSA9IE1hdGguY2VpbChNYXRoLnNxcnQocGF5bG9hZC5sZW5ndGggLyAzKSk7XG4gICAgICAgIGNvbnN0IHJnYiA9IG5ldyBVaW50OEFycmF5KHNpZGUgKiBzaWRlICogMyk7XG4gICAgICAgIHJnYi5zZXQocGF5bG9hZCk7XG4gICAgICAgIGNvbnN0IHNjYW4gPSBuZXcgVWludDhBcnJheShzaWRlICogKHNpZGUgKiAzICsgMSkpO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpZGU7IHkrKykge1xuICAgICAgICAgICAgc2Nhblt5ICogKHNpZGUgKiAzICsgMSldID0gMDtcbiAgICAgICAgICAgIHNjYW4uc2V0KHJnYi5zdWJhcnJheSh5ICogc2lkZSAqIDMsICh5ICsgMSkgKiBzaWRlICogMyksIHkgKiAoc2lkZSAqIDMgKyAxKSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBhd2FpdCB0aGlzLmRlZmxhdGUoc2Nhbik7XG4gICAgICAgIGNvbnN0IHBuZyA9IHRoaXMuY29uY2F0KHRoaXMucG5nU2lnKCksIHRoaXMuY2h1bmsoXCJJSERSXCIsIHRoaXMuSUhEUihzaWRlKSksIHRoaXMuY2h1bmsoXCJJREFUXCIsIGNvbXByZXNzZWQpLCB0aGlzLmNodW5rKFwiSUVORFwiLCBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIiArIHRoaXMudG9CYXNlNjRQTkcocG5nKTtcbiAgICB9XG4gICAgdG9CYXNlNjRQTkcoZGF0YSkge1xuICAgICAgICBsZXQgcyA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidG9hKHMpO1xuICAgIH1cbiAgICBhc3luYyBhc3NlbWJsZVNoYWRlcihhcHAsIGN1cnJlbnRQYXNzKSB7XG4gICAgICAgIGNvbnN0IGludGVybmFsQXBwID0gYXBwO1xuICAgICAgICBjb25zdCBib2R5ID0gY3VycmVudFBhc3Muc2hhZGVyO1xuICAgICAgICBjb25zdCBwYXNzTGlzdCA9IGludGVybmFsQXBwLnBhc3NlcztcbiAgICAgICAgbGV0IGIgPSAwO1xuICAgICAgICAvLyAxLiBVbmlmb3Jtc1xuICAgICAgICBsZXQgaGVhZGVyID0gYCR7aW50ZXJuYWxBcHAudW5pZm9ybXMud2dzbFN0cnVjdH1cXG5AZ3JvdXAoMCkgQGJpbmRpbmcoJHtiKyt9KSB2YXI8dW5pZm9ybT4gdTogVW5pZm9ybXM7XFxuYDtcbiAgICAgICAgLy8gMi4gR2xvYmFsIFRleHR1cmVzICYgU2FtcGxlclxuICAgICAgICBpbnRlcm5hbEFwcC5nbG9iYWxUZXh0dXJlcy5mb3JFYWNoKChfLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBoZWFkZXIgKz0gYEBncm91cCgwKSBAYmluZGluZygke2IrK30pIHZhciAke25hbWV9OiB0ZXh0dXJlXzJkPGYzMj47XFxuYDtcbiAgICAgICAgfSk7XG4gICAgICAgIGhlYWRlciArPSBgQGdyb3VwKDApIEBiaW5kaW5nKCR7YisrfSkgdmFyIHNhbXA6IHNhbXBsZXI7XFxuYDtcbiAgICAgICAgLy8gMy4gRGVwZW5kZW5jeSBMb2dpYyAoVGhlIEZpeClcbiAgICAgICAgLy8gSWYgZGVwcyBpcyBudWxsL3VuZGVmaW5lZCwgdXNlIGFsbC4gSWYgW10sIHVzZSBvbmx5IHNlbGYuXG4gICAgICAgIGNvbnN0IGdldFJlbGV2YW50ID0gKHBhc3MpID0+IHtcbiAgICAgICAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICAgICAgICBpZiAocGFzcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ID0gcGFzc0xpc3QuZmlsdGVyKHAgPT4gcGFzcy5kZXBlbmRlbmNpZXMuaW5jbHVkZXMocC5uYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ID0gcGFzc0xpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHRTZXQgPSBuZXcgU2V0KGxpc3QpO1xuICAgICAgICAgICAgaWYgKCFwYXNzLmlzTWFpbilcbiAgICAgICAgICAgICAgICByZXN1bHRTZXQuYWRkKHBhc3MpOyAvLyBFbnN1cmUgc2VsZiBpcyBBTFdBWVMgcHJlc2VudFxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0U2V0KS5zb3J0KChhLCBiKSA9PiBwYXNzTGlzdC5pbmRleE9mKGEpIC0gcGFzc0xpc3QuaW5kZXhPZihiKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlbGV2YW50ID0gZ2V0UmVsZXZhbnQoY3VycmVudFBhc3MpO1xuICAgICAgICByZWxldmFudC5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1NlbGYgPSAoY3VycmVudFBhc3MubmFtZSA9PT0gcC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09ICdjb21wdXRlJykge1xuICAgICAgICAgICAgICAgIGlmIChpc1NlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyICs9IGBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtiKyt9KSB2YXIgb3V0VGV4OiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8cmdiYTh1bm9ybSwgd3JpdGU+O1xcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgKz0gYEBncm91cCgwKSBAYmluZGluZygke2IrK30pIHZhciAke3AubmFtZX06IHRleHR1cmVfMmQ8ZjMyPjtcXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocC5zdG9yYWdlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBpc1NlbGYgPyBcImRhdGFcIiA6IGAke3AubmFtZX1fZGF0YWA7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciArPSBgQGdyb3VwKDApIEBiaW5kaW5nKCR7YisrfSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+ICR7bmFtZX06ICR7cC5pc0F0b21pYyA/ICdhcnJheTxhdG9taWM8dTMyPj4nIDogJ2FycmF5PGYzMj4nfTtcXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZyYWdtZW50IHBhaXJzIChDdXJyZW50ICsgUHJldilcbiAgICAgICAgICAgICAgICBoZWFkZXIgKz0gYEBncm91cCgwKSBAYmluZGluZygke2IrK30pIHZhciAke3AubmFtZX06IHRleHR1cmVfMmQ8ZjMyPjtcXG5gO1xuICAgICAgICAgICAgICAgIGhlYWRlciArPSBgQGdyb3VwKDApIEBiaW5kaW5nKCR7YisrfSkgdmFyIHByZXZfJHtwLm5hbWV9OiB0ZXh0dXJlXzJkPGYzMj47XFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHZlcnQgPSBgc3RydWN0IFZTT3V0IHsgQGJ1aWx0aW4ocG9zaXRpb24pIHBvczogdmVjNGYsIEBsb2NhdGlvbigwKSB1djogdmVjMmYgfTtcclxuQHZlcnRleCBmbiB2cyhAYnVpbHRpbih2ZXJ0ZXhfaW5kZXgpIGk6IHUzMikgLT4gVlNPdXQge1xyXG4gICAgdmFyIHAgPSBhcnJheTx2ZWMyZiwgMz4odmVjMmYoLTEuMCwgLTEuMCksIHZlYzJmKDMuMCwgLTEuMCksIHZlYzJmKC0xLjAsIDMuMCkpO1xyXG4gICAgcmV0dXJuIFZTT3V0KHZlYzRmKHBbaV0sIDAuMCwgMS4wKSwgdmVjMmYocFtpXS54ICogMC41ICsgMC41LCAwLjUgLSBwW2ldLnkgKiAwLjUpKTtcclxufVxcbmA7XG4gICAgICAgIGxldCBmaW5hbCA9IChjdXJyZW50UGFzcy50eXBlID09PSAnZnJhZ21lbnQnID8gdmVydCA6IFwiXCIpICsgaGVhZGVyICsgaW50ZXJuYWxBcHAuY29tbW9uV0dTTCArIGJvZHk7XG4gICAgICAgIHJldHVybiBmaW5hbC5yZXBsYWNlKFwiIyNXT1JLR1JPVVBfU0laRVwiLCBgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKDE2LCAxNiwgMSlgKTtcbiAgICB9XG4gICAgbWluaWZ5KGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvZGUucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcL3xcXC9cXC8uKi9nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICB9XG4gICAgdG9CYXNlNjQoc3JjKSB7XG4gICAgICAgIGNvbnN0IGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgYy53aWR0aCA9IHNyYy53aWR0aDtcbiAgICAgICAgYy5oZWlnaHQgPSBzcmMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2Uoc3JjLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIGMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICB9XG4gICAgcG5nU2lnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzEzNywgODAsIDc4LCA3MSwgMTMsIDEwLCAyNiwgMTBdKTtcbiAgICB9XG4gICAgSUhEUihzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNhdCh0aGlzLnUzMihzKSwgdGhpcy51MzIocyksIG5ldyBVaW50OEFycmF5KFs4LCAyLCAwLCAwLCAwXSkpO1xuICAgIH1cbiAgICBhc3luYyBkZWZsYXRlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgY3MgPSBuZXcgQ29tcHJlc3Npb25TdHJlYW0oXCJkZWZsYXRlXCIpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBjcy53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKGRhdGEpO1xuICAgICAgICB3cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IG5ldyBSZXNwb25zZShjcy5yZWFkYWJsZSkuYXJyYXlCdWZmZXIoKSk7XG4gICAgfVxuICAgIHUzMihuKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAobiA+Pj4gMjQpICYgMjU1LFxuICAgICAgICAgICAgKG4gPj4+IDE2KSAmIDI1NSxcbiAgICAgICAgICAgIChuID4+PiA4KSAmIDI1NSxcbiAgICAgICAgICAgIG4gJiAyNTVcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbmNhdCguLi5hcnJzKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGFycnMucmVkdWNlKChzLCBhKSA9PiBzICsgYS5sZW5ndGgsIDApO1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBsZXQgbyA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBhcnJzKSB7XG4gICAgICAgICAgICBvdXQuc2V0KGEsIG8pO1xuICAgICAgICAgICAgbyArPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBjcmMzMihidWYpIHtcbiAgICAgICAgbGV0IGMgPSB+MDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGMgXj0gYnVmW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgICAgICAgICAgICBjID0gKGMgJiAxKVxuICAgICAgICAgICAgICAgICAgICA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKVxuICAgICAgICAgICAgICAgICAgICA6IChjID4+PiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gfmMgPj4+IDA7XG4gICAgfVxuICAgIGNodW5rKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgdCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uY2F0KHRoaXMudTMyKGRhdGEubGVuZ3RoKSwgdCwgZGF0YSwgdGhpcy51MzIodGhpcy5jcmMzMih0aGlzLmNvbmNhdCh0LCBkYXRhKSkpKTtcbiAgICB9XG59XG5leHBvcnRzLlRpbnlTaGFkZUJha2UgPSBUaW55U2hhZGVCYWtlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/TinyShadeBake.ts\n\n}");

/***/ },

/***/ "./src/TinyShaderRunner.ts?raw"
/*!*************************************!*\
  !*** ./src/TinyShaderRunner.ts?raw ***!
  \*************************************/
(module) {

"use strict";
module.exports = "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TinyShadeRunner = void 0;\n/**\n * TinyShadeRunner\n * Handles the execution of a baked TinyShade graph.\n */\nclass TinyShadeRunner {\n    h;\n    g;\n    d;\n    c;\n    u;\n    p = new Map();\n    l = new Map();\n    t = new Map();\n    s;\n    a;\n    constructor(h, g) {\n        this.h = h;\n        this.g = g;\n    }\n    async init() {\n        const adapter = await navigator.gpu.requestAdapter();\n        if (!adapter)\n            throw new Error(\"WebGPU adapter not available\");\n        this.d = await adapter.requestDevice();\n        this.c = this.h.getContext(\"webgpu\");\n        const dpr = window.devicePixelRatio || 1;\n        this.h.width = this.h.width * dpr;\n        this.h.height = this.h.height * dpr;\n        if (this.g.audio) {\n            const { code, data, activator } = this.g.audio;\n            const AudioClass = new Function(`${code}; return GPUSynth;`)();\n            this.a = new AudioClass(this.d, data, ...(activator ?? []));\n        }\n        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n        this.c.configure({\n            device: this.d,\n            format: presentationFormat,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.s = this.d.createSampler({ magFilter: 'linear', minFilter: 'linear' });\n        this.u = this.d.createBuffer({\n            size: this.g.uniforms.byteSize,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n        for (const p of this.g.passes) {\n            const size = [this.g.canvasSize.width, this.g.canvasSize.height];\n            if (!p.isMain) {\n                if (p.type === 'compute') {\n                    this.t.set(p.name, [\n                        this.d.createTexture({\n                            size,\n                            format: 'rgba8unorm',\n                            usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING\n                        })\n                    ]);\n                }\n                else {\n                    const create = () => this.d.createTexture({\n                        size,\n                        format: \"bgra8unorm\",\n                        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n                    });\n                    this.t.set(p.name, [create(), create()]);\n                }\n            }\n            const layoutEntries = [];\n            const bindingRegex = /@binding\\s*\\(\\s*(\\d+)\\s*\\)\\s+var\\s*(?:<([^>]+)>)?\\s*([\\w\\d_]+)/g;\n            let match;\n            const visibility = p.type === 'compute' ? GPUShaderStage.COMPUTE : GPUShaderStage.FRAGMENT;\n            while ((match = bindingRegex.exec(p.shader)) !== null) {\n                const binding = parseInt(match[1]);\n                const typeInfo = match[2] || \"\";\n                const varName = match[3];\n                if (typeInfo.includes(\"uniform\")) {\n                    layoutEntries.push({ binding, visibility, buffer: { type: 'uniform' } });\n                }\n                else if (varName === \"outTex\") {\n                    layoutEntries.push({\n                        binding,\n                        visibility,\n                        storageTexture: { format: 'rgba8unorm', access: 'write-only' }\n                    });\n                }\n                else if (typeInfo.includes(\"storage\")) {\n                    layoutEntries.push({ binding, visibility, buffer: { type: 'storage' } });\n                }\n                else if (varName === \"samp\") {\n                    layoutEntries.push({ binding, visibility, sampler: { type: 'filtering' } });\n                }\n                else {\n                    layoutEntries.push({ binding, visibility, texture: { sampleType: 'float' } });\n                }\n            }\n            const layout = this.d.createBindGroupLayout({ entries: layoutEntries });\n            this.l.set(p.name, layout);\n            const mod = this.d.createShaderModule({ code: p.shader });\n            const pipelineLayout = this.d.createPipelineLayout({ bindGroupLayouts: [layout] });\n            if (p.type === 'compute') {\n                this.p.set(p.name, this.d.createComputePipeline({\n                    layout: pipelineLayout,\n                    compute: { module: mod, entryPoint: 'main' }\n                }));\n            }\n            else {\n                this.p.set(p.name, this.d.createRenderPipeline({\n                    layout: pipelineLayout,\n                    vertex: { module: mod, entryPoint: 'vs' },\n                    fragment: {\n                        module: mod,\n                        entryPoint: 'main',\n                        targets: [{ format: p.isMain ? presentationFormat : \"bgra8unorm\" }]\n                    }\n                }));\n            }\n        }\n    }\n    createBindGroup(pass, writeIdx) {\n        const layout = this.l.get(pass.name);\n        const readIdx = 1 - writeIdx;\n        const resources = new Map();\n        resources.set(\"u\", { buffer: this.u });\n        resources.set(\"samp\", this.s);\n        for (const p of this.g.passes) {\n            if (p.isMain)\n                continue;\n            const texs = this.t.get(p.name);\n            if (p.type === 'compute') {\n                if (p.name === pass.name) {\n                    resources.set(\"outTex\", texs[0].createView());\n                }\n                resources.set(p.name, texs[0].createView());\n            }\n            else {\n                resources.set(p.name, texs[readIdx].createView());\n                resources.set(`prev_${p.name}`, texs[readIdx].createView());\n            }\n        }\n        const entries = [];\n        const bindingRegex = /@binding\\s*\\(\\s*(\\d+)\\s*\\)\\s+var\\s*(?:<([^>]+)>)?\\s*([\\w\\d_]+)/g;\n        bindingRegex.lastIndex = 0;\n        let match;\n        while ((match = bindingRegex.exec(pass.shader)) !== null) {\n            const binding = parseInt(match[1]);\n            const varName = match[3];\n            const res = resources.get(varName);\n            if (res) {\n                entries.push({ binding, resource: res });\n            }\n            else {\n                console.error(`Missing resource for @binding(${binding}) var ${varName}`);\n            }\n        }\n        return this.d.createBindGroup({ layout, entries });\n    }\n    run() {\n        const audioPlugin = this.a;\n        let frame = 0;\n        if (audioPlugin)\n            audioPlugin.play();\n        const render = (now) => {\n            frame++;\n            const writeIdx = frame % 2;\n            const time = (audioPlugin && audioPlugin.isPlaying) ? audioPlugin.getTime() : now / 1000;\n            const uData = new Float32Array([this.h.width, this.h.height, this.h.width / this.h.height, time]);\n            this.d.queue.writeBuffer(this.u, 0, uData);\n            const enc = this.d.createCommandEncoder();\n            for (const p of this.g.passes) {\n                const bg = this.createBindGroup(p, writeIdx);\n                if (p.type === 'compute') {\n                    const passEnc = enc.beginComputePass();\n                    passEnc.setPipeline(this.p.get(p.name));\n                    passEnc.setBindGroup(0, bg);\n                    passEnc.dispatchWorkgroups(Math.ceil(this.h.width / 16), Math.ceil(this.h.height / 16));\n                    passEnc.end();\n                }\n                else {\n                    const view = p.isMain\n                        ? this.c.getCurrentTexture().createView()\n                        : this.t.get(p.name)[writeIdx].createView();\n                    const passEnc = enc.beginRenderPass({\n                        colorAttachments: [{\n                                view,\n                                loadOp: 'clear',\n                                storeOp: 'store',\n                                clearValue: [0, 0, 0, 1]\n                            }]\n                    });\n                    passEnc.setPipeline(this.p.get(p.name));\n                    passEnc.setBindGroup(0, bg);\n                    passEnc.draw(3);\n                    passEnc.end();\n                }\n            }\n            this.d.queue.submit([enc.finish()]);\n            requestAnimationFrame(render);\n        };\n        requestAnimationFrame(render);\n    }\n}\nexports.TinyShadeRunner = TinyShadeRunner;\n";

/***/ },

/***/ "./src/UniformLayout.ts"
/*!******************************!*\
  !*** ./src/UniformLayout.ts ***!
  \******************************/
(__unused_webpack_module, exports) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UniformLayout = void 0;\n/**\n * Manages uniform buffer layout and data for WebGPU shaders.\n *\n * Handles the organization, alignment, and serialization of uniform values\n * according to WGSL specifications. Automatically manages buffer size,\n * proper alignment (including the 16-byte requirement for WebGPU uniform buffers),\n * and provides real-time updates for time-based and function-driven uniforms.\n *\n * @example\n * ```typescript\n * const layout = new UniformLayout([800, 600]);\n * layout.addUniform(\"color\", [1.0, 0.0, 0.0, 1.0]);\n * layout.addUniform(\"speed\", (time) => Math.sin(time));\n * layout.update(performance.now() / 1000);\n * const buffer = layout.float32Array;\n * ```\n */\nclass UniformLayout {\n    entries = [];\n    size = 0;\n    _cache = null;\n    frameCount = 0;\n    currentTime = 0;\n    constructor(initialResolution) {\n        // We initialize with standard global uniforms\n        this.addUniform({ name: \"resolution\", value: initialResolution });\n        this.addUniform({ name: \"time\", value: 0 });\n    }\n    /**\n     * Adds a uniform to the layout with proper WGSL alignment.\n     * @param options - The uniform configuration\n     * @param options.name - The name of the uniform\n     * @param options.value - The value of the uniform\n     * @returns This instance for method chaining\n     */\n    addUniform({ name, value }) {\n        const { type, size, align } = this.inferType(value);\n        // Standard WGSL alignment: offset must be a multiple of 'align'\n        const offset = Math.ceil(this.size / align) * align;\n        this.entries.push({ name, type, size, align, offset, value });\n        this.size = offset + size;\n        this._cache = null; // Reset cache so it grows to fit new size\n        return this;\n    }\n    // This is the critical fix for your animation issue\n    /**\n     * Updates the uniform layout with the current time and increments the frame counter.\n     * @param time - The current time value to update the uniform layout with.\n     */\n    update(time) {\n        this.currentTime = time;\n        this.frameCount++;\n    }\n    /**\n     * Gets the byte size of the uniform layout, rounded up to the nearest multiple of 16.\n     *\n     * @remarks\n     * WebGPU requires uniform buffers to be aligned to 16-byte boundaries.\n     *\n     * @returns The size in bytes, guaranteed to be a multiple of 16.\n     */\n    get byteSize() {\n        // Uniform buffers must be multiples of 16 bytes in WebGPU\n        return Math.ceil(this.size / 16) * 16;\n    }\n    /**\n     * Generates a WGSL struct definition string for the uniform layout.\n     *\n     * @returns {string} A WGSL struct named \"Uniforms\" containing all entries\n     * with their respective names and types, formatted as a valid WGSL struct declaration.\n     *\n     * @example\n     * // Returns: \"struct Uniforms {\\n  position: vec3,\\n  color: vec4,\\n};\"\n     * const structDef = uniformLayout.wgslStruct;\n     */\n    get wgslStruct() {\n        return `struct Uniforms {\\n${this.entries.map(e => `  ${e.name}: ${e.type},`).join(\"\\n\")}\\n};`;\n    }\n    /**\n     * Gets a Float32Array representation of the uniform layout data.\n     *\n     * Lazily initializes and caches a Float32Array buffer sized to accommodate all uniform entries.\n     * Iterates through each entry, resolving its value (from time, a function, or a static value),\n     * and writes the resolved value(s) into the appropriate offset in the cache.\n     *\n     * @returns {Float32Array} The cached Float32Array containing all uniform values in binary format.\n     */\n    get float32Array() {\n        if (!this._cache)\n            this._cache = new Float32Array(this.byteSize / 4);\n        for (const e of this.entries) {\n            let val;\n            // Determine the value based on the entry name or function\n            if (e.name === \"time\") {\n                val = this.currentTime;\n            }\n            else if (typeof e.value === \"function\") {\n                val = e.value(this.currentTime, this.frameCount);\n            }\n            else {\n                val = e.value;\n            }\n            const startIndex = e.offset / 4;\n            if (typeof val === \"number\") {\n                this._cache[startIndex] = val;\n            }\n            else {\n                for (let i = 0; i < val.length; i++) {\n                    this._cache[startIndex + i] = val[i];\n                }\n            }\n        }\n        return this._cache;\n    }\n    /**\n     * Infers the WGSL type and memory layout information for a uniform value.\n     * @param value - The uniform value to infer the type for. Can be a number, array of numbers, or a function that returns one of these.\n     * @returns An object containing the WGSL type name, size in bytes, and alignment requirement in bytes.\n     * @throws {Error} If the uniform array length is not 2, 3, or 4.\n     */\n    inferType(value) {\n        const sample = typeof value === \"function\" ? value(0, 0) : value;\n        if (typeof sample === \"number\")\n            return { type: \"f32\", size: 4, align: 4 };\n        const len = sample.length;\n        switch (len) {\n            case 2: return { type: \"vec2f\", size: 8, align: 8 };\n            case 3: return { type: \"vec3f\", size: 12, align: 16 }; // Note: vec3 aligns to 16\n            case 4: return { type: \"vec4f\", size: 16, align: 16 };\n            default: throw new Error(`Uniform array length ${len} not supported.`);\n        }\n    }\n}\nexports.UniformLayout = UniformLayout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVW5pZm9ybUxheW91dC50cyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQThDO0FBQ3hFLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBLDRCQUE0Qix3Q0FBd0M7QUFDcEU7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1Q0FBdUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUksMkJBQTJCLE9BQU8sSUFBSSxPQUFPLGVBQWUsSUFBSTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCLHNDQUFzQztBQUNuRSw2QkFBNkI7QUFDN0IsNkRBQTZELEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlueXNoYWRlLy4vc3JjL1VuaWZvcm1MYXlvdXQudHM/OTE2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5pZm9ybUxheW91dCA9IHZvaWQgMDtcbi8qKlxuICogTWFuYWdlcyB1bmlmb3JtIGJ1ZmZlciBsYXlvdXQgYW5kIGRhdGEgZm9yIFdlYkdQVSBzaGFkZXJzLlxuICpcbiAqIEhhbmRsZXMgdGhlIG9yZ2FuaXphdGlvbiwgYWxpZ25tZW50LCBhbmQgc2VyaWFsaXphdGlvbiBvZiB1bmlmb3JtIHZhbHVlc1xuICogYWNjb3JkaW5nIHRvIFdHU0wgc3BlY2lmaWNhdGlvbnMuIEF1dG9tYXRpY2FsbHkgbWFuYWdlcyBidWZmZXIgc2l6ZSxcbiAqIHByb3BlciBhbGlnbm1lbnQgKGluY2x1ZGluZyB0aGUgMTYtYnl0ZSByZXF1aXJlbWVudCBmb3IgV2ViR1BVIHVuaWZvcm0gYnVmZmVycyksXG4gKiBhbmQgcHJvdmlkZXMgcmVhbC10aW1lIHVwZGF0ZXMgZm9yIHRpbWUtYmFzZWQgYW5kIGZ1bmN0aW9uLWRyaXZlbiB1bmlmb3Jtcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgbGF5b3V0ID0gbmV3IFVuaWZvcm1MYXlvdXQoWzgwMCwgNjAwXSk7XG4gKiBsYXlvdXQuYWRkVW5pZm9ybShcImNvbG9yXCIsIFsxLjAsIDAuMCwgMC4wLCAxLjBdKTtcbiAqIGxheW91dC5hZGRVbmlmb3JtKFwic3BlZWRcIiwgKHRpbWUpID0+IE1hdGguc2luKHRpbWUpKTtcbiAqIGxheW91dC51cGRhdGUocGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwKTtcbiAqIGNvbnN0IGJ1ZmZlciA9IGxheW91dC5mbG9hdDMyQXJyYXk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgVW5pZm9ybUxheW91dCB7XG4gICAgZW50cmllcyA9IFtdO1xuICAgIHNpemUgPSAwO1xuICAgIF9jYWNoZSA9IG51bGw7XG4gICAgZnJhbWVDb3VudCA9IDA7XG4gICAgY3VycmVudFRpbWUgPSAwO1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxSZXNvbHV0aW9uKSB7XG4gICAgICAgIC8vIFdlIGluaXRpYWxpemUgd2l0aCBzdGFuZGFyZCBnbG9iYWwgdW5pZm9ybXNcbiAgICAgICAgdGhpcy5hZGRVbmlmb3JtKHsgbmFtZTogXCJyZXNvbHV0aW9uXCIsIHZhbHVlOiBpbml0aWFsUmVzb2x1dGlvbiB9KTtcbiAgICAgICAgdGhpcy5hZGRVbmlmb3JtKHsgbmFtZTogXCJ0aW1lXCIsIHZhbHVlOiAwIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdW5pZm9ybSB0byB0aGUgbGF5b3V0IHdpdGggcHJvcGVyIFdHU0wgYWxpZ25tZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHVuaWZvcm0gY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdW5pZm9ybVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSB1bmlmb3JtXG4gICAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAgICovXG4gICAgYWRkVW5pZm9ybSh7IG5hbWUsIHZhbHVlIH0pIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBzaXplLCBhbGlnbiB9ID0gdGhpcy5pbmZlclR5cGUodmFsdWUpO1xuICAgICAgICAvLyBTdGFuZGFyZCBXR1NMIGFsaWdubWVudDogb2Zmc2V0IG11c3QgYmUgYSBtdWx0aXBsZSBvZiAnYWxpZ24nXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGguY2VpbCh0aGlzLnNpemUgLyBhbGlnbikgKiBhbGlnbjtcbiAgICAgICAgdGhpcy5lbnRyaWVzLnB1c2goeyBuYW1lLCB0eXBlLCBzaXplLCBhbGlnbiwgb2Zmc2V0LCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy5zaXplID0gb2Zmc2V0ICsgc2l6ZTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBudWxsOyAvLyBSZXNldCBjYWNoZSBzbyBpdCBncm93cyB0byBmaXQgbmV3IHNpemVcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIGNyaXRpY2FsIGZpeCBmb3IgeW91ciBhbmltYXRpb24gaXNzdWVcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB1bmlmb3JtIGxheW91dCB3aXRoIHRoZSBjdXJyZW50IHRpbWUgYW5kIGluY3JlbWVudHMgdGhlIGZyYW1lIGNvdW50ZXIuXG4gICAgICogQHBhcmFtIHRpbWUgLSBUaGUgY3VycmVudCB0aW1lIHZhbHVlIHRvIHVwZGF0ZSB0aGUgdW5pZm9ybSBsYXlvdXQgd2l0aC5cbiAgICAgKi9cbiAgICB1cGRhdGUodGltZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGltZTtcbiAgICAgICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGJ5dGUgc2l6ZSBvZiB0aGUgdW5pZm9ybSBsYXlvdXQsIHJvdW5kZWQgdXAgdG8gdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgMTYuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFdlYkdQVSByZXF1aXJlcyB1bmlmb3JtIGJ1ZmZlcnMgdG8gYmUgYWxpZ25lZCB0byAxNi1ieXRlIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc2l6ZSBpbiBieXRlcywgZ3VhcmFudGVlZCB0byBiZSBhIG11bHRpcGxlIG9mIDE2LlxuICAgICAqL1xuICAgIGdldCBieXRlU2l6ZSgpIHtcbiAgICAgICAgLy8gVW5pZm9ybSBidWZmZXJzIG11c3QgYmUgbXVsdGlwbGVzIG9mIDE2IGJ5dGVzIGluIFdlYkdQVVxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuc2l6ZSAvIDE2KSAqIDE2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBXR1NMIHN0cnVjdCBkZWZpbml0aW9uIHN0cmluZyBmb3IgdGhlIHVuaWZvcm0gbGF5b3V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBXR1NMIHN0cnVjdCBuYW1lZCBcIlVuaWZvcm1zXCIgY29udGFpbmluZyBhbGwgZW50cmllc1xuICAgICAqIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBuYW1lcyBhbmQgdHlwZXMsIGZvcm1hdHRlZCBhcyBhIHZhbGlkIFdHU0wgc3RydWN0IGRlY2xhcmF0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBSZXR1cm5zOiBcInN0cnVjdCBVbmlmb3JtcyB7XFxuICBwb3NpdGlvbjogdmVjMyxcXG4gIGNvbG9yOiB2ZWM0LFxcbn07XCJcbiAgICAgKiBjb25zdCBzdHJ1Y3REZWYgPSB1bmlmb3JtTGF5b3V0Lndnc2xTdHJ1Y3Q7XG4gICAgICovXG4gICAgZ2V0IHdnc2xTdHJ1Y3QoKSB7XG4gICAgICAgIHJldHVybiBgc3RydWN0IFVuaWZvcm1zIHtcXG4ke3RoaXMuZW50cmllcy5tYXAoZSA9PiBgICAke2UubmFtZX06ICR7ZS50eXBlfSxgKS5qb2luKFwiXFxuXCIpfVxcbn07YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIEZsb2F0MzJBcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pZm9ybSBsYXlvdXQgZGF0YS5cbiAgICAgKlxuICAgICAqIExhemlseSBpbml0aWFsaXplcyBhbmQgY2FjaGVzIGEgRmxvYXQzMkFycmF5IGJ1ZmZlciBzaXplZCB0byBhY2NvbW1vZGF0ZSBhbGwgdW5pZm9ybSBlbnRyaWVzLlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggZWFjaCBlbnRyeSwgcmVzb2x2aW5nIGl0cyB2YWx1ZSAoZnJvbSB0aW1lLCBhIGZ1bmN0aW9uLCBvciBhIHN0YXRpYyB2YWx1ZSksXG4gICAgICogYW5kIHdyaXRlcyB0aGUgcmVzb2x2ZWQgdmFsdWUocykgaW50byB0aGUgYXBwcm9wcmlhdGUgb2Zmc2V0IGluIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9IFRoZSBjYWNoZWQgRmxvYXQzMkFycmF5IGNvbnRhaW5pbmcgYWxsIHVuaWZvcm0gdmFsdWVzIGluIGJpbmFyeSBmb3JtYXQuXG4gICAgICovXG4gICAgZ2V0IGZsb2F0MzJBcnJheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZSlcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJ5dGVTaXplIC8gNCk7XG4gICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmVudHJpZXMpIHtcbiAgICAgICAgICAgIGxldCB2YWw7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHZhbHVlIGJhc2VkIG9uIHRoZSBlbnRyeSBuYW1lIG9yIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoZS5uYW1lID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuY3VycmVudFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZS52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZS52YWx1ZSh0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmZyYW1lQ291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBlLm9mZnNldCAvIDQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW3N0YXJ0SW5kZXhdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbc3RhcnRJbmRleCArIGldID0gdmFsW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZmVycyB0aGUgV0dTTCB0eXBlIGFuZCBtZW1vcnkgbGF5b3V0IGluZm9ybWF0aW9uIGZvciBhIHVuaWZvcm0gdmFsdWUuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHVuaWZvcm0gdmFsdWUgdG8gaW5mZXIgdGhlIHR5cGUgZm9yLiBDYW4gYmUgYSBudW1iZXIsIGFycmF5IG9mIG51bWJlcnMsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG9uZSBvZiB0aGVzZS5cbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgV0dTTCB0eXBlIG5hbWUsIHNpemUgaW4gYnl0ZXMsIGFuZCBhbGlnbm1lbnQgcmVxdWlyZW1lbnQgaW4gYnl0ZXMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB1bmlmb3JtIGFycmF5IGxlbmd0aCBpcyBub3QgMiwgMywgb3IgNC5cbiAgICAgKi9cbiAgICBpbmZlclR5cGUodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2FtcGxlID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZSgwLCAwKSA6IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHNhbXBsZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZjMyXCIsIHNpemU6IDQsIGFsaWduOiA0IH07XG4gICAgICAgIGNvbnN0IGxlbiA9IHNhbXBsZS5sZW5ndGg7XG4gICAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiB7IHR5cGU6IFwidmVjMmZcIiwgc2l6ZTogOCwgYWxpZ246IDggfTtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHsgdHlwZTogXCJ2ZWMzZlwiLCBzaXplOiAxMiwgYWxpZ246IDE2IH07IC8vIE5vdGU6IHZlYzMgYWxpZ25zIHRvIDE2XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiB7IHR5cGU6IFwidmVjNGZcIiwgc2l6ZTogMTYsIGFsaWduOiAxNiB9O1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtIGFycmF5IGxlbmd0aCAke2xlbn0gbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVW5pZm9ybUxheW91dCA9IFVuaWZvcm1MYXlvdXQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/UniformLayout.ts\n\n}");

/***/ },

/***/ "./src/example/example8.ts"
/*!*********************************!*\
  !*** ./src/example/example8.ts ***!
  \*********************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst TinyShade_1 = __webpack_require__(/*! ../TinyShade */ \"./src/TinyShade.ts\");\nconst TinyShadeBake_1 = __webpack_require__(/*! ../TinyShadeBake */ \"./src/TinyShadeBake.ts\");\nconst minifyJS_1 = __webpack_require__(/*! ../helpers/minifyJS */ \"./src/helpers/minifyJS.ts\");\nconst TinyShaderRunner_ts_raw_1 = __importDefault(__webpack_require__(/*! ../TinyShaderRunner.ts?raw */ \"./src/TinyShaderRunner.ts?raw\"));\n/*\nThis path tracer is a WebGPU-optimized adaptation of the brilliant work by Mrten Rnge, specifically inspired by his \"Festive Path Tracer.\" It translates his sophisticated GLSL Monte Carlo logic into a high-performance, branchless WebGPU compute architecture.\nOriginal GLSL Shader found at https://www.shadertoy.com/view/tfyczc\n*/\nconst start = async () => {\n    const app = await TinyShade_1.TinyShade.create(\"canvas\");\n    document.querySelector(\"canvas\")?.addEventListener(\"click\", async () => {\n        const minifiedRunnerCode = await (0, minifyJS_1.minifyJS)(TinyShaderRunner_ts_raw_1.default);\n        await TinyShadeBake_1.TinyShadeBake.downloadSelfContained(app, \"release_demo.html\", minifiedRunnerCode.code);\n    });\n    (await app\n        .setUniforms()\n        .addCommon(/*wgsl*/ `\r\n            const PI: f32 = 3.141592654;\r\n            const TAU: f32 = 6.283185307;\r\n\r\n            fn ray_unitsphere(ro: vec3f, rd: vec3f) -> f32 {\r\n                let b = dot(ro, rd);\r\n                let c = dot(ro, ro) - 1.0;\r\n                let h = b*b - c;\r\n                if(h < 0.0) { return -1.0; }\r\n                return -b - sqrt(h);\r\n            }\r\n\r\n            fn hash21(p: vec2f) -> f32 {\r\n                return fract(sin(dot(p, vec2f(12.9898, 58.233))) * 43758.5453);\r\n            }\r\n\r\n            fn orth_base(n: vec3f) -> mat3x3f {\r\n                let up = select(vec3f(0,1,0), vec3f(0,0,1), abs(n.y) > 0.999);\r\n                let x = normalize(cross(up, n));\r\n                let y = cross(n, x);\r\n                return mat3x3f(x, y, n);\r\n            }\r\n\r\n            fn uniform_lambert(n: vec3f, seed: ptr<function, u32>) -> vec3f {\r\n                let r1 = rand(seed);\r\n                let r2 = rand(seed);\r\n                let p = TAU * r1;\r\n                let cost = sqrt(r2);\r\n                let sint = sqrt(1.0 - r2);\r\n                return orth_base(n) * vec3f(cos(p)*sint, sin(p)*sint, cost);\r\n            }\r\n\r\n            fn pcg_hash(input: u32) -> u32 {\r\n                var state = input * 747796405u + 2891336453u;\r\n                var word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\r\n                return (word >> 22u) ^ word;\r\n            }\r\n\r\n            fn rand(seed: ptr<function, u32>) -> f32 {\r\n                *seed = pcg_hash(*seed);\r\n                return f32(*seed) / f32(0xffffffffu);\r\n            }\r\n        `)\n        .addCompute(\"computeTex0\", /*wgsl*/ `\r\n            ##WORKGROUP_SIZE\r\n            //@compute workgroup_size(8, 8, 1)\r\n            fn main(@builtin(global_invocation_id) id: vec3u) {\r\n                let res = u.resolution.xy;\r\n                if (f32(id.x) >= res.x || f32(id.y) >= res.y) { return; }\r\n\r\n                var seed = pcg_hash(id.x + id.y * u32(res.x) + u32(u.time * 1000.0));\r\n                \r\n                // Camera Settings\r\n                let ro = vec3f(4.0, 4.0, -6.0);\r\n                let la = vec3f(0.0, 0.5, -2.0);\r\n                let cam_fwd = normalize(la - ro);\r\n                let cam_right = normalize(cross(cam_fwd, vec3f(0,1,0)));\r\n                let cam_up = cross(cam_right, cam_fwd);\r\n\r\n                // Sphere animation\r\n                var bounce = fract(u.time);\r\n                bounce -= 0.5;\r\n                bounce *= 2.0 * bounce;\r\n                var sphere_center = la;\r\n                sphere_center.y -= bounce;\r\n                sphere_center.x += sin(u.time * 0.5);\r\n                sphere_center.z += sin(u.time * 0.3535);\r\n\r\n                var total_radiance = vec3f(0.0);\r\n                \r\n                // --- THE BIG LOOP ---\r\n                // We trace 128 paths per frame for high detail\r\n                let samples_per_frame = 128;\r\n                for (var s = 0; s < samples_per_frame; s++) {\r\n                    \r\n                    let jitter = vec2f(rand(&seed), rand(&seed)) - 0.5;\r\n                    let p = (vec2f(f32(id.x), res.y - f32(id.y)) + jitter) * 2.0 / res.y - vec2f(res.x/res.y, 1.0);\r\n                    let rd = normalize(-p.x * cam_right + p.y * cam_up + 2.0 * cam_fwd);\r\n\r\n                    var radiance = vec3f(0.0);\r\n                    var throughput = vec3f(1.0);\r\n                    var curr_ro = ro;\r\n                    var curr_rd = rd;\r\n\r\n                    // Trace path (Max 4 bounces for performance inside the 128 loop)\r\n                    for (var i = 0; i < 4; i++) {\r\n                        let t_floor = (-1.0 - curr_ro.y) / curr_rd.y;\r\n                        let t_wall = (1.0 - curr_ro.z) / curr_rd.z;\r\n                        let t_sphere = ray_unitsphere(curr_ro - sphere_center, curr_rd);\r\n\r\n                        var t = 1e3;\r\n                        var normal = vec3f(0.0);\r\n                        var hit_obj = 0;\r\n\r\n                        if (t_floor > 0.001) { t = t_floor; normal = vec3f(0,1,0); hit_obj = 1; }\r\n                        if (t_wall > 0.001 && t_wall < t) { t = t_wall; normal = vec3f(0,0,-1); hit_obj = 2; }\r\n                        if (t_sphere > 0.001 && t_sphere < t) { \r\n                            t = t_sphere; \r\n                            normal = normalize(curr_ro + curr_rd * t_sphere - sphere_center); \r\n                            hit_obj = 3; \r\n                        }\r\n\r\n                        if (hit_obj == 0 || t == 1e3) { break; }\r\n\r\n                        let pos = curr_ro + curr_rd * t;\r\n                        let wall_pos = pos.xy - vec2f(u.time, 0.5);\r\n                        let cell_idx = floor(wall_pos + 0.5);\r\n                        let cell_h = hash21(cell_idx * 123.4);\r\n\r\n                        // Light Hits\r\n                        if (hit_obj == 2 && cell_h > 0.9) {\r\n                            let cell_uv = wall_pos - cell_idx;\r\n                            radiance += throughput * (1.1 - length(cell_uv) + sin(vec3f(2,1,0) + TAU * fract(8667.0 * cell_h)));\r\n                            break;\r\n                        }\r\n                        if (hit_obj == 1 && abs(pos.z + 2.0) < 0.1 && sin(wall_pos.x) > 0.0) {\r\n                            radiance += throughput * vec3f(1.0, 0.5, 0.0);\r\n                            break;\r\n                        }\r\n\r\n                        // Reflection Math\r\n                        let fresnel = pow(1.0 + dot(curr_rd, normal), 5.0);\r\n                        let is_mirror_wall = (hit_obj == 2 && fract(cell_h * 7677.0) > 0.5);\r\n                        \r\n                        if (rand(&seed) < fresnel || is_mirror_wall || hit_obj == 3) {\r\n                            curr_rd = reflect(curr_rd, normal);\r\n                            throughput *= 0.9;\r\n                        } else {\r\n                            curr_rd = uniform_lambert(normal, &seed);\r\n                            throughput *= 0.4;\r\n                        }\r\n                        curr_ro = pos + normal * 0.001;\r\n                    }\r\n                    total_radiance += radiance;\r\n                }\r\n\r\n                textureStore(outTex, id.xy, vec4f(total_radiance / f32(samples_per_frame), 1.0));\r\n            }\r\n        `, 0)\n        .addPass(\"pass1\", /*wgsl*/ `\r\n            @fragment fn main(in: VSOut) -> @location(0) vec4f {\r\n                let current = textureSample(computeTex0, samp, in.uv).rgb;\r\n                let history = textureSample(prev_pass1, samp, in.uv).rgb;\r\n                return vec4f(mix(current, history, 0.5), 1.0);\r\n            }\r\n        `)\n        .main(/*wgsl*/ `\r\n            @fragment fn main(in: VSOut) -> @location(0) vec4f {\r\n                let col = textureSample(pass1, samp, in.uv).rgb;\r\n                return vec4f(sqrt(col), 1.0);\r\n            }\r\n        `)).run();\n};\nstart();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZXhhbXBsZS9leGFtcGxlOC50cyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLHdDQUFjO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLGdEQUFrQjtBQUNsRCxtQkFBbUIsbUJBQU8sQ0FBQyxzREFBcUI7QUFDaEQsa0RBQWtELG1CQUFPLENBQUMsaUVBQTRCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxhQUFhLHVCQUF1QjtBQUNuRiw0REFBNEQsWUFBWSx3QkFBd0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlueXNoYWRlLy4vc3JjL2V4YW1wbGUvZXhhbXBsZTgudHM/YTc0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFRpbnlTaGFkZV8xID0gcmVxdWlyZShcIi4uL1RpbnlTaGFkZVwiKTtcbmNvbnN0IFRpbnlTaGFkZUJha2VfMSA9IHJlcXVpcmUoXCIuLi9UaW55U2hhZGVCYWtlXCIpO1xuY29uc3QgbWluaWZ5SlNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL21pbmlmeUpTXCIpO1xuY29uc3QgVGlueVNoYWRlclJ1bm5lcl90c19yYXdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGlueVNoYWRlclJ1bm5lci50cz9yYXdcIikpO1xuLypcblRoaXMgcGF0aCB0cmFjZXIgaXMgYSBXZWJHUFUtb3B0aW1pemVkIGFkYXB0YXRpb24gb2YgdGhlIGJyaWxsaWFudCB3b3JrIGJ5IE3DpXJ0ZW4gUsOlbmdlLCBzcGVjaWZpY2FsbHkgaW5zcGlyZWQgYnkgaGlzIFwiRmVzdGl2ZSBQYXRoIFRyYWNlci5cIiBJdCB0cmFuc2xhdGVzIGhpcyBzb3BoaXN0aWNhdGVkIEdMU0wgTW9udGUgQ2FybG8gbG9naWMgaW50byBhIGhpZ2gtcGVyZm9ybWFuY2UsIGJyYW5jaGxlc3MgV2ViR1BVIGNvbXB1dGUgYXJjaGl0ZWN0dXJlLlxuT3JpZ2luYWwgR0xTTCBTaGFkZXIgZm91bmQgYXQgaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L3RmeWN6Y1xuKi9cbmNvbnN0IHN0YXJ0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGFwcCA9IGF3YWl0IFRpbnlTaGFkZV8xLlRpbnlTaGFkZS5jcmVhdGUoXCJjYW52YXNcIik7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImNhbnZhc1wiKT8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbWluaWZpZWRSdW5uZXJDb2RlID0gYXdhaXQgKDAsIG1pbmlmeUpTXzEubWluaWZ5SlMpKFRpbnlTaGFkZXJSdW5uZXJfdHNfcmF3XzEuZGVmYXVsdCk7XG4gICAgICAgIGF3YWl0IFRpbnlTaGFkZUJha2VfMS5UaW55U2hhZGVCYWtlLmRvd25sb2FkU2VsZkNvbnRhaW5lZChhcHAsIFwicmVsZWFzZV9kZW1vLmh0bWxcIiwgbWluaWZpZWRSdW5uZXJDb2RlLmNvZGUpO1xuICAgIH0pO1xuICAgIChhd2FpdCBhcHBcbiAgICAgICAgLnNldFVuaWZvcm1zKClcbiAgICAgICAgLmFkZENvbW1vbigvKndnc2wqLyBgXHJcbiAgICAgICAgICAgIGNvbnN0IFBJOiBmMzIgPSAzLjE0MTU5MjY1NDtcclxuICAgICAgICAgICAgY29uc3QgVEFVOiBmMzIgPSA2LjI4MzE4NTMwNztcclxuXHJcbiAgICAgICAgICAgIGZuIHJheV91bml0c3BoZXJlKHJvOiB2ZWMzZiwgcmQ6IHZlYzNmKSAtPiBmMzIge1xyXG4gICAgICAgICAgICAgICAgbGV0IGIgPSBkb3Qocm8sIHJkKTtcclxuICAgICAgICAgICAgICAgIGxldCBjID0gZG90KHJvLCBybykgLSAxLjA7XHJcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGIqYiAtIGM7XHJcbiAgICAgICAgICAgICAgICBpZihoIDwgMC4wKSB7IHJldHVybiAtMS4wOyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLWIgLSBzcXJ0KGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmbiBoYXNoMjEocDogdmVjMmYpIC0+IGYzMiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChwLCB2ZWMyZigxMi45ODk4LCA1OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm4gb3J0aF9iYXNlKG46IHZlYzNmKSAtPiBtYXQzeDNmIHtcclxuICAgICAgICAgICAgICAgIGxldCB1cCA9IHNlbGVjdCh2ZWMzZigwLDEsMCksIHZlYzNmKDAsMCwxKSwgYWJzKG4ueSkgPiAwLjk5OSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IG5vcm1hbGl6ZShjcm9zcyh1cCwgbikpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBjcm9zcyhuLCB4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXQzeDNmKHgsIHksIG4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmbiB1bmlmb3JtX2xhbWJlcnQobjogdmVjM2YsIHNlZWQ6IHB0cjxmdW5jdGlvbiwgdTMyPikgLT4gdmVjM2Yge1xyXG4gICAgICAgICAgICAgICAgbGV0IHIxID0gcmFuZChzZWVkKTtcclxuICAgICAgICAgICAgICAgIGxldCByMiA9IHJhbmQoc2VlZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcCA9IFRBVSAqIHIxO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvc3QgPSBzcXJ0KHIyKTtcclxuICAgICAgICAgICAgICAgIGxldCBzaW50ID0gc3FydCgxLjAgLSByMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3J0aF9iYXNlKG4pICogdmVjM2YoY29zKHApKnNpbnQsIHNpbihwKSpzaW50LCBjb3N0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm4gcGNnX2hhc2goaW5wdXQ6IHUzMikgLT4gdTMyIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGlucHV0ICogNzQ3Nzk2NDA1dSArIDI4OTEzMzY0NTN1O1xyXG4gICAgICAgICAgICAgICAgdmFyIHdvcmQgPSAoKHN0YXRlID4+ICgoc3RhdGUgPj4gMjh1KSArIDR1KSkgXiBzdGF0ZSkgKiAyNzc4MDM3Mzd1O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh3b3JkID4+IDIydSkgXiB3b3JkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmbiByYW5kKHNlZWQ6IHB0cjxmdW5jdGlvbiwgdTMyPikgLT4gZjMyIHtcclxuICAgICAgICAgICAgICAgICpzZWVkID0gcGNnX2hhc2goKnNlZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGYzMigqc2VlZCkgLyBmMzIoMHhmZmZmZmZmZnUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgYClcbiAgICAgICAgLmFkZENvbXB1dGUoXCJjb21wdXRlVGV4MFwiLCAvKndnc2wqLyBgXHJcbiAgICAgICAgICAgICMjV09SS0dST1VQX1NJWkVcclxuICAgICAgICAgICAgLy9AY29tcHV0ZSB3b3JrZ3JvdXBfc2l6ZSg4LCA4LCAxKVxyXG4gICAgICAgICAgICBmbiBtYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBpZDogdmVjM3UpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB1LnJlc29sdXRpb24ueHk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZjMyKGlkLngpID49IHJlcy54IHx8IGYzMihpZC55KSA+PSByZXMueSkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2VlZCA9IHBjZ19oYXNoKGlkLnggKyBpZC55ICogdTMyKHJlcy54KSArIHUzMih1LnRpbWUgKiAxMDAwLjApKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQ2FtZXJhIFNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICBsZXQgcm8gPSB2ZWMzZig0LjAsIDQuMCwgLTYuMCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGEgPSB2ZWMzZigwLjAsIDAuNSwgLTIuMCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FtX2Z3ZCA9IG5vcm1hbGl6ZShsYSAtIHJvKTtcclxuICAgICAgICAgICAgICAgIGxldCBjYW1fcmlnaHQgPSBub3JtYWxpemUoY3Jvc3MoY2FtX2Z3ZCwgdmVjM2YoMCwxLDApKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FtX3VwID0gY3Jvc3MoY2FtX3JpZ2h0LCBjYW1fZndkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTcGhlcmUgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgYm91bmNlID0gZnJhY3QodS50aW1lKTtcclxuICAgICAgICAgICAgICAgIGJvdW5jZSAtPSAwLjU7XHJcbiAgICAgICAgICAgICAgICBib3VuY2UgKj0gMi4wICogYm91bmNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwaGVyZV9jZW50ZXIgPSBsYTtcclxuICAgICAgICAgICAgICAgIHNwaGVyZV9jZW50ZXIueSAtPSBib3VuY2U7XHJcbiAgICAgICAgICAgICAgICBzcGhlcmVfY2VudGVyLnggKz0gc2luKHUudGltZSAqIDAuNSk7XHJcbiAgICAgICAgICAgICAgICBzcGhlcmVfY2VudGVyLnogKz0gc2luKHUudGltZSAqIDAuMzUzNSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsX3JhZGlhbmNlID0gdmVjM2YoMC4wKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gLS0tIFRIRSBCSUcgTE9PUCAtLS1cclxuICAgICAgICAgICAgICAgIC8vIFdlIHRyYWNlIDEyOCBwYXRocyBwZXIgZnJhbWUgZm9yIGhpZ2ggZGV0YWlsXHJcbiAgICAgICAgICAgICAgICBsZXQgc2FtcGxlc19wZXJfZnJhbWUgPSAxMjg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNhbXBsZXNfcGVyX2ZyYW1lOyBzKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaml0dGVyID0gdmVjMmYocmFuZCgmc2VlZCksIHJhbmQoJnNlZWQpKSAtIDAuNTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9ICh2ZWMyZihmMzIoaWQueCksIHJlcy55IC0gZjMyKGlkLnkpKSArIGppdHRlcikgKiAyLjAgLyByZXMueSAtIHZlYzJmKHJlcy54L3Jlcy55LCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZCA9IG5vcm1hbGl6ZSgtcC54ICogY2FtX3JpZ2h0ICsgcC55ICogY2FtX3VwICsgMi4wICogY2FtX2Z3ZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByYWRpYW5jZSA9IHZlYzNmKDAuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRocm91Z2hwdXQgPSB2ZWMzZigxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyX3JvID0gcm87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJfcmQgPSByZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhY2UgcGF0aCAoTWF4IDQgYm91bmNlcyBmb3IgcGVyZm9ybWFuY2UgaW5zaWRlIHRoZSAxMjggbG9vcClcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdF9mbG9vciA9ICgtMS4wIC0gY3Vycl9yby55KSAvIGN1cnJfcmQueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRfd2FsbCA9ICgxLjAgLSBjdXJyX3JvLnopIC8gY3Vycl9yZC56O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdF9zcGhlcmUgPSByYXlfdW5pdHNwaGVyZShjdXJyX3JvIC0gc3BoZXJlX2NlbnRlciwgY3Vycl9yZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IDFlMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHZlYzNmKDAuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaXRfb2JqID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0X2Zsb29yID4gMC4wMDEpIHsgdCA9IHRfZmxvb3I7IG5vcm1hbCA9IHZlYzNmKDAsMSwwKTsgaGl0X29iaiA9IDE7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRfd2FsbCA+IDAuMDAxICYmIHRfd2FsbCA8IHQpIHsgdCA9IHRfd2FsbDsgbm9ybWFsID0gdmVjM2YoMCwwLC0xKTsgaGl0X29iaiA9IDI7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRfc3BoZXJlID4gMC4wMDEgJiYgdF9zcGhlcmUgPCB0KSB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHRfc3BoZXJlOyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbCA9IG5vcm1hbGl6ZShjdXJyX3JvICsgY3Vycl9yZCAqIHRfc3BoZXJlIC0gc3BoZXJlX2NlbnRlcik7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0X29iaiA9IDM7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGl0X29iaiA9PSAwIHx8IHQgPT0gMWUzKSB7IGJyZWFrOyB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gY3Vycl9ybyArIGN1cnJfcmQgKiB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2FsbF9wb3MgPSBwb3MueHkgLSB2ZWMyZih1LnRpbWUsIDAuNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjZWxsX2lkeCA9IGZsb29yKHdhbGxfcG9zICsgMC41KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGxfaCA9IGhhc2gyMShjZWxsX2lkeCAqIDEyMy40KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpZ2h0IEhpdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpdF9vYmogPT0gMiAmJiBjZWxsX2ggPiAwLjkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjZWxsX3V2ID0gd2FsbF9wb3MgLSBjZWxsX2lkeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGlhbmNlICs9IHRocm91Z2hwdXQgKiAoMS4xIC0gbGVuZ3RoKGNlbGxfdXYpICsgc2luKHZlYzNmKDIsMSwwKSArIFRBVSAqIGZyYWN0KDg2NjcuMCAqIGNlbGxfaCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaXRfb2JqID09IDEgJiYgYWJzKHBvcy56ICsgMi4wKSA8IDAuMSAmJiBzaW4od2FsbF9wb3MueCkgPiAwLjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGlhbmNlICs9IHRocm91Z2hwdXQgKiB2ZWMzZigxLjAsIDAuNSwgMC4wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWZsZWN0aW9uIE1hdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyZXNuZWwgPSBwb3coMS4wICsgZG90KGN1cnJfcmQsIG5vcm1hbCksIDUuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc19taXJyb3Jfd2FsbCA9IChoaXRfb2JqID09IDIgJiYgZnJhY3QoY2VsbF9oICogNzY3Ny4wKSA+IDAuNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZCgmc2VlZCkgPCBmcmVzbmVsIHx8IGlzX21pcnJvcl93YWxsIHx8IGhpdF9vYmogPT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl9yZCA9IHJlZmxlY3QoY3Vycl9yZCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm91Z2hwdXQgKj0gMC45O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl9yZCA9IHVuaWZvcm1fbGFtYmVydChub3JtYWwsICZzZWVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm91Z2hwdXQgKj0gMC40O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJfcm8gPSBwb3MgKyBub3JtYWwgKiAwLjAwMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxfcmFkaWFuY2UgKz0gcmFkaWFuY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZVN0b3JlKG91dFRleCwgaWQueHksIHZlYzRmKHRvdGFsX3JhZGlhbmNlIC8gZjMyKHNhbXBsZXNfcGVyX2ZyYW1lKSwgMS4wKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBgLCAwKVxuICAgICAgICAuYWRkUGFzcyhcInBhc3MxXCIsIC8qd2dzbCovIGBcclxuICAgICAgICAgICAgQGZyYWdtZW50IGZuIG1haW4oaW46IFZTT3V0KSAtPiBAbG9jYXRpb24oMCkgdmVjNGYge1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0ZXh0dXJlU2FtcGxlKGNvbXB1dGVUZXgwLCBzYW1wLCBpbi51dikucmdiO1xyXG4gICAgICAgICAgICAgICAgbGV0IGhpc3RvcnkgPSB0ZXh0dXJlU2FtcGxlKHByZXZfcGFzczEsIHNhbXAsIGluLnV2KS5yZ2I7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVjNGYobWl4KGN1cnJlbnQsIGhpc3RvcnksIDAuNSksIDEuMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBgKVxuICAgICAgICAubWFpbigvKndnc2wqLyBgXHJcbiAgICAgICAgICAgIEBmcmFnbWVudCBmbiBtYWluKGluOiBWU091dCkgLT4gQGxvY2F0aW9uKDApIHZlYzRmIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb2wgPSB0ZXh0dXJlU2FtcGxlKHBhc3MxLCBzYW1wLCBpbi51dikucmdiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlYzRmKHNxcnQoY29sKSwgMS4wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGApKS5ydW4oKTtcbn07XG5zdGFydCgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/example/example8.ts\n\n}");

/***/ },

/***/ "./src/helpers/minifyJS.ts"
/*!*********************************!*\
  !*** ./src/helpers/minifyJS.ts ***!
  \*********************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.minifyJS = void 0;\nconst terser_1 = __webpack_require__(/*! terser */ \"./node_modules/terser/dist/bundle.min.js\");\n/**\n * Minifies JavaScript source code.\n *\n * Wraps the underlying JS minifier and applies a default\n * configuration when none is provided.\n *\n * @param code - JavaScript source code to minify\n * @param config - Optional minifier configuration options\n * @returns Minified code and associated metadata (e.g. source map)\n */\nconst minifyJS = async (code, config) => {\n    return await (0, terser_1.minify)(cleanForBaking(code), config || { sourceMap: true });\n};\nexports.minifyJS = minifyJS;\n/**\n * Cleans a stringified class of CommonJS boilerplate\n * so it can run directly in a <script> tag.\n */\nfunction cleanForBaking(code) {\n    return code\n        .replace(/\"use strict\";/g, \"\")\n        .replace(/Object\\.defineProperty\\(exports,.*?\\);/g, \"\")\n        .replace(/exports\\..*?\\s*=\\s*/g, \"\")\n        .replace(/void 0;/g, \"\")\n        // Optional: Remove comments to save space in the Bake\n        .replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*/g, \"\")\n        .trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaGVscGVycy9taW5pZnlKUy50cyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsaUJBQWlCLG1CQUFPLENBQUMsd0RBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHdEQUF3RDtBQUN4RDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RpbnlzaGFkZS8uL3NyYy9oZWxwZXJzL21pbmlmeUpTLnRzPzQ1MzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1pbmlmeUpTID0gdm9pZCAwO1xuY29uc3QgdGVyc2VyXzEgPSByZXF1aXJlKFwidGVyc2VyXCIpO1xuLyoqXG4gKiBNaW5pZmllcyBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlLlxuICpcbiAqIFdyYXBzIHRoZSB1bmRlcmx5aW5nIEpTIG1pbmlmaWVyIGFuZCBhcHBsaWVzIGEgZGVmYXVsdFxuICogY29uZmlndXJhdGlvbiB3aGVuIG5vbmUgaXMgcHJvdmlkZWQuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHRvIG1pbmlmeVxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIG1pbmlmaWVyIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHJldHVybnMgTWluaWZpZWQgY29kZSBhbmQgYXNzb2NpYXRlZCBtZXRhZGF0YSAoZS5nLiBzb3VyY2UgbWFwKVxuICovXG5jb25zdCBtaW5pZnlKUyA9IGFzeW5jIChjb2RlLCBjb25maWcpID0+IHtcbiAgICByZXR1cm4gYXdhaXQgKDAsIHRlcnNlcl8xLm1pbmlmeSkoY2xlYW5Gb3JCYWtpbmcoY29kZSksIGNvbmZpZyB8fCB7IHNvdXJjZU1hcDogdHJ1ZSB9KTtcbn07XG5leHBvcnRzLm1pbmlmeUpTID0gbWluaWZ5SlM7XG4vKipcbiAqIENsZWFucyBhIHN0cmluZ2lmaWVkIGNsYXNzIG9mIENvbW1vbkpTIGJvaWxlcnBsYXRlXG4gKiBzbyBpdCBjYW4gcnVuIGRpcmVjdGx5IGluIGEgPHNjcmlwdD4gdGFnLlxuICovXG5mdW5jdGlvbiBjbGVhbkZvckJha2luZyhjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGVcbiAgICAgICAgLnJlcGxhY2UoL1widXNlIHN0cmljdFwiOy9nLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvT2JqZWN0XFwuZGVmaW5lUHJvcGVydHlcXChleHBvcnRzLC4qP1xcKTsvZywgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoL2V4cG9ydHNcXC4uKj9cXHMqPVxccyovZywgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoL3ZvaWQgMDsvZywgXCJcIilcbiAgICAgICAgLy8gT3B0aW9uYWw6IFJlbW92ZSBjb21tZW50cyB0byBzYXZlIHNwYWNlIGluIHRoZSBCYWtlXG4gICAgICAgIC5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvfFxcL1xcLy4qL2csIFwiXCIpXG4gICAgICAgIC50cmltKCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/helpers/minifyJS.ts\n\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/example/example8.ts");
/******/ 	
/******/ })()
;