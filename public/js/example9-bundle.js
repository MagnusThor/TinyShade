(()=>{"use strict";var e={549:(e,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TinyShade=void 0;const n=i(524),r=e=>{let t=1;for(;2*t<=e;)t*=2;return t};class s{device;context;canvas;uniforms;uniformBuffer;audioPlugin;startTime=0;frameCounter=0;globalTextures=new Map;commonWGSL="";passes=[];passLayouts=[];mainPassShader="";mainPipeline;isCompiled=!1;startedAudio=!1;workgroupSize={x:8,y:8,z:1,str:"@workgroup_size(8, 8, 1)"};constructor(e){this.canvas=e,this.uniforms=new n.UniformLayout([this.canvas.width,this.canvas.height,window.devicePixelRatio])}static async create(e){const t=document.getElementById(e),i=new s(t);return await i.initWebGPU(),i}async initWebGPU(){const e=await(navigator.gpu?.requestAdapter());if(!e)throw"WebGPU not supported";const t=[];e.features.has("bgra8unorm-storage")&&t.push("bgra8unorm-storage"),e.features.has("timestamp-query")&&t.push("timestamp-query"),this.device=await e.requestDevice({requiredFeatures:t}),this.workgroupSize=(e=>{const t=Math.min(16,r(e.maxComputeWorkgroupSizeX)),i=Math.min(16,r(e.maxComputeWorkgroupSizeY));return{x:t,y:i,z:1,str:`@workgroup_size(${t}, ${i}, 1)`}})(e.limits),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}),this.startTime=performance.now()}addAudio(e){return this.audioPlugin=e,console.log(this.audioPlugin),this}addCommon(e){return this.commonWGSL+=`\n${e}\n`,this}async addTexture(e,t){let i;if("string"==typeof t){const e=new Image;e.src=t,await e.decode(),i=await createImageBitmap(e)}else i=t;const n=this.device.createTexture({size:[i.width,i.height],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return this.device.queue.copyExternalImageToTexture({source:i},{texture:n},[i.width,i.height]),this.globalTextures.set(e,n),this}setUniforms(e){return e&&e(this.uniforms),this.uniformBuffer=this.device.createBuffer({size:this.uniforms.byteSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this}addCompute(e,t,i=0){const n=this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING});let r;return i>0&&(r=this.device.createBuffer({size:4*i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})),this.passes.push({name:e,type:"compute",shader:t,textures:[n],storageBuffer:r,pipelines:[]}),this}addAtomicCompute(e,t,i){const n=this.device.createBuffer({size:4*i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});return this.passes.push({name:e,type:"compute",shader:t,storageBuffer:n,isAtomic:!0,pipelines:[],textures:[]}),this}addPass(e,t){const i=()=>this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"bgra8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT});return this.passes.push({name:e,type:"fragment",shader:t,textures:[i(),i()],pipelines:[]}),this}async main(e){return this.mainPassShader=e,this.compile(),this}compile(){this.uniformBuffer||this.setUniforms(),[...this.passes,{name:"main",type:"fragment",shader:this.mainPassShader,isMain:!0,textures:[],pipelines:[]}].forEach((e,t)=>{let i=1;const n=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}];let r=`${this.uniforms.wgslStruct}\n@group(0) @binding(0) var<uniform> u: Uniforms;\n`;this.globalTextures.forEach((e,t)=>{r+=`@group(0) @binding(${i}) var ${t}: texture_2d<f32>;\n`,n.push({binding:i++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}})}),r+=`@group(0) @binding(${i}) var samp: sampler;\n`,n.push({binding:i++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,sampler:{}}),this.passes.forEach(t=>{if("compute"===t.type){if(t.textures.length>0&&(e===t?(r+=`@group(0) @binding(${i}) var outTex: texture_storage_2d<rgba8unorm, write>;\n`,n.push({binding:i++,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",access:"write-only"}})):(r+=`@group(0) @binding(${i}) var ${t.name}: texture_2d<f32>;\n`,n.push({binding:i++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}}))),t.storageBuffer){const s=e===t,a=t.isAtomic?"array<atomic<u32>>":"array<f32>",o=s?"data":`${t.name}_data`;r+=`@group(0) @binding(${i}) var<storage, read_write> ${o}: ${a};\n`,n.push({binding:i++,visibility:GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT,buffer:{type:"storage"}})}}else r+=`@group(0) @binding(${i}) var ${t.name}: texture_2d<f32>;\n`,n.push({binding:i++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}}),r+=`@group(0) @binding(${i}) var prev_${t.name}: texture_2d<f32>;\n`,n.push({binding:i++,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}})});const s=this.device.createBindGroupLayout({entries:n});this.passLayouts[t]=s;const a=("fragment"===e.type?"\n        struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\n        @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\n            var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\n            return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\n        }\n    ":"")+r+this.commonWGSL+("compute"===e.type?e.shader.replace("##WORKGROUP_SIZE",`@compute ${this.workgroupSize.str}`):e.shader),o=this.device.createShaderModule({code:a}),u=this.device.createPipelineLayout({bindGroupLayouts:[s]});"compute"===e.type?e.pipelines[0]=this.device.createComputePipeline({layout:u,compute:{module:o,entryPoint:"main"}}):(e.pipelines[0]=this.device.createRenderPipeline({layout:u,vertex:{module:o,entryPoint:"vs"},fragment:{module:o,entryPoint:"main",targets:[{format:e.isMain?navigator.gpu.getPreferredCanvasFormat():"bgra8unorm"}]}}),e.isMain&&(this.mainPipeline=e.pipelines[0]))}),this.isCompiled=!0}createBindGroup(e,t){const i=1-t,n=[{binding:0,resource:{buffer:this.uniformBuffer}}];let r=1;return this.globalTextures.forEach(e=>n.push({binding:r++,resource:e.createView()})),n.push({binding:r++,resource:this.device.createSampler({magFilter:"linear",minFilter:"linear"})}),this.passes.forEach((s,a)=>{"compute"===s.type?(s.textures.length>0&&n.push({binding:r++,resource:s.textures[0].createView()}),s.storageBuffer&&n.push({binding:r++,resource:{buffer:s.storageBuffer}})):a===e?(n.push({binding:r++,resource:s.textures[i].createView()}),n.push({binding:r++,resource:s.textures[i].createView()})):(n.push({binding:r++,resource:s.textures[t].createView()}),n.push({binding:r++,resource:s.textures[i].createView()}))}),this.device.createBindGroup({layout:this.passLayouts[e],entries:n})}run(e){const t=i=>{if(!this.isCompiled)return;this.audioPlugin&&!this.startedAudio&&(this.audioPlugin.play(),this.startedAudio=!0);const n=this.audioPlugin&&this.audioPlugin.isPlaying?this.audioPlugin.getTime():(i-this.startTime)/1e3,r=this.frameCounter%2;this.uniforms.update(n),((e,t,i,n=0)=>{e.queue.writeBuffer(t,n,i.buffer,i.byteOffset,i.byteLength)})(this.device,this.uniformBuffer,this.uniforms.float32Array);const s=this.device.createCommandEncoder(),a=[];let o;if(e&&e.reset(),this.passes.forEach((t,i)=>{t.isAtomic&&t.storageBuffer&&s.clearBuffer(t.storageBuffer);const n=this.createBindGroup(i,r);let o;if(e){const i=e.allocateIndices();i&&(o={querySet:e.querySet,beginningOfPassWriteIndex:i.start,endOfPassWriteIndex:i.end},a.push({name:t.name,...i}))}if("compute"===t.type){const e=s.beginComputePass({timestampWrites:o});e.setPipeline(t.pipelines[0]),e.setBindGroup(0,n),e.dispatchWorkgroups(Math.ceil(this.canvas.width/this.workgroupSize.x),Math.ceil(this.canvas.height/this.workgroupSize.y),1),e.end()}else{const e=s.beginRenderPass({colorAttachments:[{view:t.textures[r].createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}],timestampWrites:o});e.setPipeline(t.pipelines[0]),e.setBindGroup(0,n),e.draw(3),e.end()}}),e){const t=e.allocateIndices();t&&(o={querySet:e.querySet,beginningOfPassWriteIndex:t.start,endOfPassWriteIndex:t.end},a.push({name:"main",...t}))}const u=s.beginRenderPass({colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}],timestampWrites:o});u.setPipeline(this.mainPipeline),u.setBindGroup(0,this.createBindGroup(this.passes.length,r)),u.draw(3),u.end(),this.device.queue.submit([s.finish()]),e&&e.resolve(a),this.frameCounter++,requestAnimationFrame(t)};return requestAnimationFrame(t),this}}t.TinyShade=s},524:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.UniformLayout=void 0,t.UniformLayout=class{entries=[];size=0;_cache=null;frameCount=0;currentTime=0;constructor(e){this.addUniform({name:"resolution",value:e}),this.addUniform({name:"time",value:0})}addUniform({name:e,value:t}){const{type:i,size:n,align:r}=this.inferType(t),s=Math.ceil(this.size/r)*r;return this.entries.push({name:e,type:i,size:n,align:r,offset:s,value:t}),this.size=s+n,this._cache=null,this}update(e){this.currentTime=e,this.frameCount++}get byteSize(){return 16*Math.ceil(this.size/16)}get wgslStruct(){return`struct Uniforms {\n${this.entries.map(e=>`  ${e.name}: ${e.type},`).join("\n")}\n};`}get float32Array(){this._cache||(this._cache=new Float32Array(this.byteSize/4));for(const e of this.entries){let t;t="time"===e.name?this.currentTime:"function"==typeof e.value?e.value(this.currentTime,this.frameCount):e.value;const i=e.offset/4;if("number"==typeof t)this._cache[i]=t;else for(let e=0;e<t.length;e++)this._cache[i+e]=t[e]}return this._cache}inferType(e){const t="function"==typeof e?e(0,0):e;if("number"==typeof t)return{type:"f32",size:4,align:4};const i=t.length;switch(i){case 2:return{type:"vec2f",size:8,align:8};case 3:return{type:"vec3f",size:12,align:16};case 4:return{type:"vec4f",size:16,align:16};default:throw new Error(`Uniform array length ${i} not supported.`)}}}}},t={};function i(n){var r=t[n];if(void 0!==r)return r.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,i),s.exports}(()=>{const e=i(549);document.addEventListener("DOMContentLoaded",async()=>{const t=await e.TinyShade.create("canvas"),i=t.canvas.width*t.canvas.height;(await t.setUniforms(e=>{e.addUniform({name:"count",value:1e6})}).addCompute("physics","\n        \n        fn map(p: vec3f, t: f32) -> f32 {\n            let s = sin(t * 0.4) * 0.5 + 0.5;\n            let sphere = length(p) - 1.2;\n            var q = abs(p);\n            var d = max(q.x, max(q.y, q.z)) - 1.0;\n            for (var i = 0u; i < 2u; i++) {\n                let a = fract(q * 2.5) - 0.5;\n                q = abs(a);\n                d = max(d, (0.5 - max(q.x, max(q.y, q.z))) / 2.5);\n            }\n            return mix(d, sphere, s);\n        }\n    \n        ##WORKGROUP_SIZE\n        fn main(@builtin(global_invocation_id) id: vec3u) {\n            let i = id.x; if (i >= u32(u.count)) { return; }\n            let b = i * 4u;\n            var p = vec3f(data[b], data[b+1], data[b+2]);\n            \n            if (u.time < 0.1 || length(p) > 5.0) {\n                let seed = f32(i);\n                data[b] = (fract(sin(seed) * 43758.5) - 0.5) * 4.0;\n                data[b+1] = (fract(sin(seed + 1.1) * 43758.5) - 0.5) * 4.0;\n                data[b+2] = (fract(sin(seed + 2.2) * 43758.5) - 0.5) * 4.0;\n                return;\n            }\n\n            let d = map(p, u.time);\n            let e = 0.01;\n            let grad = normalize(vec3f(\n                map(p + vec3f(e, 0, 0), u.time) - map(p - vec3f(e, 0, 0), u.time),\n                map(p + vec3f(0, e, 0), u.time) - map(p - vec3f(0, e, 0), u.time),\n                map(p + vec3f(0, 0, e), u.time) - map(p - vec3f(0, 0, e), u.time)\n            ));\n\n            let moveSpeed = 0.001; \n            let swirlSpeed = 0.002; \n\n            p -= grad * d * moveSpeed; \n            p += cross(grad, vec3f(0.0, 1.0, 0.0)) * swirlSpeed; \n\n            data[b] = p.x; data[b+1] = p.y; data[b+2] = p.z;\n            data[b+3] = saturate(1.0 - abs(d) * 5.0); \n        }\n        ",4e6).addAtomicCompute("heatmap","\n        ##WORKGROUP_SIZE\n        fn main(@builtin(global_invocation_id) id: vec3u) {\n            let i = id.x; if (i >= u32(u.count)) { return; }\n            let p = vec3f(physics_data[i*4u], physics_data[i*4u+1], physics_data[i*4u+2]);\n            let life = physics_data[i*4u+3];\n\n            let t = u.time * 0.2;\n            let rot = vec3f(p.x * cos(t) - p.z * sin(t), p.y, p.x * sin(t) + p.z * cos(t));\n            \n            let z_dist = rot.z + 5.0;\n            let screen = rot.xy / z_dist;\n            let res = u.resolution.xy;\n            let center = vec2i((screen * 2.0 + 0.5) * res);\n            \n            for(var x = -1; x <= 1; x++) {\n                for(var y = -1; y <= 1; y++) {\n                    let coords = center + vec2i(x, y);\n                    if(coords.x >= 0 && coords.x < i32(res.x) && coords.y >= 0 && coords.y < i32(res.y)) {\n                        let weight = select(5u, 10u, x == 0 && y == 0);\n                        let energy = u32(life * f32(weight) / (z_dist * 0.4));\n                        atomicAdd(&data[u32(coords.y) * u32(res.x) + u32(coords.x)], energy); \n                    }\n                }\n            }\n        }\n        ",i).addPass("streaks","\n        @fragment fn main(in: VSOut) -> @location(0) vec4f {\n            let res = u.resolution.xy;\n            let idx = u32(in.uv.y * res.y) * u32(res.x) + u32(in.uv.x * res.x);\n            let current = f32(atomicLoad(&heatmap_data[idx])) * 0.05;\n\n            let dir = in.uv - 0.5;\n            let prev = textureSample(prev_streaks, samp, in.uv - dir * 0.005).rgb;\n            \n            let col = mix(vec3f(current), prev, 0.6);\n            return vec4f(col, 1.0);\n        }\n        ").main('\n        @fragment fn main(in: VSOut) -> @location(0) vec4f {\n            let s = textureSample(streaks, samp, in.uv).r;\n            \n            // 1. TOPOGRAPHIC CONTOUR LINES\n            // We use sin() on the density to create recurring sharp bands\n            let lineFrequency = 40.0;\n            let lines = sin(s * lineFrequency - u.time * 2.0);\n            let mask = smoothstep(0.8, 0.95, lines); // Sharpen the sin wave into lines\n            \n            // 2. FAKE DEPTH SURFACE\n            let threshold = 0.1;\n            let surface = smoothstep(threshold, threshold + 0.05, s);\n            \n            // 3. COLOR PALETTE\n            let bgColor = vec3f(0.01, 0.02, 0.05);\n            let scanColor = vec3f(0.2, 0.8, 1.0); // Cyber Cyan\n            let coreColor = vec3f(0.8, 0.2, 1.0); // Neon Purple\n            \n            // Layering the effects\n            var finalCol = mix(bgColor, coreColor * s, surface * 0.3);\n            finalCol += mask * scanColor * s * 2.0; // Glowing scan lines\n            \n            // Add a "rim light" where the density starts\n            let rim = smoothstep(0.05, 0.0, abs(s - threshold));\n            finalCol += rim * scanColor;\n\n            // Final vignette for focus\n            finalCol *= smoothstep(0.8, 0.3, length(in.uv - 0.5));\n            \n            return vec4f(finalCol, 1.0);\n        }\n        ')).run()})})()})();