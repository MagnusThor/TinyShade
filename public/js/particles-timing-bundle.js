(()=>{"use strict";var e={549:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TinyShade=t.Buffer=void 0;const i=r(524);t.Buffer={write:(e,t,r,i=0)=>(e.queue.writeBuffer(t,i,r.buffer,r.byteOffset,r.byteLength),t)};class n{device;context;canvas;uniforms;uniformBuffer;startTime=0;frameCounter=0;workgroupLimits;commonWGSL="";computePipeline=null;computeBindGroup=null;storageBuffer=null;storageTexture;passes=[];mainPassShader="";mainPipeline;mainBindGroupLayout;mainInterceptors;constructor(e){this.canvas=e,this.uniforms=new i.UniformLayout([this.canvas.width,this.canvas.height,window.devicePixelRatio])}static async create(e){const t=document.getElementById(e),r=new n(t);return await r.initWebGPU(),r}async initWebGPU(){const e=await navigator.gpu.requestAdapter(),t=e?.features.has("timestamp-query");this.device=await e.requestDevice({requiredFeatures:t?["timestamp-query"]:[]}),this.workgroupLimits={str:"@workgroup_size(8, 1, 1)"},this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:navigator.gpu.getPreferredCanvasFormat()}),this.storageTexture=this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}),this.startTime=performance.now()}addCommon(e){return this.commonWGSL+=`\n${e}\n`,this}setUniforms(e){return e&&e(this.uniforms),this.uniformBuffer=this.device.createBuffer({size:this.uniforms.byteSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this}addCompute(e,t){e>0&&(this.storageBuffer=this.device.createBuffer({size:4*e,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}));const r=e>0?"@group(0) @binding(1) var<storage, read_write> data: array<f32>;":"",i=`@compute ${this.workgroupLimits.str}`,n=`\n            ${this.uniforms.wgslStruct}\n            @group(0) @binding(0) var<uniform> u: Uniforms;\n            ${r}\n            @group(0) @binding(2) var outTex: texture_storage_2d<rgba8unorm, write>;\n            ${this.commonWGSL}\n            ${t.replace("##WORKGROUP_SIZE",i)}\n        `,s=this.device.createShaderModule({code:n});this.computePipeline=this.device.createComputePipeline({layout:"auto",compute:{module:s,entryPoint:"main"}});const a=[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:2,resource:this.storageTexture.createView()}];return e>0&&this.storageBuffer&&a.push({binding:1,resource:{buffer:this.storageBuffer}}),this.computeBindGroup=this.device.createBindGroup({layout:this.computePipeline.getBindGroupLayout(0),entries:a}),this}addPass(e,t){const r=()=>this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"bgra8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT});return this.passes.push({shader:e,textures:[r(),r()],pipelines:[],bindGroups:[],interceptors:t}),this}main(e,t){return this.mainPassShader=e,this.mainInterceptors=t,this.compile(),this}compile(){const e=this.device.createSampler({magFilter:"linear",minFilter:"linear"});[...this.passes,{shader:this.mainPassShader,isMain:!0}].forEach(((t,r)=>{const i=t.isMain,n=i?this.passes.length:r+1;let s=`${this.uniforms.wgslStruct}\n@group(0) @binding(0) var<uniform> u: Uniforms;\n@group(0) @binding(1) var samp: sampler;\n`;for(let e=0;e<n;e++)s+=`@group(0) @binding(${2+2*e}) var pass${e}: texture_2d<f32>;\n@group(0) @binding(${2+2*e+1}) var prevPass${e}: texture_2d<f32>;\n`;s+=`@group(0) @binding(${2+2*this.passes.length}) var computeTex: texture_2d<f32>;`;const a=`struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\n        @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\n            var p = array<vec2f,3>(vec2f(-1,-1),vec2f(3,-1),vec2f(-1,3));\n            return VSOut(vec4f(p[i],0,1), p[i]*0.5+0.5);\n        }${s}${this.commonWGSL}${t.shader}`,o=this.device.createShaderModule({code:a}),u=[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}];for(let e=0;e<n;e++)u.push({binding:2+2*e,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}},{binding:2+2*e+1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}});u.push({binding:2+2*this.passes.length,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}});const c=this.device.createBindGroupLayout({entries:u}),f=this.device.createRenderPipeline({layout:this.device.createPipelineLayout({bindGroupLayouts:[c]}),vertex:{module:o,entryPoint:"vs"},fragment:{module:o,entryPoint:"main",targets:[{format:i?navigator.gpu.getPreferredCanvasFormat():"bgra8unorm"}]}}),h=t=>{const r=1-t,i=[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:e}];for(let e=0;e<n;e++)i.push({binding:2+2*e,resource:this.passes[e].textures[r].createView()},{binding:2+2*e+1,resource:this.passes[e].textures[r].createView()});return i.push({binding:2+2*this.passes.length,resource:this.storageTexture.createView()}),this.device.createBindGroup({layout:c,entries:i})};i?(this.mainPipeline=f,this.mainBindGroupLayout=c):(t.pipelines=[f,f],t.bindGroups=[h(0),h(1)])}))}run(e){const r=this.device.createSampler({magFilter:"linear",minFilter:"linear"}),i=n=>{this.frameCounter++;const s=this.frameCounter%2,a=1-s;this.uniforms.update((n-this.startTime)/1e3),t.Buffer.write(this.device,this.uniformBuffer,this.uniforms.float32Array);const o=this.device.createCommandEncoder();if(o.beginRenderPass({colorAttachments:[{view:this.storageTexture.createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,0]}]}).end(),this.computePipeline){const e=o.beginComputePass();e.setPipeline(this.computePipeline),e.setBindGroup(0,this.computeBindGroup),e.dispatchWorkgroups(Math.ceil(this.canvas.width/8),Math.ceil(this.canvas.height/8),1),e.end()}this.passes.forEach((e=>{const r=e.interceptors?.onBefore?.(this.uniforms);if(r?.uniforms){const e=r.uniforms instanceof Float32Array?r.uniforms:new Float32Array(r.uniforms);t.Buffer.write(this.device,this.uniformBuffer,e)}const i={colorAttachments:[{view:e.textures[s].createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}],...r?.descriptor||{}},n=o.beginRenderPass(i);n.setPipeline(e.pipelines[s]),n.setBindGroup(0,e.bindGroups[s]),n.draw(3),n.end()}));const u=this.mainInterceptors?.onBefore?.(this.uniforms);if(u?.uniforms){const e=u.uniforms instanceof Float32Array?u.uniforms:new Float32Array(u.uniforms);t.Buffer.write(this.device,this.uniformBuffer,e)}const c=[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:r}];for(let e=0;e<this.passes.length;e++)c.push({binding:2+2*e,resource:this.passes[e].textures[s].createView()},{binding:2+2*e+1,resource:this.passes[e].textures[a].createView()});c.push({binding:2+2*this.passes.length,resource:this.storageTexture.createView()});const f=this.device.createBindGroup({layout:this.mainBindGroupLayout,entries:c}),h=o.beginRenderPass({colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,1]}],...u?.descriptor||{}});h.setPipeline(this.mainPipeline),h.setBindGroup(0,f),h.draw(3),h.end(),e?.supportsTimeStampQuery&&e.querySet&&(o.resolveQuerySet(e.querySet,0,e.maxQueries||20,e.resolveBuffer,0),o.copyBufferToBuffer(e.resolveBuffer,0,e.readBuffer,0,e.resolveBuffer.size)),this.device.queue.submit([o.finish()]);const m=this.frameCounter;this.device.queue.onSubmittedWorkDone().then((()=>{this.passes.forEach((e=>e.interceptors?.onAfter?.({frame:m,timeMS:0}))),this.mainInterceptors?.onAfter?.({frame:m,timeMS:0})})),requestAnimationFrame(i)};requestAnimationFrame(i)}}t.TinyShade=n},524:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.UniformLayout=void 0,t.UniformLayout=class{entries=[];size=0;_cache=null;frameCount=0;currentTime=0;constructor(e){this.addUniform({name:"resolution",value:e}),this.addUniform({name:"time",value:0})}addUniform({name:e,value:t}){const{type:r,size:i,align:n}=this.inferType(t),s=Math.ceil(this.size/n)*n;return this.entries.push({name:e,type:r,size:i,align:n,offset:s,value:t}),this.size=s+i,this._cache=null,this}update(e){this.currentTime=e,this.frameCount++}get byteSize(){return 16*Math.ceil(this.size/16)}get wgslStruct(){return`struct Uniforms {\n${this.entries.map((e=>`  ${e.name}: ${e.type},`)).join("\n")}\n};`}get float32Array(){this._cache||(this._cache=new Float32Array(this.byteSize/4));for(const e of this.entries){let t;t="time"===e.name?this.currentTime:"function"==typeof e.value?e.value(this.currentTime,this.frameCount):e.value;const r=e.offset/4;if("number"==typeof t)this._cache[r]=t;else for(let e=0;e<t.length;e++)this._cache[r+e]=t[e]}return this._cache}inferType(e){const t="function"==typeof e?e(0,0):e;if("number"==typeof t)return{type:"f32",size:4,align:4};const r=t.length;switch(r){case 2:return{type:"vec2f",size:8,align:8};case 3:return{type:"vec3f",size:12,align:16};case 4:return{type:"vec4f",size:16,align:16};default:throw new Error(`Uniform array length ${r} not supported.`)}}}},726:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGPUTiming=t.RollingAverage=void 0,t.RollingAverage=class{size;samples=[];constructor(e=60){this.size=e}add(e){this.samples.push(e),this.samples.length>this.size&&this.samples.shift()}get(){return this.samples.reduce(((e,t)=>e+t),0)/this.samples.length}},t.WebGPUTiming=class{device;supportsTimeStampQuery;querySet;resolveBuffer;readBuffer;currentIndex=0;maxQueries=20;constructor(e){this.device=e,this.supportsTimeStampQuery=e.features.has("timestamp-query"),this.supportsTimeStampQuery&&(this.querySet=e.createQuerySet({type:"timestamp",count:this.maxQueries}),this.resolveBuffer=e.createBuffer({size:8*this.maxQueries,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.readBuffer=e.createBuffer({size:8*this.maxQueries,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}))}reset(){this.currentIndex=0}allocateIndices(){if(!this.supportsTimeStampQuery||this.currentIndex+2>this.maxQueries)return null;const e={start:this.currentIndex,end:this.currentIndex+1};return this.currentIndex+=2,e}}}},t={};function r(i){var n=t[i];if(void 0!==n)return n.exports;var s=t[i]={exports:{}};return e[i](s,s.exports,r),s.exports}(()=>{const e=r(549),t=r(726);document.addEventListener("DOMContentLoaded",(async()=>{const r=await e.TinyShade.create("canvas");new t.WebGPUTiming(r.device),new t.RollingAverage(60),r.setUniforms().main("\n        // Mandelbox Parameters\n        const SCALE = 2.8;\n        const MIN_RAD_SQ = 0.25;\n        const FIXED_RAD_SQ = 1.0;\n\n        fn boxFold(v: vec3f) -> vec3f {\n            return clamp(v, vec3f(-1.0), vec3f(1.0)) * 2.0 - v;\n        }\n\n        fn sphereFold(v: vec3f) -> vec3f {\n            let r2 = dot(v, v);\n            if (r2 < MIN_RAD_SQ) {\n                return v * (FIXED_RAD_SQ / MIN_RAD_SQ);\n            } else if (r2 < FIXED_RAD_SQ) {\n                return v * (FIXED_RAD_SQ / r2);\n            }\n            return v;\n        }\n\n        fn map(p: vec3f) -> f32 {\n            var offset = p;\n            var v = p;\n            var dr = 1.0;\n            \n            // 12 Iterations makes it heavy for the GPU Timer\n            for (var i = 0; i < 12; i++) {\n                v = boxFold(v);\n                v = sphereFold(v);\n                v = SCALE * v + offset;\n                dr = dr * abs(SCALE) + 1.0;\n            }\n            return length(v) / abs(dr);\n        }\n\n        // Ambient Occlusion\n        fn getAO(p: vec3f, n: vec3f) -> f32 {\n            var occ = 0.0;\n            var sca = 1.0;\n            for(var i = 0; i < 5; i++) {\n                let h = 0.01 + 0.12 * f32(i) / 4.0;\n                let d = map(p + n * h);\n                occ += (h - d) * sca;\n                sca *= 0.95;\n            }\n            return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n        }\n\n        fn getNormal(p: vec3f) -> vec3f {\n            let e = vec2f(0.001, 0.0);\n            return normalize(vec3f(\n                map(p + e.xyy) - map(p - e.xyy),\n                map(p + e.yxy) - map(p - e.yxy),\n                map(p + e.yyx) - map(p - e.yyx)\n            ));\n        }\n\n        @fragment fn main(in: VSOut) -> @location(0) vec4f {\n            let res = u.resolution.xy;\n            let uv = (in.pos.xy - 0.5 * res) / res.y;\n            \n            // Camera setup\n            let time = u.time * 0.02;\n            let ro = vec3f(5.0 * cos(time), 2.0 * sin(time * 0.5), 5.0 * sin(time));\n            let ta = vec3f(0.0, 0.0, -0.0);\n            let ww = normalize(ta - ro);\n            let uu = normalize(cross(ww, vec3f(0.0, 1.0, 0.0)));\n            let vv = normalize(cross(uu, ww));\n            let rd = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n            // Raymarching\n            var t = 0.01;\n            var hit = false;\n            for(var i = 0; i < 256; i++) {\n                let d = map(ro + rd * t);\n                if(d < 0.001) { hit = true; break; }\n                t += d;\n                if(t > 20.0) { break; }\n            }\n\n            var col = vec3f(0.05, 0.06, 0.1); // Background color\n\n            if(hit) {\n                let p = ro + rd * t;\n                let n = getNormal(p);\n                let ao = getAO(p, n);\n                \n                // Simple lighting\n                let lightDir = normalize(vec3f(1.0, 2.0, -1.0));\n                let diff = max(dot(n, lightDir), 0.0);\n                let shadow = clamp(map(p + n * 0.1) * 10.0, 0.5, 1.0); // Simple shadow\n                \n                let baseCol = mix(vec3f(0.1, 0.3, 0.6), vec3f(1.0, 0.8, 0.4), n.y * 0.5 + 0.5);\n                col = baseCol * (diff * shadow + 0.1) * ao;\n                \n                // Fog\n                col = mix(col, vec3f(0.05, 0.06, 0.1), 1.0 - exp(-0.02 * t * t));\n            }\n\n            return vec4f(pow(col, vec3f(0.4545)), 1.0); // Gamma correction\n        }\n    ").run()}))})()})();