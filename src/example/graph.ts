
export const graph = {
  "canvasSize": {
    "width": 800,
    "height": 450
  },
  "uniforms": {
    "byteSize": 16,
    "struct": "struct Uniforms {\n  resolution: vec3f,\n  time: f32,\n};"
  },
  "textures": [],
  "passes": [
    {
      "name": "computeTex0",
      "type": "compute",
      "shader": "struct Uniforms {\n  resolution: vec3f,\n  time: f32,\n};\n@group(0) @binding(0) var<uniform> u: Uniforms;\n@group(0) @binding(1) var samp: sampler;\n@group(0) @binding(2) var outTex: texture_storage_2d<rgba8unorm, write>;\n\n\n            const PI: f32 = 3.141592654;\n            const TAU: f32 = 6.283185307;\n\n            fn ray_unitsphere(ro: vec3f, rd: vec3f) -> f32 {\n                let b = dot(ro, rd);\n                let c = dot(ro, ro) - 1.0;\n                let h = b*b - c;\n                if(h < 0.0) { return -1.0; }\n                return -b - sqrt(h);\n            }\n\n            fn hash21(p: vec2f) -> f32 {\n                return fract(sin(dot(p, vec2f(12.9898, 58.233))) * 43758.5453);\n            }\n\n            fn orth_base(n: vec3f) -> mat3x3f {\n                let up = select(vec3f(0,1,0), vec3f(0,0,1), abs(n.y) > 0.999);\n                let x = normalize(cross(up, n));\n                let y = cross(n, x);\n                return mat3x3f(x, y, n);\n            }\n\n            fn uniform_lambert(n: vec3f, seed: ptr<function, u32>) -> vec3f {\n                let r1 = rand(seed);\n                let r2 = rand(seed);\n                let p = TAU * r1;\n                let cost = sqrt(r2);\n                let sint = sqrt(1.0 - r2);\n                return orth_base(n) * vec3f(cos(p)*sint, sin(p)*sint, cost);\n            }\n\n            fn pcg_hash(input: u32) -> u32 {\n                var state = input * 747796405u + 2891336453u;\n                var word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n                return (word >> 22u) ^ word;\n            }\n\n            fn rand(seed: ptr<function, u32>) -> f32 {\n                *seed = pcg_hash(*seed);\n                return f32(*seed) / f32(0xffffffffu);\n            }\n        \n\n            @compute @workgroup_size(16, 16, 1)\n            //@compute workgroup_size(8, 8, 1)\n            fn main(@builtin(global_invocation_id) id: vec3u) {\n                let res = u.resolution.xy;\n                if (f32(id.x) >= res.x || f32(id.y) >= res.y) { return; }\n\n                var seed = pcg_hash(id.x + id.y * u32(res.x) + u32(u.time * 1000.0));\n                \n                // Camera Settings\n                let ro = vec3f(4.0, 4.0, -6.0);\n                let la = vec3f(0.0, 0.5, -2.0);\n                let cam_fwd = normalize(la - ro);\n                let cam_right = normalize(cross(cam_fwd, vec3f(0,1,0)));\n                let cam_up = cross(cam_right, cam_fwd);\n\n                // Sphere animation\n                var bounce = fract(u.time);\n                bounce -= 0.5;\n                bounce *= 2.0 * bounce;\n                var sphere_center = la;\n                sphere_center.y -= bounce;\n                sphere_center.x += sin(u.time * 0.5);\n                sphere_center.z += sin(u.time * 0.3535);\n\n                var total_radiance = vec3f(0.0);\n                \n                // --- THE BIG LOOP ---\n                // We trace 128 paths per frame for high detail\n                let samples_per_frame = 128;\n                for (var s = 0; s < samples_per_frame; s++) {\n                    \n                    let jitter = vec2f(rand(&seed), rand(&seed)) - 0.5;\n                    let p = (vec2f(f32(id.x), res.y - f32(id.y)) + jitter) * 2.0 / res.y - vec2f(res.x/res.y, 1.0);\n                    let rd = normalize(-p.x * cam_right + p.y * cam_up + 2.0 * cam_fwd);\n\n                    var radiance = vec3f(0.0);\n                    var throughput = vec3f(1.0);\n                    var curr_ro = ro;\n                    var curr_rd = rd;\n\n                    // Trace path (Max 4 bounces for performance inside the 128 loop)\n                    for (var i = 0; i < 4; i++) {\n                        let t_floor = (-1.0 - curr_ro.y) / curr_rd.y;\n                        let t_wall = (1.0 - curr_ro.z) / curr_rd.z;\n                        let t_sphere = ray_unitsphere(curr_ro - sphere_center, curr_rd);\n\n                        var t = 1e3;\n                        var normal = vec3f(0.0);\n                        var hit_obj = 0;\n\n                        if (t_floor > 0.001) { t = t_floor; normal = vec3f(0,1,0); hit_obj = 1; }\n                        if (t_wall > 0.001 && t_wall < t) { t = t_wall; normal = vec3f(0,0,-1); hit_obj = 2; }\n                        if (t_sphere > 0.001 && t_sphere < t) { \n                            t = t_sphere; \n                            normal = normalize(curr_ro + curr_rd * t_sphere - sphere_center); \n                            hit_obj = 3; \n                        }\n\n                        if (hit_obj == 0 || t == 1e3) { break; }\n\n                        let pos = curr_ro + curr_rd * t;\n                        let wall_pos = pos.xy - vec2f(u.time, 0.5);\n                        let cell_idx = floor(wall_pos + 0.5);\n                        let cell_h = hash21(cell_idx * 123.4);\n\n                        // Light Hits\n                        if (hit_obj == 2 && cell_h > 0.9) {\n                            let cell_uv = wall_pos - cell_idx;\n                            radiance += throughput * (1.1 - length(cell_uv) + sin(vec3f(2,1,0) + TAU * fract(8667.0 * cell_h)));\n                            break;\n                        }\n                        if (hit_obj == 1 && abs(pos.z + 2.0) < 0.1 && sin(wall_pos.x) > 0.0) {\n                            radiance += throughput * vec3f(1.0, 0.5, 0.0);\n                            break;\n                        }\n\n                        // Reflection Math\n                        let fresnel = pow(1.0 + dot(curr_rd, normal), 5.0);\n                        let is_mirror_wall = (hit_obj == 2 && fract(cell_h * 7677.0) > 0.5);\n                        \n                        if (rand(&seed) < fresnel || is_mirror_wall || hit_obj == 3) {\n                            curr_rd = reflect(curr_rd, normal);\n                            throughput *= 0.9;\n                        } else {\n                            curr_rd = uniform_lambert(normal, &seed);\n                            throughput *= 0.4;\n                        }\n                        curr_ro = pos + normal * 0.001;\n                    }\n                    total_radiance += radiance;\n                }\n\n                textureStore(outTex, id.xy, vec4f(total_radiance / f32(samples_per_frame), 1.0));\n            }\n        "
    },
    {
      "name": "pass1",
      "type": "fragment",
      "shader": "struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\n@vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\n    var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\n    return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\n}\nstruct Uniforms {\n  resolution: vec3f,\n  time: f32,\n};\n@group(0) @binding(0) var<uniform> u: Uniforms;\n@group(0) @binding(1) var samp: sampler;\n@group(0) @binding(2) var computeTex0: texture_2d<f32>;\n@group(0) @binding(3) var pass1: texture_2d<f32>;\n@group(0) @binding(4) var prev_pass1: texture_2d<f32>;\n\n\n            const PI: f32 = 3.141592654;\n            const TAU: f32 = 6.283185307;\n\n            fn ray_unitsphere(ro: vec3f, rd: vec3f) -> f32 {\n                let b = dot(ro, rd);\n                let c = dot(ro, ro) - 1.0;\n                let h = b*b - c;\n                if(h < 0.0) { return -1.0; }\n                return -b - sqrt(h);\n            }\n\n            fn hash21(p: vec2f) -> f32 {\n                return fract(sin(dot(p, vec2f(12.9898, 58.233))) * 43758.5453);\n            }\n\n            fn orth_base(n: vec3f) -> mat3x3f {\n                let up = select(vec3f(0,1,0), vec3f(0,0,1), abs(n.y) > 0.999);\n                let x = normalize(cross(up, n));\n                let y = cross(n, x);\n                return mat3x3f(x, y, n);\n            }\n\n            fn uniform_lambert(n: vec3f, seed: ptr<function, u32>) -> vec3f {\n                let r1 = rand(seed);\n                let r2 = rand(seed);\n                let p = TAU * r1;\n                let cost = sqrt(r2);\n                let sint = sqrt(1.0 - r2);\n                return orth_base(n) * vec3f(cos(p)*sint, sin(p)*sint, cost);\n            }\n\n            fn pcg_hash(input: u32) -> u32 {\n                var state = input * 747796405u + 2891336453u;\n                var word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n                return (word >> 22u) ^ word;\n            }\n\n            fn rand(seed: ptr<function, u32>) -> f32 {\n                *seed = pcg_hash(*seed);\n                return f32(*seed) / f32(0xffffffffu);\n            }\n        \n\n            @fragment fn main(in: VSOut) -> @location(0) vec4f {\n                let current = textureSample(computeTex0, samp, in.uv).rgb;\n                let history = textureSample(prev_pass1, samp, in.uv).rgb;\n                return vec4f(mix(current, history, 0.5), 1.0);\n            }\n        "
    },
    {
      "name": "main",
      "type": "fragment",
      "shader": "struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\n@vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {\n    var p = array<vec2f, 3>(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));\n    return VSOut(vec4f(p[i], 0.0, 1.0), vec2f(p[i].x * 0.5 + 0.5, 0.5 - p[i].y * 0.5));\n}\nstruct Uniforms {\n  resolution: vec3f,\n  time: f32,\n};\n@group(0) @binding(0) var<uniform> u: Uniforms;\n@group(0) @binding(1) var samp: sampler;\n@group(0) @binding(2) var pass1: texture_2d<f32>;\n\n\n            const PI: f32 = 3.141592654;\n            const TAU: f32 = 6.283185307;\n\n            fn ray_unitsphere(ro: vec3f, rd: vec3f) -> f32 {\n                let b = dot(ro, rd);\n                let c = dot(ro, ro) - 1.0;\n                let h = b*b - c;\n                if(h < 0.0) { return -1.0; }\n                return -b - sqrt(h);\n            }\n\n            fn hash21(p: vec2f) -> f32 {\n                return fract(sin(dot(p, vec2f(12.9898, 58.233))) * 43758.5453);\n            }\n\n            fn orth_base(n: vec3f) -> mat3x3f {\n                let up = select(vec3f(0,1,0), vec3f(0,0,1), abs(n.y) > 0.999);\n                let x = normalize(cross(up, n));\n                let y = cross(n, x);\n                return mat3x3f(x, y, n);\n            }\n\n            fn uniform_lambert(n: vec3f, seed: ptr<function, u32>) -> vec3f {\n                let r1 = rand(seed);\n                let r2 = rand(seed);\n                let p = TAU * r1;\n                let cost = sqrt(r2);\n                let sint = sqrt(1.0 - r2);\n                return orth_base(n) * vec3f(cos(p)*sint, sin(p)*sint, cost);\n            }\n\n            fn pcg_hash(input: u32) -> u32 {\n                var state = input * 747796405u + 2891336453u;\n                var word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n                return (word >> 22u) ^ word;\n            }\n\n            fn rand(seed: ptr<function, u32>) -> f32 {\n                *seed = pcg_hash(*seed);\n                return f32(*seed) / f32(0xffffffffu);\n            }\n        \n\n            @fragment fn main(in: VSOut) -> @location(0) vec4f {\n                let col = textureSample(pass1, samp, in.uv).rgb;\n                return vec4f(sqrt(col), 1.0);\n            }\n        ",
      "isMain": true
    }
  ],
  "workgroupSize": "@workgroup_size(16, 16, 1)"
};